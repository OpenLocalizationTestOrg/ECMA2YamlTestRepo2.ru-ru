### YamlMime:ManagedReference
items:
- uid: System.Security.SecureString
  id: SecureString
  children:
  - System.Security.SecureString.#ctor
  - System.Security.SecureString.#ctor(System.Char*,System.Int32)
  - System.Security.SecureString.AppendChar(System.Char)
  - System.Security.SecureString.Clear
  - System.Security.SecureString.Copy
  - System.Security.SecureString.Dispose
  - System.Security.SecureString.InsertAt(System.Int32,System.Char)
  - System.Security.SecureString.IsReadOnly
  - System.Security.SecureString.Length
  - System.Security.SecureString.MakeReadOnly
  - System.Security.SecureString.RemoveAt(System.Int32)
  - System.Security.SecureString.SetAt(System.Int32,System.Char)
  langs:
  - csharp
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
  type: Class
  summary: "Представляет текст, который должен оставаться конфиденциальным, например путем его удаления из памяти компьютера, если больше не нужны. Этот класс не наследуется."
  remarks: "SecureString имеет тип string, содержащий данные безопасности. Он пытается избежать хранения конфиденциальных строк в памяти процесса в виде обычного текста.  (Однако ограничениях см [как обеспечить безопасность SecureString?](#HowSecure) раздел.) Значение экземпляра SecureString автоматически защищены с помощью механизма, поддерживаемые базовой платформы, при инициализации экземпляра или при изменении значения. Приложение может отрисовки неизменяемый экземпляр и запретить его дальнейшее изменение путем вызова <xref:System.Security.SecureString.MakeReadOnly%2A>метод.</xref:System.Security.SecureString.MakeReadOnly%2A>       Максимальная длина экземпляра SecureString составляет 65 536 символов.      Настроек [!IMPORTANT] настроек этот тип реализует <xref:System.IDisposable>интерфейса.</xref:System.IDisposable> После завершения, используя экземпляр типа, следует освободить его прямо или косвенно. Для удаления типа непосредственно вызвать его <xref:System.IDisposable.Dispose%2A>метод в `try` / `catch` блока.</xref:System.IDisposable.Dispose%2A> Чтобы удалить ее косвенно, использовать языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <xref:System.IDisposable>разделе интерфейса.</xref:System.IDisposable>       Класс SecureString и его члены не отображаются для COM. Дополнительные сведения см. в разделе <xref:System.Runtime.InteropServices.ComVisibleAttribute>.</xref:System.Runtime.InteropServices.ComVisibleAttribute>       В этом разделе: [строка vs. SecureString](#vsString)[операций SecureString](#Ops)[SecureString и взаимодействия](#interop)[как обеспечить безопасность SecureString?               ](#HowSecure)      <a name=&quot;vsString&quot;></a>## Строковое сравнение SecureString экземпляр <xref:System.String?displayProperty=fullName>класса является неизменяемым и, если больше не нужны, не удастся программными средствами для сборки мусора; то есть экземпляр доступен только для чтения после его создания, и невозможно предсказать, когда экземпляр будет удален из памяти компьютера.</xref:System.String?displayProperty=fullName> Поскольку <xref:System.String?displayProperty=fullName>экземпляры являются неизменяемыми, операции, которые отображаются для изменения существующего экземпляра фактически создать копию данных для работы с.</xref:System.String?displayProperty=fullName> Следовательно Если <xref:System.String>объект содержит конфиденциальные сведения, например пароль, номер кредитной карты или персональные данные, есть риск, данные могут стать доступными после использования, поскольку приложение не может удалить данные из памяти компьютера.</xref:System.String>       Объект SecureString аналогичен <xref:System.String>объекта в том, что он имеет значение text.</xref:System.String> Однако значение SecureString, объект закреплен в памяти, могут использовать механизм защиты, такие как шифрование, предоставляемые операционной системы, могут быть изменены до приложения помечает его как доступную только для чтения и может быть удален из памяти компьютера с приложением, вызывающим метод <xref:System.Security.SecureString.Dispose%2A>метода или сборщиком мусора .NET Framework.</xref:System.Security.SecureString.Dispose%2A>       Описание ограничения класса SecureString см. в разделе [как обеспечить безопасность SecureString?](#HowSecure) раздела.       [К началу](#top) <a name=&quot;Ops&quot;> </a> ## SecureString операций SecureString класс содержит элементы, которые позволяют выполнять следующие: создание экземпляра объекта SecureString экземпляр объект SecureString, вызывая его конструктор без параметров.             Добавление символов SecureString объекта можно добавить один символ одновременно объект SecureString путем вызова его <xref:System.Security.SecureString.AppendChar%2A>или <xref:System.Security.SecureString.InsertAt%2A>метод.</xref:System.Security.SecureString.InsertAt%2A> </xref:System.Security.SecureString.AppendChar%2A>      Настроек [!IMPORTANT] настроек объект SecureString никогда не должно быть составлено из <xref:System.String>так как конфиденциальные данные уже регулируется последствия сохраняемости памяти неизменяемого <xref:System.String>класса.</xref:System.String> </xref:System.String> Лучший способ создать объект SecureString является из неуправляемого источника символа во время, например <xref:System.Console.ReadKey%2A?displayProperty=fullName>метод.</xref:System.Console.ReadKey%2A?displayProperty=fullName>       Удаление символов от SecureString объекта отдельному символу можно заменить путем вызова <xref:System.Security.SecureString.SetAt%2A>метод, удалить отдельный символ путем вызова <xref:System.Security.SecureString.RemoveAt%2A>метода или удалите все символы из SecureString экземпляра, вызывая <xref:System.Security.SecureString.Clear%2A>метод.</xref:System.Security.SecureString.Clear%2A> </xref:System.Security.SecureString.RemoveAt%2A> </xref:System.Security.SecureString.SetAt%2A>       Сделать объект SecureString только для чтения после того как определен строку, представляющую объект SecureString, вызовите его <xref:System.Security.SecureString.MakeReadOnly%2A>метод, образуя из строки только для чтения.</xref:System.Security.SecureString.MakeReadOnly%2A>       Получить сведения об объекте SecureString SecureString класс имеет только два члена, которые предоставляют сведения о строке: его <xref:System.Security.SecureString.Length%2A>свойство, которое содержит количество единиц кода в кодировке UTF16 в строку; и <xref:System.Security.SecureString.IsReadOnly%2A>, метод, который указывает, является ли экземпляр только для чтения.</xref:System.Security.SecureString.IsReadOnly%2A> </xref:System.Security.SecureString.Length%2A>       Освободить память, выделенную для экземпляра SecureString, поскольку SecureString реализует <xref:System.IDisposable>интерфейс освобождать память, вызывая <xref:System.Security.SecureString.Dispose%2A>метод.</xref:System.Security.SecureString.Dispose%2A> </xref:System.IDisposable>       Класс SecureString не имеет членов, проверять, сравнивать или преобразовать значение SecureString. Отсутствие таких членов защищает значение экземпляра от случайного или злонамеренного раскрытия. Используйте соответствующие члены <xref:System.Runtime.InteropServices.Marshal?displayProperty=fullName>класса, такие как <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A>метода, чтобы управлять значение объект SecureString.</xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> </xref:System.Runtime.InteropServices.Marshal?displayProperty=fullName>       Библиотека классов .NET Framework, широко используемые экземпляры SecureString одним из следующих способов: -, чтобы предоставить сведения о пароле к процессу с помощью <xref:System.Diagnostics.ProcessStartInfo>структуры или путем вызова перегрузки <xref:System.Diagnostics.Process.Start%2A?displayProperty=fullName>метод, который имеет параметр типа SecureString.</xref:System.Diagnostics.Process.Start%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo>      -Для предоставления сведений о сети пароль путем вызова <xref:System.Net.NetworkCredential>конструктора класса, который имеет параметр типа SecureString или с помощью <xref:System.Net.NetworkCredential.SecurePassword%2A?displayProperty=fullName>свойство.</xref:System.Net.NetworkCredential.SecurePassword%2A?displayProperty=fullName> </xref:System.Net.NetworkCredential>      -Указание пароля сведений для проверки подлинности SQL Server, вызвав <xref:System.Data.SqlClient.SqlCredential.%23ctor%2A?displayProperty=fullName>конструктор или получение значения <xref:System.Data.SqlClient.SqlCredential.Password%2A?displayProperty=fullName>свойство.</xref:System.Data.SqlClient.SqlCredential.Password%2A?displayProperty=fullName> </xref:System.Data.SqlClient.SqlCredential.%23ctor%2A?displayProperty=fullName>      -Для передачи строки, в неуправляемый код. Дополнительные сведения см. в разделе [SecureString и взаимодействия](#interop) раздела.       [К началу](#top) <a name=&quot;interop&quot;> </a> ## SecureString и взаимодействия, поскольку операционная система не поддерживает напрямую SecureString, необходимо преобразовать значение SecureString объекта требуется строковый тип перед передачей строка метода машинного кода.        <xref:System.Runtime.InteropServices.Marshal>Класс имеет пять методов, которые этого:- <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A?displayProperty=fullName>, который преобразует строковое значение SecureString в двоичную строку (BSTR), известным COM.</xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A?displayProperty=fullName> </xref:System.Runtime.InteropServices.Marshal>      - <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A?displayProperty=fullName>и <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A?displayProperty=fullName>, какой из вариантов SecureString строковое значение в строку ANSI в неуправляемой памяти.</xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A?displayProperty=fullName> </xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A?displayProperty=fullName>      - <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=fullName>и <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=fullName>, какой из вариантов SecureString строковое значение строки в Юникоде в неуправляемой памяти.</xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=fullName> </xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=fullName>       Каждый из этих методов создает строку открытым текстом в неуправляемой памяти. Возлагается на разработчика обнуляет и высвобождают память, как только он больше не нужен. Каждого из методов распределения строк преобразование и памяти имеет соответствующий метод для обнуляет и освободить выделенную память: | Метод распределения и преобразование | Ноль и метод free |   |--------------------------------------|--------------------------|   | <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A?displayProperty=fullName>| <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A?displayProperty=fullName>|   | <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A?displayProperty=fullName>| <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A?displayProperty=fullName>|   | <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=fullName>| <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A?displayProperty=fullName>|   | <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A?displayProperty=fullName>| <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A?displayProperty=fullName>|   | <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=fullName>| <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A?displayProperty=fullName>|       [Back to top](#top)      <a name=&quot;HowSecure&quot;></a>    ## How secure is SecureString?</xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A?displayProperty=fullName></xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=fullName></xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A?displayProperty=fullName></xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A?displayProperty=fullName></xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A?displayProperty=fullName></xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A?displayProperty=fullName></xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A?displayProperty=fullName></xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A?displayProperty=fullName></xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A?displayProperty=fullName></xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A?displayProperty=fullName>    При создании должным образом, экземпляр SecureString обеспечивает дополнительные защиту данных, чем <xref:System.String>.</xref:System.String> При создании строки из источника символа во время <xref:System.String>создает несколько промежуточных в памяти, в то время как SecureString создает только один экземпляр.</xref:System.String>  Сборку мусора для <xref:System.String>объектов является недетерминированным.</xref:System.String> Кроме того, так как не закреплен объем памяти, сборщик мусора будет сделать дополнительные копии <xref:System.String>значения при перемещении и сжатие памяти.</xref:System.String> Напротив, память, выделенную для объект SecureString закреплена, и что память можно освободить путем вызова <xref:System.Security.SecureString.Dispose%2A>метод.</xref:System.Security.SecureString.Dispose%2A>       Несмотря на то, что данные, хранящиеся в экземпляре SecureString более безопасен, чем данные, хранящиеся в <xref:System.String>экземпляре, имеют значительные ограничения на как обеспечить безопасность SecureString экземпляра о-ва</xref:System.String> К ним относятся: платформы на Windows операционная система, шифруется содержимое массива внутреннему символьному экземпляр SecureString. Тем не менее является ли из-за отсутствия API или проблемы управления ключами, шифрование недоступно на всех платформах. По этой причине SecureString доступен на рабочем столе (Windows), а не на основе .NET Core.       Длительность, даже если реализация SecureString является возможность использования преимуществ шифрования в виде обычного текста, назначенные SecureString, экземпляр может быть открыто в разное время: — так как Windows не предоставляет реализацию защищенной строки на уровне операционной системы .NET Framework по-прежнему должен преобразовать значение безопасной строки в представление в виде обычного текста для использования.      -Значение защищенной строки при изменении методами, такими как <xref:System.Security.SecureString.AppendChar%2A>или <xref:System.Security.SecureString.RemoveAt%2A>, необходимо расшифровать (т. е. преобразованное обратно в обычный текст), изменить, а затем еще раз.</xref:System.Security.SecureString.RemoveAt%2A> </xref:System.Security.SecureString.AppendChar%2A>      -Если защищенная строка используется в вызов взаимодействия, его необходимо преобразовать в строку ANSI, строки в Юникоде или двоичную строку (BSTR). Дополнительные сведения см. в разделе [SecureString и взаимодействия](#interop) раздела.       Интервал времени, для которого предоставляется значение экземпляра SecureString просто сокращено по сравнению с <xref:System.String>классом.</xref:System.String>       Сравнение использования как правило, класс SecureString определяет механизм хранения для строковых значений, которые должны быть защищены или хранить в тайне. Однако вне .NET Framework сам, без использования механизма поддерживает SecureString. Это означает, защищенной строки необходимо преобразовать в форму можно использовать (как правило, форма открытым текстом), распознаваемое своей цели и расшифровки и преобразование должно находиться в пространстве пользователя.       В целом более безопасны, чем SecureString <xref:System.String>, так как она ограничивает возможность раскрытия конфиденциальных строковых данных.</xref:System.String> Тем не менее эти строки по-прежнему могут быть предоставлены для любого процесса или операцию, которая имеет доступ к памяти raw, например вредоносный процесса, выполняющегося на главном компьютере, дамп процесса или в файл подкачки для просмотра пользователем. Взамен рекомендуется использовать вместо SecureString для защиты паролей, является использование непрозрачный дескриптор, чтобы учетные данные, хранящиеся вне процесса.       [К началу](#top)"
  example:
  - "The following example demonstrates how to use a SecureString to secure a user’s password for use as a credential to start a new process.  \n  \n [!code-vb[System.Security.SecureString.Ctor#4](~/add/codesnippet/visualbasic/t-system.security.secure_1.vb)]\n [!code-cs[System.Security.SecureString.Ctor#4](~/add/codesnippet/csharp/t-system.security.secure_1.cs)]"
  syntax:
    content: 'public sealed class SecureString : IDisposable'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Security.SecureString.#ctor
  id: '#ctor'
  parent: System.Security.SecureString
  langs:
  - csharp
  name: SecureString()
  nameWithType: SecureString.SecureString()
  fullName: System.Security.SecureString.SecureString()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Security.SecureString&quot;> </xref> класса."
  remarks: ''
  example:
  - "The following example uses the default (or parameterless) constructor to instantiate a new <xref:System.Security.SecureString> object. It then calls the <xref:System.Security.SecureString.AppendChar%2A> method to add an array of characters to it.  \n  \n [!code-cs[System.Security.SecureString.Ctor#2](~/add/codesnippet/csharp/m-system.security.secure_7_1.cs)]\n [!code-cpp[System.Security.SecureString.Ctor#2](~/add/codesnippet/cpp/m-system.security.secure_7_1.cpp)]\n [!code-vb[System.Security.SecureString.Ctor#2](~/add/codesnippet/visualbasic/m-system.security.secure_7_1.vb)]  \n  \n The following example creates a <xref:System.Security.SecureString> object from the value of a <xref:System.String> object.  \n  \n [!code-vb[System.Security.SecureString.Ctor#3](~/add/codesnippet/visualbasic/m-system.security.secure_7_2.vb)]\n [!code-cpp[System.Security.SecureString.Ctor#3](~/add/codesnippet/cpp/m-system.security.secure_7_2.cpp)]\n [!code-cs[System.Security.SecureString.Ctor#3](~/add/codesnippet/csharp/m-system.security.secure_7_2.cs)]"
  syntax:
    content: public SecureString ();
    parameters: []
  overload: System.Security.SecureString.#ctor*
  exceptions:
  - type: System.Security.Cryptography.CryptographicException
    commentId: T:System.Security.Cryptography.CryptographicException
    description: "Произошла ошибка при защите или снятие защиты значение данного экземпляра."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Эта операция не поддерживается на этой платформе."
  platform:
  - net462
- uid: System.Security.SecureString.#ctor(System.Char*,System.Int32)
  id: '#ctor(System.Char*,System.Int32)'
  parent: System.Security.SecureString
  langs:
  - csharp
  name: SecureString(Char*,Int32)
  nameWithType: SecureString.SecureString(Char*,Int32)
  fullName: System.Security.SecureString.SecureString(Char*,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Security.SecureString&quot;> </xref> класса из подмассива &lt;xref:System.Char?displayProperty=fullName&gt; объектов.       Этот конструктор несовместим с CLS. CLS-совместимая альтернатива — &lt;xref:System.Security.SecureString.%23ctor?displayProperty=fullName&gt;."
  remarks: "Этот конструктор инициализирует новый <xref:System.Security.SecureString>объекта в число символов в `value` заданные `length`; значение экземпляра шифруется.</xref:System.Security.SecureString>       В C# этот конструктор определен только в контексте небезопасного кода."
  example:
  - "The following example instantiates a new <xref:System.Security.SecureString> object by passing its constructor a pointer to a character array.  \n  \n [!code-cpp[System.Security.SecureString.Ctor2#1](~/add/codesnippet/cpp/m-system.security.secure_3_1.cpp)]\n [!code-cs[System.Security.SecureString.Ctor2#1](~/add/codesnippet/csharp/securestringctor/ctor1.cs#1)]"
  syntax:
    content: public SecureString (char* value, int length);
    parameters:
    - id: value
      type: System.Char*
      description: "Указатель на массив &lt;xref:System.Char?displayProperty=fullName&gt; объектов."
    - id: length
      type: System.Int32
      description: "Число элементов `value` , включаемых в новый экземпляр."
  overload: System.Security.SecureString.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>value</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>length</code>меньше нуля или больше 65 536."
  - type: System.Security.Cryptography.CryptographicException
    commentId: T:System.Security.Cryptography.CryptographicException
    description: "Произошла ошибка при защите или снятие защиты значение этой защищенной строки."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Эта операция не поддерживается на этой платформе."
  platform:
  - net462
- uid: System.Security.SecureString.AppendChar(System.Char)
  id: AppendChar(System.Char)
  parent: System.Security.SecureString
  langs:
  - csharp
  name: AppendChar(Char)
  nameWithType: SecureString.AppendChar(Char)
  fullName: System.Security.SecureString.AppendChar(Char)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Добавляет знак в конец текущей защищенной строки."
  remarks: "Если реализация использует механизм защиты, такие как шифрование, значение этой защищенной строки, если таковая имеется, незащищенных; `c` добавляется; затем новое значение защищенной строки повторной защиты."
  example:
  - "The following example demonstrates how the AppendChar, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, and <xref:System.Security.SecureString.Clear%2A> methods affect the value of a <xref:System.Security.SecureString> object.  \n  \n [!code-cpp[SecureString.xAt#1](~/add/codesnippet/cpp/m-system.security.secure_6_1.cpp)]\n [!code-cs[SecureString.xAt#1](~/add/codesnippet/csharp/m-system.security.secure_6_1.cs)]\n [!code-vb[SecureString.xAt#1](~/add/codesnippet/visualbasic/m-system.security.secure_6_1.vb)]  \n  \n The following example demonstrates how the AppendChar and <xref:System.Security.SecureString.RemoveAt%2A> methods can be used to collect the characters in a password.  \n  \n [!code-cpp[SecureString.xChar#1](~/add/codesnippet/cpp/m-system.security.secure_6_2.cpp)]\n [!code-vb[SecureString.xChar#1](~/add/codesnippet/visualbasic/m-system.security.secure_6_2.vb)]\n [!code-cs[SecureString.xChar#1](~/add/codesnippet/csharp/m-system.security.secure_6_2.cs)]"
  syntax:
    content: public void AppendChar (char c);
    parameters:
    - id: c
      type: System.Char
      description: "Знак, добавляемый к защищенной строке."
  overload: System.Security.SecureString.AppendChar*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Защищенная строка уже был удален."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Защищенная строка доступна только для чтения."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Выполнение этой операции могут привести к невозможности длина этой защищенной строки больше 65 536 символов."
  - type: System.Security.Cryptography.CryptographicException
    commentId: T:System.Security.Cryptography.CryptographicException
    description: "Произошла ошибка при защите или снятие защиты значение этой защищенной строки."
  platform:
  - net462
- uid: System.Security.SecureString.Clear
  id: Clear
  parent: System.Security.SecureString
  langs:
  - csharp
  name: Clear()
  nameWithType: SecureString.Clear()
  fullName: System.Security.SecureString.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Удаляет значение текущей защищенной строки."
  remarks: "Обнулить памяти компьютера, который содержит значение этой защищенной строки, то длина значения этой защищенной строки присваивается нулевое значение."
  example:
  - "The following example demonstrates how the <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, and Clear methods affect the value of a <xref:System.Security.SecureString> object.  \n  \n [!code-cpp[SecureString.xAt#1](~/add/codesnippet/cpp/m-system.security.secure_5_1.cpp)]\n [!code-cs[SecureString.xAt#1](~/add/codesnippet/csharp/m-system.security.secure_5_1.cs)]\n [!code-vb[SecureString.xAt#1](~/add/codesnippet/visualbasic/m-system.security.secure_5_1.vb)]"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Security.SecureString.Clear*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Защищенная строка уже был удален."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Защищенная строка доступна только для чтения."
  platform:
  - net462
- uid: System.Security.SecureString.Copy
  id: Copy
  parent: System.Security.SecureString
  langs:
  - csharp
  name: Copy()
  nameWithType: SecureString.Copy()
  fullName: System.Security.SecureString.Copy()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Создает копию текущей защищенной строки."
  remarks: "Если экземпляр <xref:System.Security.SecureString>является помечен только для чтения, копия этого экземпляра не будет доступной только для чтения.</xref:System.Security.SecureString>"
  syntax:
    content: public System.Security.SecureString Copy ();
    parameters: []
    return:
      type: System.Security.SecureString
      description: "Копия этой защищенной строки."
  overload: System.Security.SecureString.Copy*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Защищенная строка уже был удален."
  - type: System.Security.Cryptography.CryptographicException
    commentId: T:System.Security.Cryptography.CryptographicException
    description: "Произошла ошибка при защите или снятие защиты значение этой защищенной строки."
  platform:
  - net462
- uid: System.Security.SecureString.Dispose
  id: Dispose
  parent: System.Security.SecureString
  langs:
  - csharp
  name: Dispose()
  nameWithType: SecureString.Dispose()
  fullName: System.Security.SecureString.Dispose()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Освобождает все ресурсы, используемые текущим <xref href=&quot;System.Security.SecureString&quot;> </xref> объекта."
  remarks: "Метод Dispose записывает двоичных нулей на выделенную память, содержащий значение этого аргумента <xref:System.Security.SecureString>объекта, а затем освобождает выделенную память.</xref:System.Security.SecureString>       Дополнительные сведения см. в разделе [мусора](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.Security.SecureString.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Security.SecureString.InsertAt(System.Int32,System.Char)
  id: InsertAt(System.Int32,System.Char)
  parent: System.Security.SecureString
  langs:
  - csharp
  name: InsertAt(Int32,Char)
  nameWithType: SecureString.InsertAt(Int32,Char)
  fullName: System.Security.SecureString.InsertAt(Int32,Char)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Вставляет символ в указанной позиции индекса защищенной строке."
  remarks: "Индекс (с нуля); Первый символ в этой защищенной строки индекс равен нулю.       Если реализация использует механизм защиты, такие как шифрование защищенной строки, если таковая имеется, равен незащищенных; `c` вставляется в указанной позиции индекса; затем новое значение повторной защиты. Метод InsertAt возвращает те же результаты, что <xref:System.Security.SecureString.AppendChar%2A>метод, который вставляет символ в конце защищенной строки, если `index` параметр InsertAt равно длине данного экземпляра.</xref:System.Security.SecureString.AppendChar%2A>"
  example:
  - "The following example demonstrates how the <xref:System.Security.SecureString.AppendChar%2A>, InsertAt, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, and <xref:System.Security.SecureString.Clear%2A> methods affect the value of a <xref:System.Security.SecureString> object.  \n  \n [!code-cpp[SecureString.xAt#1](~/add/codesnippet/cpp/m-system.security.secure_0_1.cpp)]\n [!code-cs[SecureString.xAt#1](~/add/codesnippet/csharp/m-system.security.secure_0_1.cs)]\n [!code-vb[SecureString.xAt#1](~/add/codesnippet/visualbasic/m-system.security.secure_0_1.vb)]"
  syntax:
    content: public void InsertAt (int index, char c);
    parameters:
    - id: index
      type: System.Int32
      description: "Индекс позиции параметра `c` вставляется."
    - id: c
      type: System.Char
      description: "Вставляемый знак."
  overload: System.Security.SecureString.InsertAt*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Защищенная строка уже был удален."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Защищенная строка доступна только для чтения."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>меньше нуля или больше, чем длина этой защищенной строки.       - или - выполнении этой операции могут привести к невозможности длина этой защищенной строки больше 65 536 символов."
  - type: System.Security.Cryptography.CryptographicException
    commentId: T:System.Security.Cryptography.CryptographicException
    description: "Произошла ошибка при защите или снятие защиты значение этой защищенной строки."
  platform:
  - net462
- uid: System.Security.SecureString.IsReadOnly
  id: IsReadOnly
  parent: System.Security.SecureString
  langs:
  - csharp
  name: IsReadOnly()
  nameWithType: SecureString.IsReadOnly()
  fullName: System.Security.SecureString.IsReadOnly()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Указывает, помечена ли этой защищенной строки доступным только для чтения."
  remarks: "После возникновения <xref:System.Security.SecureString>помечен только для чтения с помощью <xref:System.Security.SecureString.MakeReadOnly%2A>метода, любая попытка изменить значение этого экземпляра вызывает <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException> </xref:System.Security.SecureString.MakeReadOnly%2A> </xref:System.Security.SecureString> Используйте метод IsReadOnly, чтобы проверить, <xref:System.Security.SecureString>доступен только для чтения, прежде чем пытаться изменить его.</xref:System.Security.SecureString>"
  syntax:
    content: public bool IsReadOnly ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если защищенная строка помечен только для чтения. в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.SecureString.IsReadOnly*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Защищенная строка уже был удален."
  platform:
  - net462
- uid: System.Security.SecureString.Length
  id: Length
  parent: System.Security.SecureString
  langs:
  - csharp
  name: Length
  nameWithType: SecureString.Length
  fullName: System.Security.SecureString.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Возвращает число символов в текущей защищенной строки."
  remarks: "Свойство Length возвращает количество <xref:System.Char>объектов в этом экземпляре, не число символов Юникода.</xref:System.Char> Символ Юникода могут быть представлены в более чем одной <xref:System.Char>объекта.</xref:System.Char>       Максимальная длина <xref:System.Security.SecureString>экземпляра — 65 536 символов.</xref:System.Security.SecureString>"
  syntax:
    content: public int Length { get; }
    return:
      type: System.Int32
      description: "Число &lt;xref:System.Char?displayProperty=fullName&gt; объектов в этом защиты строки."
  overload: System.Security.SecureString.Length*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Защищенная строка уже был удален."
  platform:
  - net462
- uid: System.Security.SecureString.MakeReadOnly
  id: MakeReadOnly
  parent: System.Security.SecureString
  langs:
  - csharp
  name: MakeReadOnly()
  nameWithType: SecureString.MakeReadOnly()
  fullName: System.Security.SecureString.MakeReadOnly()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Делает текстовое значение этой защищенной строки доступным только для чтения."
  remarks: "Инициализировать текстовое значение экземпляра <xref:System.Security.SecureString>класса <xref:System.Security.SecureString.%23ctor%2A>конструкторы и измените значение с <xref:System.Security.SecureString.Clear%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, <xref:System.Security.SecureString.SetAt%2A>, <xref:System.Security.SecureString.InsertAt%2A>, и <xref:System.Security.SecureString.AppendChar%2A>методы.</xref:System.Security.SecureString.AppendChar%2A> </xref:System.Security.SecureString.InsertAt%2A> </xref:System.Security.SecureString.SetAt%2A> </xref:System.Security.SecureString.RemoveAt%2A> </xref:System.Security.SecureString.Clear%2A> </xref:System.Security.SecureString.%23ctor%2A> </xref:System.Security.SecureString>       После внесения изменений окончательный метод MakeReadOnly для сделать неизменяемым значение экземпляра (только для чтения). После пометки значения только для чтения, любые дальнейшие попытки изменить его вызывает <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       Результат вызова MakeReadOnly необратимо поскольку <xref:System.Security.SecureString>класс предоставляет нет средств, чтобы вновь сделать изменяемой защищенной строки.</xref:System.Security.SecureString> Используйте <xref:System.Security.SecureString.IsReadOnly%2A>метод для проверки соответствия экземпляра <xref:System.Security.SecureString>доступно только для чтения.</xref:System.Security.SecureString> </xref:System.Security.SecureString.IsReadOnly%2A>"
  example:
  - "The following example demonstrates how the <xref:System.Security.SecureString.AppendChar%2A> and <xref:System.Security.SecureString.RemoveAt%2A> methods can be used to collect the characters in a password. After the password is collected, it is made read-only.  \n  \n [!code-cpp[SecureString.xChar#1](~/add/codesnippet/cpp/m-system.security.secure_1_1.cpp)]\n [!code-vb[SecureString.xChar#1](~/add/codesnippet/visualbasic/m-system.security.secure_1_1.vb)]\n [!code-cs[SecureString.xChar#1](~/add/codesnippet/csharp/m-system.security.secure_1_1.cs)]"
  syntax:
    content: public void MakeReadOnly ();
    parameters: []
  overload: System.Security.SecureString.MakeReadOnly*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Защищенная строка уже был удален."
  platform:
  - net462
- uid: System.Security.SecureString.RemoveAt(System.Int32)
  id: RemoveAt(System.Int32)
  parent: System.Security.SecureString
  langs:
  - csharp
  name: RemoveAt(Int32)
  nameWithType: SecureString.RemoveAt(Int32)
  fullName: System.Security.SecureString.RemoveAt(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Удаляет указанный символ в указанной позиции индекса из этой защищенной строки."
  remarks: "Индекс (с нуля); Первый символ в данном экземпляре индекс равен нулю.       Если реализация использует механизм защиты, такие как шифрование, значение этой защищенной строки, если таковая имеется, незащищенных; символ в указанной позиции индекса удаляется; Выберите новое значение повторной защиты."
  example:
  - "The following example demonstrates how the <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, RemoveAt, <xref:System.Security.SecureString.SetAt%2A>, and <xref:System.Security.SecureString.Clear%2A> methods affect the value of a <xref:System.Security.SecureString> object.  \n  \n [!code-cpp[SecureString.xAt#1](~/add/codesnippet/cpp/m-system.security.secure_2_1.cpp)]\n [!code-cs[SecureString.xAt#1](~/add/codesnippet/csharp/m-system.security.secure_2_1.cs)]\n [!code-vb[SecureString.xAt#1](~/add/codesnippet/visualbasic/m-system.security.secure_2_1.vb)]  \n  \n The following example demonstrates how the <xref:System.Security.SecureString.AppendChar%2A> and RemoveAt methods can be used to collect the characters in a password.  \n  \n [!code-cpp[SecureString.xChar#1](~/add/codesnippet/cpp/m-system.security.secure_2_2.cpp)]\n [!code-vb[SecureString.xChar#1](~/add/codesnippet/visualbasic/m-system.security.secure_2_2.vb)]\n [!code-cs[SecureString.xChar#1](~/add/codesnippet/csharp/m-system.security.secure_2_2.cs)]"
  syntax:
    content: public void RemoveAt (int index);
    parameters:
    - id: index
      type: System.Int32
      description: "Позиция индекса символа в защищенной строке."
  overload: System.Security.SecureString.RemoveAt*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Защищенная строка уже был удален."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Защищенная строка доступна только для чтения."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>меньше нуля или больше или равно длине этой защищенной строки."
  - type: System.Security.Cryptography.CryptographicException
    commentId: T:System.Security.Cryptography.CryptographicException
    description: "Произошла ошибка при защите или снятие защиты значение этой защищенной строки."
  platform:
  - net462
- uid: System.Security.SecureString.SetAt(System.Int32,System.Char)
  id: SetAt(System.Int32,System.Char)
  parent: System.Security.SecureString
  langs:
  - csharp
  name: SetAt(Int32,Char)
  nameWithType: SecureString.SetAt(Int32,Char)
  fullName: System.Security.SecureString.SetAt(Int32,Char)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Заменяет расположенный по указанному положению индекса на другой символ."
  remarks: "Индекс (с нуля); Первый символ в данном экземпляре индекс равен нулю.       Если реализация использует механизм защиты, такие как шифрование защищенной строки, если таковая имеется, равен незащищенных; `c` назначен указанному положению индекса; затем новое значение повторной защиты."
  example:
  - "The following example demonstrates how the <xref:System.Security.SecureString.AppendChar%2A>, <xref:System.Security.SecureString.InsertAt%2A>, <xref:System.Security.SecureString.RemoveAt%2A>, SetAt, and <xref:System.Security.SecureString.Clear%2A> methods affect the value of a <xref:System.Security.SecureString> object.  \n  \n [!code-cpp[SecureString.xAt#1](~/add/codesnippet/cpp/m-system.security.secure_4_1.cpp)]\n [!code-cs[SecureString.xAt#1](~/add/codesnippet/csharp/m-system.security.secure_4_1.cs)]\n [!code-vb[SecureString.xAt#1](~/add/codesnippet/visualbasic/m-system.security.secure_4_1.vb)]"
  syntax:
    content: public void SetAt (int index, char c);
    parameters:
    - id: index
      type: System.Int32
      description: "Индекс имеющегося знака в защищенной строке"
    - id: c
      type: System.Char
      description: "Знак, заменяющий имеющийся знак."
  overload: System.Security.SecureString.SetAt*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Защищенная строка уже был удален."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Защищенная строка доступна только для чтения."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>меньше нуля или больше или равно длине этой защищенной строки."
  - type: System.Security.Cryptography.CryptographicException
    commentId: T:System.Security.Cryptography.CryptographicException
    description: "Произошла ошибка при защите или снятие защиты значение этой защищенной строки."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.Cryptography.CryptographicException
  parent: System.Security.Cryptography
  isExternal: false
  name: CryptographicException
  nameWithType: CryptographicException
  fullName: System.Security.Cryptography.CryptographicException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Security.SecureString.#ctor
  parent: System.Security.SecureString
  isExternal: false
  name: SecureString()
  nameWithType: SecureString.SecureString()
  fullName: System.Security.SecureString.SecureString()
- uid: System.Security.SecureString.#ctor(System.Char*,System.Int32)
  parent: System.Security.SecureString
  isExternal: false
  name: SecureString(Char*,Int32)
  nameWithType: SecureString.SecureString(Char*,Int32)
  fullName: System.Security.SecureString.SecureString(Char*,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Security.SecureString.AppendChar(System.Char)
  parent: System.Security.SecureString
  isExternal: false
  name: AppendChar(Char)
  nameWithType: SecureString.AppendChar(Char)
  fullName: System.Security.SecureString.AppendChar(Char)
- uid: System.Char
  parent: System
  isExternal: true
  name: Char
  nameWithType: Char
  fullName: System.Char
- uid: System.Security.SecureString.Clear
  parent: System.Security.SecureString
  isExternal: false
  name: Clear()
  nameWithType: SecureString.Clear()
  fullName: System.Security.SecureString.Clear()
- uid: System.Security.SecureString.Copy
  parent: System.Security.SecureString
  isExternal: false
  name: Copy()
  nameWithType: SecureString.Copy()
  fullName: System.Security.SecureString.Copy()
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Security.SecureString.Dispose
  parent: System.Security.SecureString
  isExternal: false
  name: Dispose()
  nameWithType: SecureString.Dispose()
  fullName: System.Security.SecureString.Dispose()
- uid: System.Security.SecureString.InsertAt(System.Int32,System.Char)
  parent: System.Security.SecureString
  isExternal: false
  name: InsertAt(Int32,Char)
  nameWithType: SecureString.InsertAt(Int32,Char)
  fullName: System.Security.SecureString.InsertAt(Int32,Char)
- uid: System.Security.SecureString.IsReadOnly
  parent: System.Security.SecureString
  isExternal: false
  name: IsReadOnly()
  nameWithType: SecureString.IsReadOnly()
  fullName: System.Security.SecureString.IsReadOnly()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.SecureString.Length
  parent: System.Security.SecureString
  isExternal: false
  name: Length
  nameWithType: SecureString.Length
  fullName: System.Security.SecureString.Length
- uid: System.Security.SecureString.MakeReadOnly
  parent: System.Security.SecureString
  isExternal: false
  name: MakeReadOnly()
  nameWithType: SecureString.MakeReadOnly()
  fullName: System.Security.SecureString.MakeReadOnly()
- uid: System.Security.SecureString.RemoveAt(System.Int32)
  parent: System.Security.SecureString
  isExternal: false
  name: RemoveAt(Int32)
  nameWithType: SecureString.RemoveAt(Int32)
  fullName: System.Security.SecureString.RemoveAt(Int32)
- uid: System.Security.SecureString.SetAt(System.Int32,System.Char)
  parent: System.Security.SecureString
  isExternal: false
  name: SetAt(Int32,Char)
  nameWithType: SecureString.SetAt(Int32,Char)
  fullName: System.Security.SecureString.SetAt(Int32,Char)
- uid: System.Security.SecureString.#ctor*
  parent: System.Security.SecureString
  isExternal: false
  name: SecureString
  nameWithType: SecureString.SecureString
- uid: System.Security.SecureString.AppendChar*
  parent: System.Security.SecureString
  isExternal: false
  name: AppendChar
  nameWithType: SecureString.AppendChar
- uid: System.Security.SecureString.Clear*
  parent: System.Security.SecureString
  isExternal: false
  name: Clear
  nameWithType: SecureString.Clear
- uid: System.Security.SecureString.Copy*
  parent: System.Security.SecureString
  isExternal: false
  name: Copy
  nameWithType: SecureString.Copy
- uid: System.Security.SecureString.Dispose*
  parent: System.Security.SecureString
  isExternal: false
  name: Dispose
  nameWithType: SecureString.Dispose
- uid: System.Security.SecureString.InsertAt*
  parent: System.Security.SecureString
  isExternal: false
  name: InsertAt
  nameWithType: SecureString.InsertAt
- uid: System.Security.SecureString.IsReadOnly*
  parent: System.Security.SecureString
  isExternal: false
  name: IsReadOnly
  nameWithType: SecureString.IsReadOnly
- uid: System.Security.SecureString.Length*
  parent: System.Security.SecureString
  isExternal: false
  name: Length
  nameWithType: SecureString.Length
- uid: System.Security.SecureString.MakeReadOnly*
  parent: System.Security.SecureString
  isExternal: false
  name: MakeReadOnly
  nameWithType: SecureString.MakeReadOnly
- uid: System.Security.SecureString.RemoveAt*
  parent: System.Security.SecureString
  isExternal: false
  name: RemoveAt
  nameWithType: SecureString.RemoveAt
- uid: System.Security.SecureString.SetAt*
  parent: System.Security.SecureString
  isExternal: false
  name: SetAt
  nameWithType: SecureString.SetAt
