### YamlMime:ManagedReference
items:
- uid: System.IO.BufferedStream
  id: BufferedStream
  children:
  - System.IO.BufferedStream.#ctor(System.IO.Stream)
  - System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  - System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.BufferedStream.CanRead
  - System.IO.BufferedStream.CanSeek
  - System.IO.BufferedStream.CanWrite
  - System.IO.BufferedStream.Dispose(System.Boolean)
  - System.IO.BufferedStream.EndRead(System.IAsyncResult)
  - System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  - System.IO.BufferedStream.Flush
  - System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.BufferedStream.Length
  - System.IO.BufferedStream.Position
  - System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.BufferedStream.ReadByte
  - System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.BufferedStream.SetLength(System.Int64)
  - System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.BufferedStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: BufferedStream
  nameWithType: BufferedStream
  fullName: System.IO.BufferedStream
  type: Class
  summary: "Добавляет буферизацию для выполнения операций на другой поток чтения и записи. Этот класс не наследуется."
  remarks: "A buffer is a block of bytes in memory used to cache data, thereby reducing the number of calls to the operating system. Buffers improve read and write performance. A buffer can be used for either reading or writing, but never both simultaneously. The [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) and [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True) methods of `BufferedStream` automatically maintain the buffer.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n `BufferedStream` can be composed around certain types of streams. It provides implementations for reading and writing bytes to an underlying data source or repository. Use <xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for reading and writing other data types. `BufferedStream` is designed to prevent the buffer from slowing down input and output when the buffer is not needed. If you always read and write for sizes greater than the internal buffer size, then `BufferedStream` might not even allocate the internal buffer. `BufferedStream` also buffers reads and writes in a shared buffer. It is assumed that you will almost always be doing a series of reads or writes, but rarely alternate between the two of them."
  example:
  - "The following code examples show how to use the `BufferedStream` class over the `NetworkStream` class to increase the performance of certain I/O operations. Start the server on a remote computer before starting the client. Specify the remote computer name as a command-line argument when starting the client. Vary the `dataArraySize` and `streamBufferSize` constants to view their effect on performance.  \n  \n The first example shows the code that runs on the client, and the second example shows the code that runs on the server.  \n  \n **Example 1: Code that runs on the client**  \n  \n [!code-cs[System.IO.BufferedStream1#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_1.vb)]  \n  \n **Example 2: Code that runs on the server**  \n  \n [!code-vb[System.IO.BufferedStream2#1](~/add/codesnippet/visualbasic/t-system.io.bufferedstream_2.vb)]\n [!code-cs[System.IO.BufferedStream2#1](~/add/codesnippet/csharp/t-system.io.bufferedstream_2.cs)]\n [!code-cpp[System.IO.BufferedStream2#1](~/add/codesnippet/cpp/t-system.io.bufferedstream_2.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class BufferedStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)
  id: '#ctor(System.IO.Stream)'
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BufferedStream(Stream)
  nameWithType: BufferedStream.BufferedStream(Stream)
  fullName: System.IO.BufferedStream.BufferedStream(Stream)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.BufferedStream&quot;> </xref> класса размер буфера по умолчанию — 4096 байт."
  remarks: "Общий, чтение и запись буфера выделяется первый раз `BufferedStream` объект инициализируется с помощью этого конструктора. Общий буфер не используется, если все операции чтения и записи, больше или равно `bufferSize`."
  syntax:
    content: public BufferedStream (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "Текущий поток."
  overload: System.IO.BufferedStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  id: '#ctor(System.IO.Stream,System.Int32)'
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BufferedStream(Stream,Int32)
  nameWithType: BufferedStream.BufferedStream(Stream,Int32)
  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.BufferedStream&quot;> </xref> класса с заданным размером буфера."
  remarks: "Общий, чтение и запись буфера выделяется первый раз `BufferedStream` объект инициализируется с помощью этого конструктора. Общий буфер не используется, если все операции чтения и записи, больше или равно `bufferSize`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#2](~/add/codesnippet/csharp/m-system.io.bufferedstre_2_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#2](~/add/codesnippet/cpp/m-system.io.bufferedstre_2_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#2](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_2_1.vb)]"
  syntax:
    content: public BufferedStream (System.IO.Stream stream, int bufferSize);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "Текущий поток."
    - id: bufferSize
      type: System.Int32
      description: "Размер буфера в байтах."
  overload: System.IO.BufferedStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>является отрицательным значением."
  platform:
  - net462
- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Начинает операцию асинхронного чтения. (Рекомендуется использовать <xref:System.IO.BufferedStream.ReadAsync*>вместо; см. в разделе &quot;Примечания&quot;.)</xref:System.IO.BufferedStream.ReadAsync*>"
  remarks: "В .NET Framework 4 и более ранних версий, необходимо использовать методы, такие как <xref:System.IO.Stream.BeginRead%2A>и <xref:System.IO.Stream.EndRead%2A>для реализации асинхронных операций.</xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] для поддержки устаревшего кода; тем не менее, новых асинхронных методов, таких как <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, и <xref:System.IO.BufferedStream.FlushAsync%2A>, вы легко реализовать асинхронные операции с файлами справки.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       <xref:System.IO.BufferedStream.EndWrite%2A>должен вызываться ровно один раз для каждого вызова BeginRead.</xref:System.IO.BufferedStream.EndWrite%2A> Невозможность закончить процесс чтения до начала другой операции чтения может привести к нежелательным поведению, например взаимоблокировки.      Настроек [!NOTE] настроек используйте <xref:System.IO.BufferedStream.CanRead%2A>свойство, чтобы определить, поддерживает ли текущий экземпляр чтение.</xref:System.IO.BufferedStream.CanRead%2A>       <xref:System.IO.BufferedStream.EndRead%2A>должен вызываться с этим <xref:System.IAsyncResult>Чтобы узнать, сколько байтов, считанных.</xref:System.IAsyncResult></xref:System.IO.BufferedStream.EndRead%2A>"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Буфер для чтения данных."
    - id: offset
      type: System.Int32
      description: "Смещение байтов в `buffer` с которого начинается запись данных, считанных из потока."
    - id: count
      type: System.Int32
      description: "Максимальное число байтов для чтения."
    - id: callback
      type: System.AsyncCallback
      description: "Необязательный асинхронный обратный вызов, вызываемый по завершении чтения."
    - id: state
      type: System.Object
      description: "Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного асинхронного запроса на чтение от других запросов."
    return:
      type: System.IAsyncResult
      description: "Объект, представляющий асинхронное чтение, которое может все еще быть отложена."
  overload: System.IO.BufferedStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>или <code>count</code> является отрицательным значением."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Предпринята попытка асинхронного чтения за концом потока."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Длина буфера минус <code> offset </code> — меньше, чем <code> count </code>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Текущий поток не поддерживает операции чтения."
  platform:
  - net462
- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Начинает операцию асинхронной записи. (Рекомендуется использовать <xref:System.IO.BufferedStream.WriteAsync*>вместо; см. в разделе &quot;Примечания&quot;.)</xref:System.IO.BufferedStream.WriteAsync*>"
  remarks: "В .NET Framework 4 и более ранних версий, необходимо использовать методы, такие как <xref:System.IO.Stream.BeginWrite%2A>и <xref:System.IO.Stream.EndWrite%2A>для реализации асинхронных операций.</xref:System.IO.Stream.EndWrite%2A> </xref:System.IO.Stream.BeginWrite%2A> Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] для поддержки устаревшего кода; тем не менее, новых асинхронных методов, таких как <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, и <xref:System.IO.BufferedStream.FlushAsync%2A>, вы легко реализовать асинхронные операции с файлами справки.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       <xref:System.IO.BufferedStream.EndWrite%2A>должен вызываться ровно по одному разу для каждого <xref:System.IAsyncResult>из BeginWrite.</xref:System.IAsyncResult></xref:System.IO.BufferedStream.EndWrite%2A> <xref:System.IO.BufferedStream.EndWrite%2A>будет заблокирован до завершения операции ввода-вывода.</xref:System.IO.BufferedStream.EndWrite%2A>"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Буфер, содержащий данные для записи в текущий поток."
    - id: offset
      type: System.Int32
      description: "Отсчитываемое от нуля смещение в `buffer` с которого начинается копирование байтов в текущий поток."
    - id: count
      type: System.Int32
      description: "Максимальное число байтов для записи."
    - id: callback
      type: System.AsyncCallback
      description: "Метод, вызываемый после завершения операции асинхронной записи."
    - id: state
      type: System.Object
      description: "Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного асинхронного запроса запись от других запросов."
    return:
      type: System.IAsyncResult
      description: "Объект, который ссылается на асинхронную запись, которая может все еще быть отложена."
  overload: System.IO.BufferedStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>buffer</code>Длина минус <code>offset</code> — меньше, чем <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>или <code>count</code> является отрицательным значением."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает запись."
  platform:
  - net462
- uid: System.IO.BufferedStream.CanRead
  id: CanRead
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanRead
  nameWithType: BufferedStream.CanRead
  fullName: System.IO.BufferedStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Возвращает значение, указывающее, поддерживает ли текущий поток операции чтения."
  remarks: "Если класс, производный от <xref:System.IO.Stream>не поддерживает чтение, при вызове <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>и `Peek` методы <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>и <xref:System.IO.TextReader>исключение <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.TextReader> </xref:System.IO.StringReader> </xref:System.IO.StreamReader> </xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> </xref:System.IO.BufferedStream.ReadByte%2A> </xref:System.IO.BufferedStream.Read%2A> </xref:System.IO.Stream>       Если поток закрыт, это свойство возвращает `false`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#5](~/add/codesnippet/csharp/p-system.io.bufferedstre_2_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#5](~/add/codesnippet/cpp/p-system.io.bufferedstre_2_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#5](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_2_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если поток поддерживает чтение; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если поток закрыт или открыт с доступом только для записи."
  overload: System.IO.BufferedStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.CanSeek
  id: CanSeek
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
  fullName: System.IO.BufferedStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Возвращает значение, указывающее, поддерживает ли текущий поток поиск."
  remarks: "Если класс, производный от <xref:System.IO.Stream>не поддерживает поиск, при вызове <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>и <xref:System.IO.BufferedStream.Seek%2A>исключение <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.BufferedStream.Seek%2A> </xref:System.IO.BufferedStream.Position%2A> </xref:System.IO.BufferedStream.SetLength%2A> </xref:System.IO.BufferedStream.Length%2A> </xref:System.IO.Stream>       Если поток закрыт, это свойство возвращает `false`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#3](~/add/codesnippet/csharp/p-system.io.bufferedstre_0_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#3](~/add/codesnippet/cpp/p-system.io.bufferedstre_0_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#3](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_0_1.vb)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если поток поддерживает поиск; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если поток закрыт или если поток был сконструирован из дескриптора операционной системы, такие как канал или вывод на консоль."
  overload: System.IO.BufferedStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.CanWrite
  id: CanWrite
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
  fullName: System.IO.BufferedStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Возвращает значение, указывающее, поддерживает ли текущий поток операции записи."
  remarks: "Если класс, производный от <xref:System.IO.Stream>не поддерживает запись, при вызове <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, или <xref:System.IO.BufferedStream.WriteByte%2A>создает <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.BufferedStream.WriteByte%2A> </xref:System.IO.BufferedStream.Write%2A> </xref:System.IO.BufferedStream.SetLength%2A> </xref:System.IO.Stream>       Если поток закрыт, это свойство возвращает `false`."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#4](~/add/codesnippet/csharp/p-system.io.bufferedstre_1_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#4](~/add/codesnippet/cpp/p-system.io.bufferedstre_1_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#4](~/add/codesnippet/visualbasic/p-system.io.bufferedstre_1_1.vb)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если поток поддерживает запись; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если поток закрыт или открыт для доступа только для чтения."
  overload: System.IO.BufferedStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: BufferedStream.Dispose(Boolean)
  fullName: System.IO.BufferedStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "Для добавления."
  overload: System.IO.BufferedStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: BufferedStream.EndRead(IAsyncResult)
  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ожидает завершения отложенной асинхронной операции чтения для завершения. (Рекомендуется использовать <xref:System.IO.BufferedStream.ReadAsync*>вместо; см. в разделе &quot;Примечания&quot;.)</xref:System.IO.BufferedStream.ReadAsync*>"
  remarks: "В .NET Framework 4 и более ранних версий, необходимо использовать методы, такие как <xref:System.IO.Stream.BeginRead%2A>и <xref:System.IO.Stream.EndRead%2A>для реализации асинхронных операций.</xref:System.IO.Stream.EndRead%2A> </xref:System.IO.Stream.BeginRead%2A> Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] для поддержки устаревшего кода; тем не менее, новых асинхронных методов, таких как <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, и <xref:System.IO.BufferedStream.FlushAsync%2A>, вы легко реализовать асинхронные операции с файлами справки.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       С этим необходимо вызвать метод EndRead <xref:System.IAsyncResult>Чтобы узнать, сколько байтов, считанных.</xref:System.IAsyncResult>"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Ссылка на отложенный асинхронный запрос для ожидания."
    return:
      type: System.Int32
      description: "Число байтов, считанных из потока, от 0 (ноль) и количество запрошенных байтов. Потоки возвращают 0 только только в конце потока, в противном случае они должны блокироваться, пока не будет доступен по крайней мере 1 байт."
  overload: System.IO.BufferedStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Этот <xref:System.IAsyncResult>объект не был создан путем вызова <xref:System.IO.BufferedStream.BeginRead*>для этого класса.</xref:System.IO.BufferedStream.BeginRead*> </xref:System.IAsyncResult>"
  platform:
  - net462
- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: BufferedStream.EndWrite(IAsyncResult)
  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Завершает асинхронную операцию записи и блокирует до завершения операции ввода-вывода. (Рекомендуется использовать <xref:System.IO.BufferedStream.WriteAsync*>вместо; см. в разделе &quot;Примечания&quot;.)</xref:System.IO.BufferedStream.WriteAsync*>"
  remarks: "В .NET Framework 4 и более ранних версий, необходимо использовать методы, такие как <xref:System.IO.Stream.BeginWrite%2A>и <xref:System.IO.Stream.EndWrite%2A>для реализации асинхронных операций.</xref:System.IO.Stream.EndWrite%2A> </xref:System.IO.Stream.BeginWrite%2A> Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] для поддержки устаревшего кода; тем не менее, новых асинхронных методов, таких как <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, и <xref:System.IO.BufferedStream.FlushAsync%2A>, вы легко реализовать асинхронные операции с файлами справки.</xref:System.IO.BufferedStream.FlushAsync%2A> </xref:System.IO.BufferedStream.WriteAsync%2A> </xref:System.IO.BufferedStream.ReadAsync%2A>       Метод EndWrite должен вызываться ровно по одному разу для каждого вызова <xref:System.IO.BufferedStream.BeginRead%2A>.</xref:System.IO.BufferedStream.BeginRead%2A> Невозможность закончить процесс чтения до начала другой операции чтения может привести к взаимоблокировке или другим нежелательным последствиям."
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Отложенный асинхронный запрос."
  overload: System.IO.BufferedStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Этот <xref:System.IAsyncResult>объект не был создан путем вызова <xref:System.IO.BufferedStream.BeginWrite*>для этого класса.</xref:System.IO.BufferedStream.BeginWrite*> </xref:System.IAsyncResult>"
  platform:
  - net462
- uid: System.IO.BufferedStream.Flush
  id: Flush
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Flush()
  nameWithType: BufferedStream.Flush()
  fullName: System.IO.BufferedStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Очищает все буферы для этого потока и вызывает запись всех буферизованных данных в базовое устройство."
  remarks: "Сброс потока его основной кодировщик не очищается, пока не будет явно вызван метод `Flush` или <xref:System.IO.Stream.Close%2A>.</xref:System.IO.Stream.Close%2A>       Если вы используете <xref:System.IO.BufferedStream.%23ctor%2A>конструктор, в котором размер буфера при создании `BufferedStream` объекта содержимое очищается при достижении размера буфера.</xref:System.IO.BufferedStream.%23ctor%2A> Например, такие как код `BufferedStream bs = new BufferedStream(bs, 5)` содержимое будут удалены, когда размер буфера достигнет 5 байт.       Все методы чтения и записи из `BufferedStream` автоматически поддерживают буфер, поэтому нет необходимости вызывать `Flush` при переключении между чтением и записью."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_0_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_0_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_0_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.BufferedStream.Flush*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Поток был удален."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Источник данных или хранилище не открыто."
  platform:
  - net462
- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: BufferedStream.FlushAsync(CancellationToken)
  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Асинхронно очищает все буферы для этого потока, вызывает запись всех буферизованных данных в базовое устройство и отслеживает запросы отмены."
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Токен для отслеживания запросов отмены."
    return:
      type: System.Threading.Tasks.Task
      description: "Задача, представляющая асинхронную операцию очистки."
  overload: System.IO.BufferedStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Поток был удален."
  platform:
  - net462
- uid: System.IO.BufferedStream.Length
  id: Length
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Length
  nameWithType: BufferedStream.Length
  fullName: System.IO.BufferedStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Возвращает длину потока в байтах."
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "Длина потока в байтах."
  overload: System.IO.BufferedStream.Length*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Основной поток является <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> или закрыт."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает поиск."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Методы были вызваны после закрытия потока."
  platform:
  - net462
- uid: System.IO.BufferedStream.Position
  id: Position
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Position
  nameWithType: BufferedStream.Position
  fullName: System.IO.BufferedStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Возвращает позицию в текущем потоке."
  remarks: "`get` Вызывает метод доступа <xref:System.IO.BufferedStream.Seek%2A>получить текущую позицию в базовом потоке и затем изменяет это значение в соответствии с текущей позиции в буфере.</xref:System.IO.BufferedStream.Seek%2A>       `set` Доступа копирует все данные, записанные ранее в буфер в основной поток, а затем вызывает <xref:System.IO.BufferedStream.Seek%2A>.</xref:System.IO.BufferedStream.Seek%2A>       Поддерживается поиск в любом месте за пределами длины потока."
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "Позиция в текущем потоке."
  overload: System.IO.BufferedStream.Position*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Значение, передаваемое <xref:System.IO.BufferedStream.Seek*>является отрицательным значением.</xref:System.IO.BufferedStream.Seek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ошибка ввода-вывода, например указанный поток закрыт."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает поиск."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Методы были вызваны после закрытия потока."
  platform:
  - net462
- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Копирует байты из текущего буферизованного потока в массив."
  remarks: "`Read` Метод возвращает 0 только в том случае, если достигнут конец потока. Во всех остальных случаях `Read` всегда считывает хотя бы один байт из потока перед возвратом. По определению, если данные недоступны в потоке при вызове `Read`, `Read` метод возвращает значение 0 (автоматически достигается конец потока). Реализация может вернуть меньше байтов, чем было запрошено, даже если не достигнут конец потока.       Используйте <xref:System.IO.BinaryReader>для чтения простых типов данных.</xref:System.IO.BinaryReader>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#7](~/add/codesnippet/csharp/m-system.io.bufferedstre_3_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#7](~/add/codesnippet/cpp/m-system.io.bufferedstre_3_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#7](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_3_1.vb)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Буфер, в который копируются байты."
    - id: offset
      type: System.Int32
      description: "Смещение байтов в буфере, с которого должно начинаться чтение байтов."
    - id: count
      type: System.Int32
      description: "Число байтов для чтения."
    return:
      type: System.Int32
      description: "Общее число байтов, считанных в <code> array </code>. Это может быть меньше запрошенного числа байтов, если что столько байтов в настоящее время недоступны, или 0, если был достигнут конец потока перед данными может быть считаны."
  overload: System.IO.BufferedStream.Read*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>или <code>count</code> является отрицательным значением."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Поток не открыт или является <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает чтение."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Методы были вызваны после закрытия потока."
  platform:
  - net462
- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Асинхронно считывает последовательность байтов из текущего потока, перемещает позицию внутри потока на число считанных байтов и отслеживает запросы отмены."
  remarks: "Токен отмены, который можно создать путем создания экземпляра <xref:System.Threading.CancellationTokenSource>класса и передавая <xref:System.Threading.CancellationTokenSource.Token%2A>свойство как `cancellationToken` параметр.</xref:System.Threading.CancellationTokenSource.Token%2A> </xref:System.Threading.CancellationTokenSource>"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Буфер для записи данных."
    - id: offset
      type: System.Int32
      description: "Смещение байтов в `buffer` с которого начинается запись данных из потока."
    - id: count
      type: System.Int32
      description: "Максимальное число байтов для чтения."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Токен для отслеживания запросов отмены."
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "Задача, представляющая асинхронную операцию чтения. Значение <code> TResult </code> параметр содержит общее число байтов, считанных в буфер. Значение результата может быть меньше запрошенного числа байтов, если число текущих доступных байтов меньше запрошенного числа, или он может быть 0 (нуль), если был достигнут конец потока."
  overload: System.IO.BufferedStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>или <code>count</code> является отрицательным значением."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Сумма <code> offset </code> и <code> count </code> больше, чем длина буфера."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает чтение."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Поток был удален."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Поток в данный момент используется предыдущей операцией чтения."
  platform:
  - net462
- uid: System.IO.BufferedStream.ReadByte
  id: ReadByte
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: BufferedStream.ReadByte()
  fullName: System.IO.BufferedStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Считывает байт из базового потока и возвращает байт, приведенный к <xref uid=&quot;langword_csharp_int&quot; name=&quot;int&quot; href=&quot;&quot;> </xref>, или значение -1, если чтение с конца потока."
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "Байт приводится к <xref uid=&quot;langword_csharp_int&quot; name=&quot;int&quot; href=&quot;&quot;> </xref>, или значение -1, если чтение с конца потока."
  overload: System.IO.BufferedStream.ReadByte*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Ошибка ввода-вывода, например указанный поток закрыт."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает чтение."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Методы были вызваны после закрытия потока."
  platform:
  - net462
- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Задает позицию в текущий буферизованный поток."
  remarks: "Если `offset` является отрицательным, новая позиция будет предшествовать позиции, заданной параметром `origin` на число байтов, указанное в `offset`. Если `offset` равно 0, новая позиция будет позиции, указанной параметром `origin`. Если `offset` является положительным, новая позиция будет следовать позиции, указанной параметром `origin` на число байтов, указанное в `offset`.       Если <xref:System.IO.BufferedStream>объект находится в базовый поток для <xref:System.IO.StreamReader>объекта, вызов метода Seek может привести к позиции потока, больше не соответствует позиции внутреннего буфера в модуле чтения.</xref:System.IO.StreamReader> </xref:System.IO.BufferedStream> Чтобы сбросить во внутреннем буфере, вызовите <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName>метода; тем не менее, этот метод снижает производительность и должен вызываться только в случае крайней необходимости.</xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=fullName>       Поддерживается поиск в любом месте за пределами длины потока."
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "Смещение байтов относительно `origin`."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Значение типа <xref:System.IO.SeekOrigin>определяет точку отсчета для получения новой позиции.</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "Новое положение в текущий буферизованный поток."
  overload: System.IO.BufferedStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Поток не открыт или является <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает поиск."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Методы были вызваны после закрытия потока."
  platform:
  - net462
- uid: System.IO.BufferedStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: BufferedStream.SetLength(Int64)
  fullName: System.IO.BufferedStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Задает длину буферизованного потока."
  remarks: "Буфер очищается перед установкой длины базового источника данных или репозиторий. Если указанное значение меньше текущей длины буферизованного потока, буферизованный поток усекается. Если указанное значение больше текущей длины буферизованного потока, буферизованный поток будет расширен. При расширении буферизованный поток содержимого из буферизованного потока между старой и новой длины не определены.       `SetLength`Очищает весь буферизованный при необходимости.       Поток должен поддерживать запись и поиск для `SetLength` для работы."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Целое число, указывающее, требуемая длина текущего буферизованного потока в байтах."
  overload: System.IO.BufferedStream.SetLength*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>value</code>является отрицательным значением."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Поток не открыт или является <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает запись и поиск."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Методы были вызваны после закрытия потока."
  platform:
  - net462
- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Копирует байты в буферизованный поток и перемещает текущую позицию в буферизованном потоке на число записанных байтов."
  remarks: ''
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.  \n  \n [!code-cs[System.IO.BufferedStream1#6](~/add/codesnippet/csharp/m-system.io.bufferedstre_1_1.cs)]\n [!code-cpp[System.IO.BufferedStream1#6](~/add/codesnippet/cpp/m-system.io.bufferedstre_1_1.cpp)]\n [!code-vb[System.IO.BufferedStream1#6](~/add/codesnippet/visualbasic/m-system.io.bufferedstre_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Массив байтов, из которого копируются `count` байтов в текущий буферизованный поток."
    - id: offset
      type: System.Int32
      description: "Смещение в буфере, с которого начинается копирование байтов в текущий буферизованный поток."
    - id: count
      type: System.Int32
      description: "Число байтов для записи в текущий буферизованный поток."
  overload: System.IO.BufferedStream.Write*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>array</code> minus <code>offset</code> is less than <code>count</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>или <code>count</code> является отрицательным значением."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Поток закрыт или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает запись."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Методы были вызваны после закрытия потока."
  platform:
  - net462
- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Асинхронно записывает последовательность байтов в текущий поток, перемещает текущую позицию внутри потока на число записанных байтов и отслеживает запросы отмены."
  remarks: "Токен отмены, который можно создать путем создания экземпляра <xref:System.Threading.CancellationTokenSource>класса и передавая <xref:System.Threading.CancellationTokenSource.Token%2A>свойство как `cancellationToken` параметр.</xref:System.Threading.CancellationTokenSource.Token%2A> </xref:System.Threading.CancellationTokenSource>"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Буфер, из которого записываются данные."
    - id: offset
      type: System.Int32
      description: "Отсчитываемое от нуля смещение в `buffer` с которого начинается копирование байтов в поток."
    - id: count
      type: System.Int32
      description: "Максимальное число байтов для записи."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Токен для отслеживания запросов отмены."
    return:
      type: System.Threading.Tasks.Task
      description: "Задача, представляющая асинхронную операцию записи."
  overload: System.IO.BufferedStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>или <code>count</code> является отрицательным значением."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Сумма <code> offset </code> и <code> count </code> больше, чем длина буфера."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает запись."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Поток был удален."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Поток в данный момент используется предыдущей операцией записи."
  platform:
  - net462
- uid: System.IO.BufferedStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.BufferedStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: BufferedStream.WriteByte(Byte)
  fullName: System.IO.BufferedStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Записывает байт в текущее положение в буферизованный поток."
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "Байт, записываемый в поток."
  overload: System.IO.BufferedStream.WriteByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает запись."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>value</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Методы были вызваны после закрытия потока."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream(Stream)
  nameWithType: BufferedStream.BufferedStream(Stream)
  fullName: System.IO.BufferedStream.BufferedStream(Stream)
- uid: System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream(Stream,Int32)
  nameWithType: BufferedStream.BufferedStream(Stream,Int32)
  fullName: System.IO.BufferedStream.BufferedStream(Stream,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.BufferedStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.BufferedStream.CanRead
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanRead
  nameWithType: BufferedStream.CanRead
  fullName: System.IO.BufferedStream.CanRead
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.BufferedStream.CanSeek
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
  fullName: System.IO.BufferedStream.CanSeek
- uid: System.IO.BufferedStream.CanWrite
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
  fullName: System.IO.BufferedStream.CanWrite
- uid: System.IO.BufferedStream.Dispose(System.Boolean)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: BufferedStream.Dispose(Boolean)
  fullName: System.IO.BufferedStream.Dispose(Boolean)
- uid: System.IO.BufferedStream.EndRead(System.IAsyncResult)
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: BufferedStream.EndRead(IAsyncResult)
  fullName: System.IO.BufferedStream.EndRead(IAsyncResult)
- uid: System.IO.BufferedStream.EndWrite(System.IAsyncResult)
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: BufferedStream.EndWrite(IAsyncResult)
  fullName: System.IO.BufferedStream.EndWrite(IAsyncResult)
- uid: System.IO.BufferedStream.Flush
  parent: System.IO.BufferedStream
  isExternal: false
  name: Flush()
  nameWithType: BufferedStream.Flush()
  fullName: System.IO.BufferedStream.Flush()
- uid: System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: BufferedStream.FlushAsync(CancellationToken)
  fullName: System.IO.BufferedStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.BufferedStream.Length
  parent: System.IO.BufferedStream
  isExternal: false
  name: Length
  nameWithType: BufferedStream.Length
  fullName: System.IO.BufferedStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.BufferedStream.Position
  parent: System.IO.BufferedStream
  isExternal: false
  name: Position
  nameWithType: BufferedStream.Position
  fullName: System.IO.BufferedStream.Position
- uid: System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Read(Byte[],Int32,Int32)
- uid: System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.BufferedStream.ReadByte
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadByte()
  nameWithType: BufferedStream.ReadByte()
  fullName: System.IO.BufferedStream.ReadByte()
- uid: System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: BufferedStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.BufferedStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.BufferedStream.SetLength(System.Int64)
  parent: System.IO.BufferedStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: BufferedStream.SetLength(Int64)
  fullName: System.IO.BufferedStream.SetLength(Int64)
- uid: System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.BufferedStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: BufferedStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.BufferedStream.Write(Byte[],Int32,Int32)
- uid: System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.BufferedStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.BufferedStream.WriteByte(System.Byte)
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: BufferedStream.WriteByte(Byte)
  fullName: System.IO.BufferedStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.BufferedStream.#ctor*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BufferedStream
  nameWithType: BufferedStream.BufferedStream
- uid: System.IO.BufferedStream.BeginRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginRead
  nameWithType: BufferedStream.BeginRead
- uid: System.IO.BufferedStream.BeginWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: BeginWrite
  nameWithType: BufferedStream.BeginWrite
- uid: System.IO.BufferedStream.CanRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanRead
  nameWithType: BufferedStream.CanRead
- uid: System.IO.BufferedStream.CanSeek*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanSeek
  nameWithType: BufferedStream.CanSeek
- uid: System.IO.BufferedStream.CanWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: CanWrite
  nameWithType: BufferedStream.CanWrite
- uid: System.IO.BufferedStream.Dispose*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Dispose
  nameWithType: BufferedStream.Dispose
- uid: System.IO.BufferedStream.EndRead*
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndRead
  nameWithType: BufferedStream.EndRead
- uid: System.IO.BufferedStream.EndWrite*
  parent: System.IO.BufferedStream
  isExternal: false
  name: EndWrite
  nameWithType: BufferedStream.EndWrite
- uid: System.IO.BufferedStream.Flush*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Flush
  nameWithType: BufferedStream.Flush
- uid: System.IO.BufferedStream.FlushAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: FlushAsync
  nameWithType: BufferedStream.FlushAsync
- uid: System.IO.BufferedStream.Length*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Length
  nameWithType: BufferedStream.Length
- uid: System.IO.BufferedStream.Position*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Position
  nameWithType: BufferedStream.Position
- uid: System.IO.BufferedStream.Read*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Read
  nameWithType: BufferedStream.Read
- uid: System.IO.BufferedStream.ReadAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadAsync
  nameWithType: BufferedStream.ReadAsync
- uid: System.IO.BufferedStream.ReadByte*
  parent: System.IO.BufferedStream
  isExternal: false
  name: ReadByte
  nameWithType: BufferedStream.ReadByte
- uid: System.IO.BufferedStream.Seek*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Seek
  nameWithType: BufferedStream.Seek
- uid: System.IO.BufferedStream.SetLength*
  parent: System.IO.BufferedStream
  isExternal: false
  name: SetLength
  nameWithType: BufferedStream.SetLength
- uid: System.IO.BufferedStream.Write*
  parent: System.IO.BufferedStream
  isExternal: false
  name: Write
  nameWithType: BufferedStream.Write
- uid: System.IO.BufferedStream.WriteAsync*
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteAsync
  nameWithType: BufferedStream.WriteAsync
- uid: System.IO.BufferedStream.WriteByte*
  parent: System.IO.BufferedStream
  isExternal: false
  name: WriteByte
  nameWithType: BufferedStream.WriteByte
