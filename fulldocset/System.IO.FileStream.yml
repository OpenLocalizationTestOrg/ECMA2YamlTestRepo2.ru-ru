### YamlMime:ManagedReference
items:
- uid: System.IO.FileStream
  id: FileStream
  children:
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.CanRead
  - System.IO.FileStream.CanSeek
  - System.IO.FileStream.CanWrite
  - System.IO.FileStream.Dispose(System.Boolean)
  - System.IO.FileStream.EndRead(System.IAsyncResult)
  - System.IO.FileStream.EndWrite(System.IAsyncResult)
  - System.IO.FileStream.Finalize
  - System.IO.FileStream.Flush
  - System.IO.FileStream.Flush(System.Boolean)
  - System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.FileStream.GetAccessControl
  - System.IO.FileStream.Handle
  - System.IO.FileStream.IsAsync
  - System.IO.FileStream.Length
  - System.IO.FileStream.Lock(System.Int64,System.Int64)
  - System.IO.FileStream.Name
  - System.IO.FileStream.Position
  - System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.ReadByte
  - System.IO.FileStream.SafeFileHandle
  - System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.SetLength(System.Int64)
  - System.IO.FileStream.Unlock(System.Int64,System.Int64)
  - System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: FileStream
  nameWithType: FileStream
  fullName: System.IO.FileStream
  type: Class
  summary: "Предоставляет <xref:System.IO.Stream>в файле, поддерживая синхронные и асинхронные чтения и записи операций.</xref:System.IO.Stream>       Для просмотра исходного кода .NET Framework для этого типа, в разделе [ссылки на источник](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3)."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Use the FileStream class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output. You can use the [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), <xref:System.IO.Stream.CopyTo%2A>, and <xref:System.IO.FileStream.Flush%2A> methods to perform synchronous operations, or the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A> methods to perform asynchronous operations. Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread. This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working. FileStream buffers input and output for better performance.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n The <xref:System.IO.FileStream.IsAsync%2A> property detects whether the file handle was opened asynchronously. You specify this value when you create an instance of the FileStream class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter. When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously. However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method. When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.  \n  \n The <xref:System.IO.FileStream.Seek%2A> method supports random access to files. <xref:System.IO.FileStream.Seek%2A> allows the read/write position to be moved to any position within the file. This is done with byte offset reference point parameters. The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <xref:System.IO.SeekOrigin> enumeration.  \n  \n> [!NOTE]\n>  Disk files always support random access. At the time of construction, the <xref:System.IO.FileStream.CanSeek%2A> property value is set to `true` or `false` depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <xref:System.IO.FileStream.CanSeek%2A> property value is `true`. Otherwise, the <xref:System.IO.FileStream.CanSeek%2A> property value is `false`.  \n  \n If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.  \n  \n For directory operations and other file operations, see the <xref:System.IO.File>, <xref:System.IO.Directory>, and <xref:System.IO.Path> classes. The <xref:System.IO.File> class is a utility class that has static methods primarily for the creation of FileStream objects based on file paths. The <xref:System.IO.MemoryStream> class creates a stream from a byte array and is similar to the FileStream class.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md).  \n  \n## Detection of Stream Position Changes  \n When a FileStream object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle. In this case, the cached position in the FileStream object and the cached data in the buffer could be compromised. The FileStream object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the FileStream object.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Read%2A> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again. This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Write%2A> method, the contents of the buffer are discarded and an <xref:System.IO.IOException> exception is thrown.  \n  \n A FileStream object will not have an exclusive hold on its handle when either the <xref:System.IO.FileStream.SafeFileHandle%2A> property is accessed to expose the handle or the FileStream object is given the <xref:System.IO.FileStream.SafeFileHandle%2A> property in its constructor."
  example:
  - "The following example demonstrates some of the FileStream constructors.  \n  \n [!code-cs[fstream class#1](~/add/codesnippet/csharp/t-system.io.filestream_1.cs)]\n [!code-vb[fstream class#1](~/add/codesnippet/visualbasic/t-system.io.filestream_1.vb)]\n [!code-cpp[fstream class#1](~/add/codesnippet/cpp/t-system.io.filestream_1.cpp)]  \n  \n The following example shows how to write to a file asynchronously. This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click. The file path needs to be changed to a file than exits on the computer.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/t-system.io.filestream_2.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/t-system.io.filestream_2.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class FileStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.FileStream&quot;> </xref> класс для заданного дескриптора файла, используя указанный чтения и записи."
  remarks: "Если <xref:System.IO.Stream.Close%2A>будет вызван, дескриптор также закрывается и уменьшается число дескрипторов файлов.</xref:System.IO.Stream.Close%2A>       `FileStream`предполагается, что он имеет исключительный контроль над маркером. Чтение, запись или поиск при `FileStream` также удерживает дескриптор может привести к повреждению данных. Безопасность данных, вызовите <xref:System.IO.FileStream.Flush%2A>перед использованием дескриптора и избежать вызов любых методов кроме `Close` после завершения использования дескриптора.</xref:System.IO.FileStream.Flush%2A>      Настроек [!CAUTION] настроек при компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символов будет невозможно и может вызвать исключение, создаваемое исключение.       `FileShare.Read`значение по умолчанию для тех, кто <xref:System.IO.FileStream>конструкторов без `FileShare` параметр.</xref:System.IO.FileStream>       Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Дескриптор файла для файла, текущий <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> будет инкапсулироваться объектом."
    - id: access
      type: System.IO.FileAccess
      description: "Константа, которая задает <> </> *настроек и <> </> *настроек свойств <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>не является полем <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например ошибка диска.       - или - поток был закрыт."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Запрошенный не разрешен операционной системой для заданного дескриптора файла, например когда <code> access </code> — <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> и дескриптора файлов установлен доступ только для чтения."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  id: '#ctor(System.IntPtr,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.FileStream&quot;> </xref> класс для заданного дескриптора файла, используя указанный чтения и записи."
  remarks: "Если <xref:System.IO.Stream.Close%2A>будет вызван, дескриптор также закрывается и уменьшается число дескрипторов файлов.</xref:System.IO.Stream.Close%2A>       `FileStream`предполагается, что он имеет исключительный контроль над маркером. Чтение, запись или поиск при `FileStream` также удерживает дескриптор может привести к повреждению данных. Безопасность данных, вызовите <xref:System.IO.FileStream.Flush%2A>перед использованием дескриптора и избежать вызов любых методов кроме `Close` после завершения использования дескриптора.</xref:System.IO.FileStream.Flush%2A>      Настроек [!CAUTION] настроек при компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символов будет невозможно и может вызвать исключение, создаваемое исключение.       `FileShare.Read`значение по умолчанию для тех, кто <xref:System.IO.FileStream>конструкторов без `FileShare` параметр.</xref:System.IO.FileStream>       Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Дескриптор файла для файла, текущий <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> будет инкапсулироваться объектом."
    - id: access
      type: System.IO.FileAccess
      description: "Константа, которая задает <> </> *настроек и <> </> *настроек свойств <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>не является полем <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например ошибка диска.       - или - поток был закрыт."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Запрошенный не разрешен операционной системой для заданного дескриптора файла, например когда <code> access </code> — <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> и дескриптора файлов установлен доступ только для чтения."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.FileStream&quot;> </xref> класса с указанным путем и режимом создания."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).  \n  \n You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a `FileAccess` parameter with the value set to `FileAccess.Read`.  \n  \n The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n For constructors without a <xref:System.IO.FileAccess> parameter, if the `mode` parameter is set to <xref:System.IO.FileMode>, <xref:System.IO.FileAccess> is the default access. Otherwise, the access is set to <xref:System.IO.FileAccess>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_0_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "Относительный или абсолютный путь к файлу, текущий <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> будет инкапсулироваться объектом."
    - id: mode
      type: System.IO.FileMode
      description: "Константа, определяющая способ открытия или создания файла."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>является пустой строкой (&quot;»), содержащую только пробелы или содержит один или несколько недопустимых символов.       - или - <code>path</code> ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде с отличной от NTFS."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Не удается найти файл, например когда <code> mode </code> — <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>и файл, указанный параметром <code> path </code> не существует. Файл должен уже существовать в этих режимах."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например задание <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> когда файл, заданный параметром <code> path </code> уже существует, произошло.       - или - поток был закрыт."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Указанный путь является недопустимым, например, ведущий на несопоставленный диск."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Указанный путь и имя файла превышает максимальную длину, определенная системой. Например для платформ на основе Windows пути должна составлять менее 248 знаков и имена файлов должны быть короче 260 символов."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>содержит недопустимое значение."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.FileStream&quot;> </xref> класса для заданного дескриптора файла, с разрешениями указанной чтения и записи и размер буфера."
  remarks: "`FileStream`предполагается, что он имеет исключительный контроль над маркером. Чтение, запись или поиск при `FileStream` также удерживает дескриптор может привести к повреждению данных. Безопасность данных, вызовите <xref:System.IO.FileStream.Flush%2A>перед использованием дескриптора и избежать вызов любых методов кроме `Close` после завершения использования дескриптора.</xref:System.IO.FileStream.Flush%2A> Кроме того, чтение и запись в дескриптор, перед вызовом этого `FileStream` конструктор.       `FileShare.Read`значение по умолчанию для тех, кто <xref:System.IO.FileStream>конструкторов без `FileShare` параметр.</xref:System.IO.FileStream>      Настроек [!CAUTION] настроек при компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символов будет невозможно и может вызвать исключение, создаваемое исключение.       Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Дескриптор файла для файла, текущий <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> будет инкапсулироваться объектом."
    - id: access
      type: System.IO.FileAccess
      description: "Объект <xref href=&quot;System.IO.FileAccess&quot;> </xref> константа, которая задает <> </> *настроек и <> </> *настроек свойств <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта."
    - id: bufferSize
      type: System.Int32
      description: "Положительное <xref:System.Int32>значение, большее 0, определяющее размер буфера.</xref:System.Int32> Размер буфера по умолчанию — 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> handle </code> Параметр имеет недопустимый дескриптор.       - или - <code> handle </code> параметра является синхронным дескриптором, но был использован асинхронно."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> bufferSize </code> Параметр имеет отрицательное значение."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например ошибка диска.       - или - поток был закрыт."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Запрошенный не разрешен операционной системой для заданного дескриптора файла, например когда <code> access </code> — <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> и дескриптора файлов установлен доступ только для чтения."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.FileStream&quot;> </xref> класс для заданного дескриптора файла, используя указанный чтения и записи и <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> владельца экземпляра."
  remarks: "`FileStream` Объекту присваивается указанный доступ к файлу. Владение дескриптор может быть как указано. Если процесс владеет дескриптором, при вызове <xref:System.IO.Stream.Close%2A>метода также будет закрыт дескриптор и уменьшается значение счетчика дескриптора файла.</xref:System.IO.Stream.Close%2A> `FileStream` Объекту присваивается размер буфера по умолчанию 4096 байт.       `FileStream`предполагается, что он имеет исключительный контроль над маркером. Чтение, запись или поиск при `FileStream` также удерживает дескриптор может привести к повреждению данных. Безопасность данных, вызовите <xref:System.IO.FileStream.Flush%2A>перед использованием дескриптора и избегать вызова методов не `Close` после завершения использования дескриптора.</xref:System.IO.FileStream.Flush%2A>       `FileShare.Read`значение по умолчанию для тех, кто <xref:System.IO.FileStream>конструкторов без `FileShare` параметр.</xref:System.IO.FileStream>      Настроек [!CAUTION] настроек при компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символов будет невозможно и может вызвать исключение, создаваемое исключение.       Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Дескриптор файла для файла, текущий <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> будет инкапсулироваться объектом."
    - id: access
      type: System.IO.FileAccess
      description: "Константа, которая задает <> </> *настроек и <> </> *настроек свойств <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если владельцем дескриптора файла будет иметь это <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> экземпляра; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>не является полем <xref href=&quot;System.IO.FileAccess&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например ошибка диска.       - или - поток был закрыт."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Запрошенный не разрешен операционной системой для заданного дескриптора файла, например когда <code> access </code> — <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> и дескриптора файлов установлен доступ только для чтения."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.FileStream&quot;> </xref> класса с указанным путем, режимом создания и разрешением на чтение и запись."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "Относительный или абсолютный путь к файлу, текущий <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> будет инкапсулироваться объектом."
    - id: mode
      type: System.IO.FileMode
      description: "Константа, определяющая способ открытия или создания файла."
    - id: access
      type: System.IO.FileAccess
      description: "Константа, определяющая способ доступа к файлу можно по <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта. Также определяет значения, возвращаемые методом <> </> *настроек и <> </> *настроек свойств <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта. <xref:System.IO.FileStream.CanSeek*>— <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Если `path` указывает файл на диске.</xref:System.IO.FileStream.CanSeek*>"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>является пустой строкой (&quot;»), содержащую только пробелы или содержит один или несколько недопустимых символов.       - или - <code>path</code> ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде с отличной от NTFS."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Не удается найти файл, например когда <code> mode </code> — <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>и файл, указанный параметром <code> path </code> не существует. Файл должен уже существовать в этих режимах."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например задание <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> когда файл, заданный параметром <code> path </code> уже существует, произошло.       - или - поток был закрыт."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Указанный путь является недопустимым, например, ведущий на несопоставленный диск."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Запрошенный не разрешен операционной системой для указанного <code> path </code>, например когда <code> access </code> — <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> и файла или каталога установлен доступ только для чтения."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Указанный путь и имя файла превышает максимальную длину, определенная системой. Например для платформ на основе Windows пути должна составлять менее 248 знаков и имена файлов должны быть короче 260 символов."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>содержит недопустимое значение."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.FileStream&quot;> </xref> класс для заданного дескриптора файла, с разрешения указанного чтение и запись, размером буфера и синхронным или асинхронным состоянием."
  remarks: "Задать `isAsync` параметр `true` для открытия дескриптора файла асинхронно. Если аргумент принимает значение `true`, поток использует перекрывающегося ввода-вывода для асинхронного выполнения операций с файлами. Тем не менее, параметр не обязательно должен быть `true` для вызова <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, или <xref:System.IO.Stream.CopyToAsync%2A>метод.</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> Когда `isAsync` параметр `false` и вызова асинхронного чтения и записи операций, в поток пользовательского интерфейса не блокируется, но фактические операции ввода-вывода выполняется синхронно.       `FileStream`предполагается, что он имеет исключительный контроль над маркером. Чтение, запись или поиск при `FileStream` также удерживает дескриптор может привести к повреждению данных. Безопасность данных, вызовите <xref:System.IO.FileStream.Flush%2A>перед использованием дескриптора и избежать вызов любых методов кроме `Close` после завершения использования дескриптора.</xref:System.IO.FileStream.Flush%2A> Кроме того, чтение и запись в дескриптор, перед вызовом этого `FileStream` конструктор.       `FileShare.Read`значение по умолчанию для тех, кто <xref:System.IO.FileStream>конструкторов без `FileShare` параметр.</xref:System.IO.FileStream>      Настроек [!CAUTION] настроек при компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символов будет невозможно и может вызвать исключение, создаваемое исключение.       Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Дескриптор файла для файла, <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> будет инкапсулироваться объектом."
    - id: access
      type: System.IO.FileAccess
      description: "Константа, которая задает <> </> *настроек и <> </> *настроек свойств <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта."
    - id: bufferSize
      type: System.Int32
      description: "Положительное <xref:System.Int32>значение, большее 0, определяющее размер буфера.</xref:System.Int32> Размер буфера по умолчанию — 4096."
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если этот дескриптор был открыт асинхронно (т. е в перекрывающегося режим ввода-вывода); в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> handle </code> Параметр имеет недопустимый дескриптор.       - или - <code> handle </code> параметра является синхронным дескриптором, но был использован асинхронно."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> bufferSize </code> Параметр имеет отрицательное значение."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например ошибка диска.       - или - поток был закрыт."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Запрошенный не разрешен операционной системой для заданного дескриптора файла, например когда <code> access </code> — <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> и дескриптора файлов установлен доступ только для чтения."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.FileStream&quot;> </xref> класс для заданного дескриптора файла, с разрешениями указанной чтения и записи, <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> владельца экземпляра и размер буфера."
  remarks: "`FileStream` Объекту присваивается указанный доступ к файлу. Владение дескриптор может быть как указано. Если этот `FileStream` владеет дескриптором, при вызове <xref:System.IO.Stream.Close%2A>метода также будет закрыт дескриптор.</xref:System.IO.Stream.Close%2A> В частности уменьшается количество дескрипторов файлов. `FileStream` Объекту присваивается заданный размер буфера.       `FileStream`предполагается, что он имеет исключительный контроль над маркером. Чтение, запись или поиск при `FileStream` также удерживает дескриптор может привести к повреждению данных. Безопасность данных, вызовите <xref:System.IO.FileStream.Flush%2A>перед использованием дескриптора и избежать вызов любых методов кроме `Close` после завершения использования дескриптора.</xref:System.IO.FileStream.Flush%2A> Кроме того, чтение и запись в дескриптор, перед вызовом этого `FileStream` конструктор.       `FileShare.Read`значение по умолчанию для тех, кто <xref:System.IO.FileStream>конструкторов без `FileShare` параметр.</xref:System.IO.FileStream>      Настроек [!CAUTION] настроек при компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символов будет невозможно и может вызвать исключение, создаваемое исключение.       Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Дескриптор файла для файла, <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> будет инкапсулироваться объектом."
    - id: access
      type: System.IO.FileAccess
      description: "Константа, которая задает <> </> *настроек и <> </> *настроек свойств <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если владельцем дескриптора файла будет иметь это <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> экземпляра; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: bufferSize
      type: System.Int32
      description: "Положительное <xref:System.Int32>значение, большее 0, определяющее размер буфера.</xref:System.Int32> Размер буфера по умолчанию — 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>является отрицательным значением."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например ошибка диска.       - или - поток был закрыт."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Запрошенный не разрешен операционной системой для заданного дескриптора файла, например когда <code> access </code> — <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> и дескриптора файлов установлен доступ только для чтения."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.FileStream&quot;> </xref> класса с указанным путем, режимом создания, разрешениями на чтение и запись и разрешением на совместное использование."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#2](~/add/codesnippet/csharp/904a8302-b9b6-44f1-89c4-_1.cs)]\n [!code-cpp[System.IO.FileStream3#2](~/add/codesnippet/cpp/904a8302-b9b6-44f1-89c4-_1.cpp)]\n [!code-vb[System.IO.FileStream3#2](~/add/codesnippet/visualbasic/904a8302-b9b6-44f1-89c4-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "Относительный или абсолютный путь к файлу, текущий <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> будет инкапсулироваться объектом."
    - id: mode
      type: System.IO.FileMode
      description: "Константа, определяющая способ открытия или создания файла."
    - id: access
      type: System.IO.FileAccess
      description: "Константа, определяющая способ доступа к файлу можно по <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта. Также определяет значения, возвращаемые методом <> </> *настроек и <> </> *настроек свойств <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта. <xref:System.IO.FileStream.CanSeek*>— <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Если `path` указывает файл на диске.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Константа, определяющая способ совместного использования файла процессами."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>является пустой строкой (&quot;»), содержащую только пробелы или содержит один или несколько недопустимых символов.       - или - <code>path</code> ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде с отличной от NTFS."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Не удается найти файл, например когда <code> mode </code> — <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>и файл, указанный параметром <code> path </code> не существует. Файл должен уже существовать в этих режимах."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например задание <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> когда файл, заданный параметром <code> path </code> уже существует, произошло.       - или - что в системе Windows 98 или Windows 98 Second Edition и <code> share </code> равно <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - или - поток был закрыт."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Указанный путь является недопустимым, например, ведущий на несопоставленный диск."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Запрошенный не разрешен операционной системой для указанного <code> path </code>, например когда <code> access </code> — <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> и файла или каталога установлен доступ только для чтения."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Указанный путь и имя файла превышает максимальную длину, определенная системой. Например для платформ на основе Windows пути должна составлять менее 248 знаков и имена файлов должны быть короче 260 символов."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>содержит недопустимое значение."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.FileStream&quot;> </xref> класс для заданного дескриптора файла, с разрешениями указанной чтения и записи, <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> экземпляра владения, размером буфера и синхронным или асинхронным состоянием."
  remarks: "`FileStream` Объекту присваивается указанный доступ к файлу. Владение дескриптор может быть как указано. Если этот `FileStream` владеет дескриптором, при вызове <xref:System.IO.Stream.Close%2A>метода также будет закрыт дескриптор.</xref:System.IO.Stream.Close%2A> В частности уменьшается количество дескрипторов файлов. `FileStream` Объекту присваивается заданный размер буфера.       `FileStream`предполагается, что он имеет исключительный контроль над маркером. Чтение, запись или поиск при `FileStream` также удерживает дескриптор может привести к повреждению данных. Безопасность данных, вызовите <xref:System.IO.FileStream.Flush%2A>перед использованием дескриптора и избежать вызов любых методов кроме `Close` после завершения использования дескриптора.</xref:System.IO.FileStream.Flush%2A> Кроме того, чтение и запись в дескриптор, перед вызовом этого `FileStream` конструктор.       `FileShare.Read`значение по умолчанию для тех, кто <xref:System.IO.FileStream>конструкторов без `FileShare` параметр.</xref:System.IO.FileStream>      Настроек [!CAUTION] настроек при компиляции с определенным параметром культуры набор символов и получить те же символы с параметром символов будет невозможно и может вызвать исключение, создаваемое исключение.       Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "Дескриптор файла для файла, <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> будет инкапсулироваться объектом."
    - id: access
      type: System.IO.FileAccess
      description: "Константа, которая задает <> </> *настроек и <> </> *настроек свойств <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта."
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если владельцем дескриптора файла будет иметь это <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> экземпляра; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: bufferSize
      type: System.Int32
      description: "Положительное <xref:System.Int32>значение, большее 0, определяющее размер буфера.</xref:System.Int32> Размер буфера по умолчанию — 4096."
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если этот дескриптор был открыт асинхронно (т. е в перекрывающегося режим ввода-вывода); в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>access</code>— меньше, чем <xref uid=&quot;langword_csharp_FileAccess.Read&quot; name=&quot;FileAccess.Read&quot; href=&quot;&quot;> </xref> или больше, чем <xref uid=&quot;langword_csharp_FileAccess.ReadWrite&quot; name=&quot;FileAccess.ReadWrite&quot; href=&quot;&quot;> </xref> или <code>bufferSize</code> меньше или равно 0."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Недопустимый дескриптор."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например ошибка диска.       - или - поток был закрыт."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Запрошенный не разрешен операционной системой для заданного дескриптора файла, например когда <code> access </code> — <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> и дескриптора файлов установлен доступ только для чтения."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.FileStream&quot;> </xref> класса с заданным путем, режимом создания, чтение и запись и совместное использование, а также размер буфера."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);
    parameters:
    - id: path
      type: System.String
      description: "Относительный или абсолютный путь к файлу, текущий <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> будет инкапсулироваться объектом."
    - id: mode
      type: System.IO.FileMode
      description: "Константа, определяющая способ открытия или создания файла."
    - id: access
      type: System.IO.FileAccess
      description: "Константа, определяющая способ доступа к файлу можно по <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта. Также определяет значения, возвращаемые методом <> </> *настроек и <> </> *настроек свойств <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта. <xref:System.IO.FileStream.CanSeek*>— <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Если `path` указывает файл на диске.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Константа, определяющая способ совместного использования файла процессами."
    - id: bufferSize
      type: System.Int32
      description: "Положительное <xref:System.Int32>значение, большее 0, определяющее размер буфера.</xref:System.Int32> Размер буфера по умолчанию — 4096."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>является пустой строкой (&quot;»), содержащую только пробелы или содержит один или несколько недопустимых символов.       - или - <code>path</code> ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде с отличной от NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>является отрицательным или равняться нулю.       - или - <code>mode</code>, <code>access</code>, или <code>share</code> содержит недопустимое значение."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Не удается найти файл, например когда <code> mode </code> — <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>и файл, указанный параметром <code> path </code> не существует. Файл должен уже существовать в этих режимах."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например задание <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> когда файл, заданный параметром <code> path </code> уже существует, произошло.       - или - что в системе Windows 98 или Windows 98 Second Edition и <code> share </code> равно <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - или - поток был закрыт."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Указанный путь является недопустимым, например, ведущий на несопоставленный диск."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Запрошенный не разрешен операционной системой для указанного <code> path </code>, например когда <code> access </code> — <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> и файла или каталога установлен доступ только для чтения."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Указанный путь и имя файла превышает максимальную длину, определенная системой. Например для платформ на основе Windows пути должна составлять менее 248 знаков и имена файлов должны быть короче 260 символов."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.FileStream&quot;> </xref> класса с заданным путем, режимом создания, чтения и записи и совместное использование, буфера размером и синхронным или асинхронным состоянием."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly. A `State` object is created to pass information from the main thread to the `EndReadCallback` and `EndWriteCallback` methods.  \n  \n [!code-cs[System.IO.FileStream2#1](~/add/codesnippet/csharp/ff94fabb-a26d-4ac2-a74e-_1.cs)]\n [!code-vb[System.IO.FileStream2#1](~/add/codesnippet/visualbasic/ff94fabb-a26d-4ac2-a74e-_1.vb)]\n [!code-cpp[System.IO.FileStream2#1](~/add/codesnippet/cpp/ff94fabb-a26d-4ac2-a74e-_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);
    parameters:
    - id: path
      type: System.String
      description: "Относительный или абсолютный путь к файлу, текущий <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> будет инкапсулироваться объектом."
    - id: mode
      type: System.IO.FileMode
      description: "Константа, определяющая способ открытия или создания файла."
    - id: access
      type: System.IO.FileAccess
      description: "Константа, определяющая способ доступа к файлу можно по <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта. Также определяет значения, возвращаемые методом <> </> *настроек и <> </> *настроек свойств <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта. <xref:System.IO.FileStream.CanSeek*>— <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Если `path` указывает файл на диске.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Константа, определяющая способ совместного использования файла процессами."
    - id: bufferSize
      type: System.Int32
      description: "Положительное <xref:System.Int32>значение, большее 0, определяющее размер буфера.</xref:System.Int32> Размер буфера по умолчанию — 4096..."
    - id: useAsync
      type: System.Boolean
      description: "Указывает, использовать ли асинхронный ввод-вывод или синхронный ввод-вывод. Однако обратите внимание, что базовая операционная система может не поддерживать асинхронный ввод-вывод, поэтому, когда задается <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, дескриптор может быть открыт синхронно в зависимости от платформы. При асинхронном открытии <> </> *настроек и <> </> *настроек методы выполняются лучше при больших операций чтения или записи, но они могут работать намного медленнее для небольших операций чтения или записи. Если приложение разработано получить преимущества асинхронного ввода-вывода, установите `useAsync` параметр <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>. Правильно с помощью асинхронного ввода-вывода может возрасти вплоть до столько коэффициентом 10, но использование без переработки приложения для асинхронного ввода-вывода может привести к снижению производительности столько же 10 раз."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>является пустой строкой (&quot;»), содержащую только пробелы или содержит один или несколько недопустимых символов.       - или - <code>path</code> ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде с отличной от NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>является отрицательным или равняться нулю.       - или - <code>mode</code>, <code>access</code>, или <code>share</code> содержит недопустимое значение."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Не удается найти файл, например когда <code> mode </code> — <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>и файл, указанный параметром <code> path </code> не существует. Файл должен уже существовать в этих режимах."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например задание <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> когда файл, заданный параметром <code> path </code> уже существует, произошло.       - или - что в системе Windows 98 или Windows 98 Second Edition и <code> share </code> равно <xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>.       - или - поток был закрыт."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Указанный путь является недопустимым, например, ведущий на несопоставленный диск."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Запрошенный не разрешен операционной системой для указанного <code> path </code>, например когда <code> access </code> — <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> и файла или каталога установлен доступ только для чтения."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Указанный путь и имя файла превышает максимальную длину, определенная системой. Например для платформ на основе Windows пути должна составлять менее 248 знаков и имена файлов должны быть короче 260 символов."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.FileStream&quot;> </xref> класса с заданным путем, режимом создания, чтение, запись и совместное использование, доступом других FileStreams к тому же файлу, размером буфера и дополнительными параметрами файла."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor1#1](~/add/codesnippet/cpp/53f739ba-7c4d-43ff-a387-_1.cpp)]\n [!code-vb[IO.FileStream.ctor1#1](~/add/codesnippet/visualbasic/53f739ba-7c4d-43ff-a387-_1.vb)]\n [!code-cs[IO.FileStream.ctor1#1](~/add/codesnippet/csharp/53f739ba-7c4d-43ff-a387-_1.cs)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "Относительный или абсолютный путь к файлу, текущий <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> будет инкапсулироваться объектом."
    - id: mode
      type: System.IO.FileMode
      description: "Константа, определяющая способ открытия или создания файла."
    - id: access
      type: System.IO.FileAccess
      description: "Константа, определяющая способ доступа к файлу можно по <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта. Также определяет значения, возвращаемые методом <> </> *настроек и <> </> *настроек свойств <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта. <xref:System.IO.FileStream.CanSeek*>— <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Если `path` указывает файл на диске.</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "Константа, определяющая способ совместного использования файла процессами."
    - id: bufferSize
      type: System.Int32
      description: "Положительное <xref:System.Int32>значение, большее 0, определяющее размер буфера.</xref:System.Int32> Размер буфера по умолчанию — 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Значение, задающее дополнительные параметры файла."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>является пустой строкой (&quot;»), содержащую только пробелы или содержит один или несколько недопустимых символов.       - или - <code>path</code> ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде с отличной от NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>является отрицательным или равняться нулю.       - или - <code>mode</code>, <code>access</code>, или <code>share</code> содержит недопустимое значение."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Не удается найти файл, например когда <code> mode </code> — <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>и файл, указанный параметром <code> path </code> не существует. Файл должен уже существовать в этих режимах."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например задание <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> когда файл, заданный параметром <code> path </code> уже существует, произошло.       - или - поток был закрыт."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Указанный путь является недопустимым, например, ведущий на несопоставленный диск."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Запрошенный не разрешен операционной системой для указанного <code> path </code>, например когда <code> access </code> — <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> и файла или каталога установлен доступ только для чтения.       - или - <xref href=&quot;System.IO.FileOptions&quot;> </xref> указан для <code> options </code>, но на текущей платформе шифрование файлов не поддерживается."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Указанный путь и имя файла превышает максимальную длину, определенная системой. Например для платформ на основе Windows пути должна составлять менее 248 знаков и имена файлов должны быть короче 260 символов."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.FileStream&quot;> </xref> класса с указанным путем, режимом создания, правами доступа и разрешением на совместное использование, буфер размером и дополнительными параметрами файла."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "Относительный или абсолютный путь к файлу, текущий <xref href=&quot;System.IO.FileStream&quot;> </xref> будет инкапсулироваться объектом."
    - id: mode
      type: System.IO.FileMode
      description: "Константа, определяющая способ открытия или создания файла."
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "Константа, определяющая права доступа для использования при создании правил доступа и аудита для файла."
    - id: share
      type: System.IO.FileShare
      description: "Константа, определяющая способ совместного использования файла процессами."
    - id: bufferSize
      type: System.Int32
      description: "Положительное <xref:System.Int32>значение, большее 0, определяющее размер буфера.</xref:System.Int32> Размер буфера по умолчанию — 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Константа, задающая дополнительные параметры файла."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>является пустой строкой (&quot;»), содержащую только пробелы или содержит один или несколько недопустимых символов.       - или - <code>path</code> ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде с отличной от NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>является отрицательным или равняться нулю.       - или - <code>mode</code>, <code>access</code>, или <code>share</code> содержит недопустимое значение."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Не удается найти файл, например когда <code> mode </code> — <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>и файл, указанный параметром <code> path </code> не существует. Файл должен уже существовать в этих режимах."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Текущая операционная система не является системой Windows NT или более поздней версии."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например задание <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> когда файл, заданный параметром <code> path </code> уже существует, произошло.       - или - поток был закрыт."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Указанный путь является недопустимым, например, ведущий на несопоставленный диск."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Запрошенный не разрешен операционной системой для указанного <code> path </code>, например когда <code> access </code> — <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> и файла или каталога установлен доступ только для чтения.       - или - <xref href=&quot;System.IO.FileOptions&quot;> </xref> указан для <code> options </code>, но на текущей платформе шифрование файлов не поддерживается."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Указанный <code> path </code>, имя файла, или оба значения превышают максимальную длину, определенную систему. Например для платформ на основе Windows пути должна составлять менее 248 знаков и имена файлов должны быть короче 260 символов."
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.IO.FileStream&quot;> </xref> класса с заданным путем, режимом создания, правами на доступ и совместное использование, размером буфера, дополнительными параметрами файла, управлением доступом и аудитом безопасности."
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor2#1](~/add/codesnippet/cpp/7f323125-1dac-495a-a4ee-_1.cpp)]\n [!code-cs[IO.FileStream.ctor2#1](~/add/codesnippet/csharp/7f323125-1dac-495a-a4ee-_1.cs)]\n [!code-vb[IO.FileStream.ctor2#1](~/add/codesnippet/visualbasic/7f323125-1dac-495a-a4ee-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "Относительный или абсолютный путь к файлу, текущий <xref href=&quot;System.IO.FileStream&quot;> </xref> будет инкапсулироваться объектом."
    - id: mode
      type: System.IO.FileMode
      description: "Константа, определяющая способ открытия или создания файла."
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "Константа, определяющая права доступа для использования при создании правил доступа и аудита для файла."
    - id: share
      type: System.IO.FileShare
      description: "Константа, определяющая способ совместного использования файла процессами."
    - id: bufferSize
      type: System.Int32
      description: "Положительное <xref:System.Int32>значение, большее 0, определяющее размер буфера.</xref:System.Int32> Размер буфера по умолчанию — 4096."
    - id: options
      type: System.IO.FileOptions
      description: "Константа, задающая дополнительные параметры файла."
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Константа, определяющая правила управления доступом и аудита безопасности для файла."
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>является пустой строкой (&quot;»), содержащую только пробелы или содержит один или несколько недопустимых символов.       - или - <code>path</code> ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде NTFS."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>ссылается на устройство нефайлового, например «con:», «com1:», «lpt1:», т. д., в среде с отличной от NTFS."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>является отрицательным или равняться нулю.       - или - <code>mode</code>, <code>access</code>, или <code>share</code> содержит недопустимое значение."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Не удается найти файл, например когда <code> mode </code> — <xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>и файл, указанный параметром <code> path </code> не существует. Файл должен уже существовать в этих режимах."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например задание <xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;> </xref> когда файл, заданный параметром <code> path </code> уже существует, произошло.       - или - поток был закрыт."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "Указанный путь является недопустимым, например, ведущий на несопоставленный диск."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code> Запрошенный не разрешен операционной системой для указанного <code> path </code>, например когда <code> access </code> — <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref> и файла или каталога установлен доступ только для чтения.       - или - <xref href=&quot;System.IO.FileOptions&quot;> </xref> указан для <code> options </code>, но на текущей платформе шифрование файлов не поддерживается."
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "Указанный <code> path </code>, имя файла, или оба значения превышают максимальную длину, определенную систему. Например для платформ на основе Windows пути должна составлять менее 248 знаков и имена файлов должны быть короче 260 символов."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Текущая операционная система не является системой Windows NT или более поздней версии."
  platform:
  - net462
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Начинает операцию асинхронного чтения. (Рекомендуется использовать <xref:System.IO.FileStream.ReadAsync*>вместо; см. в разделе &quot;Примечания&quot;.)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "В .NET Framework 4 и более ранних версий, необходимо использовать методы, например BeginRead и <xref:System.IO.FileStream.EndRead%2A>для реализации асинхронных операций.</xref:System.IO.FileStream.EndRead%2A> Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] для поддержки устаревшего кода; тем не менее, новых асинхронных методов, таких как <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, и <xref:System.IO.FileStream.FlushAsync%2A>, вы легко реализовать асинхронные операции с файлами справки.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndRead%2A>должен вызываться ровно один раз для каждого вызова BeginRead.</xref:System.IO.FileStream.EndRead%2A> Невозможность закончить процесс чтения до начала другой операции чтения может привести к нежелательным поведению, например взаимоблокировки.       <xref:System.IO.FileStream>предоставляет два различных режима работы: синхронный ввод-вывод и асинхронный ввод-вывод.</xref:System.IO.FileStream> Хотя может быть использована любая, основные ресурсы операционной системы могут разрешать доступ только в одном из следующих режимов. По умолчанию <xref:System.IO.FileStream>открывает дескриптор операционной системы синхронно.</xref:System.IO.FileStream> В Windows это замедляет асинхронные методы. Если применяются асинхронные методы, используйте <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>конструктор.</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>      Настроек [!NOTE] настроек используйте <xref:System.IO.FileStream.CanRead%2A>свойство, чтобы определить, поддерживает ли текущий экземпляр чтение.</xref:System.IO.FileStream.CanRead%2A> Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A>       Если поток закрыт или передается неверный аргумент, исключения создаются немедленно из BeginRead. Ошибки, возникающие при запросе асинхронного чтения, например ошибка диска в процессе запроса ввода-ВЫВОДА, возникают в потоке пула потоков и отображаются при вызове <xref:System.IO.FileStream.EndRead%2A>.</xref:System.IO.FileStream.EndRead%2A>       <xref:System.IO.Stream.EndRead%2A>должен вызываться с этим <xref:System.IAsyncResult>Чтобы узнать, сколько байтов, считанных.</xref:System.IAsyncResult></xref:System.IO.Stream.EndRead%2A>       Несколько одновременных асинхронных запросов отрисовки неопределенное порядок выполнения запроса.       Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/82be2bd0-0603-4287-b351-_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/82be2bd0-0603-4287-b351-_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/82be2bd0-0603-4287-b351-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Буфер для чтения данных."
    - id: offset
      type: System.Int32
      description: "Смещение байтов в `array` с которого начинается чтение."
    - id: numBytes
      type: System.Int32
      description: "Максимальное число байтов для чтения."
    - id: userCallback
      type: System.AsyncCallback
      description: "Метод, вызываемый при операции асинхронного чтения завершения."
    - id: stateObject
      type: System.Object
      description: "Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного асинхронного запроса на чтение от других запросов."
    return:
      type: System.IAsyncResult
      description: "Объект, который ссылается на асинхронное чтение."
  overload: System.IO.FileStream.BeginRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Длина массива минус <code> offset </code> — меньше, чем <code> numBytes </code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>или <code>numBytes</code> является отрицательным значением."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Предпринята попытка асинхронного чтения за концом файла."
  platform:
  - net462
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Начинает операцию асинхронной записи. (Рекомендуется использовать <xref:System.IO.FileStream.WriteAsync*>вместо; см. в разделе &quot;Примечания&quot;.)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "В .NET Framework 4 и более ранних версий, необходимо использовать методы, например BeginWrite и <xref:System.IO.FileStream.EndWrite%2A>для реализации асинхронных операций.</xref:System.IO.FileStream.EndWrite%2A> Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] для поддержки устаревшего кода; тем не менее, новых асинхронных методов, таких как <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, и <xref:System.IO.FileStream.FlushAsync%2A>, вы легко реализовать асинхронные операции с файлами справки.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndWrite%2A>должен вызываться ровно по одному разу для каждого <xref:System.IAsyncResult>из BeginWrite.</xref:System.IAsyncResult></xref:System.IO.FileStream.EndWrite%2A> <xref:System.IO.FileStream.EndWrite%2A>будет заблокирован до завершения операции ввода-вывода.</xref:System.IO.FileStream.EndWrite%2A>       Этот метод переопределяет <xref:System.IO.Stream.BeginWrite%2A>.</xref:System.IO.Stream.BeginWrite%2A>       <xref:System.IO.FileStream>предоставляет два различных режима работы: синхронный ввод-вывод и асинхронный ввод-вывод.</xref:System.IO.FileStream> Хотя может быть использована любая, основные ресурсы операционной системы могут разрешать доступ только в одном из следующих режимов. По умолчанию <xref:System.IO.FileStream>открывает дескриптор операционной системы синхронно.</xref:System.IO.FileStream> В Windows это замедляет асинхронные методы. Если применяются асинхронные методы, используйте <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>конструктор.</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>       Если поток закрыт или передается неверный аргумент, исключения создаются немедленно из BeginWrite. Ошибки, возникающие при выполнении запроса асинхронной записи, например ошибка диска в процессе запроса ввода-ВЫВОДА, возникают в потоке пула потоков и отображаются при вызове <xref:System.IO.FileStream.EndWrite%2A>.</xref:System.IO.FileStream.EndWrite%2A>       Несколько одновременных асинхронных запросов отрисовки неопределенное порядок выполнения запроса.       Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/439bdb1f-5241-4046-a4ad-_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/439bdb1f-5241-4046-a4ad-_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/439bdb1f-5241-4046-a4ad-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Буфер, содержащий данные для записи в текущий поток."
    - id: offset
      type: System.Int32
      description: "Отсчитываемое от нуля смещение в `array` с которого начинается копирование байтов в текущий поток."
    - id: numBytes
      type: System.Int32
      description: "Максимальное число байтов для записи."
    - id: userCallback
      type: System.AsyncCallback
      description: "Метод, вызываемый после завершения операции асинхронной записи."
    - id: stateObject
      type: System.Object
      description: "Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного асинхронного запроса запись от других запросов."
    return:
      type: System.IAsyncResult
      description: "Объект, который ссылается на асинхронную запись."
  overload: System.IO.FileStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>Длина минус <code>offset</code> — меньше, чем <code>numBytes</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>или <code>numBytes</code> является отрицательным значением."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает запись."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Поток закрыт."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода."
  platform:
  - net462
- uid: System.IO.FileStream.CanRead
  id: CanRead
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Возвращает значение, указывающее, поддерживает ли текущий поток операции чтения."
  remarks: "Если класс, производный от <xref:System.IO.Stream>не поддерживает чтение, при вызове <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>и <xref:System.IO.FileStream.BeginRead%2A>методы создают исключение <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.BeginRead%2A> </xref:System.IO.FileStream.ReadByte%2A> </xref:System.IO.FileStream.Read%2A> </xref:System.IO.Stream>       Если поток закрыт, это свойство возвращает `false`."
  example:
  - "The following example demonstrates a use of the `CanRead` property. The output of this code is \"MyFile.txt is not writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanRead Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_1_1.cs)]\n [!code-cpp[Classic FileStream.CanRead Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_1_1.cpp)]\n [!code-vb[Classic FileStream.CanRead Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_1_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если поток поддерживает чтение; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если поток закрыт или открыт с доступом только для записи."
  overload: System.IO.FileStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanSeek
  id: CanSeek
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Возвращает значение, указывающее, поддерживает ли текущий поток поиск."
  remarks: "Если класс, производный от <xref:System.IO.Stream>не поддерживает поиск, при вызове <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>и <xref:System.IO.FileStream.Seek%2A>исключение <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.Seek%2A> </xref:System.IO.FileStream.Position%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.FileStream.Length%2A> </xref:System.IO.Stream>       Если поток закрыт, это свойство возвращает `false`."
  example:
  - "The following example uses the `CanSeek` property to check whether a stream supports seeking.  \n  \n [!code-cpp[fstream canseek#1](~/add/codesnippet/cpp/p-system.io.filestream.c_0_1.cpp)]\n [!code-vb[fstream canseek#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_0_1.vb)]\n [!code-cs[fstream canseek#1](~/add/codesnippet/csharp/p-system.io.filestream.c_0_1.cs)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если поток поддерживает поиск; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если поток закрыт или <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> был сконструирован из дескриптора операционной системы, такие как канал или вывод на консоль."
  overload: System.IO.FileStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanWrite
  id: CanWrite
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Возвращает значение, указывающее, поддерживает ли текущий поток операции записи."
  remarks: "Если класс, производный от <xref:System.IO.Stream>не поддерживает запись, при вызове <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, или <xref:System.IO.FileStream.WriteByte%2A>создает <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.WriteByte%2A> </xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IO.FileStream.Write%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.Stream>       Если поток закрыт, это свойство возвращает `false`."
  example:
  - "The following example uses the `CanWrite` property to check whether a stream supports writing.  \n  \n [!code-cs[fstream canwrite#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_1.cs)]\n [!code-cpp[fstream canwrite#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_1.cpp)]\n [!code-vb[fstream canwrite#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_1.vb)]  \n  \n The following is an example using the `CanWrite` property. The output of this code is \"MyFile.txt is writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanWrite Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_2.cs)]\n [!code-vb[Classic FileStream.CanWrite Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_2.vb)]\n [!code-cpp[Classic FileStream.CanWrite Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_2.cpp)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если поток поддерживает запись; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если поток закрыт или открыт для доступа только для чтения."
  overload: System.IO.FileStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Освобождает неуправляемые ресурсы, используемые <xref href=&quot;System.IO.FileStream&quot;> </xref> и при необходимости освобождает также управляемые ресурсы."
  remarks: "Этот метод вызывается методом открытые <xref:System.ComponentModel.Component.Dispose%2A>метод и <xref:System.Object.Finalize%2A>метод.</xref:System.Object.Finalize%2A> </xref:System.ComponentModel.Component.Dispose%2A> <xref:System.ComponentModel.Component.Dispose%2A>вызывает защищенный метод Dispose с `disposing` равным `true`.</xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A>вызывает метод Dispose с `disposing` значение `false`.</xref:System.Object.Finalize%2A>       При `disposing` параметр `true`, данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, которые <xref:System.IO.FileStream>ссылки.</xref:System.IO.FileStream> Этот метод вызывает <xref:System.ComponentModel.Component.Dispose%2A>метод для каждого объекта, на который указывает ссылка.</xref:System.ComponentModel.Component.Dispose%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>для освобождения управляемых и неуправляемых ресурсов; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для освобождения только неуправляемых ресурсов."
  overload: System.IO.FileStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Ожидает завершения отложенной асинхронной операции чтения для завершения. (Рекомендуется использовать <xref:System.IO.FileStream.ReadAsync*>вместо; см. в разделе &quot;Примечания&quot;.)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "В .NET Framework 4 и более ранних версий, необходимо использовать методы, такие как <xref:System.IO.FileStream.BeginRead%2A>и EndRead для реализации асинхронных операций.</xref:System.IO.FileStream.BeginRead%2A> Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] для поддержки устаревшего кода; тем не менее, новых асинхронных методов, таких как <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, и <xref:System.IO.FileStream.FlushAsync%2A>, вы легко реализовать асинхронные операции с файлами справки.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       EndRead должен вызываться ровно при каждом вызове <xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A> Невозможность закончить процесс чтения до начала другой операции чтения может привести к нежелательным поведению, например взаимоблокировки.       Этот метод переопределяет <xref:System.IO.Stream.EndRead%2A>.</xref:System.IO.Stream.EndRead%2A>       Метод EndRead может вызываться для каждого <xref:System.IAsyncResult>из <xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A> </xref:System.IAsyncResult> Вызов EndRead покажет, сколько байтов, считанных из потока. EndRead будет заблокирован до завершения операции ввода-вывода."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/m-system.io.filestream.e_0_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/m-system.io.filestream.e_0_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/m-system.io.filestream.e_0_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Ссылка на отложенный асинхронный запрос для ожидания."
    return:
      type: System.Int32
      description: "Число байтов, считанных из потока, между 0 и числом запрошенных байтов. Потоки возвращают 0 только в конце потока, в противном случае они должны блокироваться, пока не будет доступен по крайней мере 1 байт."
  overload: System.IO.FileStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Этот <xref:System.IAsyncResult>объект не был создан путем вызова <xref:System.IO.FileStream.BeginRead*>для этого класса.</xref:System.IO.FileStream.BeginRead*> </xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Метод EndRead вызывается несколько раз."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Поток закрыт или произошла внутренняя ошибка."
  platform:
  - net462
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Завершает асинхронную операцию записи и блокирует до завершения операции ввода-вывода. (Рекомендуется использовать <xref:System.IO.FileStream.WriteAsync*>вместо; см. в разделе &quot;Примечания&quot;.)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "В .NET Framework 4 и более ранних версий, необходимо использовать методы, такие как <xref:System.IO.FileStream.BeginWrite%2A>и EndWrite для реализации асинхронных операций.</xref:System.IO.FileStream.BeginWrite%2A> Эти методы по-прежнему доступны в [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] для поддержки устаревшего кода; тем не менее, новых асинхронных методов, таких как <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, и <xref:System.IO.FileStream.FlushAsync%2A>, вы легко реализовать асинхронные операции с файлами справки.</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       Этот метод переопределяет <xref:System.IO.Stream.EndWrite%2A>.</xref:System.IO.Stream.EndWrite%2A>       Метод EndWrite должен вызываться ровно по одному разу для каждого <xref:System.IAsyncResult>из <xref:System.IO.FileStream.BeginWrite%2A>.</xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IAsyncResult> Метод EndWrite будет заблокирован до завершения операции ввода-вывода."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/m-system.io.filestream.e_1_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/m-system.io.filestream.e_1_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/m-system.io.filestream.e_1_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "Отложенный асинхронный запрос ввода-вывода."
  overload: System.IO.FileStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Этот <xref:System.IAsyncResult>объект не был создан путем вызова <xref:System.IO.Stream.BeginWrite*>для этого класса.</xref:System.IO.Stream.BeginWrite*> </xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Метод EndWrite вызывается несколько раз."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Поток закрыт или произошла внутренняя ошибка."
  platform:
  - net462
- uid: System.IO.FileStream.Finalize
  id: Finalize
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Гарантирует, что ресурсы освобождены и выполнены другие операции очистки, когда сборщик мусора восстанавливает <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>."
  remarks: "Сборщик мусора вызывает `Finalize` когда текущий объект готов к завершению. `Finalize`закрывает `FileStream`."
  syntax:
    content: ~FileStream ();
    parameters: []
  overload: System.IO.FileStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Flush
  id: Flush
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Очищает буферы для этого потока и вызывает запись всех буферизованных данных в файл."
  remarks: "Этот метод переопределяет <xref:System.IO.Stream.Flush%2A?displayProperty=fullName>.</xref:System.IO.Stream.Flush%2A?displayProperty=fullName>       При вызове метод Flush, также сбрасывается в буфер операционной системы ввода-вывода.       Кодировщик потока не сбрасывается, если только вы явным образом вызвать очистки или удаления объекта. Параметр <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName>для `true` означает, что данные будут сброшены из буфера в поток, но состояние кодировщика при этом не сбрасывается.</xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName> Это позволяет кодировщику сохранить свое состояние (частичные символы), чтобы правильно выполнить кодировку следующего блока знаков. Этот сценарий влияет на кодировки UTF8 и UTF7, в которых определенные символы кодируются только после кодировщик получает соседние знаки.       Поскольку буфер можно использовать для чтения или записи, очистка выполняет следующие две функции: — все данные, записанные ранее в буфер копируется в файл и буфер удаляется за исключением состояния кодировщика.      -Если <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName>является `true` и данные ранее были скопированы из файла в буфер для чтения, текущее положение в файле уменьшается количество непрочитанных байтов в буфере.</xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName> Буфер, затем удаляется.       Используйте <xref:System.IO.FileStream.Flush%28System.Boolean%29>перегрузка метода, если вы хотите убедиться, что все буферизованные данные в буферах промежуточный файл записывается на диск.</xref:System.IO.FileStream.Flush%28System.Boolean%29>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#4](~/add/codesnippet/csharp/m-system.io.filestream.f_1.cs)]\n [!code-cpp[System.IO.FileStream3#4](~/add/codesnippet/cpp/m-system.io.filestream.f_1.cpp)]\n [!code-vb[System.IO.FileStream3#4](~/add/codesnippet/visualbasic/m-system.io.filestream.f_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.FileStream.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Поток закрыт."
  platform:
  - net462
- uid: System.IO.FileStream.Flush(System.Boolean)
  id: Flush(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Очищает буферы для этого потока и вызывает запись всех буферизованных данных в файл, а также удаляет все буферы промежуточных файлов."
  remarks: "Используйте эту перегрузку, когда вы хотите убедиться, что все буферизованные данные в буферах промежуточный файл записывается на диск.       При вызове метод Flush, также сбрасывается в буфер операционной системы ввода-вывода."
  syntax:
    content: public virtual void Flush (bool flushToDisk);
    parameters:
    - id: flushToDisk
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы очистить все буферы промежуточных файлов; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Асинхронно очищает все буферы для этого потока, вызывает запись всех буферизованных данных в базовое устройство и отслеживает запросы отмены."
  remarks: "При вызове метода FlushAsync также сбрасывается в буфер операционной системы ввода-вывода.       Если операция отменена до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus>значение <xref:System.Threading.Tasks.Task.Status%2A>Свойства.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> При удалении дескриптора файла, возвращенная задача содержит <xref:System.ObjectDisposedException>исключение в <xref:System.Threading.Tasks.Task.Exception%2A>свойство.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Токен для отслеживания запросов отмены."
    return:
      type: System.Threading.Tasks.Task
      description: "Задача, представляющая асинхронную операцию очистки."
  overload: System.IO.FileStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Поток был удален."
  platform:
  - net462
- uid: System.IO.FileStream.GetAccessControl
  id: GetAccessControl
  parent: System.IO.FileStream
  langs:
  - csharp
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Возвращает <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> объекта, который инкапсулирует записи списка управления Доступом управления доступом для файла, описываемого текущим <xref href=&quot;System.IO.FileStream&quot;> </xref> объекта."
  remarks: "Хотя <xref:System.IO.FileStream>класс и GetAccessControl может использоваться для извлечения записи списка управления Доступом к существующему файлу, рассмотрите возможность использования <xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName>метода, как он проще в использовании.</xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       Используйте метод GetAccessControl для получения записей списка управления Доступом для файла.       В ACL определяются пользователи и группы, имеющие или не имеющие права на выполнение определенных действий с данным файлом. Дополнительные сведения см. в разделе [как: Добавление или удаление записей списка управления доступом](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Security.AccessControl.FileSecurity GetAccessControl ();
    parameters: []
    return:
      type: System.Security.AccessControl.FileSecurity
      description: "Объект, инкапсулирующий параметры управления доступом для файла, описываемого текущим <xref href=&quot;System.IO.FileStream&quot;> </xref> объекта."
  overload: System.IO.FileStream.GetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Файл не будет закрыт."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода при открытии файла."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Файл не найден."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Эта операция не поддерживается на текущей платформе.       - или - вызывающего объекта отсутствует необходимое разрешение."
  platform:
  - net462
- uid: System.IO.FileStream.Handle
  id: Handle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Получает дескриптор файла операционной системы для файла текущего <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> инкапсулирует объект."
  remarks: "Это свойство представляет собой дескриптор операционной системы для использования с вызовами, предоставляемых операционной системой (например, `ReadFile` в Windows). Он не будет работать с помощью функции библиотеки C, в которых предполагается, что дескриптор файла, например `fread`.       Дескриптор операционной системы может быть открыт синхронно или асинхронно, в зависимости от того, что `FileStream` конструктор уже вызывался. Используйте <xref:System.IO.FileStream.IsAsync%2A>свойство для определения, является ли этот дескриптор был открыт асинхронно.</xref:System.IO.FileStream.IsAsync%2A> В Win32, это означает этот дескриптор был открыт для перекрывающегося ввода-ВЫВОДА и требует другие параметры для `ReadFile` и `WriteFile`.      Настроек [!CAUTION] настроек может произойти повреждение данных, если `FileStream` будет создан, его дескриптор был передан, некоторые операции указатель дескриптор файла, а затем `FileStream` снова используется. Несколько потоков не могут записывать в тот же файл одновременно, и `FileStream` буферизации кода предполагается, что исключительно управляет дескриптор. `FileStream`может вызывать <xref:System.IO.IOException>Если `FileStream` обнаруживает, что некоторые другой процесс переместил указатель файла.</xref:System.IO.IOException> Чтобы избежать этого, не записывайте данные в части файла, `FileStream` может буферизировать и восстанавливайте указатель файла в папку, он находился перед последним вызовом методов на `FileStream`."
  syntax:
    content: public virtual IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "Дескриптор файла операционной системы для файла, инкапсулируемого этим <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> объекта или -1, если <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> был закрыт."
  overload: System.IO.FileStream.Handle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  platform:
  - net462
- uid: System.IO.FileStream.IsAsync
  id: IsAsync
  parent: System.IO.FileStream
  langs:
  - csharp
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Возвращает значение, указывающее, является ли <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> был открыт асинхронно или синхронно."
  remarks: "`IsAsync` Обнаруживает свойство ли `FileStream` дескриптор был открыт асинхронно, позволяя вашему коду использовать <xref:System.IO.FileStream.Handle%2A>свойство правильно.</xref:System.IO.FileStream.Handle%2A> В Win32 `IsAsync` , значение true означает дескриптор был открыт для перекрывающегося ввода-вывода и поэтому требует другие параметры для `ReadFile` и `WriteFile`.       Это значение указывается при создании экземпляра <xref:System.IO.FileStream>класса, используя конструктор, который имеет `isAsync`, `useAsync`, или `options` параметр.</xref:System.IO.FileStream> Если свойство не `true`, поток использует перекрывающегося ввода-вывода для асинхронного выполнения операций с файлами. Однако свойства IsAsync не быть `true` для вызова <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, или <xref:System.IO.Stream.CopyToAsync%2A>метод.</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> Если свойство IsAsync не `false` и вызова асинхронного чтения и записи операций, в поток пользовательского интерфейса не блокируется, но фактические операции ввода-вывода выполняется синхронно."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/p-system.io.filestream.i_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/p-system.io.filestream.i_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/p-system.io.filestream.i_1.cpp)]"
  syntax:
    content: public virtual bool IsAsync { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> был открыт асинхронно; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.IsAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Length
  id: Length
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Возвращает длину в байтах потока."
  remarks: "Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.l_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.l_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.l_1.vb)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "Длинное значение, представляющее длину потока в байтах."
  overload: System.IO.FileStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref:System.IO.FileStream.CanSeek*>для этого потока имеет <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.IO.FileStream.CanSeek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода, например, файл закрывается."
  platform:
  - net462
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  id: Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Запрещает другим процессам чтение или запись для <xref href=&quot;System.IO.FileStream&quot;> </xref>."
  remarks: "Блокировка диапазона файлового потока предоставляет потокам блокировки монопольный доступ к процессу для этого диапазона файлового потока.       Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file. Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.l_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.l_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.l_1.vb)]"
  syntax:
    content: public virtual void Lock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "Начало диапазона для блокировки. Значение этого параметра должно быть больше или равно нулю (0)."
    - id: length
      type: System.Int64
      description: "Диапазон должен быть заблокирован."
  overload: System.IO.FileStream.Lock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>или <code>length</code> является отрицательным значением."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Файл не будет закрыт."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Процесс не может получить доступ к файл, поскольку другой процесс заблокировал часть этого файла."
  platform:
  - net462
- uid: System.IO.FileStream.Name
  id: Name
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Возвращает имя <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> , переданный в конструктор."
  remarks: "Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/p-system.io.filestream.n_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/p-system.io.filestream.n_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/p-system.io.filestream.n_1.cpp)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "Строка, являющаяся имя <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.FileStream.Name*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Position
  id: Position
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Возвращает или задает текущую позицию этого потока."
  remarks: "Поддерживается поиск в любом месте за пределами длины потока.  При выполнении поиска за пределами файла, размер файла увеличивается.  В Microsoft Windows NT и более новые данные, добавленные в конец файла равен нулю.  В Microsoft Windows 98 или более ранней версии данные, добавленные в конец файла не равно нулю, это означает, что ранее удаленные данных отображается в поток. Установка позицию в потоке большое значение за пределами конца потока в Windows 98 или более ранней версии может привести к созданию исключения.       Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.p_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.p_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.p_1.vb)]"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "Текущая позиция потока."
  overload: System.IO.FileStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает поиск."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n The position was set to a very large value beyond the end of the stream in Windows 98 or earlier."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Предпринята попытка установить позицию отрицательное значение."
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "Попытка поиска за пределами потока, который не поддерживается."
  platform:
  - net462
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Считывает блок байтов из потока и записывает данные в заданный буфер."
  remarks: "Этот метод переопределяет <xref:System.IO.Stream.Read%2A>.</xref:System.IO.Stream.Read%2A>       `offset` Дает смещение байтов в `array` (индекс буфера) с которого начинается чтение и `count` дает максимальное число байтов, считанное из текущего потока. Возвращаемое значение является фактическое число считанных байтов, или нуль, если достигнут конец потока. При успешном выполнении операции чтения текущую позицию в потоке увеличивается на число считанных байтов. При возникновении исключения в текущей позиции потока не изменяется.       Метод Read возвращает ноль только по достижении конца потока. В противном случае чтения всегда считывает хотя бы один байт из потока перед возвратом. Если данные недоступны в потоке при вызове для чтения, метод будет заблокирована, пока хотя бы один байт данных могут быть возвращены. Реализация может вернуть меньше байтов, чем было запрошено, даже если не достигнут конец потока.       Используйте <xref:System.IO.BinaryReader>для чтения простых типов данных.</xref:System.IO.BinaryReader>       Не прерывайте потоков, который выполняет операции чтения. Несмотря на то, что приложение может возникнуть, для успешного выполнения после поток не заблокирован, прерывания может привести к снижению производительности и надежности приложения.       Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example reads the contents from a <xref:System.IO.FileStream> and writes it into another <xref:System.IO.FileStream>.  \n  \n [!code-vb[FSRead#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_1_1.vb)]\n [!code-cs[FSRead#1](~/add/codesnippet/csharp/m-system.io.filestream.r_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "При возвращении этого метода содержит указанный массив байтов со значениями от `offset` и (`offset`  +  `count` - 1`)` заменены байтами, считанными из текущего источника."
    - id: offset
      type: System.Int32
      description: "Смещение байтов в `array` начиная с которого будут размещаться считанные байты."
    - id: count
      type: System.Int32
      description: "Максимальное число байтов для чтения."
    return:
      type: System.Int32
      description: "Общее число байтов, считанных в буфер. Это может быть меньше запрошенного числа байтов, если это количество байтов в настоящее время недоступны, или нуль, если достигнут конец потока."
  overload: System.IO.FileStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>или <code>count</code> является отрицательным значением."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает чтение."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>и <code>count</code> описывают недопустимый диапазон в <code>array</code>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Методы были вызваны после закрытия потока."
  platform:
  - net462
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Асинхронно считывает последовательность байтов из текущего потока, перемещает позицию внутри потока на число считанных байтов и отслеживает запросы отмены."
  remarks: "Метод ReadAsync позволяет выполнять операции с файлами много ресурсов, не блокируя основной поток. Это соображение, связанное с производительностью, особенно важно в [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] приложения или [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] приложения, где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что он не работает. Асинхронные методы используются в сочетании с `async` и `await` ключевые слова в Visual Basic и C#.       Используйте <xref:System.IO.FileStream.CanRead%2A>свойство, чтобы определить, поддерживает ли текущий экземпляр чтение.</xref:System.IO.FileStream.CanRead%2A>       Если операция отменена до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus>значение <xref:System.Threading.Tasks.Task.Status%2A>Свойства.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> При удалении дескриптора файла, возвращенная задача содержит <xref:System.ObjectDisposedException>исключение в <xref:System.Threading.Tasks.Task.Exception%2A>свойство.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to read from a file asynchronously.  \n  \n [!code-vb[Asynchronous_File_IO_async#4](~/add/codesnippet/visualbasic/9c5ba435-5f90-4f89-b415-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#4](~/add/codesnippet/csharp/9c5ba435-5f90-4f89-b415-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Буфер для записи данных."
    - id: offset
      type: System.Int32
      description: "Смещение байтов в `buffer` с которого начинается запись данных из потока."
    - id: count
      type: System.Int32
      description: "Максимальное число байтов для чтения."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Токен для отслеживания запросов отмены."
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "Задача, представляющая асинхронную операцию чтения. Значение <code> TResult </code> параметр содержит общее число байтов, считанных в буфер. Значение результата может быть меньше запрошенного числа байтов, если число текущих доступных байтов меньше запрошенного числа, или он может быть 0 (нуль), если был достигнут конец потока."
  overload: System.IO.FileStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>или <code>count</code> является отрицательным значением."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Сумма <code> offset </code> и <code> count </code> больше, чем длина буфера."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает чтение."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Поток был удален."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Поток в данный момент используется предыдущей операцией чтения."
  platform:
  - net462
- uid: System.IO.FileStream.ReadByte
  id: ReadByte
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Считывает байт из файла и перемещает положение чтения на один байт."
  remarks: "Этот метод переопределяет <xref:System.IO.Stream.ReadByte%2A>.</xref:System.IO.Stream.ReadByte%2A>      Настроек [!NOTE] настроек используйте <xref:System.IO.FileStream.CanRead%2A>свойство, чтобы определить, поддерживает ли текущий экземпляр чтение.</xref:System.IO.FileStream.CanRead%2A> Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.r_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.r_0_1.cpp)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "Байт, приведенный к <xref:System.Int32>, или значение -1, если достигнут конец потока.</xref:System.Int32>"
  overload: System.IO.FileStream.ReadByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Текущий поток не поддерживает чтение."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Текущий поток закрыт."
  platform:
  - net462
- uid: System.IO.FileStream.SafeFileHandle
  id: SafeFileHandle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Возвращает <xref href=&quot;Microsoft.Win32.SafeHandles.SafeFileHandle&quot;> </xref> , представляющий дескриптор файла операционной системы для файла, текущий <xref href=&quot;System.IO.FileStream&quot;> </xref> инкапсулирует объект."
  remarks: "Свойство SafeFileHandle автоматически очищает поток и задает позицию в текущем потоке 0.  Это позволяет переместить файл или позицию в потоке, чтобы сбросить другой поток, используя SafeFileHandle, возвращаемый этим свойством."
  syntax:
    content: public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "Объект, представляющий дескриптор файла операционной системы для файла, текущий <xref href=&quot;System.IO.FileStream&quot;> </xref> инкапсулирует объект."
  overload: System.IO.FileStream.SafeFileHandle*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Задает текущую позицию этого потока на заданное значение."
  remarks: "Этот метод переопределяет <xref:System.IO.Stream.Seek%2A?displayProperty=fullName>.</xref:System.IO.Stream.Seek%2A?displayProperty=fullName>      Настроек [!NOTE] настроек используйте <xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName>свойство, чтобы определить, поддерживает ли текущий экземпляр поиск.</xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName> Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>.</xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>       Поиск возможен в любом месте за пределами длины потока. При выполнении поиска за пределами файла, размер файла увеличивается. В Windows NT и более поздних версиях данные, добавленные в конец файла равен нулю. В Windows 98 или более ранних версий данные, добавленные в конец файла не равен нулю, это означает, что ранее удаленные данных отображается в поток.       Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_1_1.cpp)]  \n  \n The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <xref:System.IO.SeekOrigin> values with the Seek method.  \n  \n [!code-vb[System.IO.FileStream.Seek#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_2.vb)]\n [!code-cs[System.IO.FileStream.Seek#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_2.cs)]"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "Точки относительно `origin` от которой начинается поиск."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Указывает начало, конечную или текущую позицию как опорную точку для `offset`, используя значение типа <xref:System.IO.SeekOrigin>.</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "Новое положение в потоке."
  overload: System.IO.FileStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает поиск, например, если <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref> создается на основе вывода консоли или канала."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Попытка поиска выполняется до начала потока."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Методы были вызваны после закрытия потока."
  platform:
  - net462
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  id: SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Применяет записи списка управления Доступом для управления доступом, описываемого <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref> объекта в файл, описанный текущим <xref href=&quot;System.IO.FileStream&quot;> </xref> объекта."
  remarks: "Хотя <xref:System.IO.FileStream>класс и SetAccessControl можно использовать для существующего файла, рассмотрите возможность использования <xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName>метода, проще в использовании.</xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       Метод SetAccessControl применяет записи списка управления Доступом в файл, представляющий noninherited список ACL.      Настроек [!CAUTION] настроек указанный ACL для `fileSecurity` параметра заменяет существующий список ACL для файла. Чтобы добавить разрешения для нового пользователя, используйте <xref:System.IO.FileStream.GetAccessControl%2A>метода получения существующий список ACL, изменить его и затем применить SetAccessControl этот обратно в файл.</xref:System.IO.FileStream.GetAccessControl%2A>       В ACL определяются пользователи и группы, имеющие или не имеющие права на выполнение определенных действий с данным файлом. Дополнительные сведения см. в разделе [как: Добавление или удаление записей списка управления доступом](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "Объект, который описывает запись ACL, чтобы применить к текущему файлу."
  overload: System.IO.FileStream.SetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Файл не будет закрыт."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>fileSecurity</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Файл не удалось найти или изменить."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Текущий процесс не имеет доступа для открытия файла."
  platform:
  - net462
- uid: System.IO.FileStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Устанавливает длину этого потока на заданное значение."
  remarks: "Этот метод переопределяет <xref:System.IO.Stream.SetLength%2A>.</xref:System.IO.Stream.SetLength%2A>       Если заданное значение меньше текущей длины потока, поток сокращается. В этом случае если текущая позиция превышает новую длину текущую позицию перемещается до получения последнего байта потока. Если заданное значение больше текущей длины потока, поток расширяется, и текущая позиция не меняется. Если поток расширяется, содержимое потока между старой и новой длиной не определено.       Поток должен поддерживать запись и поиск для `SetLength` для работы.      Настроек [!NOTE] настроек используйте <xref:System.IO.FileStream.CanWrite%2A>свойство, чтобы определить, поддерживает ли текущий экземпляр запись и <xref:System.IO.FileStream.CanSeek%2A>Свойства, чтобы определить, поддерживается ли поиск.</xref:System.IO.FileStream.CanSeek%2A> </xref:System.IO.FileStream.CanWrite%2A> Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanWrite%2A>и <xref:System.IO.Stream.CanSeek%2A>.</xref:System.IO.Stream.CanSeek%2A> </xref:System.IO.Stream.CanWrite%2A>       Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Новая длина потока."
  overload: System.IO.FileStream.SetLength*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает запись и поиск."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Предпринята попытка задать <code> value </code> параметра значение меньше 0."
  platform:
  - net462
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  id: Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Разрешает доступ других процессов ко всей или части файла, которая ранее была заблокирована."
  remarks: "Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file . Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.u_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.u_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.u_1.vb)]"
  syntax:
    content: public virtual void Unlock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "Начало диапазона для разблокирования."
    - id: length
      type: System.Int64
      description: "Диапазон должен быть разблокирован."
  overload: System.IO.FileStream.Unlock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>или <code>length</code> является отрицательным значением."
  platform:
  - net462
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Записывает блок байтов в файловый поток."
  remarks: "Этот метод переопределяет <xref:System.IO.Stream.Write%2A>.</xref:System.IO.Stream.Write%2A>       `offset` Дает смещение байтов в `array` (индекс буфера) с которого начинается копирование и `count` дает число байтов, которые будут записаны в поток. При успешном выполнении операции записи в текущей позиции потока увеличивается на число записанных байтов. При возникновении исключения в текущей позиции потока не изменяется.      Настроек [!NOTE] настроек используйте <xref:System.IO.FileStream.CanWrite%2A>свойство, чтобы определить, поддерживает ли текущий экземпляр запись.</xref:System.IO.FileStream.CanWrite%2A> Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A>       Не прерывайте потоков, который выполняет операцию записи. Несмотря на то, что приложение может возникнуть, для успешного выполнения после поток не заблокирован, прерывания может привести к снижению производительности и надежности приложения.       Список общих файлов и операции с каталогами см. в разделе [распространенные задачи ввода-вывода](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#3](~/add/codesnippet/csharp/m-system.io.filestream.w_1_1.cs)]\n [!code-cpp[System.IO.FileStream3#3](~/add/codesnippet/cpp/m-system.io.filestream.w_1_1.cpp)]\n [!code-vb[System.IO.FileStream3#3](~/add/codesnippet/visualbasic/m-system.io.filestream.w_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "Буфер, содержащий данные для записи в поток."
    - id: offset
      type: System.Int32
      description: "Отсчитываемое от нуля смещение в `array` с которого начинается копирование байтов в поток."
    - id: count
      type: System.Int32
      description: "Максимальное число байтов для записи."
  overload: System.IO.FileStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>и <code>count</code> описывают недопустимый диапазон в <code>array</code>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>или <code>count</code> является отрицательным значением."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n Another thread may have caused an unexpected change in the position of the operating system's file handle."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Поток закрыт."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Текущий экземпляр потока не поддерживает запись."
  platform:
  - net462
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Асинхронно записывает последовательность байтов в текущий поток, перемещает текущую позицию внутри потока на число записанных байтов и отслеживает запросы отмены."
  remarks: "Метод WriteAsync позволяет выполнять операции с файлами много ресурсов, не блокируя основной поток. Это соображение, связанное с производительностью, особенно важно в [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] приложения или [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] приложения, где длительная потоковая операция может блокировать поток пользовательского интерфейса и создавать впечатление, что он не работает. Асинхронные методы используются в сочетании с `async` и `await` ключевые слова в Visual Basic и C#.       Используйте <xref:System.IO.FileStream.CanWrite%2A>свойство, чтобы определить, поддерживает ли текущий экземпляр чтение.</xref:System.IO.FileStream.CanWrite%2A>       Если операция отменена до ее завершения, возвращаемая задача содержит <xref:System.Threading.Tasks.TaskStatus>значение <xref:System.Threading.Tasks.Task.Status%2A>Свойства.</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> При удалении дескриптора файла, возвращенная задача содержит <xref:System.ObjectDisposedException>исключение в <xref:System.Threading.Tasks.Task.Exception%2A>свойство.</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to write asynchronously to a file.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/7726d527-d678-42ba-9864-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/7726d527-d678-42ba-9864-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Буфер, из которого записываются данные."
    - id: offset
      type: System.Int32
      description: "Отсчитываемое от нуля смещение в `buffer` с которого начинается копирование байтов в поток."
    - id: count
      type: System.Int32
      description: "Максимальное число байтов для записи."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Токен для отслеживания запросов отмены."
    return:
      type: System.Threading.Tasks.Task
      description: "Задача, представляющая асинхронную операцию записи."
  overload: System.IO.FileStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>или <code>count</code> является отрицательным значением."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Сумма <code> offset </code> и <code> count </code> больше, чем длина буфера."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает запись."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Поток был удален."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Поток в данный момент используется предыдущей операцией записи."
  platform:
  - net462
- uid: System.IO.FileStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "Записывает байт в текущее положение в потоке файла."
  remarks: "Этот метод переопределяет <xref:System.IO.Stream.WriteByte%2A>.</xref:System.IO.Stream.WriteByte%2A>       Используйте `WriteByte` для записи байта `FileStream` эффективно. Если поток закрыт или защищен от записи, будет создано исключение.      Настроек [!NOTE] настроек используйте <xref:System.IO.FileStream.CanWrite%2A>свойство, чтобы определить, поддерживает ли текущий экземпляр запись.</xref:System.IO.FileStream.CanWrite%2A> Дополнительные сведения см. в разделе <xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.w_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.w_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.w_0_1.cpp)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "Байт, записываемый в поток."
  overload: System.IO.FileStream.WriteByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Поток закрыт."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Поток не поддерживает запись."
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.IO.PathTooLongException
  isExternal: true
  name: System.IO.PathTooLongException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
- uid: System.IO.FileOptions
  parent: System.IO
  isExternal: false
  name: FileOptions
  nameWithType: FileOptions
  fullName: System.IO.FileOptions
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
- uid: System.Security.AccessControl.FileSystemRights
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSystemRights
  nameWithType: FileSystemRights
  fullName: System.Security.AccessControl.FileSystemRights
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.FileStream.CanRead
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
- uid: System.IO.FileStream.CanSeek
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
- uid: System.IO.FileStream.Dispose(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
- uid: System.IO.FileStream.Finalize
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
- uid: System.IO.FileStream.Flush
  parent: System.IO.FileStream
  isExternal: false
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
- uid: System.IO.FileStream.Flush(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.FileStream.GetAccessControl
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
- uid: System.IO.FileStream.Handle
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
- uid: System.IO.FileStream.IsAsync
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
- uid: System.IO.FileStream.Length
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
- uid: System.IO.FileStream.Name
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
- uid: System.IO.FileStream.Position
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.FileStream.ReadByte
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
- uid: System.IO.FileStream.SafeFileHandle
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
- uid: System.IO.FileStream.SetLength(System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.FileStream.WriteByte(System.Byte)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.FileStream.#ctor*
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream
  nameWithType: FileStream.FileStream
- uid: System.IO.FileStream.BeginRead*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead
  nameWithType: FileStream.BeginRead
- uid: System.IO.FileStream.BeginWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite
  nameWithType: FileStream.BeginWrite
- uid: System.IO.FileStream.CanRead*
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
- uid: System.IO.FileStream.CanSeek*
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
- uid: System.IO.FileStream.Dispose*
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose
  nameWithType: FileStream.Dispose
- uid: System.IO.FileStream.EndRead*
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead
  nameWithType: FileStream.EndRead
- uid: System.IO.FileStream.EndWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite
  nameWithType: FileStream.EndWrite
- uid: System.IO.FileStream.Finalize*
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize
  nameWithType: FileStream.Finalize
- uid: System.IO.FileStream.Flush*
  parent: System.IO.FileStream
  isExternal: false
  name: Flush
  nameWithType: FileStream.Flush
- uid: System.IO.FileStream.FlushAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync
  nameWithType: FileStream.FlushAsync
- uid: System.IO.FileStream.GetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl
  nameWithType: FileStream.GetAccessControl
- uid: System.IO.FileStream.Handle*
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
- uid: System.IO.FileStream.IsAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
- uid: System.IO.FileStream.Length*
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
- uid: System.IO.FileStream.Lock*
  parent: System.IO.FileStream
  isExternal: false
  name: Lock
  nameWithType: FileStream.Lock
- uid: System.IO.FileStream.Name*
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
- uid: System.IO.FileStream.Position*
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
- uid: System.IO.FileStream.Read*
  parent: System.IO.FileStream
  isExternal: false
  name: Read
  nameWithType: FileStream.Read
- uid: System.IO.FileStream.ReadAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync
  nameWithType: FileStream.ReadAsync
- uid: System.IO.FileStream.ReadByte*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte
  nameWithType: FileStream.ReadByte
- uid: System.IO.FileStream.SafeFileHandle*
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek*
  parent: System.IO.FileStream
  isExternal: false
  name: Seek
  nameWithType: FileStream.Seek
- uid: System.IO.FileStream.SetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl
  nameWithType: FileStream.SetAccessControl
- uid: System.IO.FileStream.SetLength*
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength
  nameWithType: FileStream.SetLength
- uid: System.IO.FileStream.Unlock*
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock
  nameWithType: FileStream.Unlock
- uid: System.IO.FileStream.Write*
  parent: System.IO.FileStream
  isExternal: false
  name: Write
  nameWithType: FileStream.Write
- uid: System.IO.FileStream.WriteAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync
  nameWithType: FileStream.WriteAsync
- uid: System.IO.FileStream.WriteByte*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte
  nameWithType: FileStream.WriteByte
