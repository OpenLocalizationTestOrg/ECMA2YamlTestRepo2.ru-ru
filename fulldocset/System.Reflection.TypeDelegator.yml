### YamlMime:ManagedReference
items:
- uid: System.Reflection.TypeDelegator
  id: TypeDelegator
  children:
  - System.Reflection.TypeDelegator.#ctor
  - System.Reflection.TypeDelegator.#ctor(System.Type)
  - System.Reflection.TypeDelegator.Assembly
  - System.Reflection.TypeDelegator.AssemblyQualifiedName
  - System.Reflection.TypeDelegator.BaseType
  - System.Reflection.TypeDelegator.FullName
  - System.Reflection.TypeDelegator.GetAttributeFlagsImpl
  - System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  - System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)
  - System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)
  - System.Reflection.TypeDelegator.GetElementType
  - System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetEvents
  - System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)
  - System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)
  - System.Reflection.TypeDelegator.GetInterfaces
  - System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  - System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  - System.Reflection.TypeDelegator.GUID
  - System.Reflection.TypeDelegator.HasElementTypeImpl
  - System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  - System.Reflection.TypeDelegator.IsArrayImpl
  - System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)
  - System.Reflection.TypeDelegator.IsByRefImpl
  - System.Reflection.TypeDelegator.IsCOMObjectImpl
  - System.Reflection.TypeDelegator.IsConstructedGenericType
  - System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)
  - System.Reflection.TypeDelegator.IsPointerImpl
  - System.Reflection.TypeDelegator.IsPrimitiveImpl
  - System.Reflection.TypeDelegator.IsValueTypeImpl
  - System.Reflection.TypeDelegator.MetadataToken
  - System.Reflection.TypeDelegator.Module
  - System.Reflection.TypeDelegator.Name
  - System.Reflection.TypeDelegator.Namespace
  - System.Reflection.TypeDelegator.TypeHandle
  - System.Reflection.TypeDelegator.typeImpl
  - System.Reflection.TypeDelegator.UnderlyingSystemType
  langs:
  - csharp
  name: TypeDelegator
  nameWithType: TypeDelegator
  fullName: System.Reflection.TypeDelegator
  type: Class
  summary: "Создает оболочку для &lt;xref:System.Type?displayProperty=fullName&gt; методы объекта и делегаты, <xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;> </xref>."
  remarks: "Являются производными от этого типа и переопределить только те элементы, которые необходимо производить настройку, а также все члены, которые необходимы программе и еще не реализован TypeDelegator.       TypeDelegator наследует <xref:System.Type?displayProperty=fullName>и реализует большинство свойств и методов <xref:System.Type>.</xref:System.Type> </xref:System.Type?displayProperty=fullName> Для каждого элемента, он реализует, TypeDelegator автоматически делегирует соответствующий член внутренним <xref:System.Type>объект, который предоставляется в качестве аргумента конструктору.</xref:System.Type> Это внутреннее <xref:System.Type>объект предоставляется производными классами, `protected` <xref:System.Reflection.TypeDelegator.typeImpl>поля.</xref:System.Reflection.TypeDelegator.typeImpl> </xref:System.Type>      Настроек [!NOTE] настроек некоторые из членов TypeDelegator имеют реализации, несмотря на то, что самих элементов просто наследуются от <xref:System.Type>.</xref:System.Type> В этих случаях реализация предоставляется по переопределенный `protected` метод, который имеет имя, которое заканчивается суффиксом «Impl». Например, реализация для всех перегруженных версий <xref:System.Reflection.TypeDelegator.GetMethod%2A>указанный метод, переопределенный <xref:System.Reflection.TypeDelegator.GetMethodImpl%2A>метод.</xref:System.Reflection.TypeDelegator.GetMethodImpl%2A> </xref:System.Reflection.TypeDelegator.GetMethod%2A> Реализацию для унаследованные свойства, такие как <xref:System.Type.IsPublic%2A>и <xref:System.Type.IsNestedAssembly%2A>предоставляется переопределенным <xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A>метод.</xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A> </xref:System.Type.IsNestedAssembly%2A> </xref:System.Type.IsPublic%2A>       Наследование классов может предоставить открытый конструктор, принимающий <xref:System.Type>объекта в качестве параметра и просто передает объект, чтобы <xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29>конструктор, или можно установить внутренний <xref:System.Type>объект другим способом.</xref:System.Type> </xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29> </xref:System.Type>       Если производный класс использует член, который не реализован TypeDelegator, необходимо переопределить этот элемент и предоставить реализацию. Простой реализации является вызов соответствующего члена на внутренний <xref:System.Type>объекту, предоставленному <xref:System.Reflection.TypeDelegator.typeImpl>поле, но может обеспечить реализацию вашему приложению.</xref:System.Reflection.TypeDelegator.typeImpl> </xref:System.Type> Это не требуется переопределять эти элементы, если они не используются приложением или библиотекой функции приложение вызывает (например, с <xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=fullName>конструктор).</xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=fullName>       Следующие виртуальные методы (`Overridable` методы в Visual Basic) для <xref:System.Type>не реализован TypeDelegator: <xref:System.Type.MakeGenericType%2A>( <xref:System.Type.GetGenericTypeDefinition%2A>), <xref:System.Type.GetGenericArguments%2A>( <xref:System.Type.GetGenericParameterConstraints%2A>), <xref:System.Type.MakeArrayType%2A>( <xref:System.Type.MakeByRefType%2A>), <xref:System.Type.MakePointerType%2A>( <xref:System.Type.GetEnumNames%2A>), <xref:System.Type.GetEnumValues%2A>( <xref:System.Type.GetEnumUnderlyingType%2A>), <xref:System.Type.GetTypeCodeImpl%2A>( <xref:System.Type.IsEnumDefined%2A>), <xref:System.Type.IsEquivalentTo%2A>.</xref:System.Type.IsEquivalentTo%2A> </xref:System.Type.IsEnumDefined%2A> </xref:System.Type.GetTypeCodeImpl%2A> </xref:System.Type.GetEnumUnderlyingType%2A> </xref:System.Type.GetEnumValues%2A> </xref:System.Type.GetEnumNames%2A> </xref:System.Type.MakePointerType%2A> </xref:System.Type.MakeByRefType%2A> </xref:System.Type.MakeArrayType%2A> </xref:System.Type.GetGenericParameterConstraints%2A> </xref:System.Type.GetGenericArguments%2A> </xref:System.Type.GetGenericTypeDefinition%2A> </xref:System.Type.MakeGenericType%2A> </xref:System.Type>       Следующие свойства виртуального (`Overridable` свойств в Visual Basic) для <xref:System.Type>не реализован TypeDelegator: <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>( <xref:System.Type.IsGenericParameter%2A>), <xref:System.Type.ContainsGenericParameters%2A>( <xref:System.Type.DeclaringMethod%2A>), <xref:System.Type.GenericParameterAttributes%2A>( <xref:System.Type.GenericParameterPosition%2A>), <xref:System.Type.IsSecurityCritical%2A>( <xref:System.Type.IsSecuritySafeCritical%2A>), <xref:System.Type.IsSecurityTransparent%2A>.</xref:System.Type.IsSecurityTransparent%2A> </xref:System.Type.IsSecuritySafeCritical%2A> </xref:System.Type.IsSecurityCritical%2A> </xref:System.Type.GenericParameterPosition%2A> </xref:System.Type.GenericParameterAttributes%2A> </xref:System.Type.DeclaringMethod%2A> </xref:System.Type.ContainsGenericParameters%2A> </xref:System.Type.IsGenericParameter%2A> </xref:System.Type.IsGenericTypeDefinition%2A> </xref:System.Type.IsGenericType%2A> </xref:System.Type>"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class TypeDelegator : System.Reflection.TypeInfo
  inheritance:
  - System.Reflection.TypeInfo
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.#ctor
  id: '#ctor'
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: TypeDelegator()
  nameWithType: TypeDelegator.TypeDelegator()
  fullName: System.Reflection.TypeDelegator.TypeDelegator()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref> класса со свойствами по умолчанию."
  syntax:
    content: protected TypeDelegator ();
    parameters: []
  overload: System.Reflection.TypeDelegator.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.#ctor(System.Type)
  id: '#ctor(System.Type)'
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: TypeDelegator(Type)
  nameWithType: TypeDelegator.TypeDelegator(Type)
  fullName: System.Reflection.TypeDelegator.TypeDelegator(Type)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref> класса, задавая инкапсулирующий экземпляр."
  remarks: "Данный конструктор вызывается из класса для создания делегата на основе `Type` объект для класса, определяющего метод."
  syntax:
    content: public TypeDelegator (Type delegatingType);
    parameters:
    - id: delegatingType
      type: System.Type
      description: "Экземпляр класса <xref:System.Type>, инкапсулирующий вызов метода объекта.</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>delegatingType</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.Assembly
  id: Assembly
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: Assembly
  nameWithType: TypeDelegator.Assembly
  fullName: System.Reflection.TypeDelegator.Assembly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Получает сборку реализуемого типа."
  remarks: "Сборки представляют собой единицы развертывания в среде CLR. Сборки образуют пространство имен для разрешения запросов и определить, какие ресурсы доступны извне и доступные в пределах сборки. Общеязыковая среда выполнения определяет и найти сборку для любого выполняющегося объекта."
  syntax:
    content: public override System.Reflection.Assembly Assembly { get; }
    return:
      type: System.Reflection.Assembly
      description: "&lt;Xref:System.Reflection.Assembly?displayProperty=fullName&gt; объект, представляющий сборку реализуемого типа."
  overload: System.Reflection.TypeDelegator.Assembly*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.AssemblyQualifiedName
  id: AssemblyQualifiedName
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: AssemblyQualifiedName
  nameWithType: TypeDelegator.AssemblyQualifiedName
  fullName: System.Reflection.TypeDelegator.AssemblyQualifiedName
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает полное имя сборки."
  syntax:
    content: public override string AssemblyQualifiedName { get; }
    return:
      type: System.String
      description: "Объект <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> содержащая полное имя сборки."
  overload: System.Reflection.TypeDelegator.AssemblyQualifiedName*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.BaseType
  id: BaseType
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: BaseType
  nameWithType: TypeDelegator.BaseType
  fullName: System.Reflection.TypeDelegator.BaseType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает базовый тип текущего типа."
  remarks: "Базовый тип является типом, от которого непосредственно наследуется этот тип. Поскольку <xref:System.Object>тип класса является исходным базовым классом для всех других типов, он является единственным типом, у которого нет базового типа.</xref:System.Object> В этом случае `null` возвращается как базовый тип `Object` типа."
  syntax:
    content: public override Type BaseType { get; }
    return:
      type: System.Type
      description: "Базовый тип для типа."
  overload: System.Reflection.TypeDelegator.BaseType*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.FullName
  id: FullName
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: FullName
  nameWithType: TypeDelegator.FullName
  fullName: System.Reflection.TypeDelegator.FullName
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает полное имя реализуемого типа."
  remarks: "Строка, содержащая полное имя текущего `TypeDelegator`."
  syntax:
    content: public override string FullName { get; }
    return:
      type: System.String
      description: "Объект <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> содержащий полное имя типа."
  overload: System.Reflection.TypeDelegator.FullName*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetAttributeFlagsImpl
  id: GetAttributeFlagsImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetAttributeFlagsImpl()
  nameWithType: TypeDelegator.GetAttributeFlagsImpl()
  fullName: System.Reflection.TypeDelegator.GetAttributeFlagsImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает атрибуты, назначенные <xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>."
  remarks: "Этот метод можно использовать для определения `TypeDelegator` является абстрактным, открытым и т. д."
  syntax:
    content: protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();
    parameters: []
    return:
      type: System.Reflection.TypeAttributes
      description: "Объект <xref uid=&quot;langword_csharp_TypeAttributes&quot; name=&quot;TypeAttributes&quot; href=&quot;&quot;> </xref> объект, представляющий флаги атрибутов реализации."
  overload: System.Reflection.TypeDelegator.GetAttributeFlagsImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  id: GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Получает конструктор, который реализован <xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>."
  remarks: "`callConvention` Указывает соглашение о вызовах для точки входа. Если соглашение о вызовах не указан, значение по умолчанию <xref:System.Reflection.CallingConventions>значение `Standard` используется.</xref:System.Reflection.CallingConventions>"
  syntax:
    content: protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Битовая маска, влияющая на способ, в котором выполняется поиск. Значение представляет собой сочетание нуля или более битовых флагов из <xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>."
    - id: binder
      type: System.Reflection.Binder
      description: "Объект, позволяющий осуществлять привязку, приведение аргументов типов, вызов элементов и извлечение <xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;> </xref> объектов с помощью отражения. Если `binder` — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, используется связыватель по умолчанию."
    - id: callConvention
      type: System.Reflection.CallingConventions
      description: "Соглашения о вызовах."
    - id: types
      type: System.Type[]
      description: "Массив объектов типа <xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;> </xref> списком номер параметра, порядок и типы. Типы не могут быть <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; использовать соответствующий <xref uid=&quot;langword_csharp_GetMethod&quot; name=&quot;GetMethod&quot; href=&quot;&quot;> </xref> метода или пустой массив для поиска метода без параметров."
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: "Массив объектов типа <xref uid=&quot;langword_csharp_ParameterModifier&quot; name=&quot;ParameterModifier&quot; href=&quot;&quot;> </xref> документ одной длины: как `types` массив, элементы которого представляют атрибуты, связанные с параметрами метода."
    return:
      type: System.Reflection.ConstructorInfo
      description: "Объект <xref uid=&quot;langword_csharp_ConstructorInfo&quot; name=&quot;ConstructorInfo&quot; href=&quot;&quot;> </xref> объект для метода, который соответствует заданным критериям, или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> найденные совпадения."
  overload: System.Reflection.TypeDelegator.GetConstructorImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)
  id: GetConstructors(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetConstructors(BindingFlags)
  nameWithType: TypeDelegator.GetConstructors(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetConstructors(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает массив <xref:System.Reflection.ConstructorInfo>объектов, представляющих конструкторы, определенные для типа, оболочкой для которого текущий <xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>.</xref:System.Reflection.ConstructorInfo>"
  remarks: "Инициализаторы класса доступны только через `GetMember`, `GetMembers`, `FindMembers`, и `GetConstructors`."
  syntax:
    content: public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Битовая маска, влияющая на способ, в котором выполняется поиск. Значение представляет собой сочетание нуля или более битовых флагов из <xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>."
    return:
      type: System.Reflection.ConstructorInfo[]
      description: "Массив объектов типа <xref uid=&quot;langword_csharp_ConstructorInfo&quot; name=&quot;ConstructorInfo&quot; href=&quot;&quot;> </xref> содержащий заданные конструкторы, определенные для этого класса. Если конструкторы не определены, возвращается пустой массив. В зависимости от значения, заданного параметра возвращаются только открытые конструкторы или открытые и закрытые конструкторы."
  overload: System.Reflection.TypeDelegator.GetConstructors*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)
  id: GetCustomAttributes(System.Boolean)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetCustomAttributes(Boolean)
  nameWithType: TypeDelegator.GetCustomAttributes(Boolean)
  fullName: System.Reflection.TypeDelegator.GetCustomAttributes(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает все настраиваемые атрибуты, определенные для этого типа, указывая, следует ли выполнять поиск в цепочке наследования этого типа."
  syntax:
    content: public override object[] GetCustomAttributes (bool inherit);
    parameters:
    - id: inherit
      type: System.Boolean
      description: "Указывает, следует ли выполнять поиск в цепочке наследования этого типа для поиска атрибутов."
    return:
      type: System.Object[]
      description: "Массив объектов, содержащий все настраиваемые атрибуты, определенные для этого типа."
  overload: System.Reflection.TypeDelegator.GetCustomAttributes*
  exceptions:
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "Не удается загрузить тип пользовательского атрибута."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)
  id: GetCustomAttributes(System.Type,System.Boolean)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetCustomAttributes(Type,Boolean)
  nameWithType: TypeDelegator.GetCustomAttributes(Type,Boolean)
  fullName: System.Reflection.TypeDelegator.GetCustomAttributes(Type,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает массив настраиваемых атрибутов, принадлежащих указанному типу."
  syntax:
    content: public override object[] GetCustomAttributes (Type attributeType, bool inherit);
    parameters:
    - id: attributeType
      type: System.Type
      description: "Массив настраиваемых атрибутов, принадлежащих указанному типу."
    - id: inherit
      type: System.Boolean
      description: "Указывает, следует ли выполнять поиск в цепочке наследования этого типа для поиска атрибутов."
    return:
      type: System.Object[]
      description: "Массив объектов, содержащий настраиваемые атрибуты, определенные в этом типе, которые соответствуют <code> attributeType </code> параметр, указывающий, следует ли выполнять поиск в цепочке наследования этого типа, или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если пользовательские атрибуты не определены для данного типа."
  overload: System.Reflection.TypeDelegator.GetCustomAttributes*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>attributeType</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "Не удается загрузить тип пользовательского атрибута."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetElementType
  id: GetElementType
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetElementType()
  nameWithType: TypeDelegator.GetElementType()
  fullName: System.Reflection.TypeDelegator.GetElementType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает <xref:System.Type>включенных объекта, на который ссылается данный массив, указатель или ByRef.</xref:System.Type>"
  syntax:
    content: public override Type GetElementType ();
    parameters: []
    return:
      type: System.Type
      description: "<xref:System.Type>Объекта, используемого или упоминаемого в текущем массиве, указатель или <xref uid=&quot;langword_csharp_ByRef&quot; name=&quot;ByRef&quot; href=&quot;&quot;> </xref>, или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> если текущего <xref:System.Type>не является массивом, указателем или параметром <xref uid=&quot;langword_csharp_ByRef&quot; name=&quot;ByRef&quot; href=&quot;&quot;> </xref>.</xref:System.Type> </xref:System.Type>"
  overload: System.Reflection.TypeDelegator.GetElementType*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)
  id: GetEvent(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetEvent(String,BindingFlags)
  nameWithType: TypeDelegator.GetEvent(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetEvent(String,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает указанное событие."
  remarks: "Если `bindingAttr` — <xref:System.Reflection.BindingFlags>.`IgnoreCase`, вариант `name` параметр учитывается.</xref:System.Reflection.BindingFlags>"
  syntax:
    content: public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: "Имя события."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Битовая маска, влияющая на способ, в котором выполняется поиск. Значение представляет собой сочетание нуля или более битовых флагов из <xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>."
    return:
      type: System.Reflection.EventInfo
      description: "<xref:System.Reflection.EventInfo>Объектов, представляющих события, объявленные или наследованные данным типом, с указанным именем.</xref:System.Reflection.EventInfo> Этот метод возвращает <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если такое событие найдено."
  overload: System.Reflection.TypeDelegator.GetEvent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>name</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetEvents
  id: GetEvents
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetEvents()
  nameWithType: TypeDelegator.GetEvents()
  fullName: System.Reflection.TypeDelegator.GetEvents()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает массив <xref:System.Reflection.EventInfo>объектов, представляющих все открытые события, объявленные или наследуемые текущим <xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>.</xref:System.Reflection.EventInfo>"
  syntax:
    content: public override System.Reflection.EventInfo[] GetEvents ();
    parameters: []
    return:
      type: System.Reflection.EventInfo[]
      description: "Возвращает массив объектов типа <xref uid=&quot;langword_csharp_EventInfo&quot; name=&quot;EventInfo&quot; href=&quot;&quot;> </xref> содержит все события объявлено или унаследовано текущим типом. Если события отсутствуют, возвращается пустой массив."
  overload: System.Reflection.TypeDelegator.GetEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)
  id: GetEvents(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetEvents(BindingFlags)
  nameWithType: TypeDelegator.GetEvents(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetEvents(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает события, указанного в <code> bindingAttr </code> , объявленные или наследуемые текущим <xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>."
  syntax:
    content: public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Битовая маска, влияющая на способ, в котором выполняется поиск. Значение представляет собой сочетание нуля или более битовых флагов из <xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>."
    return:
      type: System.Reflection.EventInfo[]
      description: "Массив объектов типа <xref uid=&quot;langword_csharp_EventInfo&quot; name=&quot;EventInfo&quot; href=&quot;&quot;> </xref> содержит события, указанного в <code> bindingAttr </code>. Если события отсутствуют, возвращается пустой массив."
  overload: System.Reflection.TypeDelegator.GetEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)
  id: GetField(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetField(String,BindingFlags)
  nameWithType: TypeDelegator.GetField(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetField(String,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает <xref:System.Reflection.FieldInfo>объект, представляющий поле с указанным именем.</xref:System.Reflection.FieldInfo>"
  remarks: "Используйте `bindingAttr` из <xref:System.Reflection.BindingFlags>. NonPublic, чтобы вернуть все открытые и закрытые поля.</xref:System.Reflection.BindingFlags> Используйте `BindingFlags.IgnoreCase` учитывать регистр полей, как поиск с учетом регистра по умолчанию."
  syntax:
    content: public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: "Имя поля для поиска."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Битовая маска, влияющая на способ, в котором выполняется поиск. Значение представляет собой сочетание нуля или более битовых флагов из <xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>."
    return:
      type: System.Reflection.FieldInfo
      description: "Объект <xref uid=&quot;langword_csharp_FieldInfo&quot; name=&quot;FieldInfo&quot; href=&quot;&quot;> </xref> предоставляющий поле, объявленное или унаследованное этим <xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref> с указанным именем. Возвращает <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если поле не найден."
  overload: System.Reflection.TypeDelegator.GetField*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>name</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)
  id: GetFields(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetFields(BindingFlags)
  nameWithType: TypeDelegator.GetFields(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetFields(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает массив <xref:System.Reflection.FieldInfo>объектов, представляющих поля данных определено для типа, оболочкой для которого текущий <xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>.</xref:System.Reflection.FieldInfo>"
  remarks: "GetFields-метод возвращает поля в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть порядка, в котором возвращаются поля, так как этот порядок может меняться.       Используйте `bindingAttr` из <xref:System.Reflection.BindingFlags>. NonPublic, чтобы вернуть все открытые и закрытые поля.</xref:System.Reflection.BindingFlags>"
  syntax:
    content: public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Битовая маска, влияющая на способ, в котором выполняется поиск. Значение представляет собой сочетание нуля или более битовых флагов из <xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>."
    return:
      type: System.Reflection.FieldInfo[]
      description: "Массив объектов типа <xref uid=&quot;langword_csharp_FieldInfo&quot; name=&quot;FieldInfo&quot; href=&quot;&quot;> </xref> содержащий поля, объявленные или наследуемые текущим <xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>. Если нет соответствующих полей, возвращается пустой массив."
  overload: System.Reflection.TypeDelegator.GetFields*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)
  id: GetInterface(System.String,System.Boolean)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetInterface(String,Boolean)
  nameWithType: TypeDelegator.GetInterface(String,Boolean)
  fullName: System.Reflection.TypeDelegator.GetInterface(String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает указанный интерфейс, реализованный тип в оболочку текущим <xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>."
  syntax:
    content: public override Type GetInterface (string name, bool ignoreCase);
    parameters:
    - id: name
      type: System.String
      description: "Полное имя интерфейса, реализуемого в текущем классе."
    - id: ignoreCase
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если регистр не должен учитываться; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Type
      description: "Объект <xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;> </xref> объект, представляющий интерфейс, реализованный (прямо или косвенно) в текущем классе с полным именем, совпадающий с указанным именем. Если интерфейс с совпадающим именем не найден, значение null возвращается."
  overload: System.Reflection.TypeDelegator.GetInterface*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>name</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)
  id: GetInterfaceMap(System.Type)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetInterfaceMap(Type)
  nameWithType: TypeDelegator.GetInterfaceMap(Type)
  fullName: System.Reflection.TypeDelegator.GetInterfaceMap(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает сопоставление для интерфейса заданного типа."
  remarks: "В сопоставлении интерфейса указывается способ отображения интерфейса в фактических методах для класса, реализующего этот интерфейс."
  syntax:
    content: public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);
    parameters:
    - id: interfaceType
      type: System.Type
      description: "<xref:System.Type>Интерфейса для извлечения сопоставление.</xref:System.Type>"
    return:
      type: System.Reflection.InterfaceMapping
      description: "<xref:System.Reflection.InterfaceMapping>Объект, представляющий сопоставление интерфейса для <code> interfaceType </code>.</xref:System.Reflection.InterfaceMapping>"
  overload: System.Reflection.TypeDelegator.GetInterfaceMap*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetInterfaces
  id: GetInterfaces
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetInterfaces()
  nameWithType: TypeDelegator.GetInterfaces()
  fullName: System.Reflection.TypeDelegator.GetInterfaces()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает все интерфейсы, реализованные в текущем классе и его базовых классов."
  syntax:
    content: public override Type[] GetInterfaces ();
    parameters: []
    return:
      type: System.Type[]
      description: "Массив объектов типа <xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;> </xref> содержащий все интерфейсы, реализованные в текущем классе и его базовых классов. Если они не определены, возвращается пустой массив."
  overload: System.Reflection.TypeDelegator.GetInterfaces*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  id: GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetMember(String,MemberTypes,BindingFlags)
  nameWithType: TypeDelegator.GetMember(String,MemberTypes,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMember(String,MemberTypes,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает члены (свойства, методы, конструкторы, поля, события и вложенные типы), задаваемые по данной <code> name </code>, <code> type </code>, и <code> bindingAttr </code>."
  remarks: "If `bindingAttr` is <xref:System.Reflection.BindingFlags>. NonPublic, все члены будут считаться.</xref:System.Reflection.BindingFlags> Если совпадений не найдено, возвращается пустой массив."
  syntax:
    content: public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: "Имя получаемого элемента."
    - id: type
      type: System.Reflection.MemberTypes
      description: "Битовая маска, влияющая на способ, в котором выполняется поиск. Значение представляет собой сочетание нуля или более битовых флагов из <xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Тип возвращаемых элементов."
    return:
      type: System.Reflection.MemberInfo[]
      description: "Массив объектов типа <xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;> </xref> содержащего все элементы текущего класса и его базовых классов, удовлетворяющие указанным критериям."
  overload: System.Reflection.TypeDelegator.GetMember*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>name</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)
  id: GetMembers(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetMembers(BindingFlags)
  nameWithType: TypeDelegator.GetMembers(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMembers(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает элементы, указанные по <code> bindingAttr </code>."
  remarks: "If `bindingAttr` is <xref:System.Reflection.BindingFlags>. NonPublic, все члены будут считаться.</xref:System.Reflection.BindingFlags> Если совпадений не найдено, возвращается пустой массив."
  syntax:
    content: public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Битовая маска, влияющая на способ, в котором выполняется поиск. Значение представляет собой сочетание нуля или более битовых флагов из <xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>."
    return:
      type: System.Reflection.MemberInfo[]
      description: "Массив объектов типа <xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;> </xref> содержащего все элементы текущего класса и его базовых классов, которые соответствуют <code> bindingAttr </code> фильтра."
  overload: System.Reflection.TypeDelegator.GetMembers*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  id: GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Ищет указанный метод, параметры которого соответствуют указанным типам аргументов и модификаторам, используя заданные ограничения привязки и соглашение о вызовах."
  remarks: "`callConvention` Указывает соглашение о вызовах для точки входа. Если не <xref:System.Reflection.CallingConventions>указан, значение по умолчанию `CallingConventions` значение `Standard` используется.</xref:System.Reflection.CallingConventions>"
  syntax:
    content: protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);
    parameters:
    - id: name
      type: System.String
      description: "Имя метода."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Битовая маска, влияющая на способ, в котором выполняется поиск. Значение представляет собой сочетание нуля или более битовых флагов из <xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>."
    - id: binder
      type: System.Reflection.Binder
      description: "Объект, позволяющий осуществлять привязку, приведение аргументов типов, вызов элементов и извлечение <xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;> </xref> объектов с помощью отражения. Если `binder` — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, используется связыватель по умолчанию."
    - id: callConvention
      type: System.Reflection.CallingConventions
      description: "Соглашения о вызовах."
    - id: types
      type: System.Type[]
      description: "Массив объектов типа <xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;> </xref> списком номер параметра, порядок и типы. Типы не могут быть <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; использовать соответствующий <xref uid=&quot;langword_csharp_GetMethod&quot; name=&quot;GetMethod&quot; href=&quot;&quot;> </xref> метода или пустой массив для поиска метода без параметров."
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: "Массив объектов типа <xref uid=&quot;langword_csharp_ParameterModifier&quot; name=&quot;ParameterModifier&quot; href=&quot;&quot;> </xref> документ одной длины: как `types` массив, элементы которого представляют атрибуты, связанные с параметрами метода."
    return:
      type: System.Reflection.MethodInfo
      description: "Объект <xref uid=&quot;langword_csharp_MethodInfoInfo&quot; name=&quot;MethodInfoInfo&quot; href=&quot;&quot;> </xref> объекта для реализации метода, который соответствует заданным критериям, или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> найденные совпадения."
  overload: System.Reflection.TypeDelegator.GetMethodImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)
  id: GetMethods(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetMethods(BindingFlags)
  nameWithType: TypeDelegator.GetMethods(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMethods(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает массив <xref:System.Reflection.MethodInfo>объекты, представляющие методы указанного оболочкой для текущего типа <xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>.</xref:System.Reflection.MethodInfo>"
  syntax:
    content: public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Битовая маска, влияющая на способ, в котором выполняется поиск. Значение представляет собой сочетание нуля или более битовых флагов из <xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>."
    return:
      type: System.Reflection.MethodInfo[]
      description: "Массив <xref uid=&quot;langword_csharp_MethodInfo&quot; name=&quot;MethodInfo&quot; href=&quot;&quot;> </xref> объекты, представляющие методы, определенные для данного <xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>."
  overload: System.Reflection.TypeDelegator.GetMethods*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)
  id: GetNestedType(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetNestedType(String,BindingFlags)
  nameWithType: TypeDelegator.GetNestedType(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetNestedType(String,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает вложенный тип, заданный путем <code> name </code> и <code> bindingAttr </code> , объявленные или унаследованные типом, представленный текущим <xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>."
  syntax:
    content: public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: "Имя вложенного типа."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Битовая маска, влияющая на способ, в котором выполняется поиск. Значение представляет собой сочетание нуля или более битовых флагов из <xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>."
    return:
      type: System.Type
      description: "Объект <xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;> </xref> объект, предоставляющий вложенный тип."
  overload: System.Reflection.TypeDelegator.GetNestedType*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>name</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)
  id: GetNestedTypes(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetNestedTypes(BindingFlags)
  nameWithType: TypeDelegator.GetNestedTypes(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetNestedTypes(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает вложенные типы, заданные в <code> bindingAttr </code> , объявленные или унаследованные типом, оболочкой для которого текущий <xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>."
  syntax:
    content: public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Битовая маска, влияющая на способ, в котором выполняется поиск. Значение представляет собой сочетание нуля или более битовых флагов из <xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>."
    return:
      type: System.Type[]
      description: "Массив объектов типа <xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;> </xref> содержащий вложенные типы."
  overload: System.Reflection.TypeDelegator.GetNestedTypes*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)
  id: GetProperties(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetProperties(BindingFlags)
  nameWithType: TypeDelegator.GetProperties(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetProperties(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает массив <xref:System.Reflection.PropertyInfo>объекты, представляющие свойства типа, оболочкой для которого текущий <xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>.</xref:System.Reflection.PropertyInfo>"
  syntax:
    content: public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Битовая маска, влияющая на способ, в котором выполняется поиск. Значение представляет собой сочетание нуля или более битовых флагов из <xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>."
    return:
      type: System.Reflection.PropertyInfo[]
      description: "Массив <xref uid=&quot;langword_csharp_PropertyInfo&quot; name=&quot;PropertyInfo&quot; href=&quot;&quot;> </xref> объектов, представляющих свойства, определенные для данного <xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>."
  overload: System.Reflection.TypeDelegator.GetProperties*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  id: GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "При переопределении в производном классе ищет указанное свойство, параметры которого соответствуют указанным типам аргументов и модификаторам, используя заданные ограничения привязки."
  syntax:
    content: protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);
    parameters:
    - id: name
      type: System.String
      description: "Возвращаемое свойство."
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "Битовая маска, влияющая на способ, в котором выполняется поиск. Значение представляет собой сочетание нуля или более битовых флагов из <xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>."
    - id: binder
      type: System.Reflection.Binder
      description: "Объект, позволяющий осуществлять привязку, приведение аргументов типов, вызов элементов и извлечение <xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;> </xref> их с помощью отражения. Если `binder` — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, используется связыватель по умолчанию. See <xref href=&quot;System.Reflection.Binder&quot;></xref>."
    - id: returnType
      type: System.Type
      description: "Возвращаемый тип свойства."
    - id: types
      type: System.Type[]
      description: "Список типов параметров. Список представляет число, порядок и типы параметров. Типы не могут иметь значение null; использовать соответствующий <xref uid=&quot;langword_csharp_GetMethod&quot; name=&quot;GetMethod&quot; href=&quot;&quot;> </xref> метода или пустой массив для поиска метода без параметров."
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: "Массив такую же длину, что и типы элементов, представляющих атрибуты, связанные с параметрами метода."
    return:
      type: System.Reflection.PropertyInfo
      description: "Объект <xref:System.Reflection.PropertyInfo>объекта для свойства, которое соответствует заданным критериям, или значение null, если совпадение не найдено.</xref:System.Reflection.PropertyInfo>"
  overload: System.Reflection.TypeDelegator.GetPropertyImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GUID
  id: GUID
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GUID
  nameWithType: TypeDelegator.GUID
  fullName: System.Reflection.TypeDelegator.GUID
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает идентификатор GUID (глобальный уникальный идентификатор) реализуемого типа."
  remarks: "Глобально уникальный идентификатор (GUID) — 128-разрядный уникальный идентификационный строка, используемая для определения класса или интерфейса. В основном полезно для обеспечения взаимодействия между Microsoft .NET Framework и COM."
  syntax:
    content: public override Guid GUID { get; }
    return:
      type: System.Guid
      description: "ИДЕНТИФИКАТОР GUID."
  overload: System.Reflection.TypeDelegator.GUID*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.HasElementTypeImpl
  id: HasElementTypeImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: HasElementTypeImpl()
  nameWithType: TypeDelegator.HasElementTypeImpl()
  fullName: System.Reflection.TypeDelegator.HasElementTypeImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает значение, указывающее ли текущий <xref:System.Type>непосредственно другой тип; иными словами, является ли текущий <xref:System.Type>является массивом, указателем или параметром ByRef.</xref:System.Type> </xref:System.Type>"
  syntax:
    content: protected override bool HasElementTypeImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref:System.Type>является массивом, указателем или параметром ByRef; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.HasElementTypeImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  id: InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  nameWithType: TypeDelegator.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  fullName: System.Reflection.TypeDelegator.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Вызывает указанный член. Вызываемый метод должен быть доступен и обеспечивать наиболее точное соответствие указанному списку аргументов, с учетом ограничений заданного модуля привязки и атрибутов вызова."
  remarks: "Метод будет вызван, если выполняются следующие условия: - число параметров в объявлении метода равно количеству аргументов в списке аргументов (если аргументы по умолчанию не определены в элементе).      — Тип каждого аргумента может преобразовываться связывателем тип параметра.       Связыватель найдет все подходящие методы. Эти методы находятся в зависимости от типа связывания (`BindingFlags.MethodInvoke`, `BindingFlags.GetProperties`и так далее). Набор методов фильтруется по имени, количество аргументов и набор модификаторов поиска, определенных в модуле привязки.       После выбора метод будет вызван. На этом этапе проверяется доступность. Средство поиска может управлять поиском определения набора методов на основе связанного с методом атрибута доступности. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName>Метод отвечает за выбор вызываемого метода.</xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> Связыватель по умолчанию выбирает наиболее точное соответствие.      Настроек [!NOTE] настроек ограничения доступа игнорируются для полностью доверенный код. То есть закрытые конструкторы, методы, поля и свойства доступны и с использованием отражения, если полностью доверенный код.       В настоящее время `InvokeMember` выполняет семантику отражения Microsoft .NET Framework для каждого типа объекта.       Если элемент, заданный по имени является массивом и `BindingFlags.GetField` установлен флаг `invokeAttr`, `args` массив задает элементы, значения которых должны быть возвращены. Например, следующий вызов с помощью `Type` объекта `t` возвращает значение первого элемента строкового массива MyArray, который является членом вызывающего объекта: `String ret = (String) t.InvokeMember (&quot;MyArray&quot;, BindingFlags.GetField, null, this, new Variant[]{0});` можно использовать `InvokeMember` для задания одного или нескольких элементов массива членов. Все элементы, присваивается то же значение. `args` Массива должен иметь следующий формат: ```   {index1,       index2,, value}   ``` так, чтобы установить первый член MyArray из предыдущего примера, используется следующий синтаксис:```   t.InvokeMember (&quot;MyArray&quot;, BindingFlags.SetField, null, this, new       Variant[]{0,&quot;Updated&quot;});   ```"
  syntax:
    content: public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
    parameters:
    - id: name
      type: System.String
      description: "Имя вызываемого члена. Это может быть конструктор, метод, свойство или поле. Если это пустая строка (&quot;») передается значение по умолчанию-член вызывается."
    - id: invokeAttr
      type: System.Reflection.BindingFlags
      description: 'Атрибут вызова. This must be one of the following <xref href=&quot;System.Reflection.BindingFlags&quot;></xref> : <xref uid=&quot;langword_csharp_InvokeMethod&quot; name=&quot;InvokeMethod&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_CreateInstance&quot; name=&quot;CreateInstance&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Static&quot; name=&quot;Static&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_GetField&quot; name=&quot;GetField&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_SetField&quot; name=&quot;SetField&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_GetProperty&quot; name=&quot;GetProperty&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_SetProperty&quot; name=&quot;SetProperty&quot; href=&quot;&quot;></xref>. Необходимо указать подходящий атрибут вызова. Если статический член должен быть вызван, <xref uid=&quot;langword_csharp_Static&quot; name=&quot;Static&quot; href=&quot;&quot;> </xref> должен быть установлен флаг.'
    - id: binder
      type: System.Reflection.Binder
      description: "Объект, позволяющий осуществлять привязку, приведение аргументов типов, вызов элементов и извлечение <xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;> </xref> их с помощью отражения. Если `binder` — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, используется связыватель по умолчанию. See <xref href=&quot;System.Reflection.Binder&quot;></xref>."
    - id: target
      type: System.Object
      description: "Объект, для которого следует вызвать указанный член."
    - id: args
      type: System.Object[]
      description: "Массив объектов типа <xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;> </xref> , содержащий число, порядок и тип параметров вызываемого члена. Если `args` содержит неинициализированный объект <xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;> </xref>, она обрабатывается как пустой и может быть преобразован по умолчанию связывателем в 0, 0,0 или строку."
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: "Массив объектов типа <xref uid=&quot;langword_csharp_ParameterModifer&quot; name=&quot;ParameterModifer&quot; href=&quot;&quot;> </xref> именно одинаковую длину поля `args`, элементы которого представляют атрибуты, связанные с аргументами вызываемого члена. Параметр имеет атрибуты, связанные с ним в подписи элемента. ByRef, используйте <xref uid=&quot;langword_csharp_ParameterModifer.ByRef&quot; name=&quot;ParameterModifer.ByRef&quot; href=&quot;&quot;> </xref>и при отсутствии параметра — <xref uid=&quot;langword_csharp_ParameterModifer.None&quot; name=&quot;ParameterModifer.None&quot; href=&quot;&quot;> </xref>. Связыватель по умолчанию точное совпадение. Атрибуты, такие как <xref uid=&quot;langword_csharp_In&quot; name=&quot;In&quot; href=&quot;&quot;> </xref> и <xref uid=&quot;langword_csharp_InOut&quot; name=&quot;InOut&quot; href=&quot;&quot;> </xref> не используется в привязке, а также можно просматривать при помощи <xref uid=&quot;langword_csharp_ParameterInfo&quot; name=&quot;ParameterInfo&quot; href=&quot;&quot;> </xref>."
    - id: culture
      type: System.Globalization.CultureInfo
      description: "Экземпляр <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> используется для управления приведением типов. Это необходимо, например, чтобы преобразовать строку, представляющую 1000, в <xref uid=&quot;langword_csharp_Double&quot; name=&quot;Double&quot; href=&quot;&quot;> </xref> значение, поскольку при разных языках и региональных параметрах 1000 представляется по-разному. Если `culture` — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> для текущего потока <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref> используется."
    - id: namedParameters
      type: System.String[]
      description: "Массив объектов типа <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> содержащий имена параметров, совпадающие, начиная с нулевого элемента, с `args` массива. В массиве должен быть не бреши в системе. If `args`. <xref uid=&quot;langword_csharp_Length&quot; name=&quot;Length&quot; href=&quot;&quot;></xref>больше, чем `namedParameters`. <xref uid=&quot;langword_csharp_Length&quot; name=&quot;Length&quot; href=&quot;&quot;></xref>, остальные параметры заполняются по порядку."
    return:
      type: System.Object
      description: "<xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;> </xref> Представляющий возвращаемое значение вызываемого элемента."
  overload: System.Reflection.TypeDelegator.InvokeMember*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsArrayImpl
  id: IsArrayImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsArrayImpl()
  nameWithType: TypeDelegator.IsArrayImpl()
  fullName: System.Reflection.TypeDelegator.IsArrayImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает значение, указывающее, является ли <xref:System.Type>является массивом.</xref:System.Type>"
  syntax:
    content: protected override bool IsArrayImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref:System.Type>является массивом; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.IsArrayImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)
  id: IsAssignableFrom(System.Reflection.TypeInfo)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsAssignableFrom(TypeInfo)
  nameWithType: TypeDelegator.IsAssignableFrom(TypeInfo)
  fullName: System.Reflection.TypeDelegator.IsAssignableFrom(TypeInfo)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает значение, которое указывает, может ли указанный тип назначено этого типа."
  syntax:
    content: public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);
    parameters:
    - id: typeInfo
      type: System.Reflection.TypeInfo
      description: "Проверяемый тип."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если указанный тип может назначаться для этого типа; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Reflection.TypeDelegator.IsAssignableFrom*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsByRefImpl
  id: IsByRefImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsByRefImpl()
  nameWithType: TypeDelegator.IsByRefImpl()
  fullName: System.Reflection.TypeDelegator.IsByRefImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает значение, указывающее, является ли <xref:System.Type>передается по ссылке.</xref:System.Type>"
  syntax:
    content: protected override bool IsByRefImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref:System.Type>передается по ссылке; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.IsByRefImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsCOMObjectImpl
  id: IsCOMObjectImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsCOMObjectImpl()
  nameWithType: TypeDelegator.IsCOMObjectImpl()
  fullName: System.Reflection.TypeDelegator.IsCOMObjectImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает значение, указывающее, является ли <xref:System.Type>COM-объектом.</xref:System.Type>"
  syntax:
    content: protected override bool IsCOMObjectImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref:System.Type>COM-объектом; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.IsCOMObjectImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsConstructedGenericType
  id: IsConstructedGenericType
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsConstructedGenericType
  nameWithType: TypeDelegator.IsConstructedGenericType
  fullName: System.Reflection.TypeDelegator.IsConstructedGenericType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает значение, указывающее, представляет ли этот объект сконструированный универсальный тип."
  syntax:
    content: public override bool IsConstructedGenericType { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если этот объект представляет сконструированный универсальный тип; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Reflection.TypeDelegator.IsConstructedGenericType*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)
  id: IsDefined(System.Type,System.Boolean)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsDefined(Type,Boolean)
  nameWithType: TypeDelegator.IsDefined(Type,Boolean)
  fullName: System.Reflection.TypeDelegator.IsDefined(Type,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Указывает, является ли пользовательский атрибут, заданный <code> attributeType </code> определен."
  syntax:
    content: public override bool IsDefined (Type attributeType, bool inherit);
    parameters:
    - id: attributeType
      type: System.Type
      description: "Указывает, следует ли выполнять поиск в цепочке наследования этого типа для поиска атрибутов."
    - id: inherit
      type: System.Boolean
      description: "Массив настраиваемых атрибутов, принадлежащих указанному типу."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если пользовательский атрибут, заданный параметром <code> attributeType </code> определен; в противном случае — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Reflection.TypeDelegator.IsDefined*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>attributeType</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Reflection.ReflectionTypeLoadException
    commentId: T:System.Reflection.ReflectionTypeLoadException
    description: "Не удается загрузить тип пользовательского атрибута."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsPointerImpl
  id: IsPointerImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsPointerImpl()
  nameWithType: TypeDelegator.IsPointerImpl()
  fullName: System.Reflection.TypeDelegator.IsPointerImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает значение, указывающее, является ли <xref:System.Type>является указателем.</xref:System.Type>"
  syntax:
    content: protected override bool IsPointerImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref:System.Type>является указателем; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.IsPointerImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsPrimitiveImpl
  id: IsPrimitiveImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsPrimitiveImpl()
  nameWithType: TypeDelegator.IsPrimitiveImpl()
  fullName: System.Reflection.TypeDelegator.IsPrimitiveImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает значение, указывающее, является ли <xref:System.Type>является одним из типов-примитивов.</xref:System.Type>"
  syntax:
    content: protected override bool IsPrimitiveImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref:System.Type>является одним из типов-примитивов; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.IsPrimitiveImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsValueTypeImpl
  id: IsValueTypeImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsValueTypeImpl()
  nameWithType: TypeDelegator.IsValueTypeImpl()
  fullName: System.Reflection.TypeDelegator.IsValueTypeImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает значение, указывающее, является ли тип типом значения; то есть, не является классом или интерфейсом."
  syntax:
    content: protected override bool IsValueTypeImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если тип является типом значения; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Reflection.TypeDelegator.IsValueTypeImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.MetadataToken
  id: MetadataToken
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: MetadataToken
  nameWithType: TypeDelegator.MetadataToken
  fullName: System.Reflection.TypeDelegator.MetadataToken
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает значение, которое идентифицирует этот объект в метаданных."
  remarks: "Маркеры, полученные с помощью этого свойства может быть передан неуправляемого API-интерфейса отражения. Дополнительные сведения см. в разделе [неуправляемый интерфейс API отражения](http://msdn.microsoft.com/en-us/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)."
  syntax:
    content: public override int MetadataToken { get; }
    return:
      type: System.Int32
      description: "Значение, которое, в сочетании с модулем, уникальным образом идентифицирует этот объект в метаданных."
  overload: System.Reflection.TypeDelegator.MetadataToken*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.Module
  id: Module
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: Module
  nameWithType: TypeDelegator.Module
  fullName: System.Reflection.TypeDelegator.Module
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает модуль, содержащий реализованный тип."
  remarks: "Модуль — загружаемая единица, которая может содержать объявления и реализации типов. Модули содержат достаточно информации для общеязыковая среда выполнения обнаружила все части реализации, когда модуль был загружен."
  syntax:
    content: public override System.Reflection.Module Module { get; }
    return:
      type: System.Reflection.Module
      description: "Объект <xref:System.Reflection.Module>объект, представляющий модуль реализуемого типа.</xref:System.Reflection.Module>"
  overload: System.Reflection.TypeDelegator.Module*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.Name
  id: Name
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: Name
  nameWithType: TypeDelegator.Name
  fullName: System.Reflection.TypeDelegator.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает имя реализуемого типа с удалением пути."
  remarks: "Строка, содержащая имя текущего `TypeDelegator`. Возвращается только простое имя, а не полное доменное имя. Чтобы получить имя и путь, используйте <xref:System.Reflection.TypeDelegator.FullName%2A>.</xref:System.Reflection.TypeDelegator.FullName%2A>"
  syntax:
    content: public override string Name { get; }
    return:
      type: System.String
      description: "Объект <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> содержащая неполное имя типа."
  overload: System.Reflection.TypeDelegator.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.Namespace
  id: Namespace
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: Namespace
  nameWithType: TypeDelegator.Namespace
  fullName: System.Reflection.TypeDelegator.Namespace
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает пространство имен реализуемого типа."
  remarks: "Это свойство возвращает строку, содержащую пространство имен текущего `TypeDelegator`. Например если `TypeDelegator` - <xref:System.Reflection.TypeFilter>, возвращается пространство имен <xref:System.Reflection>.</xref:System.Reflection> </xref:System.Reflection.TypeFilter>"
  syntax:
    content: public override string Namespace { get; }
    return:
      type: System.String
      description: "Объект <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> содержащей пространство имен этого типа."
  overload: System.Reflection.TypeDelegator.Namespace*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.TypeHandle
  id: TypeHandle
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: TypeHandle
  nameWithType: TypeDelegator.TypeHandle
  fullName: System.Reflection.TypeDelegator.TypeHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает дескриптор представления внутренних метаданных реализуемого типа."
  remarks: "Дескриптор типа является уникальным целочисленное значение, связанное с каждым типом. Дескриптор является уникальным во время выполнения."
  syntax:
    content: public override RuntimeTypeHandle TypeHandle { get; }
    return:
      type: System.RuntimeTypeHandle
      description: "A <xref uid=&quot;langword_csharp_RuntimeTypeHandle&quot; name=&quot;RuntimeTypeHandle&quot; href=&quot;&quot;></xref> object."
  overload: System.Reflection.TypeDelegator.TypeHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.typeImpl
  id: typeImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: typeImpl
  nameWithType: TypeDelegator.typeImpl
  fullName: System.Reflection.TypeDelegator.typeImpl
  type: Field
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Значение, указывающее тип сведений."
  syntax:
    content: protected Type typeImpl;
    return:
      type: System.Type
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.UnderlyingSystemType
  id: UnderlyingSystemType
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: UnderlyingSystemType
  nameWithType: TypeDelegator.UnderlyingSystemType
  fullName: System.Reflection.TypeDelegator.UnderlyingSystemType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "Возвращает базовый <xref:System.Type>, представляющий реализованный тип.</xref:System.Type>"
  syntax:
    content: public override Type UnderlyingSystemType { get; }
    return:
      type: System.Type
      description: "Базовый тип."
  overload: System.Reflection.TypeDelegator.UnderlyingSystemType*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Reflection.TypeInfo
  isExternal: false
  name: System.Reflection.TypeInfo
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.TypeLoadException
  isExternal: true
  name: System.TypeLoadException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Reflection.ReflectionTypeLoadException
  isExternal: true
  name: System.Reflection.ReflectionTypeLoadException
- uid: System.Reflection.TypeDelegator.#ctor
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: TypeDelegator()
  nameWithType: TypeDelegator.TypeDelegator()
  fullName: System.Reflection.TypeDelegator.TypeDelegator()
- uid: System.Reflection.TypeDelegator.#ctor(System.Type)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: TypeDelegator(Type)
  nameWithType: TypeDelegator.TypeDelegator(Type)
  fullName: System.Reflection.TypeDelegator.TypeDelegator(Type)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Reflection.TypeDelegator.Assembly
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Assembly
  nameWithType: TypeDelegator.Assembly
  fullName: System.Reflection.TypeDelegator.Assembly
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.Reflection.TypeDelegator.AssemblyQualifiedName
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: AssemblyQualifiedName
  nameWithType: TypeDelegator.AssemblyQualifiedName
  fullName: System.Reflection.TypeDelegator.AssemblyQualifiedName
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Reflection.TypeDelegator.BaseType
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: BaseType
  nameWithType: TypeDelegator.BaseType
  fullName: System.Reflection.TypeDelegator.BaseType
- uid: System.Reflection.TypeDelegator.FullName
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: FullName
  nameWithType: TypeDelegator.FullName
  fullName: System.Reflection.TypeDelegator.FullName
- uid: System.Reflection.TypeDelegator.GetAttributeFlagsImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetAttributeFlagsImpl()
  nameWithType: TypeDelegator.GetAttributeFlagsImpl()
  fullName: System.Reflection.TypeDelegator.GetAttributeFlagsImpl()
- uid: System.Reflection.TypeAttributes
  parent: System.Reflection
  isExternal: true
  name: TypeAttributes
  nameWithType: TypeAttributes
  fullName: System.Reflection.TypeAttributes
- uid: System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
- uid: System.Reflection.ConstructorInfo
  parent: System.Reflection
  isExternal: true
  name: ConstructorInfo
  nameWithType: ConstructorInfo
  fullName: System.Reflection.ConstructorInfo
- uid: System.Reflection.BindingFlags
  parent: System.Reflection
  isExternal: false
  name: BindingFlags
  nameWithType: BindingFlags
  fullName: System.Reflection.BindingFlags
- uid: System.Reflection.Binder
  parent: System.Reflection
  isExternal: false
  name: Binder
  nameWithType: Binder
  fullName: System.Reflection.Binder
- uid: System.Reflection.CallingConventions
  parent: System.Reflection
  isExternal: true
  name: CallingConventions
  nameWithType: CallingConventions
  fullName: System.Reflection.CallingConventions
- uid: System.Type[]
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type[]
  spec.csharp:
  - uid: System.Type
    name: Type
    nameWithType: Type
    fullName: Type[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.ParameterModifier[]
  parent: System.Reflection
  isExternal: false
  name: ParameterModifier
  nameWithType: ParameterModifier
  fullName: System.Reflection.ParameterModifier[]
  spec.csharp:
  - uid: System.Reflection.ParameterModifier
    name: ParameterModifier
    nameWithType: ParameterModifier
    fullName: ParameterModifier[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetConstructors(BindingFlags)
  nameWithType: TypeDelegator.GetConstructors(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetConstructors(BindingFlags)
- uid: System.Reflection.ConstructorInfo[]
  parent: System.Reflection
  isExternal: true
  name: ConstructorInfo
  nameWithType: ConstructorInfo
  fullName: System.Reflection.ConstructorInfo[]
  spec.csharp:
  - uid: System.Reflection.ConstructorInfo
    name: ConstructorInfo
    nameWithType: ConstructorInfo
    fullName: ConstructorInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetCustomAttributes(Boolean)
  nameWithType: TypeDelegator.GetCustomAttributes(Boolean)
  fullName: System.Reflection.TypeDelegator.GetCustomAttributes(Boolean)
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetCustomAttributes(Type,Boolean)
  nameWithType: TypeDelegator.GetCustomAttributes(Type,Boolean)
  fullName: System.Reflection.TypeDelegator.GetCustomAttributes(Type,Boolean)
- uid: System.Reflection.TypeDelegator.GetElementType
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetElementType()
  nameWithType: TypeDelegator.GetElementType()
  fullName: System.Reflection.TypeDelegator.GetElementType()
- uid: System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetEvent(String,BindingFlags)
  nameWithType: TypeDelegator.GetEvent(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetEvent(String,BindingFlags)
- uid: System.Reflection.EventInfo
  parent: System.Reflection
  isExternal: true
  name: EventInfo
  nameWithType: EventInfo
  fullName: System.Reflection.EventInfo
- uid: System.Reflection.TypeDelegator.GetEvents
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetEvents()
  nameWithType: TypeDelegator.GetEvents()
  fullName: System.Reflection.TypeDelegator.GetEvents()
- uid: System.Reflection.EventInfo[]
  parent: System.Reflection
  isExternal: true
  name: EventInfo
  nameWithType: EventInfo
  fullName: System.Reflection.EventInfo[]
  spec.csharp:
  - uid: System.Reflection.EventInfo
    name: EventInfo
    nameWithType: EventInfo
    fullName: EventInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetEvents(BindingFlags)
  nameWithType: TypeDelegator.GetEvents(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetEvents(BindingFlags)
- uid: System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetField(String,BindingFlags)
  nameWithType: TypeDelegator.GetField(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetField(String,BindingFlags)
- uid: System.Reflection.FieldInfo
  parent: System.Reflection
  isExternal: true
  name: FieldInfo
  nameWithType: FieldInfo
  fullName: System.Reflection.FieldInfo
- uid: System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetFields(BindingFlags)
  nameWithType: TypeDelegator.GetFields(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetFields(BindingFlags)
- uid: System.Reflection.FieldInfo[]
  parent: System.Reflection
  isExternal: true
  name: FieldInfo
  nameWithType: FieldInfo
  fullName: System.Reflection.FieldInfo[]
  spec.csharp:
  - uid: System.Reflection.FieldInfo
    name: FieldInfo
    nameWithType: FieldInfo
    fullName: FieldInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterface(String,Boolean)
  nameWithType: TypeDelegator.GetInterface(String,Boolean)
  fullName: System.Reflection.TypeDelegator.GetInterface(String,Boolean)
- uid: System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterfaceMap(Type)
  nameWithType: TypeDelegator.GetInterfaceMap(Type)
  fullName: System.Reflection.TypeDelegator.GetInterfaceMap(Type)
- uid: System.Reflection.InterfaceMapping
  parent: System.Reflection
  isExternal: true
  name: InterfaceMapping
  nameWithType: InterfaceMapping
  fullName: System.Reflection.InterfaceMapping
- uid: System.Reflection.TypeDelegator.GetInterfaces
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterfaces()
  nameWithType: TypeDelegator.GetInterfaces()
  fullName: System.Reflection.TypeDelegator.GetInterfaces()
- uid: System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMember(String,MemberTypes,BindingFlags)
  nameWithType: TypeDelegator.GetMember(String,MemberTypes,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMember(String,MemberTypes,BindingFlags)
- uid: System.Reflection.MemberInfo[]
  parent: System.Reflection
  isExternal: true
  name: MemberInfo
  nameWithType: MemberInfo
  fullName: System.Reflection.MemberInfo[]
  spec.csharp:
  - uid: System.Reflection.MemberInfo
    name: MemberInfo
    nameWithType: MemberInfo
    fullName: MemberInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.MemberTypes
  parent: System.Reflection
  isExternal: false
  name: MemberTypes
  nameWithType: MemberTypes
  fullName: System.Reflection.MemberTypes
- uid: System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMembers(BindingFlags)
  nameWithType: TypeDelegator.GetMembers(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMembers(BindingFlags)
- uid: System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
- uid: System.Reflection.MethodInfo
  parent: System.Reflection
  isExternal: true
  name: MethodInfo
  nameWithType: MethodInfo
  fullName: System.Reflection.MethodInfo
- uid: System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMethods(BindingFlags)
  nameWithType: TypeDelegator.GetMethods(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMethods(BindingFlags)
- uid: System.Reflection.MethodInfo[]
  parent: System.Reflection
  isExternal: true
  name: MethodInfo
  nameWithType: MethodInfo
  fullName: System.Reflection.MethodInfo[]
  spec.csharp:
  - uid: System.Reflection.MethodInfo
    name: MethodInfo
    nameWithType: MethodInfo
    fullName: MethodInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetNestedType(String,BindingFlags)
  nameWithType: TypeDelegator.GetNestedType(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetNestedType(String,BindingFlags)
- uid: System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetNestedTypes(BindingFlags)
  nameWithType: TypeDelegator.GetNestedTypes(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetNestedTypes(BindingFlags)
- uid: System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetProperties(BindingFlags)
  nameWithType: TypeDelegator.GetProperties(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetProperties(BindingFlags)
- uid: System.Reflection.PropertyInfo[]
  parent: System.Reflection
  isExternal: true
  name: PropertyInfo
  nameWithType: PropertyInfo
  fullName: System.Reflection.PropertyInfo[]
  spec.csharp:
  - uid: System.Reflection.PropertyInfo
    name: PropertyInfo
    nameWithType: PropertyInfo
    fullName: PropertyInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
- uid: System.Reflection.PropertyInfo
  parent: System.Reflection
  isExternal: true
  name: PropertyInfo
  nameWithType: PropertyInfo
  fullName: System.Reflection.PropertyInfo
- uid: System.Reflection.TypeDelegator.GUID
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GUID
  nameWithType: TypeDelegator.GUID
  fullName: System.Reflection.TypeDelegator.GUID
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.Reflection.TypeDelegator.HasElementTypeImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: HasElementTypeImpl()
  nameWithType: TypeDelegator.HasElementTypeImpl()
  fullName: System.Reflection.TypeDelegator.HasElementTypeImpl()
- uid: System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  nameWithType: TypeDelegator.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  fullName: System.Reflection.TypeDelegator.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.IsArrayImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsArrayImpl()
  nameWithType: TypeDelegator.IsArrayImpl()
  fullName: System.Reflection.TypeDelegator.IsArrayImpl()
- uid: System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsAssignableFrom(TypeInfo)
  nameWithType: TypeDelegator.IsAssignableFrom(TypeInfo)
  fullName: System.Reflection.TypeDelegator.IsAssignableFrom(TypeInfo)
- uid: System.Reflection.TypeDelegator.IsByRefImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsByRefImpl()
  nameWithType: TypeDelegator.IsByRefImpl()
  fullName: System.Reflection.TypeDelegator.IsByRefImpl()
- uid: System.Reflection.TypeDelegator.IsCOMObjectImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsCOMObjectImpl()
  nameWithType: TypeDelegator.IsCOMObjectImpl()
  fullName: System.Reflection.TypeDelegator.IsCOMObjectImpl()
- uid: System.Reflection.TypeDelegator.IsConstructedGenericType
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsConstructedGenericType
  nameWithType: TypeDelegator.IsConstructedGenericType
  fullName: System.Reflection.TypeDelegator.IsConstructedGenericType
- uid: System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsDefined(Type,Boolean)
  nameWithType: TypeDelegator.IsDefined(Type,Boolean)
  fullName: System.Reflection.TypeDelegator.IsDefined(Type,Boolean)
- uid: System.Reflection.TypeDelegator.IsPointerImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsPointerImpl()
  nameWithType: TypeDelegator.IsPointerImpl()
  fullName: System.Reflection.TypeDelegator.IsPointerImpl()
- uid: System.Reflection.TypeDelegator.IsPrimitiveImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsPrimitiveImpl()
  nameWithType: TypeDelegator.IsPrimitiveImpl()
  fullName: System.Reflection.TypeDelegator.IsPrimitiveImpl()
- uid: System.Reflection.TypeDelegator.IsValueTypeImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsValueTypeImpl()
  nameWithType: TypeDelegator.IsValueTypeImpl()
  fullName: System.Reflection.TypeDelegator.IsValueTypeImpl()
- uid: System.Reflection.TypeDelegator.MetadataToken
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: MetadataToken
  nameWithType: TypeDelegator.MetadataToken
  fullName: System.Reflection.TypeDelegator.MetadataToken
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Reflection.TypeDelegator.Module
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Module
  nameWithType: TypeDelegator.Module
  fullName: System.Reflection.TypeDelegator.Module
- uid: System.Reflection.Module
  parent: System.Reflection
  isExternal: true
  name: Module
  nameWithType: Module
  fullName: System.Reflection.Module
- uid: System.Reflection.TypeDelegator.Name
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Name
  nameWithType: TypeDelegator.Name
  fullName: System.Reflection.TypeDelegator.Name
- uid: System.Reflection.TypeDelegator.Namespace
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Namespace
  nameWithType: TypeDelegator.Namespace
  fullName: System.Reflection.TypeDelegator.Namespace
- uid: System.Reflection.TypeDelegator.TypeHandle
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: TypeHandle
  nameWithType: TypeDelegator.TypeHandle
  fullName: System.Reflection.TypeDelegator.TypeHandle
- uid: System.RuntimeTypeHandle
  parent: System
  isExternal: true
  name: RuntimeTypeHandle
  nameWithType: RuntimeTypeHandle
  fullName: System.RuntimeTypeHandle
- uid: System.Reflection.TypeDelegator.typeImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: typeImpl
  nameWithType: TypeDelegator.typeImpl
  fullName: System.Reflection.TypeDelegator.typeImpl
- uid: System.Reflection.TypeDelegator.UnderlyingSystemType
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: UnderlyingSystemType
  nameWithType: TypeDelegator.UnderlyingSystemType
  fullName: System.Reflection.TypeDelegator.UnderlyingSystemType
- uid: System.Reflection.TypeDelegator.#ctor*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: TypeDelegator
  nameWithType: TypeDelegator.TypeDelegator
- uid: System.Reflection.TypeDelegator.Assembly*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Assembly
  nameWithType: TypeDelegator.Assembly
- uid: System.Reflection.TypeDelegator.AssemblyQualifiedName*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: AssemblyQualifiedName
  nameWithType: TypeDelegator.AssemblyQualifiedName
- uid: System.Reflection.TypeDelegator.BaseType*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: BaseType
  nameWithType: TypeDelegator.BaseType
- uid: System.Reflection.TypeDelegator.FullName*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: FullName
  nameWithType: TypeDelegator.FullName
- uid: System.Reflection.TypeDelegator.GetAttributeFlagsImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetAttributeFlagsImpl
  nameWithType: TypeDelegator.GetAttributeFlagsImpl
- uid: System.Reflection.TypeDelegator.GetConstructorImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetConstructorImpl
  nameWithType: TypeDelegator.GetConstructorImpl
- uid: System.Reflection.TypeDelegator.GetConstructors*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetConstructors
  nameWithType: TypeDelegator.GetConstructors
- uid: System.Reflection.TypeDelegator.GetCustomAttributes*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetCustomAttributes
  nameWithType: TypeDelegator.GetCustomAttributes
- uid: System.Reflection.TypeDelegator.GetElementType*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetElementType
  nameWithType: TypeDelegator.GetElementType
- uid: System.Reflection.TypeDelegator.GetEvent*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetEvent
  nameWithType: TypeDelegator.GetEvent
- uid: System.Reflection.TypeDelegator.GetEvents*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetEvents
  nameWithType: TypeDelegator.GetEvents
- uid: System.Reflection.TypeDelegator.GetField*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetField
  nameWithType: TypeDelegator.GetField
- uid: System.Reflection.TypeDelegator.GetFields*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetFields
  nameWithType: TypeDelegator.GetFields
- uid: System.Reflection.TypeDelegator.GetInterface*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterface
  nameWithType: TypeDelegator.GetInterface
- uid: System.Reflection.TypeDelegator.GetInterfaceMap*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterfaceMap
  nameWithType: TypeDelegator.GetInterfaceMap
- uid: System.Reflection.TypeDelegator.GetInterfaces*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterfaces
  nameWithType: TypeDelegator.GetInterfaces
- uid: System.Reflection.TypeDelegator.GetMember*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMember
  nameWithType: TypeDelegator.GetMember
- uid: System.Reflection.TypeDelegator.GetMembers*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMembers
  nameWithType: TypeDelegator.GetMembers
- uid: System.Reflection.TypeDelegator.GetMethodImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMethodImpl
  nameWithType: TypeDelegator.GetMethodImpl
- uid: System.Reflection.TypeDelegator.GetMethods*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMethods
  nameWithType: TypeDelegator.GetMethods
- uid: System.Reflection.TypeDelegator.GetNestedType*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetNestedType
  nameWithType: TypeDelegator.GetNestedType
- uid: System.Reflection.TypeDelegator.GetNestedTypes*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetNestedTypes
  nameWithType: TypeDelegator.GetNestedTypes
- uid: System.Reflection.TypeDelegator.GetProperties*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetProperties
  nameWithType: TypeDelegator.GetProperties
- uid: System.Reflection.TypeDelegator.GetPropertyImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetPropertyImpl
  nameWithType: TypeDelegator.GetPropertyImpl
- uid: System.Reflection.TypeDelegator.GUID*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GUID
  nameWithType: TypeDelegator.GUID
- uid: System.Reflection.TypeDelegator.HasElementTypeImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: HasElementTypeImpl
  nameWithType: TypeDelegator.HasElementTypeImpl
- uid: System.Reflection.TypeDelegator.InvokeMember*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: InvokeMember
  nameWithType: TypeDelegator.InvokeMember
- uid: System.Reflection.TypeDelegator.IsArrayImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsArrayImpl
  nameWithType: TypeDelegator.IsArrayImpl
- uid: System.Reflection.TypeDelegator.IsAssignableFrom*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsAssignableFrom
  nameWithType: TypeDelegator.IsAssignableFrom
- uid: System.Reflection.TypeDelegator.IsByRefImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsByRefImpl
  nameWithType: TypeDelegator.IsByRefImpl
- uid: System.Reflection.TypeDelegator.IsCOMObjectImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsCOMObjectImpl
  nameWithType: TypeDelegator.IsCOMObjectImpl
- uid: System.Reflection.TypeDelegator.IsConstructedGenericType*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsConstructedGenericType
  nameWithType: TypeDelegator.IsConstructedGenericType
- uid: System.Reflection.TypeDelegator.IsDefined*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsDefined
  nameWithType: TypeDelegator.IsDefined
- uid: System.Reflection.TypeDelegator.IsPointerImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsPointerImpl
  nameWithType: TypeDelegator.IsPointerImpl
- uid: System.Reflection.TypeDelegator.IsPrimitiveImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsPrimitiveImpl
  nameWithType: TypeDelegator.IsPrimitiveImpl
- uid: System.Reflection.TypeDelegator.IsValueTypeImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsValueTypeImpl
  nameWithType: TypeDelegator.IsValueTypeImpl
- uid: System.Reflection.TypeDelegator.MetadataToken*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: MetadataToken
  nameWithType: TypeDelegator.MetadataToken
- uid: System.Reflection.TypeDelegator.Module*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Module
  nameWithType: TypeDelegator.Module
- uid: System.Reflection.TypeDelegator.Name*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Name
  nameWithType: TypeDelegator.Name
- uid: System.Reflection.TypeDelegator.Namespace*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Namespace
  nameWithType: TypeDelegator.Namespace
- uid: System.Reflection.TypeDelegator.TypeHandle*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: TypeHandle
  nameWithType: TypeDelegator.TypeHandle
- uid: System.Reflection.TypeDelegator.UnderlyingSystemType*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: UnderlyingSystemType
  nameWithType: TypeDelegator.UnderlyingSystemType
