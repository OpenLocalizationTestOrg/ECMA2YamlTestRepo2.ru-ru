### YamlMime:ManagedReference
items:
- uid: System.Runtime.Remoting.RemotingServices
  id: RemotingServices
  children:
  - System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)
  - System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)
  - System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  - System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  - System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)
  - System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)
  - System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  - System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  - System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)
  - System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)
  - System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)
  - System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)
  - System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)
  - System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)
  - System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)
  - System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  - System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)
  - System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  langs:
  - csharp
  name: RemotingServices
  nameWithType: RemotingServices
  fullName: System.Runtime.Remoting.RemotingServices
  type: Class
  summary: "Предоставляет несколько методов для использования и публикации удаленных объектов и прокси. Этот класс не наследуется."
  remarks: "Только поставщика услуг, связанных с проблемами, например активации, управление временем жизни или транзакции, необязательно для различения прокси ссылки и ссылки на объект. Инфраструктура удаленного взаимодействия использует прозрачные прокси, создается впечатление, что удаленные объекты находятся в пространстве клиента. Прокси достигают этого направлением вызовов, сделанных на них реальными объектами в удаленных расположениях."
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public static class RemotingServices
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)
  id: Connect(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Connect(Type,String)
  nameWithType: RemotingServices.Connect(Type,String)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Создает прокси для хорошо известного объекта, если заданы <xref:System.Type>и URL-адрес.</xref:System.Type>"
  remarks: "Возвращаемые прокси-объекты указывают на конечную точку, обслуживаемых указанным хорошо известным объектом. Сообщения не пересылаются по сети, пока не будет вызван на прокси-сервер."
  example:
  - "The following code example demonstrates how to use the Connect method to create a proxy to a well-known object.  \n  \n [!code-cpp[RemotingServices.BasicSample#1](~/add/codesnippet/cpp/m-system.runtime.remotin_104_1.cpp)]\n [!code-cs[RemotingServices.BasicSample#1](~/add/codesnippet/csharp/m-system.runtime.remotin_104_1.cs)]\n [!code-vb[RemotingServices.BasicSample#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_104_1.vb)]"
  syntax:
    content: public static object Connect (Type classToProxy, string url);
    parameters:
    - id: classToProxy
      type: System.Type
      description: "<xref:System.Type>Известного объекта на стороне сервера, к которому необходимо подключиться.</xref:System.Type>"
    - id: url
      type: System.String
      description: "URL-адрес серверного класса."
    return:
      type: System.Object
      description: "Прокси-сервер для удаленного объекта, который указывает на конечную точку, обслуживаемых указанным хорошо известным объектом."
  overload: System.Runtime.Remoting.RemotingServices.Connect*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Непосредственный вызывающий объект не имеет разрешения на настраивать каналы и типы удаленного взаимодействия."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)
  id: Connect(System.Type,System.String,System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Connect(Type,String,Object)
  nameWithType: RemotingServices.Connect(Type,String,Object)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Создает прокси для хорошо известного объекта, если заданы <xref:System.Type>, URL-адрес и данные для указанного канала.</xref:System.Type>"
  remarks: "Возвращаемые прокси-объекты указывают на конечную точку, обслуживаемых указанным хорошо известным объектом. Сообщения не пересылаются по сети, пока не будет вызван на прокси-сервер.       `data` Объект используется для передачи сведений в канал и передается <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=fullName>метод.</xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=fullName>"
  syntax:
    content: public static object Connect (Type classToProxy, string url, object data);
    parameters:
    - id: classToProxy
      type: System.Type
      description: "<xref:System.Type>Известного объекта, к которому необходимо подключиться.</xref:System.Type>"
    - id: url
      type: System.String
      description: "URL-адрес хорошо известного объекта."
    - id: data
      type: System.Object
      description: "Данные для указанного канала. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "Прокси, который указывает на конечную точку, обслуживаемую указанным хорошо известным объектом."
  overload: System.Runtime.Remoting.RemotingServices.Connect*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Непосредственный вызывающий объект не имеет разрешения на настраивать каналы и типы удаленного взаимодействия."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)
  id: Disconnect(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Disconnect(MarshalByRefObject)
  nameWithType: RemotingServices.Disconnect(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Disconnect(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Прекращает получение дальнейших сообщений по зарегистрированным каналам удаленного доступа."
  remarks: ''
  example:
  - "The following code example demonstrates how to use the Disconnect method to disconnect an object from the remoting channels.  \n  \n [!code-cpp[RemotingServices.BasicSample#2](~/add/codesnippet/cpp/m-system.runtime.remotin_81_1.cpp)]\n [!code-cs[RemotingServices.BasicSample#2](~/add/codesnippet/csharp/m-system.runtime.remotin_81_1.cs)]\n [!code-vb[RemotingServices.BasicSample#2](~/add/codesnippet/visualbasic/m-system.runtime.remotin_81_1.vb)]"
  syntax:
    content: public static bool Disconnect (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "Объект для отключения от его канала."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если объект был отключен от зарегистрированного канала удаленного доступа успешно; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Runtime.Remoting.RemotingServices.Disconnect*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>obj</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> obj </code> Параметр является прокси."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Непосредственный вызывающий объект не имеет разрешения на настраивать каналы и типы удаленного взаимодействия."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  id: ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  nameWithType: RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  fullName: System.Runtime.Remoting.RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Подключается к указанному удаленному объекту и выполняет предоставленный <xref href=&quot;System.Runtime.Remoting.Messaging.IMethodCallMessage&quot;> </xref> на нем."
  remarks: "Текущий метод используется в особых случаях сервером для перенаправления вызова указанного метода другой, возможно удаленный объект. Этот метод может вызываться только в том случае, если вызывающий объект находится в соответствующем контексте."
  example:
  - "The following code example demonstrates how to use the ExecuteMessage method to forward method calls to remote objects.  \n  \n [!code-cs[RemotingServices.ExecuteMessage#1](~/add/codesnippet/csharp/491f5c62-582d-42d8-b526-_1.cs)]\n [!code-cpp[RemotingServices.ExecuteMessage#1](~/add/codesnippet/cpp/491f5c62-582d-42d8-b526-_1.cpp)]\n [!code-vb[RemotingServices.ExecuteMessage#1](~/add/codesnippet/visualbasic/491f5c62-582d-42d8-b526-_1.vb)]"
  syntax:
    content: public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);
    parameters:
    - id: target
      type: System.MarshalByRefObject
      description: "Удаленный объект, метод которого необходимо вызвать."
    - id: reqMsg
      type: System.Runtime.Remoting.Messaging.IMethodCallMessage
      description: "Метод сообщения вызова метода указанного удаленного объекта."
    return:
      type: System.Runtime.Remoting.Messaging.IMethodReturnMessage
      description: "Ответ удаленного метода."
  overload: System.Runtime.Remoting.RemotingServices.ExecuteMessage*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Непосредственный вызывающий объект не имеет разрешения инфраструктуры."
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "Метод был вызван из контекста, отличного от собственного контекста объекта."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)
  id: GetEnvoyChainForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetEnvoyChainForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Возвращает цепочку приемников делегата, которые должны использоваться при отправке сообщений на удаленный объект, представленный указанным прокси."
  remarks: "Приемников делегата, передаются по <xref:System.Runtime.Remoting.ObjRef>объекта, который используется при возвращении сообщений на этот объект.</xref:System.Runtime.Remoting.ObjRef> Текущий метод возвращает приемники делегатов, которые используются при обмене сообщениями между прокси-объекта и сам объект."
  syntax:
    content: public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "Прокси-сервер удаленного объекта, который запросил приемников делегата, связанный с."
    return:
      type: System.Runtime.Remoting.Messaging.IMessageSink
      description: "Цепочка приемников делегата, связанных с указанным прокси."
  overload: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Непосредственный вызывающий объект не имеет разрешения инфраструктуры."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)
  id: GetLifetimeService(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetLifetimeService(MarshalByRefObject)
  nameWithType: RemotingServices.GetLifetimeService(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetLifetimeService(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Возвращает объект службы времени существования, который управляет политикой времени существования указанного объекта."
  remarks: "Значение по умолчанию служба времени жизни возвращаемый объект будет объект типа <xref:System.Runtime.Remoting.Lifetime.ILease>.</xref:System.Runtime.Remoting.Lifetime.ILease> Если `obj` параметр `null`, метод возвращает `null`."
  example:
  - "The following code example demonstrates how to use the GetLifetimeService method to get a lifetime lease for the specified object.  \n  \n [!code-cpp[RemotingServices.TimerSample#1](~/add/codesnippet/cpp/a7d2891c-3dad-448c-949c-_1.cpp)]\n [!code-cs[RemotingServices.TimerSample#1](~/add/codesnippet/csharp/a7d2891c-3dad-448c-949c-_1.cs)]\n [!code-vb[RemotingServices.TimerSample#1](~/add/codesnippet/visualbasic/a7d2891c-3dad-448c-949c-_1.vb)]  \n  \n To compile and run this example, you will need to compile and run a server, timerserver.exe, and compile a shared library, timerservice.dll.  \n  \n The source for timerserver.exe follows:  \n  \n [!code-vb[RemotingServices.TimerSample#2](~/add/codesnippet/visualbasic/a7d2891c-3dad-448c-949c-_2.vb)]\n [!code-cs[RemotingServices.TimerSample#2](~/add/codesnippet/csharp/a7d2891c-3dad-448c-949c-_2.cs)]  \n  \n The source for timerservice.dll follows:  \n  \n [!code-vb[RemotingServices.TimerSample#3](~/add/codesnippet/visualbasic/a7d2891c-3dad-448c-949c-_3.vb)]\n [!code-cs[RemotingServices.TimerSample#3](~/add/codesnippet/csharp/a7d2891c-3dad-448c-949c-_3.cs)]"
  syntax:
    content: public static object GetLifetimeService (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "Объекта, чтобы получить время жизни службы."
    return:
      type: System.Object
      description: "Объект, который управляет временем существования <code> obj </code>."
  overload: System.Runtime.Remoting.RemotingServices.GetLifetimeService*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Непосредственный вызывающий объект не имеет разрешения инфраструктуры."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  id: GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetMethodBaseFromMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Возвращает метод базового из заданного <xref href=&quot;System.Runtime.Remoting.Messaging.IMethodMessage&quot;> </xref>."
  remarks: "Определяет метод из базового <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>, <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>, и <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A>Свойства <xref:System.Runtime.Remoting.Messaging.IMethodMessage>и используемые классы, реализующие <xref:System.Runtime.Remoting.Messaging.IMethodMessage>интерфейса.</xref:System.Runtime.Remoting.Messaging.IMethodMessage> </xref:System.Runtime.Remoting.Messaging.IMethodMessage> </xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> </xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A> </xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A> Потребители <xref:System.Runtime.Remoting.Messaging.IMethodMessage>классы должны ссылаться <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=fullName>свойство.</xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=fullName> </xref:System.Runtime.Remoting.Messaging.IMethodMessage>"
  syntax:
    content: public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMethodMessage
      description: "Сообщение, метод для извлечения из базового метода."
    return:
      type: System.Reflection.MethodBase
      description: "Базовый метод извлеченных из <code> msg </code> параметра."
  overload: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Непосредственный вызывающий объект не имеет разрешения инфраструктуры, или по крайней мере один из вызывающим объектам выше в стеке вызовов не имеет разрешения на получение информации о закрытых членов типе."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetObjectData(Object,SerializationInfo,StreamingContext)
  nameWithType: RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Сериализует указанный маршалинг по ссылке в указанных <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>."
  syntax:
    content: public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: obj
      type: System.Object
      description: "Объект для сериализации."
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> , В который сериализуется объект."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "Источник и назначение сериализации."
  overload: System.Runtime.Remoting.RemotingServices.GetObjectData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>obj</code> or <code>info</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Непосредственный вызывающий объект не имеет разрешения инфраструктуры."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)
  id: GetObjectUri(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetObjectUri(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjectUri(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectUri(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Возвращает URI для указанного объекта."
  remarks: ''
  example:
  - >-
    [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/add/codesnippet/visualbasic/318892c3-7b62-40bd-9e3b-_1.vb)]
     [!code-cs[System.Runtime.Remoting.RemotingServices#18](~/add/codesnippet/csharp/318892c3-7b62-40bd-9e3b-_1.cs)]
     [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/add/codesnippet/cpp/318892c3-7b62-40bd-9e3b-_1.cpp)]
  syntax:
    content: public static string GetObjectUri (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "<xref href=&quot;System.MarshalByRefObject&quot;> </xref> Для которого запрашивается URI."
    return:
      type: System.String
      description: "URI указанного объекта, если оно имеется, или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> , если объект не был упакован."
  overload: System.Runtime.Remoting.RemotingServices.GetObjectUri*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Непосредственный вызывающий объект не имеет разрешения инфраструктуры."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)
  id: GetObjRefForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetObjRefForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjRefForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Возвращает <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> , представляющий удаленный объект из указанного прокси-сервера."
  remarks: "Объект <xref:System.Runtime.Remoting.ObjRef>является упорядоченным представлением объекта, используемого для передачи ссылки на объект через границы домена приложения.</xref:System.Runtime.Remoting.ObjRef> Создание <xref:System.Runtime.Remoting.ObjRef>для объекта известно как маршалирование.</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>Могут передаваться по каналу в другой домен приложения (возможно в другой процесс или компьютер).</xref:System.Runtime.Remoting.ObjRef> Один раз в другом домене приложения <xref:System.Runtime.Remoting.ObjRef>необходимо проанализировать для создания прокси для объекта, обычно подключенного к реальному объекту.</xref:System.Runtime.Remoting.ObjRef> Эта операция известна как распаковка. Во время Распаковка, <xref:System.Runtime.Remoting.ObjRef>анализируется для получения сведений о методе удаленного объекта и прозрачного прокси и <xref:System.Runtime.Remoting.Proxies.RealProxy>создаются объекты.</xref:System.Runtime.Remoting.Proxies.RealProxy> </xref:System.Runtime.Remoting.ObjRef>       Объект <xref:System.Runtime.Remoting.ObjRef>содержит сведения, описывающие <xref:System.Type>и класс объекта, URI, однозначно определяющий экземпляр указанного объекта и обмен данными сведения о том, как к удаленного приложения, где находится объект.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>"
  example:
  - "The following code example demonstrates how to get a <xref:System.Runtime.Remoting.ObjRef> instance for the specified object.  \n  \n [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/add/codesnippet/cpp/d6ce9a9a-8ec9-4559-9b2d-_1.cpp)]\n [!code-vb[RemotingServices.GetObjRefForProxy#1](~/add/codesnippet/visualbasic/d6ce9a9a-8ec9-4559-9b2d-_1.vb)]\n [!code-cs[RemotingServices.GetObjRefForProxy#1](~/add/codesnippet/csharp/d6ce9a9a-8ec9-4559-9b2d-_1.cs)]"
  syntax:
    content: public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "Прокси, подключенный к объекту, который вы хотите создать <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> для."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "Объект <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> , представляющий удаленный объект, указанный прокси-сервер подключен, или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если объект или прокси-сервера не был передан."
  overload: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Непосредственный вызывающий объект не имеет разрешения инфраструктуры."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)
  id: GetRealProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetRealProxy(Object)
  nameWithType: RemotingServices.GetRealProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.GetRealProxy(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Возвращает настоящий прокси, поддерживающий указанный прозрачный прокси."
  remarks: "Клиент, использующий объект через любые границы удаленного взаимодействия использует прозрачный прокси для объекта. Прозрачный прокси создает впечатление, что фактический объект находится в пространстве клиента. Это достигается с помощью пересылки вызовов реальному объекту, используя инфраструктуру удаленного взаимодействия.       Прозрачный прокси поддерживаемый экземпляр управляемого класса среды выполнения типа <xref:System.Runtime.Remoting.Proxies.RealProxy>.</xref:System.Runtime.Remoting.Proxies.RealProxy> <xref:System.Runtime.Remoting.Proxies.RealProxy>Реализует часть функциональных возможностей, необходимых для направления операций из прозрачного прокси.</xref:System.Runtime.Remoting.Proxies.RealProxy>       Прокси-объект наследует связанную семантику управляемых объектов, такие как сборка мусора, поддержка члены и методы и может быть расширен для создания новых классов. Прокси-сервер выступает в качестве объекта того же класса, что и удаленный объект (прозрачный прокси), а также является управляемым объектом."
  syntax:
    content: public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);
    parameters:
    - id: proxy
      type: System.Object
      description: "Прозрачный прокси."
    return:
      type: System.Runtime.Remoting.Proxies.RealProxy
      description: "Экземпляр реального посредника резервирования прозрачного прокси."
  overload: System.Runtime.Remoting.RemotingServices.GetRealProxy*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Непосредственный вызывающий объект не имеет разрешения инфраструктуры."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)
  id: GetServerTypeForUri(System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetServerTypeForUri(String)
  nameWithType: RemotingServices.GetServerTypeForUri(String)
  fullName: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Возвращает <xref:System.Type>объекта с указанным URI.</xref:System.Type>"
  remarks: "Поскольку удаленное взаимодействие определяет идентификаторы URI конечных точек, метод GetServerTypeForUri очень полезно в подключаемых элементах инфраструктуры удаленного взаимодействия (например, приемники, динамических и контекстных приемниках), использующих <xref:System.Runtime.Remoting.Messaging.IMessage>объектов, так как текущий метод вернет объект связанный тип из URI.</xref:System.Runtime.Remoting.Messaging.IMessage>"
  example:
  - >-
    [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/add/codesnippet/visualbasic/m-system.runtime.remotin_84_1.vb)]
     [!code-cs[System.Runtime.Remoting.RemotingServices#7](~/add/codesnippet/csharp/m-system.runtime.remotin_84_1.cs)]
     [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/add/codesnippet/cpp/m-system.runtime.remotin_84_1.cpp)]
  syntax:
    content: public static Type GetServerTypeForUri (string URI);
    parameters:
    - id: URI
      type: System.String
      description: "URI объекта которого <xref:System.Type>запрашивается.</xref:System.Type>"
    return:
      type: System.Type
      description: "<xref:System.Type>Объекта с указанным URI.</xref:System.Type>"
  overload: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Непосредственный вызывающий объект не имеет разрешения инфраструктуры, или по крайней мере один из вызывающим объектам выше в стеке вызовов не имеет разрешения на получение информации о закрытых членов типе."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  id: GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetSessionIdForMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Получает идентификатор сеанса сообщения."
  remarks: "Для объектов в одном приложении может возвращаться один и тот же идентификатор сеанса, но этот метод никогда не будут возвращать один и тот же идентификатор сеанса для двух объектов из разных удаленных приложений.       Дополнительные сведения об определении сеансов и их идентификаторов см. в разделе ASP.Net [Общие сведения о состоянии сеанса ASP.NET](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to get the session ID string for the current session.  \n  \n [!code-cs[RemotingServices.ExecuteMessage#1](~/add/codesnippet/csharp/b83444fc-48c3-47e9-b264-_1.cs)]\n [!code-cpp[RemotingServices.ExecuteMessage#1](~/add/codesnippet/cpp/b83444fc-48c3-47e9-b264-_1.cpp)]\n [!code-vb[RemotingServices.ExecuteMessage#1](~/add/codesnippet/visualbasic/b83444fc-48c3-47e9-b264-_1.vb)]"
  syntax:
    content: public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMethodMessage
      description: "<xref href=&quot;System.Runtime.Remoting.Messaging.IMethodMessage&quot;> </xref> Для которого запрашивается идентификатор сеанса."
    return:
      type: System.String
      description: "Строка идентификатора сеанса, однозначно определяющее в текущем сеансе."
  overload: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Непосредственный вызывающий объект не имеет разрешения инфраструктуры."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  id: IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsMethodOverloaded(IMethodMessage)
  nameWithType: RemotingServices.IsMethodOverloaded(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(IMethodMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Возвращает логическое значение, указывающее, перегружен ли метод в данном сообщении."
  syntax:
    content: public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMethodMessage
      description: "Сообщение, которое содержит вызов метода в вопросе."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если метод, вызываемый в <code> msg </code> перегруженных; в противном случае — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Непосредственный вызывающий объект не имеет разрешения инфраструктуры."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)
  id: IsObjectOutOfAppDomain(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsObjectOutOfAppDomain(Object)
  nameWithType: RemotingServices.IsObjectOutOfAppDomain(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Возвращает логическое значение, указывающее, содержится ли указанный объект данным прозрачного прокси в другом домене приложения от объекта, который вызвал текущий метод."
  remarks: "Сведения о доменах приложений см. в разделе [домены приложений](http://msdn.microsoft.com/en-us/39e57d07-a740-4cd4-ae82-e119ea3856c1)."
  example:
  - >-
    [!code-cpp[RemotingServices IsObject Snippets#1](~/add/codesnippet/cpp/m-system.runtime.remotin_103_1.cpp)]
     [!code-vb[RemotingServices IsObject Snippets#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_103_1.vb)]
     [!code-cs[RemotingServices IsObject Snippets#1](~/add/codesnippet/csharp/m-system.runtime.remotin_103_1.cs)]
  syntax:
    content: public static bool IsObjectOutOfAppDomain (object tp);
    parameters:
    - id: tp
      type: System.Object
      description: "Проверяемый объект."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если объект не находится в текущем домене приложения; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)
  id: IsObjectOutOfContext(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsObjectOutOfContext(Object)
  nameWithType: RemotingServices.IsObjectOutOfContext(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Возвращает логическое значение, указывающее, содержится ли объект, представленный данным прокси в контексте, отличном от объекта, который вызвал текущий метод."
  remarks: "Контекст — это упорядоченный набор свойств, которые определяют среду для объектов, находящихся внутри него. Контексты создаются во время процесса активации для объектов, которым требуются определенные автоматические службы такой синхронизации, транзакции, в момент активации, безопасности и т. д. Внутри контекста возможно существование нескольких объектов."
  example:
  - >-
    [!code-cpp[RemotingServices IsObject Snippets#1](~/add/codesnippet/cpp/m-system.runtime.remotin_37_1.cpp)]
     [!code-vb[RemotingServices IsObject Snippets#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_37_1.vb)]
     [!code-cs[RemotingServices IsObject Snippets#1](~/add/codesnippet/csharp/m-system.runtime.remotin_37_1.cs)]
  syntax:
    content: public static bool IsObjectOutOfContext (object tp);
    parameters:
    - id: tp
      type: System.Object
      description: "Проверяемый объект."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если объект не находится в текущем контексте; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)
  id: IsOneWay(System.Reflection.MethodBase)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsOneWay(MethodBase)
  nameWithType: RemotingServices.IsOneWay(MethodBase)
  fullName: System.Runtime.Remoting.RemotingServices.IsOneWay(MethodBase)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Возвращает логическое значение, указывающее, ожидает ли клиент, вызывающий метод указан в данного сообщения сервер, чтобы завершить обработку до продолжения выполнения метода."
  remarks: "При вызове одностороннего метода, клиент не ожидает окончания обработки сообщения. Метод клиент возвращает в приложение, не имея сведений из того, является ли сервер успешно обработать сообщение. Методы отмечаются как один из способов с помощью <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>.</xref:System.Runtime.Remoting.Messaging.OneWayAttribute>       Односторонние методы не могут иметь возвращаемое значение или выходные параметры."
  example:
  - >-
    [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/add/codesnippet/visualbasic/e9c4a9fc-d92a-4e43-97a5-_1.vb)]
     [!code-cs[System.Runtime.Remoting.RemotingServices#2](~/add/codesnippet/csharp/e9c4a9fc-d92a-4e43-97a5-_1.cs)]
     [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/add/codesnippet/cpp/e9c4a9fc-d92a-4e43-97a5-_1.cpp)]
  syntax:
    content: public static bool IsOneWay (System.Reflection.MethodBase method);
    parameters:
    - id: method
      type: System.Reflection.MethodBase
      description: "Метод в вопросе."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если метод является одним из способов; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Runtime.Remoting.RemotingServices.IsOneWay*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Непосредственный вызывающий объект не имеет разрешения инфраструктуры."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)
  id: IsTransparentProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsTransparentProxy(Object)
  nameWithType: RemotingServices.IsTransparentProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Возвращает логическое значение, указывающее, является ли данный объект прозрачным прокси или настоящим объектом."
  remarks: "Клиент, использующий объект через любые границы удаленного взаимодействия использует прозрачный прокси для объекта. Прозрачный прокси создает впечатление, что фактический объект находится в пространстве клиента. Это достигается с помощью пересылки вызовов реальному объекту, используя инфраструктуру удаленного взаимодействия.       Сам по себе размещается экземпляром управляемого класса среды выполнения типа <xref:System.Runtime.Remoting.Proxies.RealProxy>.</xref:System.Runtime.Remoting.Proxies.RealProxy> является прозрачным прокси-сервера <xref:System.Runtime.Remoting.Proxies.RealProxy>Реализует часть функциональных возможностей, необходимых для направления операций из прозрачного прокси.</xref:System.Runtime.Remoting.Proxies.RealProxy> Прокси-объект наследует связанную семантику управляемых объектов, такие как сборка мусора, поддержка члены и методы и может быть расширен для создания новых классов. Таким образом, прокси-сервер имеет два представления; с одной стороны, он должен работать в качестве объекта того же класса, что и удаленный объект (прозрачный прокси), а на другом является управляемым объектом.       Можно использовать прокси-объекта без учета любым удаленным подразделениям в <xref:System.AppDomain>.</xref:System.AppDomain> Приложения не должны отличать между прокси-сервера ссылки и ссылки на объект. Тем не менее, поставщики служб, работающие с проблемами, например активации, управление временем жизни и транзакции, должны различать таких их."
  example:
  - "The following code example demonstrates the use of the IsTransparentProxy method to determine whether an object is a proxy or a real object. For the complete example code, see the example for the <xref:System.Runtime.Remoting.Messaging.AsyncResult> class.  \n  \n [!code-cpp[AsyncResult.NewExamples#6](~/add/codesnippet/cpp/m-system.runtime.remotin_47_1.cpp)]\n [!code-vb[AsyncResult.NewExamples#6](~/add/codesnippet/visualbasic/m-system.runtime.remotin_47_1.vb)]\n [!code-cs[AsyncResult.NewExamples#6](~/add/codesnippet/csharp/m-system.runtime.remotin_47_1.cs)]"
  syntax:
    content: public static bool IsTransparentProxy (object proxy);
    parameters:
    - id: proxy
      type: System.Object
      description: "Ссылка на объект для проверки."
    return:
      type: System.Boolean
      description: "Логическое значение, указывающее, является ли объект, указанный в <code> proxy </code> параметр является прозрачным прокси или реальному объекту."
  overload: System.Runtime.Remoting.RemotingServices.IsTransparentProxy*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)
  id: LogRemotingStage(System.Int32)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: LogRemotingStage(Int32)
  nameWithType: RemotingServices.LogRemotingStage(Int32)
  fullName: System.Runtime.Remoting.RemotingServices.LogRemotingStage(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Регистрирует этап удаленного обмена во внешнем отладчике."
  remarks: "Объект `&quot;REMOTING_PERF&quot;` символа предварительной обработки применяется к методу с помощью <xref:System.Diagnostics.ConditionalAttribute>атрибут.</xref:System.Diagnostics.ConditionalAttribute>"
  syntax:
    content: public static void LogRemotingStage (int stage);
    parameters:
    - id: stage
      type: System.Int32
      description: "Определенная внутри константа, определяющая этап удаленного обмена."
  overload: System.Runtime.Remoting.RemotingServices.LogRemotingStage*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)
  id: Marshal(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Marshal(MarshalByRefObject)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Принимает <xref href=&quot;System.MarshalByRefObject&quot;> </xref>, регистрирует его с инфраструктурой удаленного взаимодействия и преобразует его в экземпляр <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> класса."
  remarks: "Объект <xref:System.Runtime.Remoting.ObjRef>является упорядоченным представлением объекта, используемого для передачи ссылки на объект через границы домена приложения.</xref:System.Runtime.Remoting.ObjRef> Создание <xref:System.Runtime.Remoting.ObjRef>для объекта известно как маршалирование.</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>Могут передаваться по каналу в другой домен приложения (возможно в другой процесс или компьютер).</xref:System.Runtime.Remoting.ObjRef> Один раз в другом домене приложения <xref:System.Runtime.Remoting.ObjRef>необходимо проанализировать для создания прокси для объекта, обычно подключенного к реальному объекту.</xref:System.Runtime.Remoting.ObjRef> Эта операция известна как распаковка.       Объект <xref:System.Runtime.Remoting.ObjRef>содержит сведения, описывающие <xref:System.Type>и класс объекта, URI, однозначно определяющий экземпляр указанного объекта и обмен данными сведения о подключении к подразделению удаленного взаимодействия, где находится объект.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       Во время маршалинга, контекст, из текущего потока, а не контекст, который был активен при создании объекта. Если URI не было задано явно <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A>метод, автоматически создаваемых субъектом инфраструктуры удаленного доступа.</xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A>       Нельзя связать URI с прокси по одной из двух причин: URI был создан на стороне сервера для объекта, он представляет, или объект хорошо известен, в этом случае известен URI. По этой причине если `Obj` параметр представляет учетную запись-посредник, будет вызвано исключение. Для пользовательских прокси это ограничение смягчается, поскольку прозрачный прокси обрабатывается как объект сервера."
  syntax:
    content: public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);
    parameters:
    - id: Obj
      type: System.MarshalByRefObject
      description: "Преобразуемый объект."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "Экземпляр <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> класс, представляющий объект, указанный в <code> Obj </code> параметра."
  overload: System.Runtime.Remoting.RemotingServices.Marshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code> Obj </code> Параметр прокси-сервер объекта."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "По крайней мере один из вызывающим объектам выше в стеке вызовов не имеет разрешения для настраивать каналы и типы удаленного взаимодействия."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)
  id: Marshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Marshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Преобразует данный <xref href=&quot;System.MarshalByRefObject&quot;> </xref> в экземпляр <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> класса с заданным URI."
  remarks: "Объект <xref:System.Runtime.Remoting.ObjRef>является упорядоченным представлением объекта, используемого для передачи ссылки на объект через границы домена приложения.</xref:System.Runtime.Remoting.ObjRef> Создание <xref:System.Runtime.Remoting.ObjRef>для объекта известно как маршалирование.</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>Могут передаваться по каналу в другой домен приложения (возможно в другой процесс или компьютер).</xref:System.Runtime.Remoting.ObjRef> Один раз в другом домене приложения <xref:System.Runtime.Remoting.ObjRef>необходимо проанализировать для создания прокси для объекта, обычно подключенного к реальному объекту.</xref:System.Runtime.Remoting.ObjRef> Эта операция известна как распаковка.       Объект <xref:System.Runtime.Remoting.ObjRef>содержит сведения, описывающие <xref:System.Type>и класс объекта, URI, однозначно определяющий экземпляр указанного объекта и обмен данными сведения о подключении к подразделению удаленного взаимодействия, где находится объект.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       Во время маршалинга, контекст, из текущего потока, а не контекст, который был активен при создании объекта.       Нельзя связать URI с прокси по одной из двух причин: URI был создан на стороне сервера для объекта, он представляет, или объект хорошо известен, в этом случае известен URI. По этой причине если `Obj` параметр представляет учетную запись-посредник, будет вызвано исключение. Для пользовательских прокси это ограничение смягчается, поскольку прозрачный прокси обрабатывается как объект сервера."
  example:
  - "The following code example demonstrates how to use the current <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> method to marshal a specified object.  \n  \n [!code-cpp[RemotingServices.BasicSample#2](~/add/codesnippet/cpp/01236a8e-f8c3-4b7b-875d-_1.cpp)]\n [!code-cs[RemotingServices.BasicSample#2](~/add/codesnippet/csharp/01236a8e-f8c3-4b7b-875d-_1.cs)]\n [!code-vb[RemotingServices.BasicSample#2](~/add/codesnippet/visualbasic/01236a8e-f8c3-4b7b-875d-_1.vb)]"
  syntax:
    content: public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);
    parameters:
    - id: Obj
      type: System.MarshalByRefObject
      description: "Преобразуемый объект."
    - id: URI
      type: System.String
      description: "Указанный URI, с которого требуется инициализировать новый <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "Экземпляр <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> класс, представляющий объект, указанный в <code> Obj </code> параметра."
  overload: System.Runtime.Remoting.RemotingServices.Marshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code>Obj</code>прокси-сервер объекта и <code>URI</code> не <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "По крайней мере один из вызывающим объектам выше в стеке вызовов не имеет разрешения для настраивать каналы и типы удаленного взаимодействия."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)
  id: Marshal(System.MarshalByRefObject,System.String,System.Type)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Marshal(MarshalByRefObject,String,Type)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String,Type)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String,Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Принимает <xref href=&quot;System.MarshalByRefObject&quot;> </xref> и преобразует его в экземпляр <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> класса с указанным URI и указанного <xref:System.Type>.</xref:System.Type>"
  remarks: "Объект <xref:System.Runtime.Remoting.ObjRef>является упорядоченным представлением объекта, используемого для передачи ссылки на объект через границы домена приложения.</xref:System.Runtime.Remoting.ObjRef> Создание <xref:System.Runtime.Remoting.ObjRef>для объекта известно как маршалирование.</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>Могут передаваться по каналу в другой домен приложения (возможно в другой процесс или компьютер).</xref:System.Runtime.Remoting.ObjRef> Один раз в другом домене приложения <xref:System.Runtime.Remoting.ObjRef>необходимо проанализировать для создания прокси для объекта, обычно подключенного к реальному объекту.</xref:System.Runtime.Remoting.ObjRef> Эта операция известна как распаковка.       Объект <xref:System.Runtime.Remoting.ObjRef>содержит сведения, описывающие <xref:System.Type>и класс объекта, URI, однозначно определяющий экземпляр указанного объекта и обмен данными сведения о подключении к подразделению удаленного взаимодействия, где находится объект.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       Указанный <xref:System.Type>используется инфраструктурой удаленного взаимодействия, чтобы ограничить область выведенного типа.</xref:System.Type> Например если объект A является производным от объекта B, который является производным от объекта C, и вызывается <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A>, затем клиент может создать прокси между C и B, но не A.       Во время маршалинга, используется контекст, из текущего потока, не контекст, который был активен при создании объекта.</xref:System.Runtime.Remoting.RemotingServices.Marshal%2A>       Нельзя связать URI с прокси по одной из двух причин: URI был создан на стороне сервера для объекта, он представляет, или объект хорошо известен, в этом случае известен URI. По этой причине если `Obj` параметр представляет учетную запись-посредник, будет вызвано исключение. Для пользовательских прокси это ограничение смягчается, поскольку прозрачный прокси обрабатывается как объект сервера."
  syntax:
    content: public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);
    parameters:
    - id: Obj
      type: System.MarshalByRefObject
      description: "Объект, преобразуемый в <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>."
    - id: ObjURI
      type: System.String
      description: "Объект, указанный в URI `Obj` параметр маршалируется с. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    - id: RequestedType
      type: System.Type
      description: "<xref:System.Type> `Obj` Маршалируется как.</xref:System.Type> Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "Экземпляр <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> класс, представляющий объект, указанный в <code> Obj </code> параметра."
  overload: System.Runtime.Remoting.RemotingServices.Marshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code>Obj</code>является прокси удаленного объекта и <code>ObjUri</code> не <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "По крайней мере один из вызывающим объектам выше в стеке вызовов не имеет разрешения для настраивать каналы и типы удаленного взаимодействия."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  id: SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: SetObjectUriForMarshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Задает URI для последующего вызова <xref:System.Runtime.Remoting.RemotingServices.Marshal*>метод.</xref:System.Runtime.Remoting.RemotingServices.Marshal*>"
  remarks: "The URI set by the current method is used when marshaling the given object.  \n  \n After marshaling, the URI of the specified object is set to the string in the `uri` parameter appended onto the <xref:System.Guid> of the current <xref:System.AppDomain>.  \n  \n If the current application is listening on an HTTP port, then both the string specified in the `uri` parameter and the `uri` string appended onto the <xref:System.Guid> of the current <xref:System.AppDomain> route to the specified object. For example, if the application is listening on HTTP port 9000, then both http://localhost:9000/objectUri, and http://localhost:9000/\\<appdomainguid>/objectUri route to the object specified in the `obj` parameter."
  example:
  - "The following code example demonstrates how to set the URI that will be used by the <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> method when marshaling the specified object.  \n  \n [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/add/codesnippet/cpp/2ed6d271-806d-4778-95aa-_1.cpp)]\n [!code-cs[RemotingServices.SetObjectUriForMarshal#1](~/add/codesnippet/csharp/2ed6d271-806d-4778-95aa-_1.cs)]\n [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/add/codesnippet/visualbasic/2ed6d271-806d-4778-95aa-_1.vb)]"
  syntax:
    content: public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "Элемент, который задается URI."
    - id: uri
      type: System.String
      description: "URI для назначения в указанный объект."
  overload: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code>obj</code>— локальный объект, уже был маршалирован или уже был вызван на текущий метод."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "По крайней мере один из вызывающим объектам выше в стеке вызовов не имеет разрешения для настраивать каналы и типы удаленного взаимодействия."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)
  id: Unmarshal(System.Runtime.Remoting.ObjRef)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Unmarshal(ObjRef)
  nameWithType: RemotingServices.Unmarshal(ObjRef)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Принимает <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> и создает прокси-объект от него."
  remarks: "Объект <xref:System.Runtime.Remoting.ObjRef>является упорядоченным представлением объекта, используемого для передачи ссылки на объект через границы домена приложения.</xref:System.Runtime.Remoting.ObjRef> Создание <xref:System.Runtime.Remoting.ObjRef>для объекта известно как маршалирование.</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>Могут передаваться по каналу в другой домен приложения (возможно в другой процесс или компьютер).</xref:System.Runtime.Remoting.ObjRef> Один раз в другом домене приложения <xref:System.Runtime.Remoting.ObjRef>необходимо проанализировать для создания прокси для объекта, обычно подключенного к реальному объекту.</xref:System.Runtime.Remoting.ObjRef> Эта операция известна как распаковка. Во время Распаковка, <xref:System.Runtime.Remoting.ObjRef>анализируется для получения сведений о методе удаленного объекта и прозрачного прокси и <xref:System.Runtime.Remoting.Proxies.RealProxy>создаются объекты.</xref:System.Runtime.Remoting.Proxies.RealProxy> </xref:System.Runtime.Remoting.ObjRef> Содержимое проанализированный <xref:System.Runtime.Remoting.ObjRef>добавляется прозрачный прокси-сервера до регистрации прозрачного прокси общеязыковая среда выполнения.</xref:System.Runtime.Remoting.ObjRef>       Объект <xref:System.Runtime.Remoting.ObjRef>содержит сведения, описывающие <xref:System.Type>и класс объекта, URI, однозначно определяющий экземпляр указанного объекта и обмен данными сведения о подключении к подразделению удаленного взаимодействия, где находится объект.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>"
  example:
  - "The following code example demonstrates how to unmarshal an object.  \n  \n [!code-vb[RemotingServices.Unmarshal#2](~/add/codesnippet/visualbasic/b4be8871-533a-4641-8763-_1.vb)]\n [!code-cpp[RemotingServices.Unmarshal#2](~/add/codesnippet/cpp/b4be8871-533a-4641-8763-_1.cpp)]\n [!code-cs[RemotingServices.Unmarshal#2](~/add/codesnippet/csharp/b4be8871-533a-4641-8763-_1.cs)]"
  syntax:
    content: public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);
    parameters:
    - id: objectRef
      type: System.Runtime.Remoting.ObjRef
      description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> , Представляющий удаленного объекта, для которого создается прокси-сервер."
    return:
      type: System.Object
      description: "Прокси-объекта, заданного <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> представляет."
  overload: System.Runtime.Remoting.RemotingServices.Unmarshal*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> Экземпляра, указанного в <code> objectRef </code> параметр не является правильным."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "По крайней мере один из вызывающим объектам выше в стеке вызовов не имеет разрешения для настраивать каналы и типы удаленного взаимодействия."
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  id: Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Unmarshal(ObjRef,Boolean)
  nameWithType: RemotingServices.Unmarshal(ObjRef,Boolean)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "Принимает <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> и создает прокси-объект от него, подгоняя его тип на сервере."
  remarks: "Объект <xref:System.Runtime.Remoting.ObjRef>является упорядоченным представлением объекта, используемого для передачи ссылки на объект через границы домена приложения.</xref:System.Runtime.Remoting.ObjRef> Создание <xref:System.Runtime.Remoting.ObjRef>для объекта известно как маршалирование.</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>Могут передаваться по каналу в другой домен приложения (возможно в другой процесс или компьютер).</xref:System.Runtime.Remoting.ObjRef> Один раз в другом домене приложения <xref:System.Runtime.Remoting.ObjRef>необходимо проанализировать для создания прокси для объекта, обычно подключенного к реальному объекту.</xref:System.Runtime.Remoting.ObjRef> Эта операция известна как распаковка. Во время Распаковка, <xref:System.Runtime.Remoting.ObjRef>анализируется для получения сведений о методе удаленного объекта и прозрачного прокси и <xref:System.Runtime.Remoting.Proxies.RealProxy>создаются объекты.</xref:System.Runtime.Remoting.Proxies.RealProxy> </xref:System.Runtime.Remoting.ObjRef> Содержимое проанализированный <xref:System.Runtime.Remoting.ObjRef>добавляется прозрачный прокси-сервера до регистрации прозрачного прокси общеязыковая среда выполнения.</xref:System.Runtime.Remoting.ObjRef>       Объект <xref:System.Runtime.Remoting.ObjRef>содержит сведения, описывающие <xref:System.Type>и класс объекта, URI, однозначно определяющий экземпляр указанного объекта и обмен данными сведения о подключении к подразделению удаленного взаимодействия, где находится объект.</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       При первом создании прокси-сервер имеет тип <xref:System.MarshalByRefObject>.</xref:System.MarshalByRefObject> Как привести его в различные типы инфраструктуры удаленного взаимодействия сохраняет сведения о наиболее часто используемыми типами, чтобы избежать ненужного загрузки типа."
  syntax:
    content: public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);
    parameters:
    - id: objectRef
      type: System.Runtime.Remoting.ObjRef
      description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> , Представляющий удаленного объекта, для которого создается прокси-сервер."
    - id: fRefine
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы уточнить прокси для типа сервера. в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Object
      description: "Прокси-объекта, заданного <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> представляет."
  overload: System.Runtime.Remoting.RemotingServices.Unmarshal*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> Экземпляра, указанного в <code> objectRef </code> параметр не является правильным."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "По крайней мере один из вызывающим объектам выше в стеке вызовов не имеет разрешения для настраивать каналы и типы удаленного взаимодействия."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Runtime.Remoting.RemotingException
  parent: System.Runtime.Remoting
  isExternal: false
  name: RemotingException
  nameWithType: RemotingException
  fullName: System.Runtime.Remoting.RemotingException
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Connect(Type,String)
  nameWithType: RemotingServices.Connect(Type,String)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Connect(Type,String,Object)
  nameWithType: RemotingServices.Connect(Type,String,Object)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String,Object)
- uid: System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Disconnect(MarshalByRefObject)
  nameWithType: RemotingServices.Disconnect(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Disconnect(MarshalByRefObject)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.MarshalByRefObject
  parent: System
  isExternal: false
  name: MarshalByRefObject
  nameWithType: MarshalByRefObject
  fullName: System.MarshalByRefObject
- uid: System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  nameWithType: RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  fullName: System.Runtime.Remoting.RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
- uid: System.Runtime.Remoting.Messaging.IMethodReturnMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMethodReturnMessage
  nameWithType: IMethodReturnMessage
  fullName: System.Runtime.Remoting.Messaging.IMethodReturnMessage
- uid: System.Runtime.Remoting.Messaging.IMethodCallMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMethodCallMessage
  nameWithType: IMethodCallMessage
  fullName: System.Runtime.Remoting.Messaging.IMethodCallMessage
- uid: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetEnvoyChainForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
- uid: System.Runtime.Remoting.Messaging.IMessageSink
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMessageSink
  nameWithType: IMessageSink
  fullName: System.Runtime.Remoting.Messaging.IMessageSink
- uid: System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetLifetimeService(MarshalByRefObject)
  nameWithType: RemotingServices.GetLifetimeService(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetLifetimeService(MarshalByRefObject)
- uid: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetMethodBaseFromMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
- uid: System.Reflection.MethodBase
  parent: System.Reflection
  isExternal: true
  name: MethodBase
  nameWithType: MethodBase
  fullName: System.Reflection.MethodBase
- uid: System.Runtime.Remoting.Messaging.IMethodMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMethodMessage
  nameWithType: IMethodMessage
  fullName: System.Runtime.Remoting.Messaging.IMethodMessage
- uid: System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectData(Object,SerializationInfo,StreamingContext)
  nameWithType: RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectUri(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjectUri(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectUri(MarshalByRefObject)
- uid: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjRefForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjRefForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(MarshalByRefObject)
- uid: System.Runtime.Remoting.ObjRef
  parent: System.Runtime.Remoting
  isExternal: false
  name: ObjRef
  nameWithType: ObjRef
  fullName: System.Runtime.Remoting.ObjRef
- uid: System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetRealProxy(Object)
  nameWithType: RemotingServices.GetRealProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.GetRealProxy(Object)
- uid: System.Runtime.Remoting.Proxies.RealProxy
  parent: System.Runtime.Remoting.Proxies
  isExternal: false
  name: RealProxy
  nameWithType: RealProxy
  fullName: System.Runtime.Remoting.Proxies.RealProxy
- uid: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetServerTypeForUri(String)
  nameWithType: RemotingServices.GetServerTypeForUri(String)
  fullName: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(String)
- uid: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetSessionIdForMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
- uid: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsMethodOverloaded(IMethodMessage)
  nameWithType: RemotingServices.IsMethodOverloaded(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(IMethodMessage)
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfAppDomain(Object)
  nameWithType: RemotingServices.IsObjectOutOfAppDomain(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(Object)
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfContext(Object)
  nameWithType: RemotingServices.IsObjectOutOfContext(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(Object)
- uid: System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsOneWay(MethodBase)
  nameWithType: RemotingServices.IsOneWay(MethodBase)
  fullName: System.Runtime.Remoting.RemotingServices.IsOneWay(MethodBase)
- uid: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsTransparentProxy(Object)
  nameWithType: RemotingServices.IsTransparentProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(Object)
- uid: System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: LogRemotingStage(Int32)
  nameWithType: RemotingServices.LogRemotingStage(Int32)
  fullName: System.Runtime.Remoting.RemotingServices.LogRemotingStage(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal(MarshalByRefObject)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject)
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String)
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal(MarshalByRefObject,String,Type)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String,Type)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String,Type)
- uid: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: SetObjectUriForMarshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Unmarshal(ObjRef)
  nameWithType: RemotingServices.Unmarshal(ObjRef)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef)
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Unmarshal(ObjRef,Boolean)
  nameWithType: RemotingServices.Unmarshal(ObjRef,Boolean)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef,Boolean)
- uid: System.Runtime.Remoting.RemotingServices.Connect*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Connect
  nameWithType: RemotingServices.Connect
- uid: System.Runtime.Remoting.RemotingServices.Disconnect*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Disconnect
  nameWithType: RemotingServices.Disconnect
- uid: System.Runtime.Remoting.RemotingServices.ExecuteMessage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: ExecuteMessage
  nameWithType: RemotingServices.ExecuteMessage
- uid: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetEnvoyChainForProxy
  nameWithType: RemotingServices.GetEnvoyChainForProxy
- uid: System.Runtime.Remoting.RemotingServices.GetLifetimeService*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetLifetimeService
  nameWithType: RemotingServices.GetLifetimeService
- uid: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetMethodBaseFromMethodMessage
  nameWithType: RemotingServices.GetMethodBaseFromMethodMessage
- uid: System.Runtime.Remoting.RemotingServices.GetObjectData*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectData
  nameWithType: RemotingServices.GetObjectData
- uid: System.Runtime.Remoting.RemotingServices.GetObjectUri*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectUri
  nameWithType: RemotingServices.GetObjectUri
- uid: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjRefForProxy
  nameWithType: RemotingServices.GetObjRefForProxy
- uid: System.Runtime.Remoting.RemotingServices.GetRealProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetRealProxy
  nameWithType: RemotingServices.GetRealProxy
- uid: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetServerTypeForUri
  nameWithType: RemotingServices.GetServerTypeForUri
- uid: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetSessionIdForMethodMessage
  nameWithType: RemotingServices.GetSessionIdForMethodMessage
- uid: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsMethodOverloaded
  nameWithType: RemotingServices.IsMethodOverloaded
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfAppDomain
  nameWithType: RemotingServices.IsObjectOutOfAppDomain
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfContext
  nameWithType: RemotingServices.IsObjectOutOfContext
- uid: System.Runtime.Remoting.RemotingServices.IsOneWay*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsOneWay
  nameWithType: RemotingServices.IsOneWay
- uid: System.Runtime.Remoting.RemotingServices.IsTransparentProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsTransparentProxy
  nameWithType: RemotingServices.IsTransparentProxy
- uid: System.Runtime.Remoting.RemotingServices.LogRemotingStage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: LogRemotingStage
  nameWithType: RemotingServices.LogRemotingStage
- uid: System.Runtime.Remoting.RemotingServices.Marshal*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal
  nameWithType: RemotingServices.Marshal
- uid: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: SetObjectUriForMarshal
  nameWithType: RemotingServices.SetObjectUriForMarshal
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Unmarshal
  nameWithType: RemotingServices.Unmarshal
