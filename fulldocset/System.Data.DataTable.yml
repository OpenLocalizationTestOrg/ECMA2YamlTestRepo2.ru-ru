### YamlMime:ManagedReference
items:
- uid: System.Data.DataTable
  id: DataTable
  children:
  - System.Data.DataTable.#ctor
  - System.Data.DataTable.#ctor(System.String)
  - System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataTable.#ctor(System.String,System.String)
  - System.Data.DataTable.AcceptChanges
  - System.Data.DataTable.BeginInit
  - System.Data.DataTable.BeginLoadData
  - System.Data.DataTable.CaseSensitive
  - System.Data.DataTable.ChildRelations
  - System.Data.DataTable.Clear
  - System.Data.DataTable.Clone
  - System.Data.DataTable.ColumnChanged
  - System.Data.DataTable.ColumnChanging
  - System.Data.DataTable.Columns
  - System.Data.DataTable.Compute(System.String,System.String)
  - System.Data.DataTable.Constraints
  - System.Data.DataTable.Copy
  - System.Data.DataTable.CreateDataReader
  - System.Data.DataTable.CreateInstance
  - System.Data.DataTable.DataSet
  - System.Data.DataTable.DefaultView
  - System.Data.DataTable.DisplayExpression
  - System.Data.DataTable.EndInit
  - System.Data.DataTable.EndLoadData
  - System.Data.DataTable.ExtendedProperties
  - System.Data.DataTable.fInitInProgress
  - System.Data.DataTable.GetChanges
  - System.Data.DataTable.GetChanges(System.Data.DataRowState)
  - System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)
  - System.Data.DataTable.GetErrors
  - System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataTable.GetRowType
  - System.Data.DataTable.GetSchema
  - System.Data.DataTable.HasErrors
  - System.Data.DataTable.ImportRow(System.Data.DataRow)
  - System.Data.DataTable.Initialized
  - System.Data.DataTable.IsInitialized
  - System.Data.DataTable.Load(System.Data.IDataReader)
  - System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)
  - System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)
  - System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)
  - System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)
  - System.Data.DataTable.Locale
  - System.Data.DataTable.Merge(System.Data.DataTable)
  - System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)
  - System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  - System.Data.DataTable.MinimumCapacity
  - System.Data.DataTable.Namespace
  - System.Data.DataTable.NewRow
  - System.Data.DataTable.NewRowArray(System.Int32)
  - System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)
  - System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)
  - System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)
  - System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  - System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)
  - System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)
  - System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)
  - System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)
  - System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)
  - System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)
  - System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)
  - System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)
  - System.Data.DataTable.ParentRelations
  - System.Data.DataTable.Prefix
  - System.Data.DataTable.PrimaryKey
  - System.Data.DataTable.ReadXml(System.IO.Stream)
  - System.Data.DataTable.ReadXml(System.IO.TextReader)
  - System.Data.DataTable.ReadXml(System.String)
  - System.Data.DataTable.ReadXml(System.Xml.XmlReader)
  - System.Data.DataTable.ReadXmlSchema(System.IO.Stream)
  - System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)
  - System.Data.DataTable.ReadXmlSchema(System.String)
  - System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)
  - System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)
  - System.Data.DataTable.RejectChanges
  - System.Data.DataTable.RemotingFormat
  - System.Data.DataTable.Reset
  - System.Data.DataTable.RowChanged
  - System.Data.DataTable.RowChanging
  - System.Data.DataTable.RowDeleted
  - System.Data.DataTable.RowDeleting
  - System.Data.DataTable.Rows
  - System.Data.DataTable.Select
  - System.Data.DataTable.Select(System.String)
  - System.Data.DataTable.Select(System.String,System.String)
  - System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)
  - System.Data.DataTable.Site
  - System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection
  - System.Data.DataTable.System#ComponentModel#IListSource#GetList
  - System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema
  - System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  - System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  - System.Data.DataTable.TableCleared
  - System.Data.DataTable.TableClearing
  - System.Data.DataTable.TableName
  - System.Data.DataTable.TableNewRow
  - System.Data.DataTable.ToString
  - System.Data.DataTable.WriteXml(System.IO.Stream)
  - System.Data.DataTable.WriteXml(System.IO.TextWriter)
  - System.Data.DataTable.WriteXml(System.String)
  - System.Data.DataTable.WriteXml(System.Xml.XmlWriter)
  - System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)
  - System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  - System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)
  - System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  - System.Data.DataTable.WriteXml(System.String,System.Boolean)
  - System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)
  - System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)
  - System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  - System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)
  - System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)
  - System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)
  - System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)
  - System.Data.DataTable.WriteXmlSchema(System.IO.Stream)
  - System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)
  - System.Data.DataTable.WriteXmlSchema(System.String)
  - System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)
  - System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)
  - System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)
  - System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)
  - System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)
  langs:
  - csharp
  name: DataTable
  nameWithType: DataTable
  fullName: System.Data.DataTable
  type: Class
  summary: "Представляет одну таблицу данных в памяти."
  remarks: "Объект DataTable является центральным объектом библиотеки ADO.NET. Другие объекты, использующие DataTable включают <xref:System.Data.DataSet>и <xref:System.Data.DataView>.</xref:System.Data.DataView> </xref:System.Data.DataSet>       При доступе к DataTable-объекты, обратите внимание, что они условию с учетом регистра. Например если один объект DataTable с именем «mydatatable» и другой называется «Mydatatable», строка, используемая для поиска одной из таблиц рассматривается с учетом регистра. Тем не менее если существует «mydatatable» и «Mydatatable» нет, строка поиска считается без учета регистра. Объект <xref:System.Data.DataSet>может содержать два объекта DataTable с одинаковым <xref:System.Data.DataTable.TableName%2A>значение свойства, но разные <xref:System.Data.DataTable.Namespace%2A>значений свойств.</xref:System.Data.DataTable.Namespace%2A> </xref:System.Data.DataTable.TableName%2A> </xref:System.Data.DataSet> Дополнительные сведения о работе с объектами DataTable см. в разделе [создание таблицы данных](~/add/includes/ajax-current-ext-md.md).       Если вы создаете таблицу данных программным образом, необходимо сначала определить его схемы путем добавления <xref:System.Data.DataColumn>объектов <xref:System.Data.DataColumnCollection>(через <xref:System.Data.DataTable.Columns%2A>свойство).</xref:System.Data.DataTable.Columns%2A> </xref:System.Data.DataColumnCollection> </xref:System.Data.DataColumn> Дополнительные сведения о добавлении <xref:System.Data.DataColumn>см [Добавление столбцов в таблицу данных](~/add/includes/ajax-current-ext-md.md).</xref:System.Data.DataColumn>       Для добавления строк в таблицу данных, необходимо сначала использовать <xref:System.Data.DataTable.NewRow%2A>метод для возврата нового <xref:System.Data.DataRow>объекта.</xref:System.Data.DataRow> </xref:System.Data.DataTable.NewRow%2A> <xref:System.Data.DataTable.NewRow%2A>Метод возвращает строку со схемой объекта DataTable, как это определено в таблице <xref:System.Data.DataColumnCollection>.</xref:System.Data.DataColumnCollection> </xref:System.Data.DataTable.NewRow%2A> Максимальное число строк, которые можно хранить DataTable равно 16 777 216. Дополнительные сведения см. в разделе [Добавление данных в таблицу данных](~/add/includes/ajax-current-ext-md.md).       Таблицы данных также содержит коллекцию <xref:System.Data.Constraint>объекты, которые могут использоваться для обеспечения целостности данных.</xref:System.Data.Constraint> Дополнительные сведения см. в разделе [ограничения таблиц данных](~/add/includes/ajax-current-ext-md.md).       Существует множество событий DataTable, которые можно использовать для определения, когда изменения вносятся в таблицу. К ним относятся <xref:System.Data.DataTable.RowChanged>, <xref:System.Data.DataTable.RowChanging>, <xref:System.Data.DataTable.RowDeleting>и <xref:System.Data.DataTable.RowDeleted>.</xref:System.Data.DataTable.RowDeleted> </xref:System.Data.DataTable.RowDeleting> </xref:System.Data.DataTable.RowChanging> </xref:System.Data.DataTable.RowChanged> Дополнительные сведения о событиях, которые можно использовать с DataTable см. в разделе [обработка событий DataTable](~/add/includes/ajax-current-ext-md.md).       Когда создается экземпляр объекта DataTable, некоторые свойства чтения/записи устанавливаются начальные значения. Список этих значений см. в разделе <xref:System.Data.DataTable.%23ctor%2A?displayProperty=fullName>разделе конструктор.</xref:System.Data.DataTable.%23ctor%2A?displayProperty=fullName>      Настроек [!NOTE] настроек <xref:System.Data.DataSet>и DataTable-объекты наследуют <xref:System.ComponentModel.MarshalByValueComponent>и поддерживают <xref:System.Runtime.Serialization.ISerializable>интерфейс для удаленного взаимодействия .NET Framework.</xref:System.Runtime.Serialization.ISerializable> </xref:System.ComponentModel.MarshalByValueComponent> </xref:System.Data.DataSet> Это единственные объекты ADO.NET, которые можно использовать для удаленного взаимодействия .NET Framework."
  example:
  - "The following example creates two DataTable objects and one <xref:System.Data.DataRelation> object, and adds the new objects to a <xref:System.Data.DataSet>. The tables are then displayed in a <xref:System.Windows.Forms.DataGridView> control.  \n  \n [!code-vb[Classic WebData DataTable Example#1](~/add/codesnippet/visualbasic/t-system.data.datatable_1.vb)]\n [!code-cs[Classic WebData DataTable Example#1](~/add/codesnippet/csharp/t-system.data.datatable_1.cs)]  \n  \n This sample demonstrates how to create a DataTable manually with specific schema definitions:  \n  \n-   Create multiple DataTables and define the initial columns.  \n  \n-   Create the table constraints.  \n  \n-   Insert the values and display the tables.  \n  \n-   Create the expression columns and display the tables.  \n  \n C# and Visual Basic projects with this code sample can be found on [Developer Code Samples](http://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914).  \n  \n [!code-cs[Classic WebData DataTable Example2#1](~/add/codesnippet/csharp/t-system.data.datatable_2.cs)]\n [!code-vb[Classic WebData DataTable Example2#1](~/add/codesnippet/visualbasic/t-system.data.datatable_2.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("RowChanging")]

      [System.ComponentModel.DefaultProperty("TableName")]

      [System.ComponentModel.DesignTimeVisible(false)]

      [System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.ComponentModel.ToolboxItem(false)]

      [System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")]

      public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable
  inheritance:
  - System.Object
  - System.ComponentModel.MarshalByValueComponent
  implements:
  - System.ComponentModel.IListSource
  - System.ComponentModel.ISupportInitializeNotification
  - System.Runtime.Serialization.ISerializable
  - System.Xml.Serialization.IXmlSerializable
  inheritedMembers:
  - System.ComponentModel.MarshalByValueComponent.Container
  - System.ComponentModel.MarshalByValueComponent.DesignMode
  - System.ComponentModel.MarshalByValueComponent.Dispose
  - System.ComponentModel.MarshalByValueComponent.Dispose(System.Boolean)
  - System.ComponentModel.MarshalByValueComponent.Disposed
  - System.ComponentModel.MarshalByValueComponent.Events
  - System.ComponentModel.MarshalByValueComponent.GetService(System.Type)
  platform:
  - net462
- uid: System.Data.DataTable.#ctor
  id: '#ctor'
  parent: System.Data.DataTable
  langs:
  - csharp
  name: DataTable()
  nameWithType: DataTable.DataTable()
  fullName: System.Data.DataTable.DataTable()
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Data.DataTable&quot;> </xref> класса без аргументов."
  remarks: "Конструктор задает начальные значения для всех свойств <xref:System.Data.DataTable>объекта.</xref:System.Data.DataTable> В следующей таблице показаны свойства и их значения по умолчанию. При создании экземпляра <xref:System.Data.DataTable>создается следующие начальные значения задаются свойства чтения и записи.</xref:System.Data.DataTable>      | Свойство | Значение по умолчанию |   |--------------|-------------------|   | **CaseSensitive**| То же, что родительский <xref:System.Data.DataSet>, если он относится к одной.</xref:System.Data.DataSet> В противном случае `false`. |   | **DisplayExpression**| Пустая строка (»») |   | **Locale**| То же, что <xref:System.Data.DataSet>родительского объекта <xref:System.Globalization.CultureInfo>(возвращается свойством <xref:System.Data.DataSet.Locale%2A>); Если отсутствия родительского элемента, значение по умолчанию — текущая система <xref:System.Globalization.CultureInfo>. |   | **Значение MinimumCapacity**|&50; строк. |       Можно изменить значение для любого из этих свойств, вызвав его отдельно.</xref:System.Globalization.CultureInfo> </xref:System.Data.DataSet.Locale%2A> </xref:System.Globalization.CultureInfo> </xref:System.Data.DataSet>"
  example:
  - "The following example creates a new <xref:System.Data.DataTable> with <xref:System.Data.DataColumn> and <xref:System.Data.DataRow>, and displays it in a <xref:System.Windows.Forms.DataGridView> control.  \n  \n [!code-vb[Classic WebData DataTable.DataTable Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._0_1.vb)]\n [!code-cs[Classic WebData DataTable.DataTable Example#1](~/add/codesnippet/csharp/m-system.data.datatable._0_1.cs)]"
  syntax:
    content: public DataTable ();
    parameters: []
  overload: System.Data.DataTable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Data.DataTable
  langs:
  - csharp
  name: DataTable(String)
  nameWithType: DataTable.DataTable(String)
  fullName: System.Data.DataTable.DataTable(String)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Data.DataTable&quot;> </xref> класс с именем указанной таблицы."
  remarks: ''
  example:
  - "The following example creates a <xref:System.Data.DataTable> and displays it in a <xref:System.Windows.Forms.DataGridView> control.  \n  \n [!code-cs[Classic WebData DataTable.DataTable1 Example#1](~/add/codesnippet/csharp/m-system.data.datatable._21_1.cs)]\n [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._21_1.vb)]"
  syntax:
    content: public DataTable (string tableName);
    parameters:
    - id: tableName
      type: System.String
      description: "Имя таблицы. Если `tableName` — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> или является пустой строкой, дается имя по умолчанию при добавлении <xref href=&quot;System.Data.DataTableCollection&quot;> </xref>."
  overload: System.Data.DataTable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: '#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)'
  parent: System.Data.DataTable
  langs:
  - csharp
  name: DataTable(SerializationInfo,StreamingContext)
  nameWithType: DataTable.DataTable(SerializationInfo,StreamingContext)
  fullName: System.Data.DataTable.DataTable(SerializationInfo,StreamingContext)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Data.DataTable&quot;> </xref> класса <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> и <xref:System.Runtime.Serialization.StreamingContext>.</xref:System.Runtime.Serialization.StreamingContext>"
  remarks: "Эта реализация <xref:System.Data.DataTable>конструктор необходим для <xref:System.Runtime.Serialization.ISerializable>.</xref:System.Runtime.Serialization.ISerializable> </xref:System.Data.DataTable>"
  syntax:
    content: protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "Данные, необходимые для сериализации или десериализации объекта."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "Источник и назначение данного сериализованного потока."
  overload: System.Data.DataTable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Data.DataTable
  langs:
  - csharp
  name: DataTable(String,String)
  nameWithType: DataTable.DataTable(String,String)
  fullName: System.Data.DataTable.DataTable(String,String)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Data.DataTable&quot;> </xref> класса с помощью указанного имени таблицы и пространством имен."
  syntax:
    content: public DataTable (string tableName, string tableNamespace);
    parameters:
    - id: tableName
      type: System.String
      description: "Имя таблицы. Если `tableName` — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> или является пустой строкой, дается имя по умолчанию при добавлении <xref href=&quot;System.Data.DataTableCollection&quot;> </xref>."
    - id: tableNamespace
      type: System.String
      description: "Пространство имен для XML-представление данных, хранящихся в <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>."
  overload: System.Data.DataTable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.AcceptChanges
  id: AcceptChanges
  parent: System.Data.DataTable
  langs:
  - csharp
  name: AcceptChanges()
  nameWithType: DataTable.AcceptChanges()
  fullName: System.Data.DataTable.AcceptChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Фиксирует все изменения, внесенные в этой таблице со времени последнего вызова метода AcceptChanges."
  remarks: "Когда выполнение метода AcceptChanges вызывается, любой <xref:System.Data.DataRow>объектов, находящихся в режиме успешно завершает свои изменения.</xref:System.Data.DataRow> <xref:System.Data.DataRowState>Также изменяется: все `Added` и `Modified` строками стать `Unchanged`, и `Deleted` строки будут удалены.</xref:System.Data.DataRowState>       Метод AcceptChanges вызывается обычно на <xref:System.Data.DataTable>после попытки обновления <xref:System.Data.DataSet>с помощью <xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=fullName>метод.</xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=fullName> </xref:System.Data.DataSet> </xref:System.Data.DataTable>"
  example:
  - "The following example tests each table for errors. If the table's errors can be reconciled (by passing it to an undefined function), AcceptChanges is called; otherwise, <xref:System.Data.DataTable.RejectChanges%2A> is called.  \n  \n [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._22_1.vb)]\n [!code-cs[Classic WebData DataTable.AcceptChanges Example#1](~/add/codesnippet/csharp/m-system.data.datatable._22_1.cs)]"
  syntax:
    content: public void AcceptChanges ();
    parameters: []
  overload: System.Data.DataTable.AcceptChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.BeginInit
  id: BeginInit
  parent: System.Data.DataTable
  langs:
  - csharp
  name: BeginInit()
  nameWithType: DataTable.BeginInit()
  fullName: System.Data.DataTable.BeginInit()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Начинает инициализацию <xref href=&quot;System.Data.DataTable&quot;> </xref> , используемого в форме или другим компонентом. Инициализация происходит во время выполнения."
  remarks: "Этот метод применяется в среде разработки Visual Studio .NET для запуска инициализации компонента, используемого в форме или другим компонентом. <xref:System.Data.DataTable.EndInit%2A>Метод завершает инициализацию.</xref:System.Data.DataTable.EndInit%2A> С помощью BeginInit и <xref:System.Data.DataTable.EndInit%2A>методы предотвращает использование до полной инициализации элемента управления.</xref:System.Data.DataTable.EndInit%2A>"
  syntax:
    content: public virtual void BeginInit ();
    parameters: []
  overload: System.Data.DataTable.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.BeginLoadData
  id: BeginLoadData
  parent: System.Data.DataTable
  langs:
  - csharp
  name: BeginLoadData()
  nameWithType: DataTable.BeginLoadData()
  fullName: System.Data.DataTable.BeginLoadData()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Отключает уведомления, обслуживание индекса и ограничения при загрузке данных."
  remarks: "Используется совместно с <xref:System.Data.DataTable.LoadDataRow%2A>и <xref:System.Data.DataTable.EndLoadData%2A>.</xref:System.Data.DataTable.EndLoadData%2A> </xref:System.Data.DataTable.LoadDataRow%2A> BeginLoadData"
  syntax:
    content: public void BeginLoadData ();
    parameters: []
  overload: System.Data.DataTable.BeginLoadData*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.CaseSensitive
  id: CaseSensitive
  parent: System.Data.DataTable
  langs:
  - csharp
  name: CaseSensitive
  nameWithType: DataTable.CaseSensitive
  fullName: System.Data.DataTable.CaseSensitive
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Указывает, учитывается ли сравнения строк в таблице."
  remarks: "Свойство CaseSensitive влияет сравнения строк в сортировку, поиск и фильтрация."
  example:
  - "The following example calls the <xref:System.Data.DataTable.Select%2A> method twice on a <xref:System.Data.DataTable>. The first time, the CaseSensitive property is set to `false`, the second, to `true`.  \n  \n [!code-cs[Classic WebData DataTable.CaseSensitive Example#1](~/add/codesnippet/csharp/p-system.data.datatable._0_1.cs)]\n [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._0_1.vb)]"
  syntax:
    content: public bool CaseSensitive { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если при сравнении учитывается регистр; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию задано значение parent <xref href=&quot;System.Data.DataSet&quot;> </xref> объекта <xref:System.Data.DataSet.CaseSensitive*>Свойства, или <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если <xref href=&quot;System.Data.DataTable&quot;> </xref> был создан независимо от <xref href=&quot;System.Data.DataSet&quot;> </xref>.</xref:System.Data.DataSet.CaseSensitive*>"
  overload: System.Data.DataTable.CaseSensitive*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ChildRelations
  id: ChildRelations
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ChildRelations
  nameWithType: DataTable.ChildRelations
  fullName: System.Data.DataTable.ChildRelations
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает коллекцию дочерних соотношений для <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  remarks: 'Объект <xref:System.Data.DataRelation>определяет связь между двумя таблицами.</xref:System.Data.DataRelation> Как правило две таблицы связаны с помощью одного поля, содержит те же данные. Например таблица с адресными данными может иметь одно поле с кодами, представляющими странах и регионах. Вторая таблица, содержащая данные страны или региона будет одно поле, содержащий код, который идентифицирует страны или региона, и именно этот код, который вставляется в соответствующее поле в первой таблице. Объект <xref:System.Data.DataRelation>, содержит по крайней мере четыре фрагмента данных: (1) имя первой таблицы, (2) имя столбца первой таблицы, (3) имя второй таблицы и (4) имя столбца во второй таблице.</xref:System.Data.DataRelation>'
  example:
  - "The following example uses the ChildRelations property to return each child <xref:System.Data.DataRelation> in a <xref:System.Data.DataTable>. Each relation is then used as an argument in the <xref:System.Data.DataRow.GetChildRows%2A> method of the <xref:System.Data.DataRow> to return an array of rows. The value of each column in the row is then printed.  \n  \n [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._13_1.vb)]\n [!code-cs[Classic WebData DataTable.ChildRelations Example#1](~/add/codesnippet/csharp/p-system.data.datatable._13_1.cs)]"
  syntax:
    content: public System.Data.DataRelationCollection ChildRelations { get; }
    return:
      type: System.Data.DataRelationCollection
      description: "Объект <xref href=&quot;System.Data.DataRelationCollection&quot;> </xref> , содержащий дочерние отношения для таблицы. Если нет, возвращается пустая коллекция <xref href=&quot;System.Data.DataRelation&quot;> </xref> объекты существуют."
  overload: System.Data.DataTable.ChildRelations*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Clear
  id: Clear
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Clear()
  nameWithType: DataTable.Clear()
  fullName: System.Data.DataTable.Clear()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Очищает <xref href=&quot;System.Data.DataTable&quot;> </xref> всех данных."
  remarks: "Удаляются все строки во всех таблицах. Если таблица имеет назначенные дочерние отношения, приводящие дочерние строки будут изолированы, создается исключение.       Если <xref:System.Data.DataSet>привязан к <xref:System.Xml.XmlDataDocument>вызов <xref:System.Data.DataSet.Clear%2A?displayProperty=fullName>или снимите вызывает <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Data.DataSet.Clear%2A?displayProperty=fullName> </xref:System.Xml.XmlDataDocument> </xref:System.Data.DataSet> Чтобы избежать такой ситуации, просмотрите каждую таблицу и удалить каждую строку одновременно. При использовании <xref:System.Data.DataTable.NewRow%2A>для создания новых строк, строки должны быть обработаны перед вызовом метода Clear.</xref:System.Data.DataTable.NewRow%2A>"
  example:
  - "The following example clears the table of all data.  \n  \n [!code-cs[Classic WebData DataTable.Clear Example#1](~/add/codesnippet/csharp/m-system.data.datatable._20_1.cs)]\n [!code-vb[Classic WebData DataTable.Clear Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._20_1.vb)]"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Data.DataTable.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Clone
  id: Clone
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Clone()
  nameWithType: DataTable.Clone()
  fullName: System.Data.DataTable.Clone()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Создает точную копию структуры <xref href=&quot;System.Data.DataTable&quot;> </xref>, включая все <xref href=&quot;System.Data.DataTable&quot;> </xref> схемы и ограничения."
  remarks: "Если эти классы являются производными, копия также будет производным классом.       Создает новый клон <xref:System.Data.DataTable>ту же структуру, что и исходный <xref:System.Data.DataTable>, данные не копируются, но (новый <xref:System.Data.DataTable>не будет содержать `DataRows`).</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataTable> Чтобы скопировать структуру и данные в новую <xref:System.Data.DataTable>Используйте <xref:System.Data.DataTable.Copy%2A>.</xref:System.Data.DataTable.Copy%2A> </xref:System.Data.DataTable>"
  example:
  - "The following sample demonstrates how to update the structure and constraints of the destination table after you execute DataTable.Clone. The ClonedDataTable class will return a destination table and includes all the updating events. After the clone, structure changes in the source table won’t be reflected in the destination table. Specifically, this sample will:  \n  \n-   Update the changes of the columns in source table.  \n  \n-   Update the changes of the UniqueConstraint in source table.  \n  \n-   Update the changes of the ForeignKeyConstraint in source table.  \n  \n C# and Visual Basic projects with this code sample can be found on [Developer Code Samples](http://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable).  \n  \n```  \nusing System;  \nusing System.Linq;  \nusing System.Data;  \nusing System.ComponentModel;  \n  \nclass Program {  \n   static void Main(string[] args) {  \n      DataTable courses = NewCourseDataTable();  \n      Console.WriteLine(\"This is the source table:\");  \n      WriteDataTable(courses);  \n  \n      ClonedDataTable clonedResult = new ClonedDataTable(courses);  \n      DataTable clonedCourses = clonedResult.DestinationTable;  \n      Console.WriteLine(\"This is the destination table:\");  \n      WriteDataTable(clonedCourses);  \n  \n      // Add the events of updating column collection into the source table.  \n      clonedResult.UpdateAddedColumn();  \n      clonedResult.UpdateDeletedColumn();  \n      // Add a DataColumn in source table.  \n      DataColumn columnCreidts = new DataColumn(\"Credits\", typeof(Int32));  \n      courses.Columns.Add(columnCreidts);  \n      Console.WriteLine(\"After add a column in source table, it's the result in the destination:\");  \n      WriteDataTable(clonedCourses);  \n  \n      // Add the event of updating UniqueConstraint into the source table.  \n      clonedResult.UpdateUniqueConstraint();  \n  \n      // Add the unique constraint in source table.  \n      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns[\"CourseId\"]);  \n      courses.Constraints.Add(uniqueConstraint);  \n  \n      Console.WriteLine(@\"If we add the unique constraint in source table and then insert the duplicate   \nrows into the destination table, we will get the following error:\");  \n      InsertDuplicateData(clonedCourses);  \n      Console.WriteLine();  \n  \n      // Add the event of updating ForeignKeyConstraint into the source table.  \n      clonedResult.UpdateForeignKeyConstraint();  \n  \n      // Add the ForeignKeyConstraint into the source table.  \n      DataTable deparments = NewDeparmentDataTable();  \n      DataSet dataset = new DataSet();  \n  \n      dataset.Tables.Add(courses);  \n      dataset.Tables.Add(clonedCourses);  \n      dataset.Tables.Add(deparments);  \n  \n      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns[\"DepartmentId\"], courses.Columns[\"DepartmentId\"]);  \n      courses.Constraints.Add(foreignKey);  \n  \n      Console.WriteLine(@\"If we add the foreign key constraint in source table and then insert a row   \nwithout the parent  into the destination table, we will get the following error:\");  \n      InsertNoParentRow(clonedCourses);  \n      Console.WriteLine();  \n  \n      Console.WriteLine(\"Please press any key to exit...\");  \n      Console.ReadKey();  \n   }  \n  \n   static private DataTable NewCourseDataTable() {  \n      DataTable newTable = new DataTable();  \n  \n      DataColumn[] columns ={   \n                                      new DataColumn(\"CourseId\", typeof(String)),  \n                                      new DataColumn(\"CourseName\",typeof(String)),                                        \n                                      new DataColumn(\"DepartmentId\", typeof(Int32))  \n                                  };  \n  \n      newTable.Columns.AddRange(columns);  \n  \n      newTable.Rows.Add(\"C1045\", \"Calculus\", 7);  \n      newTable.Rows.Add(\"C1061\", \"Physics\", 1);  \n      newTable.Rows.Add(\"C2021\", \"Composition\", 2);  \n      newTable.Rows.Add(\"C2042\", \"Literature\", 2);  \n  \n      return newTable;  \n   }  \n  \n   static private DataTable NewDeparmentDataTable() {  \n      DataTable newTable = new DataTable();  \n  \n      DataColumn[] columns ={   \n                                      new DataColumn(\"DepartmentId\", typeof(Int32)),  \n                                      new DataColumn(\"Name\",typeof(String)),  \n                                  };  \n  \n      newTable.Columns.AddRange(columns);  \n  \n      newTable.Rows.Add(1, \"Engineering\");  \n      newTable.Rows.Add(2, \"English\");  \n      newTable.Rows.Add(4, \"Economics\");  \n      newTable.Rows.Add(7, \"Mathematics\");  \n  \n      return newTable;  \n   }  \n  \n   static private void WriteDataTable(DataTable table) {  \n      if (table == null)  \n         return;  \n  \n      foreach (DataColumn column in table.Columns) {  \n         Console.Write(\"{0,-15}\", column.ColumnName);  \n      }  \n      Console.WriteLine();  \n  \n      foreach (DataRow row in table.Rows) {  \n         for (int i = 0; i < table.Columns.Count; i++)  \n            Console.Write(\"{0,-15}\", row[i].ToString());  \n         Console.WriteLine();  \n      }  \n  \n      Console.WriteLine();  \n   }  \n  \n   static private void InsertDuplicateData(DataTable table) {  \n      try {  \n         table.Rows.Add(\"C1045\", \"Calculus\", 7);  \n         table.Rows.Add(\"C1045\", \"Calculus\", 7);  \n      } catch (Exception e) {  \n         Console.WriteLine(\"\\\"\" + e.Message + \"\\\"\");  \n      }  \n   }  \n  \n   private static void InsertNoParentRow(DataTable table) {  \n      try {  \n         table.Rows.Add(\"C1061\", \"Physics\", 11);  \n      } catch (Exception e) {  \n         Console.WriteLine(\"\\\"\" + e.Message + \"\\\"\");  \n      }  \n   }  \n}  \n  \npublic class ClonedDataTable {  \n   private DataTable sourceTable;  \n   private DataTable destinationTable;  \n  \n   public ClonedDataTable(DataTable source) {  \n      sourceTable = source;  \n      // set the cloned result  \n      destinationTable = sourceTable.Clone();  \n   }  \n  \n   public void UpdateAddedColumn() {  \n      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  \n   }  \n  \n   public void UpdateDeletedColumn() {  \n      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  \n   }  \n  \n   public void UpdateUniqueConstraint() {  \n      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  \n   }  \n  \n   public void UpdateForeignKeyConstraint() {  \n      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  \n   }  \n  \n   // After the source table adds a column, the method will add the same column in the destination table.  \n   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  \n      if (e.Action == CollectionChangeAction.Add) {  \n         DataColumn column = e.Element as DataColumn;  \n  \n         if (column != null) {  \n            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  \n  \n            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  \n               destinationTable.Columns.Add(newColumn);  \n         }  \n      }  \n   }  \n  \n   // After the source table deletes a column, the method will delete the same column in the destination table.  \n   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  \n      if (e.Action == CollectionChangeAction.Remove) {  \n         DataColumn column = e.Element as DataColumn;  \n  \n         if (column != null)  \n            if (destinationTable.Columns.Contains(column.ColumnName))  \n               destinationTable.Columns.Remove(column.ColumnName);  \n      }  \n   }  \n  \n   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        \n   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  \n      UniqueConstraint constraint = e.Element as UniqueConstraint;  \n  \n      if (constraint == null)  \n         return;  \n  \n      String constraintName = constraint.ConstraintName;  \n  \n      if (e.Action == CollectionChangeAction.Add) {  \n         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  \n         Boolean isPrimaryKey = constraint.IsPrimaryKey;  \n  \n         // Get the columns used in new constraint from the destiantion table.  \n         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  \n            String columnName = constraint.Columns[i].ColumnName;  \n  \n            if (destinationTable.Columns.Contains(columnName))  \n               columns[i] = destinationTable.Columns[columnName];  \n            else  \n               return;  \n         }  \n  \n         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  \n  \n         if (!destinationTable.Constraints.Contains(constraintName))  \n            destinationTable.Constraints.Add(newConstraint);  \n  \n      } else if (e.Action == CollectionChangeAction.Remove)  \n         if (destinationTable.Constraints.Contains(constraintName))  \n            destinationTable.Constraints.Remove(constraintName);  \n   }  \n  \n   // After the source table changes the ForeignKeyConstraint, this method changes    \n   // the same ForeignKeyConstraint in the destination table.  \n   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  \n      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  \n  \n      if (constraint == null)  \n         return;  \n  \n      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  \n      if (sourceTable.DataSet != destinationTable.DataSet)  \n         return;  \n  \n      String constraintName = constraint.ConstraintName;  \n  \n      if (e.Action == CollectionChangeAction.Add) {  \n         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  \n         DataColumn[] parentColumns = constraint.RelatedColumns;  \n  \n         // Get the columns used in new constraint from the destination table.  \n         for (int i = 0; i < constraint.Columns.Count(); i++) {  \n            String columnName = constraint.Columns[i].ColumnName;  \n  \n            if (destinationTable.Columns.Contains(columnName))  \n               columns[i] = destinationTable.Columns[columnName];  \n            else  \n               return;  \n         }  \n  \n         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  \n         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  \n         newConstraint.DeleteRule = constraint.DeleteRule;  \n         newConstraint.UpdateRule = constraint.UpdateRule;  \n  \n         if (!destinationTable.Constraints.Contains(constraintName))  \n            destinationTable.Constraints.Add(newConstraint);  \n      } else if (e.Action == CollectionChangeAction.Remove)  \n         if (destinationTable.Constraints.Contains(constraintName))  \n            destinationTable.Constraints.Remove(constraintName);  \n   }  \n  \n   // return the destination table.  \n   public DataTable DestinationTable {  \n      get { return destinationTable; }  \n   }  \n}  \n```  \n  \n This sample shows how to modify data in a DataTable and update the data source.  \n  \n First, create a database:  \n  \n```  \nUSE [master]  \nGO  \n  \nCREATE DATABASE [MySchool]   \n  \nGO  \n  \nUSE [MySchool]  \nGO  \n  \nSET ANSI_NULLS ON  \nGO  \nSET QUOTED_IDENTIFIER ON  \nGO  \nCREATE TABLE [dbo].[Course](~/add/includes/ajax-current-ext-md.md [nvarchar](10) NOT NULL,  \n[Year] [smallint] NOT NULL,  \n[Title] [nvarchar](100) NOT NULL,  \n[Credits] [int] NOT NULL,  \n[DepartmentID] [int] NOT NULL,  \n CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   \n(  \n[CourseID] ASC,  \n[Year] ASC  \n)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  \n  \nGO  \n  \nSET ANSI_NULLS ON  \nGO  \nSET QUOTED_IDENTIFIER ON  \nGO  \nCREATE TABLE [dbo].[Department](~/add/includes/ajax-current-ext-md.md [int] IDENTITY(1,1) NOT NULL,  \n[Name] [nvarchar](50) NOT NULL,  \n[Budget] [money] NOT NULL,  \n[StartDate] [datetime] NOT NULL,  \n[Administrator] [int] NULL,  \n CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   \n(  \n[DepartmentID] ASC  \n)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  \n  \nGO  \n  \nINSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  \nINSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  \nINSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  \nINSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  \n  \nSET IDENTITY_INSERT [dbo].[Department] ON   \n  \nINSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  \nINSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  \nINSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  \nINSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  \nSET IDENTITY_INSERT [dbo].[Department] OFF  \n  \nALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  \nREFERENCES [dbo].[Department] ([DepartmentID])  \nGO  \nALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  \nGO  \n```  \n  \n You can now compile and run the sample. [How to modify data in DataTable and update to the data source](http://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4) has Visual Basic and C# projects of this sample.  \n  \n```  \nusing System;  \nusing System.Data;  \nusing System.Data.SqlClient;  \n  \nclass Program {  \n   static void Main(string[] args) {  \n  \n   string MySchoolConnectionString = \"Data Source=(local);Initial Catalog=MySchool;Integrated Security=True\";  \n  \n      // Get Data  \n      String selectString =  \n       @\"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  \n               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] \";  \n  \n      DataSet dataSet = new DataSet();  \n      DataTable course = dataSet.Tables.Add(\"Course\");  \n      DataTable department = dataSet.Tables.Add(\"Department\");  \n  \n      Console.WriteLine(\"Get data from database:\");  \n      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  \n      Console.WriteLine();  \n  \n      // Use DataTable Edits to edit the data  \n      String updateString =  \n              @\"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;\";  \n  \n      course.ColumnChanged += OnColumnChanged;  \n  \n      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  \n      ChangeCredits(course, course.Rows[0], -1);  \n      ChangeCredits(course, course.Rows[1], 11);  \n  \n      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, \"Course\",  \n          new SqlParameter(\"@CourseID\", SqlDbType.NVarChar, 10, \"CourseID\"),  \n          new SqlParameter(\"@Credits\", SqlDbType.Int, 4, \"Credits\"));  \n      Console.WriteLine(\"Only the Credits of second row is changed.\");  \n      ShowDataTable(course);  \n      Console.WriteLine();  \n  \n      // Delete and Remove from DataTable  \n      // Create the foreign key constraint, and set the DeleteRule with Cascade.  \n      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint(\"CourseDepartFK\", department.Columns[\"DepartmentID\"], course.Columns[\"DepartmentID\"]);  \n      courseDepartFK.DeleteRule = Rule.Cascade;  \n      courseDepartFK.UpdateRule = Rule.Cascade;  \n      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  \n      course.Constraints.Add(courseDepartFK);  \n  \n      String deleteString = @\"Delete From [dbo].[Course] Where [CourseID]=@CourseID;\";  \n  \n      department.Rows[0].Delete();  \n      Console.WriteLine(\"If One row in Department table is deleted, the related rows in Course table will also be deleted.\");  \n      Console.WriteLine(\"Department DataTable:\");  \n      ShowDataTable(department);  \n      Console.WriteLine();  \n      Console.WriteLine(\"Course DataTable:\");  \n      ShowDataTable(course);  \n      Console.WriteLine();  \n      // Update the delete operation  \n      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, \"Course\",  \n          new SqlParameter(\"@CourseID\", SqlDbType.NVarChar, 10, \"CourseID\"));  \n      Console.WriteLine(\"After delete operation:\");  \n      Console.WriteLine(\"Course DataTable:\");  \n      ShowDataTable(course);  \n      Console.WriteLine();  \n  \n      course.Rows.RemoveAt(0);  \n      Console.WriteLine(\"Now we remove one row from Course:\");  \n      ShowDataTable(course);  \n      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, \"Course\",  \n          new SqlParameter(\"@CourseID\", SqlDbType.NVarChar, 10, \"CourseID\"));  \n   }  \n  \n   // Use SqlDataAdapter to get data.  \n   private static void GetDataTables(String connectionString, String selectString,  \n       DataSet dataSet, params DataTable[] tables) {  \n      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  \n         adapter.SelectCommand = new SqlCommand(selectString);  \n         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  \n  \n         adapter.Fill(0, 0, tables);  \n  \n         foreach (DataTable table in dataSet.Tables) {  \n            Console.WriteLine(\"Data in {0}:\", table.TableName);  \n            ShowDataTable(table);  \n            Console.WriteLine();  \n         }  \n      }  \n   }  \n  \n   // Use SqlDataAdapter to update the updata operation.  \n   private static void UpdateDataTables(String connectionString, String updateString,  \n       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  \n      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  \n         adapter.UpdateCommand = new SqlCommand(updateString);  \n         adapter.UpdateCommand.Parameters.AddRange(parameters);  \n         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  \n  \n         adapter.Update(dataSet, tableName);  \n      }  \n   }  \n  \n   // Use SqlDataAdapter to update delete operation.  \n   private static void DeleteDataTables(String connectionString, String deleteString,  \n       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  \n      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  \n         adapter.DeleteCommand = new SqlCommand(deleteString);  \n         adapter.DeleteCommand.Parameters.AddRange(parameters);  \n         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  \n  \n         adapter.Update(dataSet, tableName);  \n      }  \n   }  \n  \n   // Use DataTable Edits to modify the data.  \n   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  \n      row.BeginEdit();  \n      Console.WriteLine(\"We change row {0}\", table.Rows.IndexOf(row));  \n      row[\"Credits\"] = credits;  \n      row.EndEdit();  \n   }  \n  \n   // The method will be invoked when the value in DataTable is changed.  \n   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  \n      Int32 credits = 0;  \n      // If Credits is changed and the value is negative, we'll cancel the edit.  \n      if ((args.Column.ColumnName == \"Credits\") &&  \n          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  \n         Console.WriteLine(\"The value of Credits is invalid. Edit canceled.\");  \n         args.Row.CancelEdit();  \n      }  \n   }  \n  \n   // Display the column and value of DataTable.  \n   private static void ShowDataTable(DataTable table) {  \n      foreach (DataColumn col in table.Columns) {  \n         Console.Write(\"{0,-14}\", col.ColumnName);  \n      }  \n      Console.WriteLine(\"{0,-14}\", \"RowState\");  \n  \n      foreach (DataRow row in table.Rows) {  \n         if (row.RowState == DataRowState.Deleted) {  \n            foreach (DataColumn col in table.Columns) {  \n               if (col.DataType.Equals(typeof(DateTime)))  \n                  Console.Write(\"{0,-14:d}\", row[col, DataRowVersion.Original]);  \n               else if (col.DataType.Equals(typeof(Decimal)))  \n                  Console.Write(\"{0,-14:C}\", row[col, DataRowVersion.Original]);  \n               else  \n                  Console.Write(\"{0,-14}\", row[col, DataRowVersion.Original]);  \n            }  \n         }  \n         else {  \n            foreach (DataColumn col in table.Columns) {  \n               if (col.DataType.Equals(typeof(DateTime)))  \n                  Console.Write(\"{0,-14:d}\", row[col]);  \n               else if (col.DataType.Equals(typeof(Decimal)))  \n                  Console.Write(\"{0,-14:C}\", row[col]);  \n               else  \n                  Console.Write(\"{0,-14}\", row[col]);  \n            }  \n         }  \n         Console.WriteLine(\"{0,-14}\", row.RowState);  \n      }  \n   }  \n}  \n```"
  syntax:
    content: public virtual System.Data.DataTable Clone ();
    parameters: []
    return:
      type: System.Data.DataTable
      description: "Новый <xref href=&quot;System.Data.DataTable&quot;> </xref> с той же схемой, что и текущий <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  overload: System.Data.DataTable.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ColumnChanged
  id: ColumnChanged
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ColumnChanged
  nameWithType: DataTable.ColumnChanged
  fullName: System.Data.DataTable.ColumnChanged
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Происходит после изменения значения для указанного <xref href=&quot;System.Data.DataColumn&quot;> </xref> в <xref href=&quot;System.Data.DataRow&quot;> </xref>."
  remarks: "Дополнительные сведения см. в разделе [обработка событий DataTable](~/add/includes/ajax-current-ext-md.md)."
  example:
  - >-
    [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/add/codesnippet/visualbasic/e-system.data.datatable._4_1.vb)]
     [!code-cs[Classic WebData DataTable.ColumnChanged Example#1](~/add/codesnippet/csharp/e-system.data.datatable._4_1.cs)]
  syntax:
    content: public event System.Data.DataColumnChangeEventHandler ColumnChanged;
    return:
      type: System.Data.DataColumnChangeEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ColumnChanging
  id: ColumnChanging
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ColumnChanging
  nameWithType: DataTable.ColumnChanging
  fullName: System.Data.DataTable.ColumnChanging
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Происходит при изменении значения для указанного <xref href=&quot;System.Data.DataColumn&quot;> </xref> в <xref href=&quot;System.Data.DataRow&quot;> </xref>."
  remarks: "Дополнительные сведения см. в разделе [обработка событий DataTable](~/add/includes/ajax-current-ext-md.md)."
  example:
  - >-
    [!code-cs[Classic WebData DataTable.ColumnChanging Example#1](~/add/codesnippet/csharp/e-system.data.datatable._5_1.cs)]
     [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/add/codesnippet/visualbasic/e-system.data.datatable._5_1.vb)]
  syntax:
    content: public event System.Data.DataColumnChangeEventHandler ColumnChanging;
    return:
      type: System.Data.DataColumnChangeEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Columns
  id: Columns
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Columns
  nameWithType: DataTable.Columns
  fullName: System.Data.DataTable.Columns
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает коллекцию столбцов, входящих в эту таблицу."
  remarks: "<xref:System.Data.DataColumnCollection>Определяет схему таблицы с помощью определения типа данных каждого столбца.</xref:System.Data.DataColumnCollection>"
  example:
  - "The following example prints each value of each row in a table using the Columns property.  \n  \n [!code-vb[Classic WebData DataTable.Columns Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._12_1.vb)]\n [!code-cs[Classic WebData DataTable.Columns Example#1](~/add/codesnippet/csharp/p-system.data.datatable._12_1.cs)]"
  syntax:
    content: public System.Data.DataColumnCollection Columns { get; }
    return:
      type: System.Data.DataColumnCollection
      description: "Объект <xref href=&quot;System.Data.DataColumnCollection&quot;> </xref> , содержащий коллекцию <xref href=&quot;System.Data.DataColumn&quot;> </xref> объектов для таблицы. Если нет, возвращается пустая коллекция <xref href=&quot;System.Data.DataColumn&quot;> </xref> объекты существуют."
  overload: System.Data.DataTable.Columns*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Compute(System.String,System.String)
  id: Compute(System.String,System.String)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Compute(String,String)
  nameWithType: DataTable.Compute(String,String)
  fullName: System.Data.DataTable.Compute(String,String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Вычисляет заданное выражение для текущих строк, удовлетворяющих условию фильтра."
  remarks: "`expression` Параметр требует наличия статистической функции. Например, следующее выражение является допустимым: `Count(Quantity)` , но это выражение не: `Sum (Quantity * UnitPrice)` необходимо выполнить операцию на несколько столбцов, следует создать <xref:System.Data.DataColumn>, задайте его <xref:System.Data.DataColumn.Expression%2A>Свойства соответствующее выражение, а использование статистическое выражение на результирующего столбца.</xref:System.Data.DataColumn.Expression%2A> </xref:System.Data.DataColumn> В этом случае заданному <xref:System.Data.DataColumn>с именем «итог» и <xref:System.Data.DataColumn.Expression%2A>значение этого свойства: `&quot;Quantity * UnitPrice&quot;` аргумент выражения для вычислений метода будет иметь это: `Sum(total)` второй параметр `filter`, определяет строки, используемые в выражении.</xref:System.Data.DataColumn.Expression%2A> </xref:System.Data.DataColumn> Например, если таблица содержит столбец с именем «colDate» даты, можно ограничить строки с помощью следующего выражения: `colDate > 1/1/99 AND colDate < 17/1/99` правила создания выражений для обоих параметров в разделе <xref:System.Data.DataColumn.Expression%2A?displayProperty=fullName>свойство.</xref:System.Data.DataColumn.Expression%2A?displayProperty=fullName>"
  example:
  - "The following example sums the values of a column named \"Total\", for the salesperson whose identification number is five.  \n  \n [!code-cs[Classic WebData DataTable.Compute Example#1](~/add/codesnippet/csharp/m-system.data.datatable._24_1.cs)]\n [!code-vb[Classic WebData DataTable.Compute Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._24_1.vb)]"
  syntax:
    content: public object Compute (string expression, string filter);
    parameters:
    - id: expression
      type: System.String
      description: "Выражение для вычисления."
    - id: filter
      type: System.String
      description: "Фильтр для ограничения строк, используемых выражением."
    return:
      type: System.Object
      description: "<xref:System.Object>, Результатом вычисления.</xref:System.Object> Если выражение имеет значение null, возвращаемое значение будет <xref href=&quot;System.DBNull.Value&quot;> </xref>."
  overload: System.Data.DataTable.Compute*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Constraints
  id: Constraints
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Constraints
  nameWithType: DataTable.Constraints
  fullName: System.Data.DataTable.Constraints
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает коллекцию ограничений, содержащихся в этой таблице."
  remarks: "Объект <xref:System.Data.ForeignKeyConstraint>ограничивает действие, выполняемое при удалении или обновлении значения столбца (столбцов).</xref:System.Data.ForeignKeyConstraint> Такое ограничение предназначено для использования с первичными ключевыми столбцами. В отношении &quot;родители потомки&quot; между двумя таблицами Удаление значения из родительской таблицы может влиять на дочерние строки в один из следующих способов.      -Дочерние строки могут быть удалены (каскадное действие).      -Значения в дочерний столбец (или столбцы) можно задать со значением null.      -Значения в дочерний столбец (или столбцы) можно задать значения по умолчанию.      -Может быть создан исключение.       Объект <xref:System.Data.UniqueConstraint>становится активным, при попытке задать значение в первичном ключе неуникального значение.</xref:System.Data.UniqueConstraint>"
  example:
  - "The following example adds a <xref:System.Data.ForeignKeyConstraint> to the collection of constraints.  \n  \n [!code-vb[Classic WebData DataTable.Constraints Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._3_1.vb)]\n [!code-cs[Classic WebData DataTable.Constraints Example#1](~/add/codesnippet/csharp/p-system.data.datatable._3_1.cs)]"
  syntax:
    content: public System.Data.ConstraintCollection Constraints { get; }
    return:
      type: System.Data.ConstraintCollection
      description: "Объект <xref href=&quot;System.Data.ConstraintCollection&quot;> </xref> , содержащий коллекцию <xref href=&quot;System.Data.Constraint&quot;> </xref> объектов для таблицы. Если нет, возвращается пустая коллекция <xref href=&quot;System.Data.Constraint&quot;> </xref> объекты существуют."
  overload: System.Data.DataTable.Constraints*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Copy
  id: Copy
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Copy()
  nameWithType: DataTable.Copy()
  fullName: System.Data.DataTable.Copy()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Копирует структуру и данные для <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  remarks: ''
  example:
  - "The following example uses the Copy method to create a copy of the original <xref:System.Data.DataTable>. The namespace name is not retained if it is inherited from a parent <xref:System.Data.DataTable> or <xref:System.Data.DataSet>.  \n  \n [!code-cs[Classic WebData DataTable.Copy Example#1](~/add/codesnippet/csharp/m-system.data.datatable._5_1.cs)]\n [!code-vb[Classic WebData DataTable.Copy Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._5_1.vb)]"
  syntax:
    content: public System.Data.DataTable Copy ();
    parameters: []
    return:
      type: System.Data.DataTable
      description: "Новый <xref href=&quot;System.Data.DataTable&quot;> </xref> с тем же структуру (схемы таблиц и ограничения) и данные, что <xref href=&quot;System.Data.DataTable&quot;> </xref>.       Если эти классы являются производными, копия также будет производным классом.       Создает новую копию <xref href=&quot;System.Data.DataTable&quot;> </xref> с тем же структуру и данные, что и исходный <xref href=&quot;System.Data.DataTable&quot;> </xref>. Чтобы скопировать структуру в новую <xref href=&quot;System.Data.DataTable&quot;> </xref>, но не данные, используйте <xref:System.Data.DataTable.Clone*>.</xref:System.Data.DataTable.Clone*>"
  overload: System.Data.DataTable.Copy*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.CreateDataReader
  id: CreateDataReader
  parent: System.Data.DataTable
  langs:
  - csharp
  name: CreateDataReader()
  nameWithType: DataTable.CreateDataReader()
  fullName: System.Data.DataTable.CreateDataReader()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает <xref href=&quot;System.Data.DataTableReader&quot;> </xref> соответствующее данным в рамках этого <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  remarks: ''
  example:
  - "The following console application creates a <xref:System.Data.DataTable> instance. The example then passes the filled <xref:System.Data.DataTable>to a procedure that calls the CreateDataReader method, which iterates through the results contained within the <xref:System.Data.DataTableReader>.  \n  \n [!code-vb[DataWorks DataTable.CreateDataReader#1](~/add/codesnippet/visualbasic/m-system.data.datatable._9_1.vb)]\n [!code-cs[DataWorks DataTable.CreateDataReader#1](~/add/codesnippet/csharp/m-system.data.datatable._9_1.cs)]  \n  \n The example displays the following output in the console window:  \n  \n `1 Mary`  \n  \n `2 Andy`  \n  \n `3 Peter`  \n  \n `4 Russ`"
  syntax:
    content: public System.Data.DataTableReader CreateDataReader ();
    parameters: []
    return:
      type: System.Data.DataTableReader
      description: "Объект <xref href=&quot;System.Data.DataTableReader&quot;> </xref> содержащего один результирующий набор, соответствующий источнику <xref href=&quot;System.Data.DataTable&quot;> </xref> экземпляра."
  overload: System.Data.DataTable.CreateDataReader*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.CreateInstance
  id: CreateInstance
  parent: System.Data.DataTable
  langs:
  - csharp
  name: CreateInstance()
  nameWithType: DataTable.CreateInstance()
  fullName: System.Data.DataTable.CreateInstance()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Создает новый экземпляр <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  syntax:
    content: protected virtual System.Data.DataTable CreateInstance ();
    parameters: []
    return:
      type: System.Data.DataTable
      description: "Новое выражение."
  overload: System.Data.DataTable.CreateInstance*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.DataSet
  id: DataSet
  parent: System.Data.DataTable
  langs:
  - csharp
  name: DataSet
  nameWithType: DataTable.DataSet
  fullName: System.Data.DataTable.DataSet
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает <xref href=&quot;System.Data.DataSet&quot;> </xref> , которому принадлежит эта таблица."
  remarks: "Если элемент управления имеет данные, привязанные к <xref:System.Data.DataTable>, и таблица принадлежит к <xref:System.Data.DataSet>, можно получить <xref:System.Data.DataSet>через это свойство.</xref:System.Data.DataSet> </xref:System.Data.DataSet> </xref:System.Data.DataTable>"
  example:
  - "The following example returns the parent <xref:System.Data.DataSet> of a given table through the DataSet property.  \n  \n [!code-vb[Classic WebData DataTable.DataSet Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._10_1.vb)]\n [!code-cs[Classic WebData DataTable.DataSet Example#1](~/add/codesnippet/csharp/p-system.data.datatable._10_1.cs)]"
  syntax:
    content: public System.Data.DataSet DataSet { get; }
    return:
      type: System.Data.DataSet
      description: "<xref href=&quot;System.Data.DataSet&quot;> </xref> , Которому принадлежит эта таблица."
  overload: System.Data.DataTable.DataSet*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.DefaultView
  id: DefaultView
  parent: System.Data.DataTable
  langs:
  - csharp
  name: DefaultView
  nameWithType: DataTable.DefaultView
  fullName: System.Data.DataTable.DefaultView
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Получает настраиваемое представление таблицы, которая может включать отфильтрованное представление или положение курсора."
  remarks: "Возвращает свойство режим по умолчанию <xref:System.Data.DataView>можно использовать для сортировки, фильтрации и поиск <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataView>"
  example:
  - "The following example sets a property of the <xref:System.Data.DataTable> object's <xref:System.Data.DataView> through the DefaultView property. The example also shows the binding of a <xref:System.Windows.Forms.DataGridView> control to a <xref:System.Data.DataTable> named \"Suppliers\" that includes a column named \"CompanyName.\"  \n  \n [!code-cs[Classic WebData DataTable.DefaultView Example#1](~/add/codesnippet/csharp/p-system.data.datatable._11_1.cs)]\n [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._11_1.vb)]"
  syntax:
    content: public System.Data.DataView DefaultView { get; }
    return:
      type: System.Data.DataView
      description: "<xref href=&quot;System.Data.DataView&quot;> </xref> Связанных с <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  overload: System.Data.DataTable.DefaultView*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.DisplayExpression
  id: DisplayExpression
  parent: System.Data.DataTable
  langs:
  - csharp
  name: DisplayExpression
  nameWithType: DataTable.DisplayExpression
  fullName: System.Data.DataTable.DisplayExpression
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает или задает выражение, которое возвращает значение, используемое для представления таблицы в пользовательском интерфейсе. <xref uid=&quot;langword_csharp_DisplayExpression&quot; name=&quot;DisplayExpression&quot; href=&quot;&quot;> </xref> Позволяет отобразить имя этой таблицы в пользовательском интерфейсе."
  syntax:
    content: public string DisplayExpression { get; set; }
    return:
      type: System.String
      description: "Отображаемая строка."
  overload: System.Data.DataTable.DisplayExpression*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.EndInit
  id: EndInit
  parent: System.Data.DataTable
  langs:
  - csharp
  name: EndInit()
  nameWithType: DataTable.EndInit()
  fullName: System.Data.DataTable.EndInit()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Завершает инициализацию <xref href=&quot;System.Data.DataTable&quot;> </xref> , используемого в форме или другим компонентом. Инициализация происходит во время выполнения."
  remarks: "Этот метод применяется в среде разработки Visual Studio .NET для завершения инициализации компонента, используемого в форме или другим компонентом. <xref:System.Data.DataTable.BeginInit%2A>Метод начинает инициализацию.</xref:System.Data.DataTable.BeginInit%2A> С помощью <xref:System.Data.DataTable.BeginInit%2A>и методы EndInit предотвращает использование до полной инициализации элемента управления.</xref:System.Data.DataTable.BeginInit%2A>"
  syntax:
    content: public virtual void EndInit ();
    parameters: []
  overload: System.Data.DataTable.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.EndLoadData
  id: EndLoadData
  parent: System.Data.DataTable
  langs:
  - csharp
  name: EndLoadData()
  nameWithType: DataTable.EndLoadData()
  fullName: System.Data.DataTable.EndLoadData()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Включение уведомления, обслуживание индекса и ограничения после загрузки данных."
  remarks: "Используется совместно с <xref:System.Data.DataTable.LoadDataRow%2A>и <xref:System.Data.DataTable.BeginLoadData%2A>.</xref:System.Data.DataTable.BeginLoadData%2A> </xref:System.Data.DataTable.LoadDataRow%2A> EndLoadData"
  syntax:
    content: public void EndLoadData ();
    parameters: []
  overload: System.Data.DataTable.EndLoadData*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ExtendedProperties
  id: ExtendedProperties
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ExtendedProperties
  nameWithType: DataTable.ExtendedProperties
  fullName: System.Data.DataTable.ExtendedProperties
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает коллекцию настраиваемых данных пользователя."
  remarks: "Используется для добавления сведений о настраиваемом <xref:System.Data.DataTable>.</xref:System.Data.DataTable> ExtendedProperties Добавление данных с `Add` метод. Получить сведения с `Item` метод.       Расширенные свойства должны иметь тип <xref:System.String>.</xref:System.String> Свойства не типа String не сохраняются при <xref:System.Data.DataTable>записывается как XML.</xref:System.Data.DataTable>"
  example:
  - "The following example adds a timestamp value to the <xref:System.Data.DataTable> through the ExtendedProperties property.  \n  \n [!code-cs[Classic WebData DataTable.ExtendedProperties Example#1](~/add/codesnippet/csharp/p-system.data.datatable._7_1.cs)]\n [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._7_1.vb)]"
  syntax:
    content: public System.Data.PropertyCollection ExtendedProperties { get; }
    return:
      type: System.Data.PropertyCollection
      description: "Объект <xref href=&quot;System.Data.PropertyCollection&quot;> </xref> , содержащий особую информацию пользователя."
  overload: System.Data.DataTable.ExtendedProperties*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.fInitInProgress
  id: fInitInProgress
  parent: System.Data.DataTable
  langs:
  - csharp
  name: fInitInProgress
  nameWithType: DataTable.fInitInProgress
  fullName: System.Data.DataTable.fInitInProgress
  type: Field
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Проверяет, является ли инициализация выполняется. Инициализация происходит во время выполнения."
  syntax:
    content: protected bool fInitInProgress;
    return:
      type: System.Boolean
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.GetChanges
  id: GetChanges
  parent: System.Data.DataTable
  langs:
  - csharp
  name: GetChanges()
  nameWithType: DataTable.GetChanges()
  fullName: System.Data.DataTable.GetChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает копию <xref href=&quot;System.Data.DataTable&quot;> </xref> , содержащую все изменения, внесенные после его загрузки или <xref:System.Data.DataTable.AcceptChanges*>последнего вызова.</xref:System.Data.DataTable.AcceptChanges*>"
  remarks: "Создает новый <xref:System.Data.DataSet>содержит копию всех строк в исходной коллекции <xref:System.Data.DataSet>, ожидающими изменениями.</xref:System.Data.DataSet> </xref:System.Data.DataSet> Ограничения отношений могут приводить дополнительные строки без изменений для добавления нового <xref:System.Data.DataSet>Если неизмененные строки содержат первичные ключи, соответствующие внешним ключам в измененных строках.</xref:System.Data.DataSet> Метод возвращает `null` (`Nothing` в Visual Basic), если нет ни одной строки в исходном <xref:System.Data.DataSet>с ожидающими изменениями.</xref:System.Data.DataSet>"
  example:
  - >-
    [!code-cs[Classic WebData DataTable.GetChanges Example#1](~/add/codesnippet/csharp/m-system.data.datatable._25_1.cs)]
     [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._25_1.vb)]
  syntax:
    content: public System.Data.DataTable GetChanges ();
    parameters: []
    return:
      type: System.Data.DataTable
      description: "Копия изменений класса <xref href=&quot;System.Data.DataTable&quot;> </xref>, или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если изменения не обнаружены."
  overload: System.Data.DataTable.GetChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.GetChanges(System.Data.DataRowState)
  id: GetChanges(System.Data.DataRowState)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: GetChanges(DataRowState)
  nameWithType: DataTable.GetChanges(DataRowState)
  fullName: System.Data.DataTable.GetChanges(DataRowState)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает копию <xref href=&quot;System.Data.DataTable&quot;> </xref> содержащую все изменения, внесенные с момента последней загрузки или после <xref:System.Data.DataTable.AcceptChanges*>был вызван, отфильтрованный по <xref href=&quot;System.Data.DataRowState&quot;> </xref>.</xref:System.Data.DataTable.AcceptChanges*>"
  remarks: "<xref:System.Data.DataTable.GetChanges%2A>Метод используется для создания второго <xref:System.Data.DataTable>объект, содержащий только изменения, появившиеся с оригинальным.</xref:System.Data.DataTable> </xref:System.Data.DataTable.GetChanges%2A> Используйте `rowStates` аргумент, чтобы указать тип изменений, должен содержать новый объект.       Ограничения связи могут вызвать без изменений родительских строк для включения."
  example:
  - >-
    [!code-cs[Classic WebData DataTable.GetChanges1 Example#1](~/add/codesnippet/csharp/m-system.data.datatable._15_1.cs)]
     [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._15_1.vb)]
  syntax:
    content: public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);
    parameters:
    - id: rowStates
      type: System.Data.DataRowState
      description: "Один из <xref href=&quot;System.Data.DataRowState&quot;> </xref> значения."
    return:
      type: System.Data.DataTable
      description: "Отфильтрованные копию <xref href=&quot;System.Data.DataTable&quot;> </xref> , это может привести к действиям, выполняемым на нем, а затем вернуть в <xref href=&quot;System.Data.DataTable&quot;> </xref> с помощью <xref:System.Data.DataSet.Merge*>.</xref:System.Data.DataSet.Merge*> Если строки с требуемым типом <xref href=&quot;System.Data.DataRowState&quot;> </xref> обнаружены, метод возвращает <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Data.DataTable.GetChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)
  id: GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: GetDataTableSchema(XmlSchemaSet)
  nameWithType: DataTable.GetDataTableSchema(XmlSchemaSet)
  fullName: System.Data.DataTable.GetDataTableSchema(XmlSchemaSet)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Этот метод возвращает <xref href=&quot;System.Xml.Schema.XmlSchemaSet&quot;> </xref> экземпляра, содержащего веб-служб языка (WSDL), описывающий <xref href=&quot;System.Data.DataTable&quot;> </xref> для веб-служб."
  syntax:
    content: public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);
    parameters:
    - id: schemaSet
      type: System.Xml.Schema.XmlSchemaSet
      description: "<xref href=&quot;System.Xml.Schema.XmlSchemaSet&quot;> </xref> Экземпляра."
    return:
      type: System.Xml.Schema.XmlSchemaComplexType
      description: "<xref href=&quot;System.Xml.Schema.XmlSchemaSet&quot;> </xref> Экземпляра."
  overload: System.Data.DataTable.GetDataTableSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.GetErrors
  id: GetErrors
  parent: System.Data.DataTable
  langs:
  - csharp
  name: GetErrors()
  nameWithType: DataTable.GetErrors()
  fullName: System.Data.DataTable.GetErrors()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Получает или задает массив <xref href=&quot;System.Data.DataRow&quot;> </xref> объектов, содержащих ошибки."
  remarks: "Возвращает список <xref:System.Data.DataRow>объекты, имеющие <xref:System.Data.DataRow.RowError%2A>Задайте.</xref:System.Data.DataRow.RowError%2A> </xref:System.Data.DataRow> Например, ошибки могут возникать при вызове <xref:System.Data.Common.DataAdapter.Update%2A>с <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>значение **true**.</xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> </xref:System.Data.Common.DataAdapter.Update%2A> Не вызывайте <xref:System.Data.DataTable.AcceptChanges%2A>на <xref:System.Data.DataTable>до устранить все ошибки и повторно отправьте <xref:System.Data.DataSet>для обновления.</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.DataTable.AcceptChanges%2A>"
  example:
  - "The following example uses the GetErrors method to return an array of <xref:System.Data.DataRow> objects that have errors.  \n  \n [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._18_1.vb)]\n [!code-cs[Classic WebData DataTable.GetErrors Example#1](~/add/codesnippet/csharp/m-system.data.datatable._18_1.cs)]"
  syntax:
    content: public System.Data.DataRow[] GetErrors ();
    parameters: []
    return:
      type: System.Data.DataRow[]
      description: "Массив <xref href=&quot;System.Data.DataRow&quot;> </xref> объекты с ошибками."
  overload: System.Data.DataTable.GetErrors*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: DataTable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataTable.GetObjectData(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Заполняет данными, необходимыми для сериализации объекта сведений сериализации <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  syntax:
    content: public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "Объект <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> объект, содержащий сериализованные данные, связанные с <xref href=&quot;System.Data.DataTable&quot;> </xref>."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "Объект <xref:System.Runtime.Serialization.StreamingContext>, содержащий источник и назначение сериализованного потока, связанного с <xref href=&quot;System.Data.DataTable&quot;> </xref>.</xref:System.Runtime.Serialization.StreamingContext>"
  overload: System.Data.DataTable.GetObjectData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code> info </code> Параметра является пустой ссылкой (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> в Visual Basic)."
  platform:
  - net462
- uid: System.Data.DataTable.GetRowType
  id: GetRowType
  parent: System.Data.DataTable
  langs:
  - csharp
  name: GetRowType()
  nameWithType: DataTable.GetRowType()
  fullName: System.Data.DataTable.GetRowType()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает тип строки."
  syntax:
    content: protected virtual Type GetRowType ();
    parameters: []
    return:
      type: System.Type
      description: "Возвращает тип <xref href=&quot;System.Data.DataRow&quot;> </xref>."
  overload: System.Data.DataTable.GetRowType*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.GetSchema
  id: GetSchema
  parent: System.Data.DataTable
  langs:
  - csharp
  name: GetSchema()
  nameWithType: DataTable.GetSchema()
  fullName: System.Data.DataTable.GetSchema()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Описание этого члена см. в разделе &lt;xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A?displayProperty=fullName&gt;."
  syntax:
    content: protected virtual System.Xml.Schema.XmlSchema GetSchema ();
    parameters: []
    return:
      type: System.Xml.Schema.XmlSchema
      description: "<xref:System.Xml.Schema.XmlSchema>, Описывающий XML-представление объекта, формируемого с <> </> *настроек метод и используемый <> </> *настроек метод.</xref:System.Xml.Schema.XmlSchema>"
  overload: System.Data.DataTable.GetSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.HasErrors
  id: HasErrors
  parent: System.Data.DataTable
  langs:
  - csharp
  name: HasErrors
  nameWithType: DataTable.HasErrors
  fullName: System.Data.DataTable.HasErrors
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает значение, указывающее, есть ли ошибки в любой из строк во всех таблицах с <xref href=&quot;System.Data.DataSet&quot;> </xref> , которой принадлежит таблица."
  remarks: "При работе на набор данных, содержащихся в <xref:System.Data.DataTable>, можно пометить каждое изменение с ошибкой, если оно вызывает сбой проверки.</xref:System.Data.DataTable> Вы можете пометить всей <xref:System.Data.DataRow>с ошибкой сообщение с помощью <xref:System.Data.DataRow.RowError%2A>свойство.</xref:System.Data.DataRow.RowError%2A> </xref:System.Data.DataRow> Ошибки можно также установить на каждый столбец строки с <xref:System.Data.DataRow.SetColumnError%2A>метод.</xref:System.Data.DataRow.SetColumnError%2A>       Перед обновлением источника данных <xref:System.Data.DataSet>рекомендуется сначала вызвать <xref:System.Data.DataSet.GetChanges%2A>метод на целевом сервере <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataSet.GetChanges%2A> </xref:System.Data.DataSet> В результате метод <xref:System.Data.DataSet>, содержащий только изменения, внесенные в исходный.</xref:System.Data.DataSet> Перед отправкой <xref:System.Data.DataSet>к источнику данных для обновления, проверьте свойство HasErrors каждой таблицы, чтобы увидеть, если любой ошибок для строк или столбцов в строках.</xref:System.Data.DataSet>       После согласования ошибок, очистить ошибки с <xref:System.Data.DataRow.ClearErrors%2A>метод `DataRow`.</xref:System.Data.DataRow.ClearErrors%2A>"
  example:
  - "The following example uses the HasErrors property to check if a table contains errors.  \n  \n [!code-cs[Classic WebData DataTable.HasErrors Example#1](~/add/codesnippet/csharp/p-system.data.datatable._8_1.cs)]\n [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._8_1.vb)]"
  syntax:
    content: public bool HasErrors { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если имеются ошибки; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Data.DataTable.HasErrors*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ImportRow(System.Data.DataRow)
  id: ImportRow(System.Data.DataRow)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ImportRow(DataRow)
  nameWithType: DataTable.ImportRow(DataRow)
  fullName: System.Data.DataTable.ImportRow(DataRow)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Копирует <xref href=&quot;System.Data.DataRow&quot;> </xref> в <xref href=&quot;System.Data.DataTable&quot;> </xref>, сохраняя все параметры свойств, а также исходные и текущие значения."
  remarks: "Вызов <xref:System.Data.DataTable.NewRow%2A>добавляет строку в таблицу, используя существующую схему таблицы, но со значениями по умолчанию для строки и задает <xref:System.Data.DataRowState>для `Detached`.</xref:System.Data.DataRowState> </xref:System.Data.DataTable.NewRow%2A> Вызов ImportRow сохраняет существующий <xref:System.Data.DataRowState>и другие значения в строке.</xref:System.Data.DataRowState> Если `DataRow` , передается как параметр находится в отсоединенном состоянии, учитывается, и исключение не возникает.       Новая строка добавляется в конец таблицы данных.       Если новая строка нарушает ограничение не будет добавлена в таблицу данных.       Индекс новой строки с DataTable.Rows.Find и DataTable.Rows.IndexOf можно получить. В разделе <xref:System.Data.DataRowCollection>и <xref:System.Data.DataTable.Rows%2A>Подробнее.</xref:System.Data.DataTable.Rows%2A> </xref:System.Data.DataRowCollection>"
  syntax:
    content: public void ImportRow (System.Data.DataRow row);
    parameters:
    - id: row
      type: System.Data.DataRow
      description: "<xref href=&quot;System.Data.DataRow&quot;> </xref> Для импорта."
  overload: System.Data.DataTable.ImportRow*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Initialized
  id: Initialized
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Initialized
  nameWithType: DataTable.Initialized
  fullName: System.Data.DataTable.Initialized
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Происходит после <xref href=&quot;System.Data.DataTable&quot;> </xref> инициализируется."
  remarks: "Дополнительные сведения см. в разделе <xref:System.Data.DataTable.IsInitialized%2A>.</xref:System.Data.DataTable.IsInitialized%2A>"
  syntax:
    content: public event EventHandler Initialized;
    return:
      type: System.EventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.IsInitialized
  id: IsInitialized
  parent: System.Data.DataTable
  langs:
  - csharp
  name: IsInitialized
  nameWithType: DataTable.IsInitialized
  fullName: System.Data.DataTable.IsInitialized
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает значение, указывающее, является ли <xref href=&quot;System.Data.DataTable&quot;> </xref> инициализируется."
  remarks: "Возвращает состояние <xref:System.Data.DataTable>пока она создана, например с помощью Visual Studio.</xref:System.Data.DataTable> <xref:System.Data.DataTable.BeginInit%2A>Задает метод для `false` и <xref:System.Data.DataTable.EndInit%2A>метод назначает ей `true`.</xref:System.Data.DataTable.EndInit%2A> </xref:System.Data.DataTable.BeginInit%2A>"
  syntax:
    content: public bool IsInitialized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы указывает, что компонент завершил инициализацию; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Data.DataTable.IsInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Load(System.Data.IDataReader)
  id: Load(System.Data.IDataReader)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Load(IDataReader)
  nameWithType: DataTable.Load(IDataReader)
  fullName: System.Data.DataTable.Load(IDataReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Заполняет <xref href=&quot;System.Data.DataTable&quot;> </xref> со значениями из источника данных с помощью предоставленного <xref href=&quot;System.Data.IDataReader&quot;> </xref>. Если <xref href=&quot;System.Data.DataTable&quot;> </xref> уже содержит строки, входящие данные из источника данных объединяется с существующие строки."
  remarks: "The Loadmethod consumes the first result set from the loaded <xref:System.Data.IDataReader>, and after successful completion, sets the reader's position to the next result set, if any. When converting data, the `Load` method uses the same conversion rules as the <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=fullName> method.  \n  \n The Load method must take into account three specific issues when loading the data from an <xref:System.Data.IDataReader> instance: schema, data, and event operations. When working with the schema, the Load method may encounter conditions as described in the following table. The schema operations take place for all imported result sets, even those containing no data.  \n  \n|Condition|Behavior|  \n|---------------|--------------|  \n|The <xref:System.Data.DataTable> has no schema.|The Load method infers the schema based on the result set from the imported <xref:System.Data.IDataReader>.|  \n|The <xref:System.Data.DataTable> has a schema, but it is incompatible with the loaded schema.|The Load method throws an exception corresponding to the particular error that occurs when attempting to load data into the incompatible schema.|  \n|The schemas are compatible, but the loaded result set schema contains columns that do not exist in the <xref:System.Data.DataTable>.|The Load method adds the extra columns to `DataTable`'s schema. The method throws an exception if corresponding columns in the <xref:System.Data.DataTable> and the loaded result set are not value compatible. The method also retrieves constraint information from the result set for all added columns. Except for the case of Primary Key constraint, this constraint information is used only if the current <xref:System.Data.DataTable> does not contain any columns at the start of the load operation.|  \n|The schemas are compatible, but the loaded result set schema contains fewer columns than does the `DataTable`.|If a missing column has a default value defined or the column's data type is nullable, the Load method allows the rows to be added, substituting the default or `null` value for the missing column. If no default value or `null` can be used, then the `Load` method throws an exception. If no specific default value has been supplied, the `Load` method uses the `null` value as the implied default value.|  \n  \n Before considering the behavior of the `Load` method in terms of data operations, consider that each row within a <xref:System.Data.DataTable> maintains both the current value and the original value for each column. These values may be equivalent, or may be different if the data in the row has been changed since filling the `DataTable`.  For more information, see [Row States and Row Versions](~/add/includes/ajax-current-ext-md.md).  \n  \n This version of the `Load` method attempts to preserve the current values in each row, leaving the original value intact. (If you want finer control over the behavior of incoming data, see <xref:System.Data.DataTable.Load%2A?displayProperty=fullName>.) If the existing row and the incoming row contain corresponding primary key values, the row is processed using its current row state value, otherwise it's treated as a new row.  \n  \n In terms of event operations, the <xref:System.Data.DataTable.RowChanging> event occurs before each row is changed, and the <xref:System.Data.DataTable.RowChanged> event occurs after each row has been changed. In each case, the <xref:System.Data.DataRowChangeEventArgs.Action%2A> property of the <xref:System.Data.DataRowChangeEventArgs> instance passed to the event handler contains information about the particular action associated with the event. This action value depends on the state of the row before the load operation. In each case, both events occur, and the action is the same for each. The action may be applied to either the current or original version of each row, or both, depending on the current row state.  \n  \n The following table displays behavior for the `Load` method. The final row (labeled \"(Not present)\") describes the behavior for incoming rows that don't match any existing row. Each cell in this table describes the current and original value for a field within a row, along with the <xref:System.Data.DataRowState> for the value after the `Load` method has completed. In this case, the method doesn't allow you to indicate the load option, and uses the default, `PreserveChanges`.  \n  \n|Existing DataRowState|Values after `Load` method, and event action|  \n|---------------------------|--------------------------------------------------|  \n|Added|Current = \\<Existing><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Modified><br /><br /> RowAction = ChangeOriginal|  \n|Modified|Current = \\<Existing><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Modified><br /><br /> RowAction = ChangeOriginal|  \n|Deleted|Current = \\<Not available><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Deleted><br /><br /> RowAction = ChangeOriginal|  \n|Unchanged|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|  \n|(Not present)|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|  \n  \n Values in a <xref:System.Data.DataColumn> can be constrained through use of properties such as <xref:System.Data.DataColumn.ReadOnly%2A> and <xref:System.Data.DataColumn.AutoIncrement%2A>. The `Load` method handles such columns in a manner that is consistent with the behavior defined by the column's properties. The read only constraint on a <xref:System.Data.DataColumn> is applicable only for changes that occur in memory. The `Load` method's overwrites the read-only column values, if needed.  \n  \n To determine which version of the primary key field to use for comparing the current row with an incoming row, the `Load` method uses the original version of the primary key value within a row, if it exists. Otherwise, the `Load` method uses the current version of the primary key field."
  example:
  - "The following example demonstrates several of the issues involved with calling the Load method. First, the example focuses on schema issues, including inferring a schema from the loaded <xref:System.Data.IDataReader>, and then handling incompatible schemas, and schemas with missing or additional columns. The example then calls the `Load` method, displaying the data both before and after the load operation.  \n  \n [!code-cs[DataWorks DataTableLoad.IDataReader#1](~/add/codesnippet/csharp/m-system.data.datatable._13_1.cs)]\n [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/add/codesnippet/visualbasic/m-system.data.datatable._13_1.vb)]"
  syntax:
    content: public void Load (System.Data.IDataReader reader);
    parameters:
    - id: reader
      type: System.Data.IDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref> , Предоставляющий набор результатов."
  overload: System.Data.DataTable.Load*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)
  id: Load(System.Data.IDataReader,System.Data.LoadOption)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Load(IDataReader,LoadOption)
  nameWithType: DataTable.Load(IDataReader,LoadOption)
  fullName: System.Data.DataTable.Load(IDataReader,LoadOption)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Заполняет <xref href=&quot;System.Data.DataTable&quot;> </xref> со значениями из источника данных с помощью предоставленного <xref href=&quot;System.Data.IDataReader&quot;> </xref>. Если <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref> уже содержит строки, входящие данные из источника данных объединяется с существующими строками согласно значению <code> loadOption </code> параметра."
  remarks: "The `Load` method consumes the first result set from the loaded <xref:System.Data.IDataReader>, and after successful completion, sets the reader's position to the next result set, if any. When converting data, the `Load` method uses the same conversion rules as the <xref:System.Data.Common.DbDataAdapter.Fill%2A> method.  \n  \n The `Load` method must take into account three specific issues when loading the data from an <xref:System.Data.IDataReader> instance: schema, data, and event operations. When working with the schema, the `Load` method may encounter conditions as described in the following table. The schema operations take place for all imported result sets, even those containing no data.  \n  \n|Condition|Behavior|  \n|---------------|--------------|  \n|The <xref:System.Data.DataTable> has no schema.|The `Load` method infers the schema based on the result set from the imported <xref:System.Data.IDataReader>.|  \n|The <xref:System.Data.DataTable> has a schema, but it is incompatible with the loaded schema.|The `Load` method throws an exception corresponding to the particular error that occurs when attempting to load data into the incompatible schema.|  \n|The schemas are compatible, but the loaded result set schema contains columns that don't exist in the `DataTable`.|The `Load` method adds the extra columns to `DataTable`’s schema. The method throws an exception if corresponding columns in the <xref:System.Data.DataTable> and the loaded result set are not value compatible. The method also retrieves constraint information from the result set for all added columns. Except for the case of Primary Key constraint, this constraint information is used only if the current <xref:System.Data.DataTable> does not contain any columns at the start of the load operation.|  \n|The schemas are compatible, but the loaded result set schema contains fewer columns than does the `DataTable`.|If a missing column has a default value defined or the column's data type is nullable, the `Load` method allows the rows to be added, substituting the default or null value for the missing column. If no default value or null can be used, then the `Load` method throws an exception. If no specific default value has been supplied, the `Load` method uses the null value as the implied default value.|  \n  \n Before considering the behavior of the `Load` method in terms of data operations, consider that each row within a <xref:System.Data.DataTable> maintains both the current value and the original value for each column. These values may be equivalent, or may be different if the data in the row has been changed since filling the `DataTable`. See [Row States and Row Versions](~/add/includes/ajax-current-ext-md.md) for more information.  \n  \n In this method call, the specified <xref:System.Data.LoadOption> parameter influences the processing of the incoming data. How should the Load method handle loading rows that have the same primary key as existing rows? Should it modify current values, original values, or both? These issues, and more, are controlled by the `loadOption` parameter.  \n  \n If the existing row and the incoming row contain corresponding primary key values, the row is processed using its current row state value, otherwise it's treated as a new row.  \n  \n In terms of event operations, the <xref:System.Data.DataTable.RowChanging> event occurs before each row is changed, and the <xref:System.Data.DataTable.RowChanged> event occurs after each row has been changed. In each case, the <xref:System.Data.DataRowChangeEventArgs.Action%2A> property of the <xref:System.Data.DataRowChangeEventArgs> instance passed to the event handler contains information about the particular action associated with the event. This action value varies, depending on the state of the row before the load operation. In each case, both events occur, and the action is the same for each. The action may be applied to either the current or original version of each row, or both, depending on the current row state.  \n  \n The following table displays behavior for the Load method when called with each of the `LoadOption` values, and also shows how the values interact with the row state for the row being loaded. The final row (labeled \"(Not present)\") describes the behavior for incoming rows that don't match any existing row. Each cell in this table describes the current and original value for a field within a row, along with the <xref:System.Data.DataRowState> for the value after the `Load` method has completed.  \n  \n|Existing DataRowState|Upsert|OverwriteChanges|PreserveChanges (Default behavior)|  \n|---------------------------|------------|----------------------|------------------------------------------|  \n|Added|Current = \\<Incoming><br /><br /> Original = -\\<Not available><br /><br /> State = \\<Added><br /><br /> RowAction = Change|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Existing><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Modified><br /><br /> RowAction = ChangeOriginal|  \n|Modified|Current = \\<Incoming><br /><br /> Original = \\<Existing><br /><br /> State = \\<Modified><br /><br /> RowAction = Change|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Existing><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Modified><br /><br /> RowAction =ChangeOriginal|  \neleted|(Load does not affect deleted rows)<br /><br /> Current = ---<br /><br /> Original = \\<Existing><br /><br /> State = \\<Deleted><br /><br /> (New row is added with the following characteristics)<br /><br /> Current = \\<Incoming><br /><br /> Original = \\<Not available><br /><br /> State = \\<Added><br /><br /> RowAction = Add|Undo delete and<br /><br /> Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Not available><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Deleted><br /><br /> RowAction = ChangeOriginal|  \n|Unchanged|Current = \\<Incoming><br /><br /> Original = \\<Existing><br /><br /> If new value is the same as the existing value then<br /><br /> State = \\<Unchanged><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> State = \\<Modified><br /><br /> RowAction = Change|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|  \nNot present)|Current = \\<Incoming><br /><br /> Original = \\<Not available><br /><br /> State = \\<Added><br /><br /> RowAction = Add|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|  \n  \n Values in a <xref:System.Data.DataColumn> can be constrained through use of properties such as <xref:System.Data.DataColumn.ReadOnly%2A> and <xref:System.Data.DataColumn.AutoIncrement%2A>. The `Load` method handles such columns in a manner that is consistent with the behavior defined by the column's properties. The read only constraint on a <xref:System.Data.DataColumn> is applicable only for changes that occur in memory. The `Load` method's overwrites the read-only column values, if needed.  \n  \n If you specify the OverwriteChanges or PreserveChanges options when calling the `Load` method, then the assumption is made that the incoming data is coming from the `DataTable`'s primary data source, and the DataTable tracks changes and can propagate the changes back to the data source. If you select the Upsert option, it is assumed that the data is coming from one of a secondary data source, such as data provided by a middle-tier component, perhaps altered by a user. In this case, the assumption is that the intent is to aggregate data from one or more data sources in the `DataTable`, and then perhaps propagate the data back to the primary data source. The <xref:System.Data.LoadOption> parameter is used for determining the specific version of the row that is to be used for primary key comparison. The table below provides the details.  \n  \n|Load option|DataRow version used for primary key comparison|  \n|-----------------|-----------------------------------------------------|  \n|`OverwriteChanges`|Original version, if it exists, otherwise Current version|  \n|`PreserveChanges`|Original version, if it exists, otherwise Current version|  \n|`Upsert`|Current version, if it exists, otherwise Original version|"
  example:
  - "The following example demonstrates several of the issues involved with calling the Load method. First, the example focuses on schema issues, including inferring a schema from the loaded <xref:System.Data.IDataReader>, and then handling incompatible schemas, and schemas with missing or additional columns. The example then focuses on data issues, including handling the various loading options.  \n  \n [!code-cs[DataWorks DataTableLoad.LoadOption#1](~/add/codesnippet/csharp/m-system.data.datatable._29_1.cs)]\n [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/add/codesnippet/visualbasic/m-system.data.datatable._29_1.vb)]"
  syntax:
    content: public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);
    parameters:
    - id: reader
      type: System.Data.IDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref> , Предоставляющий один или несколько результирующих наборов."
    - id: loadOption
      type: System.Data.LoadOption
      description: "Значение из <xref href=&quot;System.Data.LoadOption&quot;> </xref> перечисление, указывающее, как строки уже <xref href=&quot;System.Data.DataTable&quot;> </xref> вместе с входящих строк, которые совместно используют один и тот же первичный ключ."
  overload: System.Data.DataTable.Load*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)
  id: Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Load(IDataReader,LoadOption,FillErrorEventHandler)
  nameWithType: DataTable.Load(IDataReader,LoadOption,FillErrorEventHandler)
  fullName: System.Data.DataTable.Load(IDataReader,LoadOption,FillErrorEventHandler)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Заполняет <xref href=&quot;System.Data.DataTable&quot;> </xref> со значениями из источника данных с помощью предоставленного <xref href=&quot;System.Data.IDataReader&quot;> </xref> с помощью делегата обработки ошибок."
  remarks: "The `Load` method consumes the first result set from the loaded <xref:System.Data.IDataReader>, and after successful completion, sets the reader's position to the next result set, if any. When converting data, the `Load` method uses the same conversion rules as the <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=fullName> method.  \n  \n The `Load` method must take into account three specific issues when loading the data from an <xref:System.Data.IDataReader> instance: schema, data, and event operations. When working with the schema, the `Load` method may encounter conditions as described in the following table. The schema operations take place for all imported result sets, even those containing no data.  \n  \n|Condition|Behavior|  \n|---------------|--------------|  \n|The <xref:System.Data.DataTable> has no schema.|The `Load` method infers the schema based on the result set from the imported <xref:System.Data.IDataReader>.|  \n|The <xref:System.Data.DataTable> has a schema, but it is incompatible with the loaded schema.|The `Load` method throws an exception corresponding to the particular error that occurs when attempting to load data into the incompatible schema.|  \n|The schemas are compatible, but the loaded result set schema contains columns that don't exist in the `DataTable`.|The `Load` method adds the extra column(s) to `DataTable`’s schema. The method throws an exception if corresponding columns in the <xref:System.Data.DataTable> and the loaded result set are not value compatible. The method also retrieves constraint information from the result set for all added columns. Except for the case of Primary Key constraint, this constraint information is used only if the current <xref:System.Data.DataTable> does not contain any columns at the start of the load operation.|  \n|The schemas are compatible, but the loaded result set schema contains fewer columns than does the `DataTable`.|If a missing column has a default value defined or the column's data type is nullable, the `Load` method allows the rows to be added, substituting the default or null value for the missing column. If no default value or null can be used, then the `Load` method throws an exception. If no specific default value has been supplied, the `Load` method uses the null value as the implied default value.|  \n  \n Before considering the behavior of the `Load` method in terms of data operations, consider that each row within a <xref:System.Data.DataTable> maintains both the current value and the original value for each column. These values may be equivalent, or may be different if the data in the row has been changed since filling the `DataTable`. See [Row States and Row Versions](~/add/includes/ajax-current-ext-md.md) for more information.  \n  \n In this method call, the specified <xref:System.Data.LoadOption> parameter influences the processing of the incoming data. How should the Load method handle loading rows that have the same primary key as existing rows? Should it modify current values, original values, or both? These issues, and more, are controlled by the `loadOption` parameter.  \n  \n If the existing row and the incoming row contain corresponding primary key values, the row is processed using its current row state value, otherwise it's treated as a new row.  \n  \n In terms of event operations, the <xref:System.Data.DataTable.RowChanging> event occurs before each row is changed, and the <xref:System.Data.DataTable.RowChanged> event occurs after each row has been changed. In each case, the <xref:System.Data.DataRowChangeEventArgs.Action%2A> property of the <xref:System.Data.DataRowChangeEventArgs> instance passed to the event handler contains information about the particular action associated with the event. This action value varies, depending on the state of the row before the load operation. In each case, both events occur, and the action is the same for each. The action may be applied to either the current or original version of each row, or both, depending on the current row state.  \n  \n The following table displays behavior for the Load method when called with each of the `LoadOption` values, and also shows how the values interact with the row state for the row being loaded. The final row (labeled \"(Not present)\") describes the behavior for incoming rows that don't match any existing row. Each cell in this table describes the current and original value for a field within a row, along with the <xref:System.Data.DataRowState> for the value after the `Load` method has completed.  \n  \n|Existing DataRowState|Upsert|OverwriteChanges|PreserveChanges (Default behavior)|  \n|---------------------------|------------|----------------------|------------------------------------------|  \n|Added|Current = \\<Incoming><br /><br /> Original = -\\<Not available><br /><br /> State = \\<Added><br /><br /> RowAction = Change|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Existing><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Modified><br /><br /> RowAction = ChangeOriginal|  \n|Modified|Current = \\<Incoming><br /><br /> Original = \\<Existing><br /><br /> State = \\<Modified><br /><br /> RowAction = Change|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Existing><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Modified><br /><br /> RowAction =ChangeOriginal|  \neleted|(Load does not affect deleted rows)<br /><br /> Current = ---<br /><br /> Original = \\<Existing><br /><br /> State = \\<Deleted><br /><br /> (New row is added with the following characteristics)<br /><br /> Current = \\<Incoming><br /><br /> Original = \\<Not available><br /><br /> State = \\<Added><br /><br /> RowAction = Add|Undo delete and<br /><br /> Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Not available><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Deleted><br /><br /> RowAction = ChangeOriginal|  \n|Unchanged|Current = \\<Incoming><br /><br /> Original = \\<Existing><br /><br /> If new value is the same as the existing value then<br /><br /> State = \\<Unchanged><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> State = \\<Modified><br /><br /> RowAction = Change|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|  \nNot present)|Current = \\<Incoming><br /><br /> Original = \\<Not available><br /><br /> State = \\<Added><br /><br /> RowAction = Add|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|Current = \\<Incoming><br /><br /> Original = \\<Incoming><br /><br /> State = \\<Unchanged><br /><br /> RowAction = ChangeCurrentAndOriginal|  \n  \n Values in a <xref:System.Data.DataColumn> can be constrained through use of properties such as <xref:System.Data.DataColumn.ReadOnly%2A> and <xref:System.Data.DataColumn.AutoIncrement%2A>. The `Load` method handles such columns in a manner that is consistent with the behavior defined by the column's properties. The read only constraint on a <xref:System.Data.DataColumn> is applicable only for changes that occur in memory. The `Load` method's overwrites the read-only column values, if needed.  \n  \n If you specify the OverwriteChanges or PreserveChanges options when calling the `Load` method, then the assumption is made that the incoming data is coming from the `DataTable`'s primary data source, and the DataTable tracks changes and can propagate the changes back to the data source. If you select the Upsert option, it is assumed that the data is coming from one of a secondary data source, such as data provided by a middle-tier component, perhaps altered by a user. In this case, the assumption is that the intent is to aggregate data from one or more data sources in the `DataTable`, and then perhaps propagate the data back to the primary data source. The <xref:System.Data.LoadOption> parameter is used for determining the specific version of the row that is to be used for primary key comparison. The table below provides the details.  \n  \n|Load option|DataRow version used for primary key comparison|  \n|-----------------|-----------------------------------------------------|  \n|`OverwriteChanges`|Original version, if it exists, otherwise Current version|  \n|`PreserveChanges`|Original version, if it exists, otherwise Current version|  \n|`Upsert`|Current version, if it exists, otherwise Original version|  \n  \n The `errorHandler` parameter is a <xref:System.Data.FillErrorEventHandler> delegate that refers to a procedure that is called when an error occurs while loading data. The <xref:System.Data.FillErrorEventArgs> parameter passed to the procedure provides properties that allow you to retrieve information about the error that occurred, the current row of data, and the <xref:System.Data.DataTable> being filled. Using this delegate mechanism, rather than a simpler try/catch block, allows you to determine the error, handle the situation, and continue processing if you like. The <xref:System.Data.FillErrorEventArgs> parameter supplies a <xref:System.Data.FillErrorEventArgs.Continue%2A> property: set this property to `true` to indicate that you have handled the error and wish to continue processing. Set the property to `false` to indicate that you wish to halt processing. Be aware that setting the property to `false` causes the code that triggered the problem to throw an exception."
  example:
  - >-
    [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/add/codesnippet/visualbasic/e9f1029e-2520-490c-8397-_1.vb)]
     [!code-cs[DataWorks DataTableLoad.ErrorEventHandler#1](~/add/codesnippet/csharp/e9f1029e-2520-490c-8397-_1.cs)]
  syntax:
    content: public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);
    parameters:
    - id: reader
      type: System.Data.IDataReader
      description: "Объект <xref href=&quot;System.Data.IDataReader&quot;> </xref> , предоставляющий набор результатов."
    - id: loadOption
      type: System.Data.LoadOption
      description: "Значение из <xref href=&quot;System.Data.LoadOption&quot;> </xref> перечисление, указывающее, как строки уже <xref href=&quot;System.Data.DataTable&quot;> </xref> вместе с входящих строк, которые совместно используют один и тот же первичный ключ."
    - id: errorHandler
      type: System.Data.FillErrorEventHandler
      description: "Объект <xref href=&quot;System.Data.FillErrorEventHandler&quot;> </xref> делегат, который вызывается при возникновении ошибки во время загрузки данных."
  overload: System.Data.DataTable.Load*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)
  id: LoadDataRow(System.Object[],System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: LoadDataRow(Object[],Boolean)
  nameWithType: DataTable.LoadDataRow(Object[],Boolean)
  fullName: System.Data.DataTable.LoadDataRow(Object[],Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Находит и обновляет конкретную строку. Если найдена подходящая строка не найдена, новая строка создается с использованием заданных значений."
  remarks: "Метод LoadDataRow принимает массив значений и находит соответствующие значения в столбцы первичного ключа.       Если столбец содержит значение по умолчанию, необходимо передайте значение null в массиве, чтобы задать значение по умолчанию для этого столбца. Аналогично Если в столбце его <xref:System.Data.DataColumn.AutoIncrement%2A>установлено значение true, передать значение null в массив для установки автоматически сформированное значение для строки.</xref:System.Data.DataColumn.AutoIncrement%2A>       Если `fAcceptChanges` параметр `true` или не указан, добавления новых данных и затем <xref:System.Data.DataTable.AcceptChanges%2A>вызывается, чтобы применить все изменения в <xref:System.Data.DataTable>; Если аргумент является `false`, только что добавленных строк, помечаются как операции вставки и изменения существующих строк, помечаются как изменения.</xref:System.Data.DataTable> </xref:System.Data.DataTable.AcceptChanges%2A>       Исключения могут также возникнуть в <xref:System.Data.DataTable.ColumnChanging>или <xref:System.Data.DataTable.RowChanging>событий.</xref:System.Data.DataTable.RowChanging> </xref:System.Data.DataTable.ColumnChanging> При возникновении исключения, строка не добавляется в таблицу.       Используется совместно с <xref:System.Data.DataTable.BeginLoadData%2A>и <xref:System.Data.DataTable.EndLoadData%2A>.</xref:System.Data.DataTable.EndLoadData%2A> </xref:System.Data.DataTable.BeginLoadData%2A> LoadDataRow"
  example:
  - "The following example uses the LoadDataRow method to attempt to find a row. If no such row is found, the values are used to create a new row.  \n  \n [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._23_1.vb)]\n [!code-cs[Classic WebData DataTable.LoadDataRow Example#1](~/add/codesnippet/csharp/m-system.data.datatable._23_1.cs)]"
  syntax:
    content: public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);
    parameters:
    - id: values
      type: System.Object[]
      description: "Массив значений, используемых для создания новой строки."
    - id: fAcceptChanges
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы принять изменения. в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Data.DataRow
      description: "The new <xref href=&quot;System.Data.DataRow&quot;></xref>."
  overload: System.Data.DataTable.LoadDataRow*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Массив не должен превышать количество столбцов в таблице."
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "Значение не соответствует соответствующему типу столбца."
  - type: System.Data.ConstraintException
    commentId: T:System.Data.ConstraintException
    description: "Добавление строки нарушает ограничение."
  - type: System.Data.NoNullAllowedException
    commentId: T:System.Data.NoNullAllowedException
    description: "Попытка задать значение null в столбце где <xref:System.Data.DataColumn.AllowDBNull*>имеет значение false.</xref:System.Data.DataColumn.AllowDBNull*>"
  platform:
  - net462
- uid: System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)
  id: LoadDataRow(System.Object[],System.Data.LoadOption)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: LoadDataRow(Object[],LoadOption)
  nameWithType: DataTable.LoadDataRow(Object[],LoadOption)
  fullName: System.Data.DataTable.LoadDataRow(Object[],LoadOption)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Находит и обновляет конкретную строку. Если найдена подходящая строка не найдена, новая строка создается с использованием заданных значений."
  remarks: "<xref:System.Data.DataTable.LoadDataRow%2A>Метод принимает массив значений и находит соответствующие значения в столбцы первичного ключа.</xref:System.Data.DataTable.LoadDataRow%2A>       Если столбец содержит значение по умолчанию, необходимо передайте значение null в массиве, чтобы задать значение по умолчанию для этого столбца. Аналогично Если в столбце его <xref:System.Data.DataColumn.AutoIncrement%2A>установлено значение true, передать значение null в массив для установки автоматически сформированное значение для строки.</xref:System.Data.DataColumn.AutoIncrement%2A>       Значение `loadOption` параметр используется для определения способа применения значения в массиве в существующую строку. Например если `loadOption` равно `OverwriteChanges`, `Original` и `Current` значения каждого столбца заменяются значениями из входящей строки и `RowState` свойству `Unchanged`.       Исключения могут также возникнуть в <xref:System.Data.DataTable.ColumnChanging>или <xref:System.Data.DataTable.RowChanging>событий.</xref:System.Data.DataTable.RowChanging> </xref:System.Data.DataTable.ColumnChanging> При возникновении исключения, строка не добавляется в таблицу.       Использовать <xref:System.Data.DataTable.LoadDataRow%2A>в сочетании с <xref:System.Data.DataTable.BeginLoadData%2A>и <xref:System.Data.DataTable.EndLoadData%2A>.</xref:System.Data.DataTable.EndLoadData%2A> </xref:System.Data.DataTable.BeginLoadData%2A> </xref:System.Data.DataTable.LoadDataRow%2A>"
  syntax:
    content: public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);
    parameters:
    - id: values
      type: System.Object[]
      description: "Массив значений, используемых для создания новой строки."
    - id: loadOption
      type: System.Data.LoadOption
      description: "Используется для определения того, как значения массива применяются соответствующие значения в существующую строку."
    return:
      type: System.Data.DataRow
      description: "The new <xref href=&quot;System.Data.DataRow&quot;></xref>."
  overload: System.Data.DataTable.LoadDataRow*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Locale
  id: Locale
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Locale
  nameWithType: DataTable.Locale
  fullName: System.Data.DataTable.Locale
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает или задает сведения о языке, используемые для сравнения строк в таблице."
  remarks: "Объект <xref:System.Globalization.CultureInfo>представляет программные настройки конкретного языка и региональных параметров или community.</xref:System.Globalization.CultureInfo>       При сравнении строк <xref:System.Globalization.CultureInfo>влияет на сортировки и сравнения и фильтрации.</xref:System.Globalization.CultureInfo>      Настроек [!NOTE] настроек в столбцах, содержащих выражения, <xref:System.StringComparison>используется.</xref:System.StringComparison> <xref:System.StringComparison>Игнорируется.</xref:System.StringComparison>"
  example:
  - "The following example sets the <xref:System.Globalization.CultureInfo> through the Locale and prints the ISO language name.  \n  \n [!code-cs[Classic WebData DataTable.Locale Example#1](~/add/codesnippet/csharp/p-system.data.datatable._5_1.cs)]\n [!code-vb[Classic WebData DataTable.Locale Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._5_1.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo Locale { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "Объект <xref:System.Globalization.CultureInfo>, содержащий данные о языковой стандарт пользователя компьютера.</xref:System.Globalization.CultureInfo> Значение по умолчанию — <xref href=&quot;System.Data.DataSet&quot;> </xref> объекта <xref:System.Globalization.CultureInfo>(возвращенный <xref:System.Data.DataSet.Locale*>свойство) к которому <xref href=&quot;System.Data.DataTable&quot;> </xref> принадлежит; Если не принадлежит таблице <xref href=&quot;System.Data.DataSet&quot;> </xref>, значение по умолчанию — текущая система <xref:System.Globalization.CultureInfo>.</xref:System.Globalization.CultureInfo> </xref:System.Data.DataSet.Locale*> </xref:System.Globalization.CultureInfo>"
  overload: System.Data.DataTable.Locale*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Merge(System.Data.DataTable)
  id: Merge(System.Data.DataTable)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Merge(DataTable)
  nameWithType: DataTable.Merge(DataTable)
  fullName: System.Data.DataTable.Merge(DataTable)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Слияние указанного <xref href=&quot;System.Data.DataTable&quot;> </xref> с текущим <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  remarks: "Метод Merge используется для объединения двух <xref:System.Data.DataTable>объекты, которые во многом аналогично схемами.</xref:System.Data.DataTable> Слияние с данными обычно используется для включения последних изменений из источника данных в существующий <xref:System.Data.DataTable>.</xref:System.Data.DataTable> на клиентское приложение Это позволяет клиентскому приложению обновлять <xref:System.Data.DataTable>последние данные из источника данных.</xref:System.Data.DataTable>       Операция слияния принимает во внимание только исходная таблица и объединяемая таблица. Дочерние таблицы не влияет и не включены. Если таблица содержит один или несколько дочерних таблиц, определенных как часть отношения, каждая дочерняя таблица должны быть объединены по отдельности.       `Merge` Метод обычно вызывается в конце серии процедур, включающей проверку изменений, согласование ошибок, обновление источника данных с учетом изменений и наконец обновление существующего <xref:System.Data.DataTable>.</xref:System.Data.DataTable>       При выполнении слияния, изменения, внесенные в существующие данные до слияния, сохраняются по умолчанию во время операции слияния. Разработчики могут изменить это поведение, путем вызова одного из двух других перегрузок данного метода и указав значение false для `preserveChanges` параметра.       В клиентском приложении обычно существует одна кнопка, которой пользователь может щелкнуть собрать измененные данные и проверить их перед отправкой назад в компонент среднего уровня. В этом сценарии <xref:System.Data.DataTable.GetChanges%2A>сначала вызывается метод.</xref:System.Data.DataTable.GetChanges%2A> Метод возвращает второй <xref:System.Data.DataTable>оптимизированный для проверки и слияния.</xref:System.Data.DataTable> Этот второй <xref:System.Data.DataTable>объект содержит <xref:System.Data.DataRow>объекты, которые были изменены, возникающие в подмножестве исходного <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataRow> </xref:System.Data.DataTable> Это подмножество обычно меньше и поэтому более эффективно передается обратно в компонент среднего уровня. Затем компонент среднего уровня обновляет исходный источник данных изменениями с помощью хранимых процедур. Средний уровень может отправить назад либо новый <xref:System.Data.DataTable>с исходными данными и последними данными из источника данных (повторив исходный запрос), или он может отправить обратно подмножество с любыми изменениями, внесенными в него из источника данных.</xref:System.Data.DataTable> (Например, если источник данных автоматически создает уникальные значения первичного ключа, эти значения могут передаваться обратно в клиентское приложение.) В любом случае возвращаемый <xref:System.Data.DataTable>могут быть объединены обратно в исходный клиентское приложение <xref:System.Data.DataTable>при использовании метода Merge.</xref:System.Data.DataTable> </xref:System.Data.DataTable>       При слиянии нового источника <xref:System.Data.DataTable>и конечного объекта исходные строки со <xref:System.Data.DataRowState>значение `Unchanged`, `Modified`, или `Deleted`, сопоставляется с конечным строкам и имеют те же значения первичного ключа.</xref:System.Data.DataRowState> </xref:System.Data.DataTable> Исходные строки со <xref:System.Data.DataRowState>значение `Added` сопоставляются с новым конечным строкам с теми же значениями первичного ключа, как новые исходные строки.</xref:System.Data.DataRowState>"
  example:
  - "The following console application creates a simple <xref:System.Data.DataTable> and adds data to the table. The example then creates a copy of the table, adding rows to the copy. Finally, the example calls the Merge method to merge the data in the second table with the data in the first table.  \n  \n [!code-vb[DataWorks DataTable.Merge#1](~/add/codesnippet/visualbasic/m-system.data.datatable._4_1.vb)]\n [!code-cs[DataWorks DataTable.Merge#1](~/add/codesnippet/csharp/m-system.data.datatable._4_1.cs)]"
  syntax:
    content: public void Merge (System.Data.DataTable table);
    parameters:
    - id: table
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref> Необходимо объединить с текущим <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  overload: System.Data.DataTable.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)
  id: Merge(System.Data.DataTable,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Merge(DataTable,Boolean)
  nameWithType: DataTable.Merge(DataTable,Boolean)
  fullName: System.Data.DataTable.Merge(DataTable,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Слияние указанного <xref href=&quot;System.Data.DataTable&quot;> </xref> с текущим <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>, указывающее, следует ли сохранить изменения в текущем <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>."
  remarks: "Метод Merge используется для объединения двух <xref:System.Data.DataTable>объекты, которые во многом аналогично схемами.</xref:System.Data.DataTable> Слияние с данными обычно используется для включения последних изменений из источника данных в существующий <xref:System.Data.DataTable>.</xref:System.Data.DataTable> на клиентское приложение Это позволяет клиентскому приложению обновлять <xref:System.Data.DataTable>последние данные из источника данных.</xref:System.Data.DataTable>       Операция слияния принимает во внимание только исходная таблица и объединяемая таблица. Дочерние таблицы не влияет и не включены. Если таблица содержит один или несколько дочерних таблиц, определенных как часть отношения, каждая дочерняя таблица должны быть объединены по отдельности.       `Merge` Метод обычно вызывается в конце серии процедур, включающей проверку изменений, согласование ошибок, обновление источника данных с учетом изменений и наконец обновление существующего <xref:System.Data.DataTable>.</xref:System.Data.DataTable>       При выполнении слияния, изменения, внесенные в существующие данные до слияния, сохраняются при слиянии, если только значение &quot;false&quot; для `preserveChanges` параметра. Если `preserveChanges` параметр имеет значение `true`, входные значения не переопределяют существующие значения в версии Current существующей строки. Если `preserveChanges` параметр имеет значение `false`, входные значения переопределяют существующие значения в версии Current существующей строки. Дополнительные сведения о версиях строк см. в разделе [состояния строк и версии строк](~/add/includes/ajax-current-ext-md.md).       В клиентском приложении обычно существует одна кнопка, которой пользователь может щелкнуть собрать измененные данные и проверить их перед отправкой назад в компонент среднего уровня. В этом сценарии <xref:System.Data.DataTable.GetChanges%2A>сначала вызывается метод.</xref:System.Data.DataTable.GetChanges%2A> Метод возвращает второй <xref:System.Data.DataTable>оптимизированный для проверки и слияния.</xref:System.Data.DataTable> Этот второй <xref:System.Data.DataTable>объект содержит только <xref:System.Data.DataTable>и <xref:System.Data.DataRow>объекты, которые были изменены, возникающие в подмножестве исходного <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataRow> </xref:System.Data.DataTable> </xref:System.Data.DataTable> Это подмножество обычно меньше и поэтому это подмножество более эффективно передается обратно в компонент среднего уровня. Затем компонент среднего уровня обновляет исходный источник данных изменениями с помощью хранимых процедур. Средний уровень может отправить назад либо новый <xref:System.Data.DataTable>с исходными данными и последними данными из источника данных (повторив исходный запрос), или он может отправить обратно подмножество с любыми изменениями, внесенными в него из источника данных.</xref:System.Data.DataTable> (Например, если источник данных автоматически создает уникальные значения первичного ключа, эти значения могут передаваться обратно в клиентское приложение.) В любом случае возвращаемый <xref:System.Data.DataTable>могут быть объединены обратно в исходный клиентское приложение <xref:System.Data.DataTable>с <xref:System.Data.DataTable.Merge%2A>метод.</xref:System.Data.DataTable.Merge%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable>       При слиянии нового источника <xref:System.Data.DataTable>и конечного объекта исходные строки со <xref:System.Data.DataRowState>значение `Unchanged`, `Modified`, или `Deleted` сопоставляются с конечным строкам и имеют те же значения первичного ключа.</xref:System.Data.DataRowState> </xref:System.Data.DataTable> Исходные строки со <xref:System.Data.DataRowState>значение `Added` сопоставляются с новым конечным строкам с теми же значениями первичного ключа, как новые исходные строки.</xref:System.Data.DataRowState>"
  example:
  - "The following console application creates a <xref:System.Data.DataTable> containing rows, modifies some of the data in those rows, and attempts to merge data from a different <xref:System.Data.DataTable>. The example demonstrates the different behaviors for the `preserveChanges` parameter.  \n  \n [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/add/codesnippet/visualbasic/m-system.data.datatable._2_1.vb)]\n [!code-cs[DataWorks DataTable.MergePreserveChanges#1](~/add/codesnippet/csharp/m-system.data.datatable._2_1.cs)]"
  syntax:
    content: public void Merge (System.Data.DataTable table, bool preserveChanges);
    parameters:
    - id: table
      type: System.Data.DataTable
      description: "<xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref> Необходимо объединить с текущим <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>."
    - id: preserveChanges
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>, чтобы сохранить изменения в текущем <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.<xref uid=&quot;langword_csharp_&quot; name=&quot;&quot; href=&quot;&quot;></xref>"
  overload: System.Data.DataTable.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  id: Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Merge(DataTable,Boolean,MissingSchemaAction)
  nameWithType: DataTable.Merge(DataTable,Boolean,MissingSchemaAction)
  fullName: System.Data.DataTable.Merge(DataTable,Boolean,MissingSchemaAction)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Слияние указанного <xref href=&quot;System.Data.DataTable&quot;> </xref> с текущим <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>, указывающее, следует ли сохранить изменения и способ обработки отсутствующей схемы в текущем <xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>."
  remarks: "`Merge` Метод используется для объединения двух <xref:System.Data.DataTable>объекты, которые во многом аналогично схемами.</xref:System.Data.DataTable> Слияние с данными обычно используется для включения последних изменений из источника данных в существующий <xref:System.Data.DataTable>.</xref:System.Data.DataTable> на клиентское приложение Это позволяет клиентскому приложению обновлять <xref:System.Data.DataTable>последние данные из источника данных.</xref:System.Data.DataTable>       Операция слияния принимает во внимание только исходная таблица и объединяемая таблица. Дочерние таблицы не влияет и не включены. Если таблица содержит один или несколько дочерних таблиц, определенных как часть отношения, каждая дочерняя таблица должны быть объединены по отдельности.       `Merge` Метод обычно вызывается в конце серии процедур, включающей проверку изменений, согласование ошибок, обновление источника данных с учетом изменений и наконец обновление существующего <xref:System.Data.DataTable>.</xref:System.Data.DataTable>       При выполнении слияния, изменения, внесенные в существующие данные до слияния, сохраняются при слиянии, если только значение &quot;false&quot; для `preserveChanges` параметра. Если `preserveChanges` параметр имеет значение `true`, входные значения не переопределяют существующие значения в версии Current существующей строки. Если `preserveChanges` параметр имеет значение `false`, входные значения переопределяют существующие значения в версии Current существующей строки. Дополнительные сведения о версиях строк см. в разделе [состояния строк и версии строк](~/add/includes/ajax-current-ext-md.md).       В клиентском приложении обычно существует одна кнопка, которой пользователь может щелкнуть собрать измененные данные и проверить их перед отправкой назад в компонент среднего уровня. В этом сценарии <xref:System.Data.DataTable.GetChanges%2A>сначала вызывается метод.</xref:System.Data.DataTable.GetChanges%2A> Метод возвращает второй <xref:System.Data.DataTable>оптимизированный для проверки и слияния.</xref:System.Data.DataTable> Этот второй <xref:System.Data.DataTable>объект содержит только <xref:System.Data.DataTable>и <xref:System.Data.DataRow>объекты, которые были изменены, возникающие в подмножестве исходного <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataRow> </xref:System.Data.DataTable> </xref:System.Data.DataTable> Это подмножество обычно меньше и поэтому это подмножество более эффективно передается обратно в компонент среднего уровня. Затем компонент среднего уровня обновляет исходный источник данных изменениями с помощью хранимых процедур. Средний уровень может отправить назад либо новый <xref:System.Data.DataTable>с исходными данными и последними данными из источника данных (повторив исходный запрос), или он может отправить обратно подмножество с любыми изменениями, внесенными в него из источника данных.</xref:System.Data.DataTable> (Например, если источник данных автоматически создает уникальные значения первичного ключа, эти значения могут передаваться обратно в клиентское приложение.) В любом случае возвращаемый <xref:System.Data.DataTable>могут быть объединены обратно в исходный клиентское приложение <xref:System.Data.DataTable>с <xref:System.Data.DataTable.Merge%2A>метод.</xref:System.Data.DataTable.Merge%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable>       При <xref:System.Data.DataTable.Merge%2A>вызове метода схемы двух <xref:System.Data.DataTable>объекты сравнения, так как это схемы могут быть изменены.</xref:System.Data.DataTable> </xref:System.Data.DataTable.Merge%2A> Например в бизнес-сценарии, добавлены новые столбцы могут XML-схеме автоматизированным процессом. Если источник <xref:System.Data.DataTable>содержит элементы схемы (добавлены <xref:System.Data.DataColumn>объекты), которые отсутствуют в целевом объекте, могут быть добавлены к целевому элементы схемы, задав `missingSchemaAction` аргумент `MissingSchemaAction.Add`.</xref:System.Data.DataColumn> </xref:System.Data.DataTable> В этом случае объединенный <xref:System.Data.DataTable>содержит добавленные схему и данные.</xref:System.Data.DataTable>       Данные объединяются после слияния схем.       При слиянии нового источника <xref:System.Data.DataTable>и конечного объекта исходные строки со <xref:System.Data.DataRowState>значение `Unchanged`, `Modified`, или `Deleted` сопоставляются с конечным строкам и имеют те же значения первичного ключа.</xref:System.Data.DataRowState> </xref:System.Data.DataTable> Исходные строки со <xref:System.Data.DataRowState>значение `Added` сопоставляются с новым конечным строкам с теми же значениями первичного ключа, как новые исходные строки.</xref:System.Data.DataRowState>"
  example:
  - "The following console application demonstrates the behavior of the `missingSchemaAction` parameter of the Merge method. This example creates two versions of the same table, modifying the schema for the second version. The code then attempts to merge the second table into the first.  \n  \n [!code-cs[DataWorks DataTable.MergeMissingSchemaAction#1](~/add/codesnippet/csharp/0a34dc2a-14c3-4d65-b78d-_1.cs)]\n [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/add/codesnippet/visualbasic/0a34dc2a-14c3-4d65-b78d-_1.vb)]"
  syntax:
    content: public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);
    parameters:
    - id: table
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref> Необходимо объединить с текущим <xref href=&quot;System.Data.DataTable&quot;> </xref>."
    - id: preserveChanges
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>, чтобы сохранить изменения в текущем <xref href=&quot;System.Data.DataTable&quot;> </xref>; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: missingSchemaAction
      type: System.Data.MissingSchemaAction
      description: "Один из <xref href=&quot;System.Data.MissingSchemaAction&quot;> </xref> значения."
  overload: System.Data.DataTable.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.MinimumCapacity
  id: MinimumCapacity
  parent: System.Data.DataTable
  langs:
  - csharp
  name: MinimumCapacity
  nameWithType: DataTable.MinimumCapacity
  fullName: System.Data.DataTable.MinimumCapacity
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает или задает начальный размер этой таблицы."
  remarks: "Значение MinimumCapacity позволяет системе создать соответствующий набор ресурсов перед получением данных. В ситуации, когда важна производительность, задание этого свойства можно оптимизировать производительность."
  example:
  - "The following example sets the MinimumCapacity of a <xref:System.Data.DataTable>.  \n  \n [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._6_1.vb)]\n [!code-cs[Classic WebData DataTable.MinimumCapacity Example#1](~/add/codesnippet/csharp/p-system.data.datatable._6_1.cs)]"
  syntax:
    content: public int MinimumCapacity { get; set; }
    return:
      type: System.Int32
      description: "Начальный размер в строках этой таблицы. Значение по умолчанию — 50."
  overload: System.Data.DataTable.MinimumCapacity*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Namespace
  id: Namespace
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Namespace
  nameWithType: DataTable.Namespace
  fullName: System.Data.DataTable.Namespace
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает или задает пространство имен для XML-представление данных, хранящихся в <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  syntax:
    content: public string Namespace { get; set; }
    return:
      type: System.String
      description: "Пространство имен <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  overload: System.Data.DataTable.Namespace*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.NewRow
  id: NewRow
  parent: System.Data.DataTable
  langs:
  - csharp
  name: NewRow()
  nameWithType: DataTable.NewRow()
  fullName: System.Data.DataTable.NewRow()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Создает новый <xref href=&quot;System.Data.DataRow&quot;> </xref> с той же схемой, что и таблица."
  remarks: "Метод NewRow необходимо использовать для создания новых <xref:System.Data.DataRow>объектов с той же схеме, <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataRow> После создания <xref:System.Data.DataRow>, его можно добавить к <xref:System.Data.DataRowCollection>, с помощью <xref:System.Data.DataTable>объекта <xref:System.Data.DataTable.Rows%2A>свойство.</xref:System.Data.DataTable.Rows%2A> </xref:System.Data.DataTable> </xref:System.Data.DataRowCollection> </xref:System.Data.DataRow> При использовании NewRow для создания новых строк, строки должен быть добавлен или удален из таблицы данных, перед вызовом метода <xref:System.Data.DataTable.Clear%2A>.</xref:System.Data.DataTable.Clear%2A>"
  example:
  - "The following example creates a <xref:System.Data.DataTable>, adds two <xref:System.Data.DataColumn> objects that determine the table's schema, and creates several new <xref:System.Data.DataRow> objects using the NewRow method. Those <xref:System.Data.DataRow> objects are then added to the <xref:System.Data.DataRowCollection> using the <xref:System.Data.DataRowCollection.Add%2A> method.  \n  \n [!code-vb[Classic WebData DataTable.NewRow Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._27_1.vb)]\n [!code-cs[Classic WebData DataTable.NewRow Example#1](~/add/codesnippet/csharp/m-system.data.datatable._27_1.cs)]"
  syntax:
    content: public System.Data.DataRow NewRow ();
    parameters: []
    return:
      type: System.Data.DataRow
      description: "Объект <xref href=&quot;System.Data.DataRow&quot;> </xref> с той же схеме, <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  overload: System.Data.DataTable.NewRow*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.NewRowArray(System.Int32)
  id: NewRowArray(System.Int32)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: NewRowArray(Int32)
  nameWithType: DataTable.NewRowArray(Int32)
  fullName: System.Data.DataTable.NewRowArray(Int32)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает массив <xref href=&quot;System.Data.DataRow&quot;> </xref>."
  syntax:
    content: protected System.Data.DataRow[] NewRowArray (int size);
    parameters:
    - id: size
      type: System.Int32
      description: "Объект <xref:System.Int32>значение, описывающее размер массива.</xref:System.Int32>"
    return:
      type: System.Data.DataRow[]
      description: "Новый массив."
  overload: System.Data.DataTable.NewRowArray*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)
  id: NewRowFromBuilder(System.Data.DataRowBuilder)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: NewRowFromBuilder(DataRowBuilder)
  nameWithType: DataTable.NewRowFromBuilder(DataRowBuilder)
  fullName: System.Data.DataTable.NewRowFromBuilder(DataRowBuilder)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Создает новую строку из существующей строки."
  syntax:
    content: protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);
    parameters:
    - id: builder
      type: System.Data.DataRowBuilder
      description: "A <xref href=&quot;System.Data.DataRowBuilder&quot;></xref> object."
    return:
      type: System.Data.DataRow
      description: "Объект <xref href=&quot;System.Data.DataRow&quot;> </xref> производного класса."
  overload: System.Data.DataTable.NewRowFromBuilder*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)
  id: OnColumnChanged(System.Data.DataColumnChangeEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnColumnChanged(DataColumnChangeEventArgs)
  nameWithType: DataTable.OnColumnChanged(DataColumnChangeEventArgs)
  fullName: System.Data.DataTable.OnColumnChanged(DataColumnChangeEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Вызывает <xref href=&quot;System.Data.DataTable.ColumnChanged&quot;> </xref> событий."
  remarks: 'При возникновении события вызывается обработчик события в делегате. Общие сведения см. в разделе [NIB: при возникновении события](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).'
  syntax:
    content: protected virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataColumnChangeEventArgs
      description: "Объект <xref href=&quot;System.Data.DataColumnChangeEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Data.DataTable.OnColumnChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)
  id: OnColumnChanging(System.Data.DataColumnChangeEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnColumnChanging(DataColumnChangeEventArgs)
  nameWithType: DataTable.OnColumnChanging(DataColumnChangeEventArgs)
  fullName: System.Data.DataTable.OnColumnChanging(DataColumnChangeEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Вызывает <xref href=&quot;System.Data.DataTable.ColumnChanging&quot;> </xref> событий."
  remarks: 'При возникновении события вызывается обработчик события в делегате. Общие сведения см. в разделе [NIB: при возникновении события](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).'
  syntax:
    content: protected virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataColumnChangeEventArgs
      description: "Объект <xref href=&quot;System.Data.DataColumnChangeEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Data.DataTable.OnColumnChanging*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  id: OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnPropertyChanging(PropertyChangedEventArgs)
  nameWithType: DataTable.OnPropertyChanging(PropertyChangedEventArgs)
  fullName: System.Data.DataTable.OnPropertyChanging(PropertyChangedEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Вызывает <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged>событий.</xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged>"
  remarks: 'При возникновении события вызывается обработчик события в делегате. Общие сведения см. в разделе [NIB: при возникновении события](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).'
  syntax:
    content: protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);
    parameters:
    - id: pcevent
      type: System.ComponentModel.PropertyChangedEventArgs
      description: "Объект <xref:System.ComponentModel.PropertyChangedEventArgs>, содержащий данные события.</xref:System.ComponentModel.PropertyChangedEventArgs>"
  overload: System.Data.DataTable.OnPropertyChanging*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)
  id: OnRemoveColumn(System.Data.DataColumn)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnRemoveColumn(DataColumn)
  nameWithType: DataTable.OnRemoveColumn(DataColumn)
  fullName: System.Data.DataTable.OnRemoveColumn(DataColumn)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Уведомляет <xref href=&quot;System.Data.DataTable&quot;> </xref> , <xref href=&quot;System.Data.DataColumn&quot;> </xref> удаляется."
  remarks: 'При возникновении события вызывается обработчик события в делегате. Дополнительные сведения см. в разделе [NIB: при возникновении события](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).'
  syntax:
    content: protected virtual void OnRemoveColumn (System.Data.DataColumn column);
    parameters:
    - id: column
      type: System.Data.DataColumn
      description: "<xref href=&quot;System.Data.DataColumn&quot;> </xref> Удаления."
  overload: System.Data.DataTable.OnRemoveColumn*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)
  id: OnRowChanged(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnRowChanged(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowChanged(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowChanged(DataRowChangeEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Вызывает <xref href=&quot;System.Data.DataTable.RowChanged&quot;> </xref> событий."
  remarks: 'При возникновении события вызывается обработчик события в делегате. Общие сведения см. в разделе [NIB: при возникновении события](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).'
  syntax:
    content: protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataRowChangeEventArgs
      description: "Объект <xref href=&quot;System.Data.DataRowChangeEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Data.DataTable.OnRowChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)
  id: OnRowChanging(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnRowChanging(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowChanging(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowChanging(DataRowChangeEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Вызывает <xref href=&quot;System.Data.DataTable.RowChanging&quot;> </xref> событий."
  remarks: 'При возникновении события вызывается обработчик события в делегате. Общие сведения см. в разделе [NIB: при возникновении события](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).'
  syntax:
    content: protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataRowChangeEventArgs
      description: "Объект <xref href=&quot;System.Data.DataRowChangeEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Data.DataTable.OnRowChanging*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)
  id: OnRowDeleted(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnRowDeleted(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowDeleted(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowDeleted(DataRowChangeEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Вызывает <xref href=&quot;System.Data.DataTable.RowDeleted&quot;> </xref> событий."
  remarks: 'При возникновении события вызывается обработчик события в делегате. Общие сведения см. в разделе [NIB: при возникновении события](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).'
  syntax:
    content: protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataRowChangeEventArgs
      description: "Объект <xref href=&quot;System.Data.DataRowChangeEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Data.DataTable.OnRowDeleted*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)
  id: OnRowDeleting(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnRowDeleting(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowDeleting(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowDeleting(DataRowChangeEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Вызывает <xref href=&quot;System.Data.DataTable.RowDeleting&quot;> </xref> событий."
  remarks: 'При возникновении события вызывается обработчик события в делегате. Общие сведения см. в разделе [NIB: при возникновении события](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).'
  syntax:
    content: protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataRowChangeEventArgs
      description: "Объект <xref href=&quot;System.Data.DataRowChangeEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Data.DataTable.OnRowDeleting*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)
  id: OnTableCleared(System.Data.DataTableClearEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnTableCleared(DataTableClearEventArgs)
  nameWithType: DataTable.OnTableCleared(DataTableClearEventArgs)
  fullName: System.Data.DataTable.OnTableCleared(DataTableClearEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Вызывает <xref href=&quot;System.Data.DataTable.TableCleared&quot;> </xref> событий."
  remarks: "Вызывает <xref:System.Data.DataTable.TableCleared>событие, которое создается немедленно после все строки успешно удалены перед вызовом <xref:System.Data.DataTable.Clear%2A>метод возвращает управление вызывающему объекту.</xref:System.Data.DataTable.Clear%2A> </xref:System.Data.DataTable.TableCleared>       При возникновении события вызывается обработчик события в делегате. Общие сведения см. в разделе [NIB: при возникновении события](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)."
  syntax:
    content: protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataTableClearEventArgs
      description: "Объект <xref href=&quot;System.Data.DataTableClearEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Data.DataTable.OnTableCleared*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)
  id: OnTableClearing(System.Data.DataTableClearEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnTableClearing(DataTableClearEventArgs)
  nameWithType: DataTable.OnTableClearing(DataTableClearEventArgs)
  fullName: System.Data.DataTable.OnTableClearing(DataTableClearEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Вызывает <xref href=&quot;System.Data.DataTable.TableClearing&quot;> </xref> событий."
  remarks: "Вызывает <xref:System.Data.DataTable.TableClearing>событие, которое возникает перед началом обработки <xref:System.Data.DataTable.Clear%2A>начала операции.</xref:System.Data.DataTable.Clear%2A> </xref:System.Data.DataTable.TableClearing>       При возникновении события вызывается обработчик события в делегате. Общие сведения см. в разделе [NIB: при возникновении события](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)."
  syntax:
    content: protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataTableClearEventArgs
      description: "Объект <xref href=&quot;System.Data.DataTableClearEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Data.DataTable.OnTableClearing*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)
  id: OnTableNewRow(System.Data.DataTableNewRowEventArgs)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: OnTableNewRow(DataTableNewRowEventArgs)
  nameWithType: DataTable.OnTableNewRow(DataTableNewRowEventArgs)
  fullName: System.Data.DataTable.OnTableNewRow(DataTableNewRowEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Вызывает <xref href=&quot;System.Data.DataTable.TableNewRow&quot;> </xref> событий."
  remarks: "Вызывает <xref:System.Data.DataTable.TableNewRow>событие, который срабатывает после новой <xref:System.Data.DataRow>был создан с помощью <xref:System.Data.DataTable.NewRow%2A>.</xref:System.Data.DataTable.NewRow%2A> </xref:System.Data.DataRow> </xref:System.Data.DataTable.TableNewRow>       При возникновении события вызывается обработчик события в делегате. Общие сведения см. в разделе [NIB: при возникновении события](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)."
  syntax:
    content: protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);
    parameters:
    - id: e
      type: System.Data.DataTableNewRowEventArgs
      description: "Объект <xref href=&quot;System.Data.DataTableNewRowEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Data.DataTable.OnTableNewRow*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ParentRelations
  id: ParentRelations
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ParentRelations
  nameWithType: DataTable.ParentRelations
  fullName: System.Data.DataTable.ParentRelations
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Получает коллекцию родительских соотношений для <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  remarks: ''
  example:
  - "The following example uses the ParentRelations property to return each parent <xref:System.Data.DataRelation> in a <xref:System.Data.DataTable>. Each relation is then used as an argument in the <xref:System.Data.DataRow.GetParentRows%2A> method of the <xref:System.Data.DataRow> to return an array of rows. The value of each column in the row is then printed.  \n  \n [!code-cs[Classic WebData DataTable.ParentRelations Example#1](~/add/codesnippet/csharp/p-system.data.datatable._9_1.cs)]\n [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._9_1.vb)]"
  syntax:
    content: public System.Data.DataRelationCollection ParentRelations { get; }
    return:
      type: System.Data.DataRelationCollection
      description: "Объект <xref href=&quot;System.Data.DataRelationCollection&quot;> </xref> , содержащий родительские соотношения таблицы. Если нет, возвращается пустая коллекция <xref href=&quot;System.Data.DataRelation&quot;> </xref> объекты существуют."
  overload: System.Data.DataTable.ParentRelations*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Prefix
  id: Prefix
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Prefix
  nameWithType: DataTable.Prefix
  fullName: System.Data.DataTable.Prefix
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает или задает пространство имен для XML-представление данных, хранящихся в <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  syntax:
    content: public string Prefix { get; set; }
    return:
      type: System.String
      description: "Префикс <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  overload: System.Data.DataTable.Prefix*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.PrimaryKey
  id: PrimaryKey
  parent: System.Data.DataTable
  langs:
  - csharp
  name: PrimaryKey
  nameWithType: DataTable.PrimaryKey
  fullName: System.Data.DataTable.PrimaryKey
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает или задает массив столбцов этой функции в качестве первичного ключа для таблицы данных."
  remarks: "Первичный ключ таблицы должен быть уникальным для определения записи в таблице. Можно также создать таблицу с первичным ключом, состоящий из двух или более столбцов. Это происходит, когда один столбец не может содержать достаточного количества уникальных значений. Например два столбца первичного ключа может состоять из столбца «Имя» и «Фамилия». Поскольку первичные ключи могут состоять из более чем одного столбца, свойство PrimaryKey состоит из массива <xref:System.Data.DataColumn>объектов.</xref:System.Data.DataColumn>"
  example:
  - "The first example shows how to return the primary key columns for a <xref:System.Data.DataTable> displayed in a `DataGrid`. The second example demonstrates how to set the primary key columns for a <xref:System.Data.DataTable>.  \n  \n [!code-cs[Classic WebData DataTable.PrimaryKey Example#1](~/add/codesnippet/csharp/p-system.data.datatable._4_1.cs)]\n [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._4_1.vb)]"
  syntax:
    content: public System.Data.DataColumn[] PrimaryKey { get; set; }
    return:
      type: System.Data.DataColumn[]
      description: "Массив <xref href=&quot;System.Data.DataColumn&quot;> </xref> объектов."
  overload: System.Data.DataTable.PrimaryKey*
  exceptions:
  - type: System.Data.DataException
    commentId: T:System.Data.DataException
    description: "Ключ — внешний ключ."
  platform:
  - net462
- uid: System.Data.DataTable.ReadXml(System.IO.Stream)
  id: ReadXml(System.IO.Stream)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXml(Stream)
  nameWithType: DataTable.ReadXml(Stream)
  fullName: System.Data.DataTable.ReadXml(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Считывает XML-схему и данные в <xref href=&quot;System.Data.DataTable&quot;> </xref> с помощью указанного <xref:System.IO.Stream>.</xref:System.IO.Stream>"
  remarks: "Текущие <xref:System.Data.DataTable>, и его потомков, загружаемых с данными из предоставленного <xref:System.IO.Stream>.</xref:System.IO.Stream> </xref:System.Data.DataTable> Поведение данного метода, идентичной <xref:System.Data.DataSet.ReadXml%2A?displayProperty=fullName>метода, за исключением того, в этом случае данные загружаются только для текущей таблицы и всех его потомков.</xref:System.Data.DataSet.ReadXml%2A?displayProperty=fullName>       Метод ReadXml предоставляет способ чтения только данных или данных вместе со схемой в <xref:System.Data.DataTable>из документа XML, тогда как <xref:System.Data.DataTable.ReadXmlSchema%2A>метод считывает только схему.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.WriteXml%2A>и <xref:System.Data.DataTable.WriteXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable.WriteXml%2A> Для записи XML-данных или схемы и данных из `DataTable`, используйте `WriteXml` метод. Для записи только схемы используйте `WriteXmlSchema` метод.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       Если встроенная схема, встроенная схема используется для расширения существующей реляционной структуры перед загрузкой данных. При возникновении любого конфликта (например, же столбец в той же таблице, определенных с различными типами данных) вызывает исключение.       Если схема в строке не указан, реляционную структуру распространяется через определение, при необходимости, структурой XML-документа. Если схема не может расширить с помощью интерфейса для представления всех данных, возникает исключение.      Настроек [!NOTE] настроек `DataSet` не связывает XML-элемента с соответствующим `DataColumn` или `DataTable` при экранируются допустимых символов XML как («_») в сериализованный XML. `DataSet` Себя только экранирует XML-символы в именах элементов XML и таким образом можно использовать только такие же. Когда допустимые символы в имени XML-элемента удаляются, элемент игнорируется при обработке."
  example:
  - "The following example creates a <xref:System.Data.DataTable> containing two columns and ten rows. The example writes the <xref:System.Data.DataTable> schema and data to a memory stream, by invoking the <xref:System.Data.DataTable.WriteXml%2A> method. The example creates a second <xref:System.Data.DataTable> and calls the ReadXml method to fill it with schema and data.  \n  \n [!code-cs[DataWorks DataTable.ReadXml#1](~/add/codesnippet/csharp/m-system.data.datatable._19_1.cs)]\n [!code-vb[DataWorks DataTable.ReadXml#1](~/add/codesnippet/visualbasic/m-system.data.datatable._19_1.vb)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "Объект, который является производным от<xref:System.IO.Stream></xref:System.IO.Stream>"
    return:
      type: System.Data.XmlReadMode
      description: "<xref href=&quot;System.Data.XmlReadMode&quot;> </xref> Используется для чтения данных."
  overload: System.Data.DataTable.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXml(System.IO.TextReader)
  id: ReadXml(System.IO.TextReader)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXml(TextReader)
  nameWithType: DataTable.ReadXml(TextReader)
  fullName: System.Data.DataTable.ReadXml(TextReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Считывает XML-схему и данные в <xref href=&quot;System.Data.DataTable&quot;> </xref> с помощью указанного <xref:System.IO.TextReader>.</xref:System.IO.TextReader>"
  remarks: "Текущие <xref:System.Data.DataTable>, и его потомков, загружаемых с данными из предоставленного <xref:System.IO.TextReader>.</xref:System.IO.TextReader> </xref:System.Data.DataTable> Поведение данного метода, идентичной <xref:System.Data.DataSet.ReadXml%2A?displayProperty=fullName>метода, за исключением того, в этом случае данные загружаются только для текущей таблицы и всех его потомков.</xref:System.Data.DataSet.ReadXml%2A?displayProperty=fullName>       Метод ReadXml предоставляет способ чтения только данных или данных вместе со схемой в <xref:System.Data.DataTable>из документа XML, тогда как <xref:System.Data.DataTable.ReadXmlSchema%2A>метод считывает только схему.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.WriteXml%2A>и <xref:System.Data.DataTable.WriteXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable.WriteXml%2A> Для записи XML-данных или схемы и данных из `DataTable`, используйте `WriteXml` метод. Для записи только схемы используйте `WriteXmlSchema` метод.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       Если встроенная схема, встроенная схема используется для расширения существующей реляционной структуры перед загрузкой данных. При возникновении любого конфликта (например, же столбец в той же таблице, определенных с различными типами данных) вызывает исключение.       Если схема в строке не указан, реляционную структуру распространяется через определение, при необходимости, структурой XML-документа. Если схема не может расширить с помощью интерфейса для представления всех данных, возникает исключение.      Настроек [!NOTE] настроек `DataSet` не связывает XML-элемента с соответствующим `DataColumn` или `DataTable` при экранируются допустимых символов XML как («_») в сериализованный XML. `DataSet` Себя только экранирует XML-символы в именах элементов XML и таким образом можно использовать только такие же. Когда допустимые символы в имени XML-элемента удаляются, элемент игнорируется при обработке."
  example:
  - "The following example creates a <xref:System.Data.DataTable> containing two columns and ten rows. The example writes the <xref:System.Data.DataTable> schema and data to a memory stream, by invoking the <xref:System.Data.DataTable.WriteXml%2A> method. The example creates a second <xref:System.Data.DataTable> and calls the ReadXml method to fill it with schema and data.  \n  \n [!code-vb[DataWorks DataTable.ReadXmlText#1](~/add/codesnippet/visualbasic/m-system.data.datatable._26_1.vb)]\n [!code-cs[DataWorks DataTable.ReadXmlText#1](~/add/codesnippet/csharp/m-system.data.datatable._26_1.cs)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref:System.IO.TextReader>Будет использоваться для чтения данных.</xref:System.IO.TextReader>"
    return:
      type: System.Data.XmlReadMode
      description: "<xref href=&quot;System.Data.XmlReadMode&quot;> </xref> Используется для чтения данных."
  overload: System.Data.DataTable.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXml(System.String)
  id: ReadXml(System.String)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXml(String)
  nameWithType: DataTable.ReadXml(String)
  fullName: System.Data.DataTable.ReadXml(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Считывает XML-схему и данные в <xref href=&quot;System.Data.DataTable&quot;> </xref> из указанного файла."
  remarks: "Текущие <xref:System.Data.DataTable>, и его потомков, загружаемых с данными в файле с именем в предоставленных <xref:System.String>.</xref:System.String> </xref:System.Data.DataTable> Поведение данного метода, идентичной <xref:System.Data.DataSet.ReadXml%2A?displayProperty=fullName>метода, за исключением того, в этом случае данные загружаются только для текущей таблицы и всех его потомков.</xref:System.Data.DataSet.ReadXml%2A?displayProperty=fullName>       Метод ReadXml предоставляет способ чтения только данных или данных вместе со схемой в <xref:System.Data.DataTable>из документа XML, тогда как <xref:System.Data.DataTable.ReadXmlSchema%2A>метод считывает только схему.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.WriteXml%2A>и <xref:System.Data.DataTable.WriteXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable.WriteXml%2A> Для записи XML-данных или схемы и данных из `DataTable`, используйте `WriteXml` метод. Для записи только схемы используйте `WriteXmlSchema` метод.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       Если встроенная схема, встроенная схема используется для расширения существующей реляционной структуры перед загрузкой данных. При возникновении любого конфликта (например, же столбец в той же таблице, определенных с различными типами данных) вызывает исключение.       Если схема в строке не указан, реляционную структуру распространяется через определение, при необходимости, структурой XML-документа. Если схема не может расширить с помощью интерфейса для представления всех данных, возникает исключение.      Настроек [!NOTE] настроек `DataSet` не связывает XML-элемента с соответствующим `DataColumn` или `DataTable` при экранируются допустимых символов XML как («_») в сериализованный XML. `DataSet` Себя только экранирует XML-символы в именах элементов XML и таким образом можно использовать только такие же. Когда допустимые символы в имени XML-элемента удаляются, элемент игнорируется при обработке.      ```   using System.Data;   public class A {      static void Main(string[] args) {         DataTable tabl = new DataTable(&quot;mytable&quot;);         tabl.Columns.Add(new DataColumn(&quot;id&quot;, typeof(int)));         for (int i = 0; i < 10; i++) {            DataRow row = tabl.NewRow();            row[&quot;id&quot;] = i;            tabl.Rows.Add(row);         }         tabl.WriteXml(&quot;f.xml&quot;, XmlWriteMode.WriteSchema);         DataTable newt = new DataTable();         newt.ReadXml(&quot;f.xml&quot;);      }   }   ```"
  example:
  - "The following example creates a <xref:System.Data.DataTable> containing two columns and ten rows. The example writes the <xref:System.Data.DataTable> schema and data to disk. The example creates a second <xref:System.Data.DataTable> and calls the ReadXml method to fill it with schema and data.  \n  \n [!code-cs[DataWorks DataTable.ReadXmlString#1](~/add/codesnippet/csharp/m-system.data.datatable._14_1.cs)]\n [!code-vb[DataWorks DataTable.ReadXmlString#1](~/add/codesnippet/visualbasic/m-system.data.datatable._14_1.vb)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "Имя файла, из которого следует считывать данные."
    return:
      type: System.Data.XmlReadMode
      description: "<xref href=&quot;System.Data.XmlReadMode&quot;> </xref> Используется для чтения данных."
  overload: System.Data.DataTable.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXml(System.Xml.XmlReader)
  id: ReadXml(System.Xml.XmlReader)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXml(XmlReader)
  nameWithType: DataTable.ReadXml(XmlReader)
  fullName: System.Data.DataTable.ReadXml(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Считывает XML-схему и данные в <xref href=&quot;System.Data.DataTable&quot;> </xref> с помощью указанного <xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader>"
  remarks: "Текущие <xref:System.Data.DataTable>, и его потомков, загружаемых с данными в файле с именем в предоставленных <xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader> </xref:System.Data.DataTable> Поведение этого метода аналогичен метода ReadXml, за исключением того, что в этом случае данные загружаются только для текущей таблицы и всех его потомков.       Метод ReadXml предоставляет способ чтения только данных или данных вместе со схемой в <xref:System.Data.DataTable>из документа XML, тогда как <xref:System.Data.DataTable.ReadXmlSchema%2A>метод считывает только схему.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.WriteXml%2A>и <xref:System.Data.DataTable.WriteXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable.WriteXml%2A> Для записи XML-данных или схемы и данных из `DataTable`, используйте `WriteXml` метод. Для записи только схемы используйте `WriteXmlSchema` метод.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       Если встроенная схема, встроенная схема используется для расширения существующей реляционной структуры перед загрузкой данных. При возникновении любого конфликта (например, же столбец в той же таблице, определенных с различными типами данных) вызывает исключение.       Если схема в строке не указан, реляционную структуру распространяется через определение, при необходимости, структурой XML-документа. Если схема не может расширить с помощью интерфейса для представления всех данных, возникает исключение.      Настроек [!NOTE] настроек `DataSet` не связывает XML-элемента с соответствующим `DataColumn` или `DataTable` при экранируются допустимых символов XML как («_») в сериализованный XML. `DataSet` Себя только экранирует XML-символы в именах элементов XML и таким образом можно использовать только такие же. Когда допустимые символы в имени XML-элемента удаляются, элемент игнорируется при обработке."
  example:
  - "The following example creates a <xref:System.Data.DataTable> containing two columns and ten rows. The example writes the <xref:System.Data.DataTable> schema and data to an <xref:System.Xml.XmlReader>. The example creates a second <xref:System.Data.DataTable> and calls the ReadXml method to fill it with schema and data from the <xref:System.Xml.XmlReader> instance.  \n  \n [!code-cs[DataWorks DataTable.ReadXmlXmlReader#1](~/add/codesnippet/csharp/m-system.data.datatable._10_1.cs)]\n [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/add/codesnippet/visualbasic/m-system.data.datatable._10_1.vb)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>Будет использоваться для чтения данных.</xref:System.Xml.XmlReader>"
    return:
      type: System.Data.XmlReadMode
      description: "<xref href=&quot;System.Data.XmlReadMode&quot;> </xref> Используется для чтения данных."
  overload: System.Data.DataTable.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXmlSchema(System.IO.Stream)
  id: ReadXmlSchema(System.IO.Stream)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXmlSchema(Stream)
  nameWithType: DataTable.ReadXmlSchema(Stream)
  fullName: System.Data.DataTable.ReadXmlSchema(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Считывает XML-схемы в <xref href=&quot;System.Data.DataTable&quot;> </xref> с помощью указанного потока."
  remarks: "Метод ReadXmlSchema используется для создания схемы для <xref:System.Data.DataTable>.</xref:System.Data.DataTable> Схема содержит определения таблиц, связей и ограничений.       Для записи схемы в XML-документа, используйте <xref:System.Data.DataTable.WriteXmlSchema%2A>метод.</xref:System.Data.DataTable.WriteXmlSchema%2A>       XML-схема интерпретируется согласно стандарту XSD.       Если msdata:DataType и типы xs: Type не совпадают, это может привести к повреждению данных. Будет создано исключение.       `ReadXmlSchema` Метод обычно вызывается перед вызовом <xref:System.Data.DataTable.ReadXml%2A>метода, который используется для заполнения <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataTable.ReadXml%2A>       Для создания вложенного отношения с помощью XML-схемы, используйте неявные вложенные элементы. Можно также настроить вложенное отношение для использования явных имен столбцов. Элементы должны быть неявно вложены в порядке для соответствующего DataTables участвовать во вложенном отношении."
  example:
  - "The following console application creates a new <xref:System.Data.DataTable>, and writes the schema for that table to a <xref:System.IO.MemoryStream>. Then, the example creates a new <xref:System.Data.DataTable> and reads its schema from the saved XML schema.  \n  \n [!code-cs[DataWorks DataTable.ReadXmlIOStream#1](~/add/codesnippet/csharp/m-system.data.datatable._8_1.cs)]\n [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/add/codesnippet/visualbasic/m-system.data.datatable._8_1.vb)]"
  syntax:
    content: public void ReadXmlSchema (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "Поток, используемый для чтения схемы."
  overload: System.Data.DataTable.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)
  id: ReadXmlSchema(System.IO.TextReader)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXmlSchema(TextReader)
  nameWithType: DataTable.ReadXmlSchema(TextReader)
  fullName: System.Data.DataTable.ReadXmlSchema(TextReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Считывает XML-схемы в <xref href=&quot;System.Data.DataTable&quot;> </xref> с помощью указанного <xref:System.IO.TextReader>.</xref:System.IO.TextReader>"
  remarks: "Метод ReadXmlSchema используется для создания схемы для <xref:System.Data.DataTable>.</xref:System.Data.DataTable> Схема содержит определения таблиц, связей и ограничений.       Для записи схемы в XML-документа, используйте <xref:System.Data.DataTable.WriteXmlSchema%2A>метод.</xref:System.Data.DataTable.WriteXmlSchema%2A>       XML-схема интерпретируется согласно стандарту XSD.       Если msdata:DataType и типы xs: Type не совпадают, это может привести к повреждению данных. Будет создано исключение.       `ReadXmlSchema` Метод обычно вызывается перед вызовом <xref:System.Data.DataTable.ReadXml%2A>метода, который используется для заполнения <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataTable.ReadXml%2A>       Для создания вложенного отношения с помощью XML-схемы, используйте неявные вложенные элементы. Также можно перенастроить вложенное отношение для использования явных имен столбцов. Элементы должны быть неявно вложены в порядке для соответствующего DataTables участвовать во вложенном отношении."
  example:
  - "The following console application creates a new <xref:System.Data.DataTable>, and writes the schema for that table to a <xref:System.IO.MemoryStream>. Then, the example creates a new <xref:System.Data.DataTable> and reads its schema from the saved XML schema, using a <xref:System.IO.StreamReader> (which inherits from <xref:System.IO.TextReader>) as its source.  \n  \n [!code-cs[DataWorks DataTable.ReadXmlSchema#1](~/add/codesnippet/csharp/m-system.data.datatable._12_1.cs)]\n [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/add/codesnippet/visualbasic/m-system.data.datatable._12_1.vb)]"
  syntax:
    content: public void ReadXmlSchema (System.IO.TextReader reader);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref:System.IO.TextReader>Использовать для чтения сведений о схеме.</xref:System.IO.TextReader>"
  overload: System.Data.DataTable.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXmlSchema(System.String)
  id: ReadXmlSchema(System.String)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXmlSchema(String)
  nameWithType: DataTable.ReadXmlSchema(String)
  fullName: System.Data.DataTable.ReadXmlSchema(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Считывает XML-схемы в <xref href=&quot;System.Data.DataTable&quot;> </xref> из указанного файла."
  remarks: "Метод ReadXmlSchema используется для создания схемы для <xref:System.Data.DataTable>.</xref:System.Data.DataTable> Схема содержит определения таблиц, связей и ограничений.       Для записи схемы в XML-документа, используйте <xref:System.Data.DataTable.WriteXmlSchema%2A>метод.</xref:System.Data.DataTable.WriteXmlSchema%2A>       XML-схема интерпретируется согласно стандарту XSD.       Если msdata:DataType и типы xs: Type не совпадают, это может привести к повреждению данных. Будет создано исключение.       `ReadXmlSchema` Метод обычно вызывается перед вызовом <xref:System.Data.DataTable.ReadXml%2A>метод, который используется для заполнения `DataTable`.</xref:System.Data.DataTable.ReadXml%2A>       Для создания вложенного отношения с помощью XML-схемы, используйте неявные вложенные элементы. Также можно перенастроить вложенное отношение для использования явных имен столбцов. Элементы должны быть неявно вложены в порядке для соответствующего DataTables участвовать во вложенном отношении."
  example:
  - "The following console application creates a new <xref:System.Data.DataTable>, and writes the schema for that table to a file. Then, the example creates a new <xref:System.Data.DataTable> and reads its schema from the saved XML schema, using the file as its source.  \n  \n [!code-cs[DataWorks DataTable.ReadXmlSchemaString#1](~/add/codesnippet/csharp/m-system.data.datatable._16_1.cs)]\n [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/add/codesnippet/visualbasic/m-system.data.datatable._16_1.vb)]"
  syntax:
    content: public void ReadXmlSchema (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "Имя файла, из которого следует считывать данные схемы."
  overload: System.Data.DataTable.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)
  id: ReadXmlSchema(System.Xml.XmlReader)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXmlSchema(XmlReader)
  nameWithType: DataTable.ReadXmlSchema(XmlReader)
  fullName: System.Data.DataTable.ReadXmlSchema(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Считывает XML-схемы в <xref href=&quot;System.Data.DataTable&quot;> </xref> с помощью указанного <xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader>"
  remarks: "Метод ReadXmlSchema используется для создания схемы для <xref:System.Data.DataTable>.</xref:System.Data.DataTable> Схема содержит определения таблиц, связей и ограничений.       Для записи схемы в XML-документа, используйте <xref:System.Data.DataTable.WriteXmlSchema%2A>метод.</xref:System.Data.DataTable.WriteXmlSchema%2A>       XML-схема интерпретируется согласно стандарту XSD.       Если msdata:DataType и типы xs: Type не совпадают, это может привести к повреждению данных. Будет создано исключение.       `ReadXmlSchema` Метод обычно вызывается перед вызовом <xref:System.Data.DataTable.ReadXml%2A>метода, который используется для заполнения <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataTable.ReadXml%2A>      Настроек [!NOTE] настроек способ создания вложенного отношения с помощью XML-схемы — иметь неявные вложенные элементы. Кроме того вложенное отношение может быть переопределено для использования явных имен столбцов. Является обязательным для элементов, которые должны быть неявно вложенными для соответствующего DataTables участвовать во вложенном отношении."
  example:
  - "The following console application creates a new <xref:System.Data.DataTable>, and writes the schema for that table to a <xref:System.IO.MemoryStream>. Then, the example creates a new <xref:System.Data.DataTable> and reads its schema from the saved XML schema, using a <xref:System.Xml.XmlTextReader> (which inherits from <xref:System.Xml.XmlReader>) as its source.  \n  \n [!code-cs[DataWorks DataTable.ReadXmlSchemaReader#1](~/add/codesnippet/csharp/m-system.data.datatable._17_1.cs)]\n [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/add/codesnippet/visualbasic/m-system.data.datatable._17_1.vb)]"
  syntax:
    content: public void ReadXmlSchema (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>Использовать для чтения сведений о схеме.</xref:System.Xml.XmlReader>"
  overload: System.Data.DataTable.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)
  id: ReadXmlSerializable(System.Xml.XmlReader)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ReadXmlSerializable(XmlReader)
  nameWithType: DataTable.ReadXmlSerializable(XmlReader)
  fullName: System.Data.DataTable.ReadXmlSerializable(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Считывает из потока XML."
  syntax:
    content: protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "Объект <xref:System.Xml.XmlReader>объекта.</xref:System.Xml.XmlReader>"
  overload: System.Data.DataTable.ReadXmlSerializable*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.RejectChanges
  id: RejectChanges
  parent: System.Data.DataTable
  langs:
  - csharp
  name: RejectChanges()
  nameWithType: DataTable.RejectChanges()
  fullName: System.Data.DataTable.RejectChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Откат всех изменений, выполненных для таблицы, так как она была загружена, или в последний раз <xref:System.Data.DataTable.AcceptChanges*>был вызван.</xref:System.Data.DataTable.AcceptChanges*>"
  remarks: "Когда RejectChanges вызывается, любой <xref:System.Data.DataRow>объекты, которые все еще находятся в режиме редактирования отменить их изменения.</xref:System.Data.DataRow> Новые строки будут удалены. Строки, у которых <xref:System.Data.DataRowState>значение `Modified` или `Deleted` возвращаются в исходное состояние.</xref:System.Data.DataRowState>"
  example:
  - "The following example makes several changes to a <xref:System.Data.DataTable>, but rejects the changes by invoking the RejectChanges method.  \n  \n [!code-cs[Classic WebData DataTable.RejectChanges Example#1](~/add/codesnippet/csharp/m-system.data.datatable._3_1.cs)]\n [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._3_1.vb)]"
  syntax:
    content: public void RejectChanges ();
    parameters: []
  overload: System.Data.DataTable.RejectChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.RemotingFormat
  id: RemotingFormat
  parent: System.Data.DataTable
  langs:
  - csharp
  name: RemotingFormat
  nameWithType: DataTable.RemotingFormat
  fullName: System.Data.DataTable.RemotingFormat
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает или задает формат сериализации."
  syntax:
    content: public System.Data.SerializationFormat RemotingFormat { get; set; }
    return:
      type: System.Data.SerializationFormat
      description: "Объект <xref href=&quot;System.Data.SerializationFormat&quot;> </xref> перечисление, определяющее, либо <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_Xml&quot; name=&quot;Xml&quot; href=&quot;&quot;> </xref> сериализации."
  overload: System.Data.DataTable.RemotingFormat*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Reset
  id: Reset
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Reset()
  nameWithType: DataTable.Reset()
  fullName: System.Data.DataTable.Reset()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Сбрасывает <xref href=&quot;System.Data.DataTable&quot;> </xref> в исходное состояние. Сброс удаляет все данные, индексы, связи и столбцы таблицы. Если набор данных содержит таблицу данных, таблица по-прежнему будет частью набора данных после сброса таблицы."
  syntax:
    content: public virtual void Reset ();
    parameters: []
  overload: System.Data.DataTable.Reset*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.RowChanged
  id: RowChanged
  parent: System.Data.DataTable
  langs:
  - csharp
  name: RowChanged
  nameWithType: DataTable.RowChanged
  fullName: System.Data.DataTable.RowChanged
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Происходит после <xref href=&quot;System.Data.DataRow&quot;> </xref> успешно изменен."
  remarks: "Дополнительные сведения см. в разделе [обработка событий DataTable](~/add/includes/ajax-current-ext-md.md)."
  example:
  - >-
    [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/add/codesnippet/visualbasic/e-system.data.datatable._0_1.vb)]
     [!code-cs[Classic WebData DataTable.RowChanged Example#1](~/add/codesnippet/csharp/e-system.data.datatable._0_1.cs)]
  syntax:
    content: public event System.Data.DataRowChangeEventHandler RowChanged;
    return:
      type: System.Data.DataRowChangeEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.RowChanging
  id: RowChanging
  parent: System.Data.DataTable
  langs:
  - csharp
  name: RowChanging
  nameWithType: DataTable.RowChanging
  fullName: System.Data.DataTable.RowChanging
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Происходит, когда <xref href=&quot;System.Data.DataRow&quot;> </xref> изменяется."
  remarks: "Дополнительные сведения см. в разделе [обработка событий DataTable](~/add/includes/ajax-current-ext-md.md)."
  example:
  - >-
    [!code-cs[Classic WebData DataTable.RowChanging Example#1](~/add/codesnippet/csharp/e-system.data.datatable._1_1.cs)]
     [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/add/codesnippet/visualbasic/e-system.data.datatable._1_1.vb)]
  syntax:
    content: public event System.Data.DataRowChangeEventHandler RowChanging;
    return:
      type: System.Data.DataRowChangeEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.RowDeleted
  id: RowDeleted
  parent: System.Data.DataTable
  langs:
  - csharp
  name: RowDeleted
  nameWithType: DataTable.RowDeleted
  fullName: System.Data.DataTable.RowDeleted
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Происходит после удаления строки в таблице."
  remarks: "Дополнительные сведения см. в разделе [обработка событий DataTable](~/add/includes/ajax-current-ext-md.md)."
  example:
  - >-
    [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/add/codesnippet/visualbasic/e-system.data.datatable._3_1.vb)]
     [!code-cs[Classic WebData DataTable.RowDeleted Example#1](~/add/codesnippet/csharp/e-system.data.datatable._3_1.cs)]
  syntax:
    content: public event System.Data.DataRowChangeEventHandler RowDeleted;
    return:
      type: System.Data.DataRowChangeEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.RowDeleting
  id: RowDeleting
  parent: System.Data.DataTable
  langs:
  - csharp
  name: RowDeleting
  nameWithType: DataTable.RowDeleting
  fullName: System.Data.DataTable.RowDeleting
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возникает перед удалением строки в таблице."
  remarks: "Дополнительные сведения см. в разделе [обработка событий DataTable](~/add/includes/ajax-current-ext-md.md)."
  example:
  - >-
    [!code-cs[Classic WebData DataTable.RowDeleting Example#1](~/add/codesnippet/csharp/e-system.data.datatable._2_1.cs)]
     [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/add/codesnippet/visualbasic/e-system.data.datatable._2_1.vb)]
  syntax:
    content: public event System.Data.DataRowChangeEventHandler RowDeleting;
    return:
      type: System.Data.DataRowChangeEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Rows
  id: Rows
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Rows
  nameWithType: DataTable.Rows
  fullName: System.Data.DataTable.Rows
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает коллекцию строк, принадлежащих к этой таблице."
  remarks: "Чтобы создать новую <xref:System.Data.DataRow>, необходимо использовать <xref:System.Data.DataTable.NewRow%2A>метод для возврата объекта.</xref:System.Data.DataTable.NewRow%2A> </xref:System.Data.DataRow> Такой объект автоматически настраивается в соответствии со схемой, определенной для <xref:System.Data.DataTable>через его коллекцию <xref:System.Data.DataColumn>объектов.</xref:System.Data.DataColumn> </xref:System.Data.DataTable> После создания новой строки и задание значений для каждого столбца в строке, добавьте строку <xref:System.Data.DataRowCollection>с помощью `Add` метод.</xref:System.Data.DataRowCollection>       Каждый <xref:System.Data.DataRow>в коллекции представляет строку данных в таблице.</xref:System.Data.DataRow> Чтобы сохранить измененное значение столбца в строке, необходимо вызвать <xref:System.Data.DataTable.AcceptChanges%2A>метод.</xref:System.Data.DataTable.AcceptChanges%2A>"
  example:
  - "The following shows two examples of returning and setting rows. The first example uses the Rows property and prints the value of each column for every row. The second example uses the <xref:System.Data.DataTable> object's <xref:System.Data.DataTable.NewRow%2A> method to create a new <xref:System.Data.DataRow> object with the schema of the <xref:System.Data.DataTable>. After setting the row values, the row is added to the <xref:System.Data.DataRowCollection> through the `Add` method.  \n  \n [!code-cs[Classic WebData DataTable.Rows Example#1](~/add/codesnippet/csharp/p-system.data.datatable._1_1.cs)]\n [!code-vb[Classic WebData DataTable.Rows Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._1_1.vb)]"
  syntax:
    content: public System.Data.DataRowCollection Rows { get; }
    return:
      type: System.Data.DataRowCollection
      description: "Объект <xref href=&quot;System.Data.DataRowCollection&quot;> </xref> , содержащий <xref href=&quot;System.Data.DataRow&quot;> </xref> объектов; в противном случае — значение null, если не <xref href=&quot;System.Data.DataRow&quot;> </xref> объекты существуют."
  overload: System.Data.DataTable.Rows*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Select
  id: Select
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Select()
  nameWithType: DataTable.Select()
  fullName: System.Data.DataTable.Select()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает массив всех <xref href=&quot;System.Data.DataRow&quot;> </xref> объектов."
  remarks: "Чтобы обеспечить правильную сортировку, укажите критерии сортировки или <xref:System.Data.DataTable.Select%2A> <xref:System.Data.DataTable.Select%2A>.</xref:System.Data.DataTable.Select%2A> </xref:System.Data.DataTable.Select%2A>"
  example:
  - "The following example returns an array of <xref:System.Data.DataRow> objects through the Select method.  \n  \n [!code-cs[Classic WebData DataTable.Select Example#1](~/add/codesnippet/csharp/m-system.data.datatable._6_1.cs)]\n [!code-vb[Classic WebData DataTable.Select Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._6_1.vb)]"
  syntax:
    content: public System.Data.DataRow[] Select ();
    parameters: []
    return:
      type: System.Data.DataRow[]
      description: "Массив <xref href=&quot;System.Data.DataRow&quot;> </xref> объектов."
  overload: System.Data.DataTable.Select*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Select(System.String)
  id: Select(System.String)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Select(String)
  nameWithType: DataTable.Select(String)
  fullName: System.Data.DataTable.Select(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает массив всех <xref href=&quot;System.Data.DataRow&quot;> </xref> объектов, соответствующих условиям фильтра."
  remarks: "Для создания `filterExpression` аргумент, использующих те же правила, которые применяются к <xref:System.Data.DataColumn>класса <xref:System.Data.DataColumn.Expression%2A>значение свойства для создания фильтров.</xref:System.Data.DataColumn.Expression%2A> </xref:System.Data.DataColumn>       Чтобы обеспечить правильную сортировку, укажите критерии сортировки или <xref:System.Data.DataTable.Select%2A> <xref:System.Data.DataTable.Select%2A>.</xref:System.Data.DataTable.Select%2A> </xref:System.Data.DataTable.Select%2A>       Если столбец фильтра содержит значение null, он не будет часть результата."
  example:
  - "The following example uses a filter expression to return an array of <xref:System.Data.DataRow> objects.  \n  \n [!code-cs[Classic WebData DataTable.Select1 Example#1](~/add/codesnippet/csharp/m-system.data.datatable._7_1.cs)]\n [!code-vb[Classic WebData DataTable.Select1 Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._7_1.vb)]"
  syntax:
    content: public System.Data.DataRow[] Select (string filterExpression);
    parameters:
    - id: filterExpression
      type: System.String
      description: "Критерии, используемые для фильтрации строк. Примеры, демонстрирующие для фильтрации строк, в разделе [синтаксис RowFilter DataView \\[C#\\]](http://www.csharp-examples.net/dataview-rowfilter/)."
    return:
      type: System.Data.DataRow[]
      description: "Массив <xref href=&quot;System.Data.DataRow&quot;> </xref> объектов."
  overload: System.Data.DataTable.Select*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Select(System.String,System.String)
  id: Select(System.String,System.String)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Select(String,String)
  nameWithType: DataTable.Select(String,String)
  fullName: System.Data.DataTable.Select(String,String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает массив всех <xref href=&quot;System.Data.DataRow&quot;> </xref> объекты, соответствующие условиям фильтра, согласно определенному порядку сортировки."
  remarks: "Форму `filterExpression` аргумент, использующих те же правила для создания <xref:System.Data.DataColumn>класса <xref:System.Data.DataColumn.Expression%2A>значение свойства.</xref:System.Data.DataColumn.Expression%2A> </xref:System.Data.DataColumn> `Sort` Аргумент также использует те же правила для создания класса <xref:System.Data.DataColumn.Expression%2A>строки.</xref:System.Data.DataColumn.Expression%2A>       Если столбец фильтра содержит значение null, он не будет часть результата."
  example:
  - "The following example uses a filter expression to return an array of <xref:System.Data.DataRow> objects.  \n  \n [!code-cs[Classic WebData DataTable.Select2 Example#1](~/add/codesnippet/csharp/m-system.data.datatable._11_1.cs)]\n [!code-vb[Classic WebData DataTable.Select2 Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._11_1.vb)]"
  syntax:
    content: public System.Data.DataRow[] Select (string filterExpression, string sort);
    parameters:
    - id: filterExpression
      type: System.String
      description: "Критерии, используемые для фильтрации строк. Примеры, демонстрирующие для фильтрации строк, в разделе [синтаксис RowFilter DataView \\[C#\\]](http://www.csharp-examples.net/dataview-rowfilter/)."
    - id: sort
      type: System.String
      description: "Строка, задающая столбец и направление сортировки."
    return:
      type: System.Data.DataRow[]
      description: "Массив <xref href=&quot;System.Data.DataRow&quot;> </xref> объектов, соответствующих критерий фильтра."
  overload: System.Data.DataTable.Select*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)
  id: Select(System.String,System.String,System.Data.DataViewRowState)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Select(String,String,DataViewRowState)
  nameWithType: DataTable.Select(String,String,DataViewRowState)
  fullName: System.Data.DataTable.Select(String,String,DataViewRowState)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает массив всех <xref href=&quot;System.Data.DataRow&quot;> </xref> объекты, соответствующие фильтру, в порядке сортировки для указанного состояния."
  remarks: "Форму `filterExpression` аргумент, использующих те же правила для создания <xref:System.Data.DataColumn>класса <xref:System.Data.DataColumn.Expression%2A>значение свойства.</xref:System.Data.DataColumn.Expression%2A> </xref:System.Data.DataColumn> `Sort` Аргумент также использует те же правила для создания класса <xref:System.Data.DataColumn.Expression%2A>строки.</xref:System.Data.DataColumn.Expression%2A>       Если столбец фильтра содержит значение null, он не будет часть результата."
  example:
  - "The following example uses a filter expression and record state to return an array of <xref:System.Data.DataRow> objects.  \n  \n [!code-cs[Classic WebData DataTable.Select3 Example#1](~/add/codesnippet/csharp/c72cdab9-f58a-41a1-a322-_1.cs)]\n [!code-vb[Classic WebData DataTable.Select3 Example#1](~/add/codesnippet/visualbasic/c72cdab9-f58a-41a1-a322-_1.vb)]"
  syntax:
    content: public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);
    parameters:
    - id: filterExpression
      type: System.String
      description: "Критерии, используемые для фильтрации строк. Примеры, демонстрирующие для фильтрации строк, в разделе [синтаксис RowFilter DataView \\[C#\\]](http://www.csharp-examples.net/dataview-rowfilter/)."
    - id: sort
      type: System.String
      description: "Строка, задающая столбец и направление сортировки."
    - id: recordStates
      type: System.Data.DataViewRowState
      description: "Один из <xref href=&quot;System.Data.DataViewRowState&quot;> </xref> значения."
    return:
      type: System.Data.DataRow[]
      description: "Массив <xref href=&quot;System.Data.DataRow&quot;> </xref> объектов."
  overload: System.Data.DataTable.Select*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.Site
  id: Site
  parent: System.Data.DataTable
  langs:
  - csharp
  name: Site
  nameWithType: DataTable.Site
  fullName: System.Data.DataTable.Site
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает или задает <xref href=&quot;System.ComponentModel.ISite&quot;> </xref> для <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  remarks: "Узлы связывают <xref:System.ComponentModel.Component>для <xref:System.ComponentModel.Container>и разрешить связь между ними, а также предоставляют способ для управления компонентами в контейнере.</xref:System.ComponentModel.Container> </xref:System.ComponentModel.Component>"
  syntax:
    content: public override System.ComponentModel.ISite Site { get; set; }
    return:
      type: System.ComponentModel.ISite
      description: "An <xref href=&quot;System.ComponentModel.ISite&quot;></xref> for the <xref href=&quot;System.Data.DataTable&quot;></xref>."
  overload: System.Data.DataTable.Site*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection
  id: System#ComponentModel#IListSource#ContainsListCollection
  isEii: true
  parent: System.Data.DataTable
  langs:
  - csharp
  name: System.ComponentModel.IListSource.ContainsListCollection
  nameWithType: DataTable.System.ComponentModel.IListSource.ContainsListCollection
  fullName: System.Data.DataTable.System.ComponentModel.IListSource.ContainsListCollection
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Описание этого члена см. в разделе &lt;xref:System.ComponentModel.IListSource.ContainsListCollection%2A?displayProperty=fullName&gt;."
  remarks: "Этот член представляет явную реализацию члена интерфейса. Он может использоваться только если <xref:System.Data.DataTable>экземпляр приводится к <xref:System.ComponentModel.IListSource>интерфейс.</xref:System.ComponentModel.IListSource> </xref:System.Data.DataTable>"
  syntax:
    content: bool System.ComponentModel.IListSource.ContainsListCollection { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если коллекция — это совокупность <xref:System.Collections.IList>объектов; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Collections.IList>"
  overload: System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.System#ComponentModel#IListSource#GetList
  id: System#ComponentModel#IListSource#GetList
  isEii: true
  parent: System.Data.DataTable
  langs:
  - csharp
  name: System.ComponentModel.IListSource.GetList()
  nameWithType: DataTable.System.ComponentModel.IListSource.GetList()
  fullName: System.Data.DataTable.System.ComponentModel.IListSource.GetList()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Описание этого члена см. в разделе &lt;xref:System.ComponentModel.IListSource.GetList%2A?displayProperty=fullName&gt;."
  remarks: "Этот член представляет явную реализацию члена интерфейса. Он может использоваться только если <xref:System.Data.DataTable>экземпляр приводится к <xref:System.ComponentModel.IListSource>интерфейс.</xref:System.ComponentModel.IListSource> </xref:System.Data.DataTable>"
  syntax:
    content: System.Collections.IList IListSource.GetList ();
    parameters: []
    return:
      type: System.Collections.IList
      description: "<xref:System.Collections.IList>, Можно привязать к источнику данных из объекта.</xref:System.Collections.IList>"
  overload: System.Data.DataTable.System#ComponentModel#IListSource#GetList*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema
  id: System#Xml#Serialization#IXmlSerializable#GetSchema
  isEii: true
  parent: System.Data.DataTable
  langs:
  - csharp
  name: System.Xml.Serialization.IXmlSerializable.GetSchema()
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.GetSchema()
  fullName: System.Data.DataTable.System.Xml.Serialization.IXmlSerializable.GetSchema()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Описание этого члена см. в разделе &lt;xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A?displayProperty=fullName&gt;."
  remarks: "Этот член представляет явную реализацию члена интерфейса. Он может использоваться только если <xref:System.Data.DataSet>экземпляр приводится к <xref:System.Xml.Serialization.IXmlSerializable>интерфейс.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Data.DataSet>"
  syntax:
    content: System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();
    parameters: []
    return:
      type: System.Xml.Schema.XmlSchema
      description: "<xref:System.Xml.Schema.XmlSchema>, Описывающий XML-представление объекта, формируемого с <> </> *настроек метод и используемый <> </> *настроек метод.</xref:System.Xml.Schema.XmlSchema>"
  overload: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  id: System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  isEii: true
  parent: System.Data.DataTable
  langs:
  - csharp
  name: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  fullName: System.Data.DataTable.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Описание этого члена см. в разделе &lt;xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A?displayProperty=fullName&gt;."
  remarks: "Этот член представляет явную реализацию члена интерфейса. Он может использоваться только если <xref:System.Data.DataSet>экземпляр приводится к <xref:System.Xml.Serialization.IXmlSerializable>интерфейс.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Data.DataSet>"
  syntax:
    content: void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "Объект XmlReader."
  overload: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  id: System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  isEii: true
  parent: System.Data.DataTable
  langs:
  - csharp
  name: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  fullName: System.Data.DataTable.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Описание этого члена см. в разделе &lt;xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A?displayProperty=fullName&gt;."
  remarks: "Этот член представляет явную реализацию члена интерфейса. Он может использоваться только если <xref:System.Data.DataSet>экземпляр приводится к <xref:System.Xml.Serialization.IXmlSerializable>интерфейс.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Data.DataSet>"
  syntax:
    content: void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "Объект XmlWriter."
  overload: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.TableCleared
  id: TableCleared
  parent: System.Data.DataTable
  langs:
  - csharp
  name: TableCleared
  nameWithType: DataTable.TableCleared
  fullName: System.Data.DataTable.TableCleared
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Происходит после <xref href=&quot;System.Data.DataTable&quot;> </xref> очищается."
  remarks: "TableCleared событие сразу после все строки успешно удалены перед вызовом <xref:System.Data.DataTable.Clear%2A>метод возвращает управление вызывающему объекту.</xref:System.Data.DataTable.Clear%2A> Событие TableCleared не срабатывает, если любые исключения во время операции очистки."
  syntax:
    content: public event System.Data.DataTableClearEventHandler TableCleared;
    return:
      type: System.Data.DataTableClearEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.TableClearing
  id: TableClearing
  parent: System.Data.DataTable
  langs:
  - csharp
  name: TableClearing
  nameWithType: DataTable.TableClearing
  fullName: System.Data.DataTable.TableClearing
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Происходит, когда <xref href=&quot;System.Data.DataTable&quot;> </xref> очищается."
  remarks: "TableClearing событие перед началом обработки <xref:System.Data.DataTable.Clear%2A>начала операции.</xref:System.Data.DataTable.Clear%2A> Это событие всегда возникает, когда <xref:System.Data.DataTable.Clear%2A>вызывается метод, даже если таблица содержит нулевые строки.</xref:System.Data.DataTable.Clear%2A>"
  syntax:
    content: public event System.Data.DataTableClearEventHandler TableClearing;
    return:
      type: System.Data.DataTableClearEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.TableName
  id: TableName
  parent: System.Data.DataTable
  langs:
  - csharp
  name: TableName
  nameWithType: DataTable.TableName
  fullName: System.Data.DataTable.TableName
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает или задает имя <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  remarks: "TableName используется для возврата в этой таблице от родительского <xref:System.Data.DataSet>объекта <xref:System.Data.DataTableCollection>(возвращенный <xref:System.Data.DataSet.Tables%2A>свойство).</xref:System.Data.DataSet.Tables%2A> </xref:System.Data.DataTableCollection> </xref:System.Data.DataSet>"
  example:
  - "The following example prints the TableName for each table in a collection of <xref:System.Data.DataTable> objects.  \n  \n [!code-cs[Classic WebData DataTable.TableName Example#1](~/add/codesnippet/csharp/p-system.data.datatable._2_1.cs)]\n [!code-vb[Classic WebData DataTable.TableName Example#1](~/add/codesnippet/visualbasic/p-system.data.datatable._2_1.vb)]"
  syntax:
    content: public string TableName { get; set; }
    return:
      type: System.String
      description: "Имя <xref href=&quot;System.Data.DataTable&quot;> </xref>."
  overload: System.Data.DataTable.TableName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>или пустая строка (&quot;») передается в и таблица принадлежит коллекции."
  - type: System.Data.DuplicateNameException
    commentId: T:System.Data.DuplicateNameException
    description: "Таблица принадлежит к коллекции, которая уже содержит таблицу с тем же именем. (При сравнении учитывается регистр)."
  platform:
  - net462
- uid: System.Data.DataTable.TableNewRow
  id: TableNewRow
  parent: System.Data.DataTable
  langs:
  - csharp
  name: TableNewRow
  nameWithType: DataTable.TableNewRow
  fullName: System.Data.DataTable.TableNewRow
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Происходит при создании нового <xref href=&quot;System.Data.DataRow&quot;> </xref> вставляется."
  remarks: "Активируется после новой <xref:System.Data.DataRow>был создан с помощью <xref:System.Data.DataTable.NewRow%2A>.</xref:System.Data.DataTable.NewRow%2A> </xref:System.Data.DataRow> Это событие возникает перед вызываемую `NewRow` возвращает метод. Новый <xref:System.Data.DataRow>экземпляр отключен; он не был добавлен в коллекцию.</xref:System.Data.DataRow>"
  syntax:
    content: public event System.Data.DataTableNewRowEventHandler TableNewRow;
    return:
      type: System.Data.DataTableNewRowEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.ToString
  id: ToString
  parent: System.Data.DataTable
  langs:
  - csharp
  name: ToString()
  nameWithType: DataTable.ToString()
  fullName: System.Data.DataTable.ToString()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Возвращает <> </> *настроек и <> </> *настроек, если он определен как объединенная строка."
  remarks: "Получает <xref:System.Data.DataTable.TableName%2A>и <xref:System.Data.DataTable.DisplayExpression%2A>для <xref:System.Data.DataTable>.</xref:System.Data.DataTable> </xref:System.Data.DataTable.DisplayExpression%2A> </xref:System.Data.DataTable.TableName%2A>"
  example:
  - "The following example returns the <xref:System.Data.DataTable.TableName%2A> and <xref:System.Data.DataTable.DisplayExpression%2A> using the ToString method.  \n  \n [!code-cs[Classic WebData DataTable.ToString Example#1](~/add/codesnippet/csharp/m-system.data.datatable._28_1.cs)]\n [!code-vb[Classic WebData DataTable.ToString Example#1](~/add/codesnippet/visualbasic/m-system.data.datatable._28_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "Строка, состоящая из <> </> *настроек и <> </> *настроек значения."
  overload: System.Data.DataTable.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.Stream)
  id: WriteXml(System.IO.Stream)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(Stream)
  nameWithType: DataTable.WriteXml(Stream)
  fullName: System.Data.DataTable.WriteXml(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущее содержимое <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML с помощью указанного <xref:System.IO.Stream>.</xref:System.IO.Stream>"
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "Поток, в который будут записываться данные."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter)
  id: WriteXml(System.IO.TextWriter)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(TextWriter)
  nameWithType: DataTable.WriteXml(TextWriter)
  fullName: System.Data.DataTable.WriteXml(TextWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущее содержимое <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML с помощью указанного <xref:System.IO.TextWriter>.</xref:System.IO.TextWriter>"
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.TextWriter writer);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>С помощью которого для записи содержимого.</xref:System.IO.TextWriter>"
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.String)
  id: WriteXml(System.String)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(String)
  nameWithType: DataTable.WriteXml(String)
  fullName: System.Data.DataTable.WriteXml(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущее содержимое <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML, используя указанный файл."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "Файл, в который записывается XML-данных."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter)
  id: WriteXml(System.Xml.XmlWriter)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(XmlWriter)
  nameWithType: DataTable.WriteXml(XmlWriter)
  fullName: System.Data.DataTable.WriteXml(XmlWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущее содержимое <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML с помощью указанного <xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter>"
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые включают <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.Xml.XmlWriter writer);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>С помощью которого для записи содержимого.</xref:System.Xml.XmlWriter>"
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)
  id: WriteXml(System.IO.Stream,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(Stream,Boolean)
  nameWithType: DataTable.WriteXml(Stream,Boolean)
  fullName: System.Data.DataTable.WriteXml(Stream,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущее содержимое <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML с помощью указанного <xref:System.IO.Stream>.</xref:System.IO.Stream> Чтобы сохранить данные для таблицы и всех его потомков, задайте <code> writeHierarchy </code> параметр <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  remarks: "Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A>способ записи схемы для <xref:System.Data.DataTable>в XML-документ.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> Схема содержит определения таблиц, связей и ограничений.       XML-схема записывается с использованием стандарта XSD.       Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A>метод.</xref:System.Data.DataTable.WriteXml%2A>       Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всех ее потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.Stream stream, bool writeHierarchy);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "Поток, в который будут записываться данные."
    - id: writeHierarchy
      type: System.Boolean
      description: "Если <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, запись содержимого текущей таблицы и всех его потомков. Если <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (значение по умолчанию), записать данные в текущей таблице."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  id: WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(Stream,XmlWriteMode)
  nameWithType: DataTable.WriteXml(Stream,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(Stream,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущие данные и по возможности схемы для <xref href=&quot;System.Data.DataTable&quot;> </xref> в указанном файле, с использованием указанного <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>. Чтобы записать схему, задайте значение для <code> mode </code> параметр <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "Поток, в который будут записываться данные."
    - id: mode
      type: System.Data.XmlWriteMode
      description: "Один из <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> значения."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)
  id: WriteXml(System.IO.TextWriter,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(TextWriter,Boolean)
  nameWithType: DataTable.WriteXml(TextWriter,Boolean)
  fullName: System.Data.DataTable.WriteXml(TextWriter,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущее содержимое <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML с помощью указанного <xref:System.IO.TextWriter>.</xref:System.IO.TextWriter> Чтобы сохранить данные для таблицы и всех его потомков, задайте <code> writeHierarchy </code> параметр <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всех его потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  example:
  - "The following console application creates two <xref:System.Data.DataTable> instances, adds each to a <xref:System.Data.DataSet>, creates a <xref:System.Data.DataRelation> relating the two tables, and then uses the WriteXml method to write the data contained within the parent table to a <xref:System.IO.TextWriter>. The example demonstrates the behavior when setting the `writeHierarchy` parameter to `true`.  \n  \n [!code-cs[DataWorks DataTable.WriteXml#1](~/add/codesnippet/csharp/m-system.data.datatable._1_1.cs)]\n [!code-vb[DataWorks DataTable.WriteXml#1](~/add/codesnippet/visualbasic/m-system.data.datatable._1_1.vb)]"
  syntax:
    content: public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>С помощью которого для записи содержимого.</xref:System.IO.TextWriter>"
    - id: writeHierarchy
      type: System.Boolean
      description: "Если <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, запись содержимого текущей таблицы и всех его потомков. Если <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (значение по умолчанию), записать данные в текущей таблице."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  id: WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(TextWriter,XmlWriteMode)
  nameWithType: DataTable.WriteXml(TextWriter,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(TextWriter,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущие данные и по возможности схемы для <xref href=&quot;System.Data.DataTable&quot;> </xref> с использованием указанного <xref:System.IO.TextWriter>и <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>.</xref:System.IO.TextWriter> Чтобы записать схему, задайте значение для <code> mode </code> параметр <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>Используется для записи в документ.</xref:System.IO.TextWriter>"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "Один из <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> значения."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.String,System.Boolean)
  id: WriteXml(System.String,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(String,Boolean)
  nameWithType: DataTable.WriteXml(String,Boolean)
  fullName: System.Data.DataTable.WriteXml(String,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущее содержимое <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML, используя указанный файл. Чтобы сохранить данные для таблицы и всех его потомков, задайте <code> writeHierarchy </code> параметр <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.       Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всех ее потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (string fileName, bool writeHierarchy);
    parameters:
    - id: fileName
      type: System.String
      description: "Файл, в который записывается XML-данных."
    - id: writeHierarchy
      type: System.Boolean
      description: "Если <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, запись содержимого текущей таблицы и всех его потомков. Если <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (значение по умолчанию), записать данные в текущей таблице."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)
  id: WriteXml(System.String,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(String,XmlWriteMode)
  nameWithType: DataTable.WriteXml(String,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(String,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущие данные и по возможности схемы для <xref href=&quot;System.Data.DataTable&quot;> </xref> с помощью указанного файла и <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>. Чтобы записать схему, задайте значение для <code> mode </code> параметр <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые включают <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (string fileName, System.Data.XmlWriteMode mode);
    parameters:
    - id: fileName
      type: System.String
      description: "Имя файла, в который будут записываться данные."
    - id: mode
      type: System.Data.XmlWriteMode
      description: "Один из <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> значения."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)
  id: WriteXml(System.Xml.XmlWriter,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(XmlWriter,Boolean)
  nameWithType: DataTable.WriteXml(XmlWriter,Boolean)
  fullName: System.Data.DataTable.WriteXml(XmlWriter,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущее содержимое <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML с помощью указанного <xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter>"
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые включают <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.       Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всей потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>С помощью которого для записи содержимого.</xref:System.Xml.XmlWriter>"
    - id: writeHierarchy
      type: System.Boolean
      description: "Если <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, запись содержимого текущей таблицы и всех его потомков. Если <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (значение по умолчанию), записать данные в текущей таблице."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  id: WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(XmlWriter,XmlWriteMode)
  nameWithType: DataTable.WriteXml(XmlWriter,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(XmlWriter,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущие данные и по возможности схемы для <xref href=&quot;System.Data.DataTable&quot;> </xref> с использованием указанного <xref:System.Xml.XmlWriter>и <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>.</xref:System.Xml.XmlWriter> Чтобы записать схему, задайте значение для <code> mode </code> параметр <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые включают <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>Используется для записи в документ.</xref:System.Xml.XmlWriter>"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "Один из <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> значения."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)
  id: WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(Stream,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(Stream,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(Stream,XmlWriteMode,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущие данные и по возможности схемы для <xref href=&quot;System.Data.DataTable&quot;> </xref> в указанном файле, с использованием указанного <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>. Чтобы записать схему, задайте значение для <code> mode </code> параметр <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>. Чтобы сохранить данные для таблицы и всех его потомков, задайте <code> writeHierarchy </code> параметр <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из `DataTable` в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в `XmlWriteMode` параметра и присвойте ему значение `WriteSchema`.       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.       Как правило `WriteXml` метод сохраняет данные только для текущей таблицы. `WriteXml` Метод предоставляет способ записи только данных или данных вместе со схемой из `DataTable` в XML-документ, в то время как `WriteXmlSchema` метод записывает только схему. Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в `XmlWriteMode` параметра и присвойте ему значение `WriteSchema`.       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.       Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всех ее потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "Поток, в который будут записываться данные."
    - id: mode
      type: System.Data.XmlWriteMode
      description: "Один из <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> значения."
    - id: writeHierarchy
      type: System.Boolean
      description: "Если <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, запись содержимого текущей таблицы и всех его потомков. Если <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (значение по умолчанию), записать данные в текущей таблице."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)
  id: WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(TextWriter,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(TextWriter,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(TextWriter,XmlWriteMode,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущие данные и по возможности схемы для <xref href=&quot;System.Data.DataTable&quot;> </xref> с использованием указанного <xref:System.IO.TextWriter>и <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>.</xref:System.IO.TextWriter> Чтобы записать схему, задайте значение для <code> mode </code> параметр <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>. Чтобы сохранить данные для таблицы и всех его потомков, задайте <code> writeHierarchy </code> параметр <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.       Как правило `WriteXml` метод сохраняет данные только для текущей таблицы. <xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые содержатся в <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.       Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всех ее потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  example:
  - "The following console application creates two <xref:System.Data.DataTable> instances, adds each to a <xref:System.Data.DataSet>, creates a <xref:System.Data.DataRelation> relating the two tables, and then uses the WriteXml method to write the data contained within the parent table to a <xref:System.IO.TextWriter>. The example demonstrates the behavior when setting the `writeHierarchy` parameter to each of its values.  \n  \n [!code-cs[DataWorks DataTable.WriteXmlIO#1](~/add/codesnippet/csharp/a21e26c1-61d0-4d79-88a3-_1.cs)]\n [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/add/codesnippet/visualbasic/a21e26c1-61d0-4d79-88a3-_1.vb)]  \n  \n The example displays the following output in the console window:  \n  \n```  \n==============================  \nCustomer table, without hierarchy  \n==============================  \n<NewDataSet>  \n  <xs:schema id=\"NewDataSet\" xmlns=\"\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema  \n\" xmlns:msdata=\"urn:schemas-microsoft-com:xml-msdata\">  \n    <xs:element name=\"NewDataSet\" msdata:IsDataSet=\"true\" msdata:MainDataTable=\"Table1\">  \n      <xs:complexType>  \n        <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">  \n          <xs:element name=\"Table1\">  \n            <xs:complexType>  \n              <xs:sequence>  \n                <xs:element name=\"ID\" type=\"xs:int\" />  \n                <xs:element name=\"Name\" type=\"xs:string\" minOccurs=\"0\" />  \n              </xs:sequence>  \n            </xs:complexType>  \n          </xs:element>  \n        </xs:choice>  \n      </xs:complexType>  \n      <xs:unique name=\"Constraint1\" msdata:PrimaryKey=\"true\">  \n        <xs:selector xpath=\".//Table1\" />  \n        <xs:field xpath=\"ID\" />  \n      </xs:unique>  \n    </xs:element>  \n  </xs:schema>  \n  <Table1>  \n    <ID>1</ID>  \n    <Name>Mary</Name>  \n  </Table1>  \n  <Table1>  \n    <ID>2</ID>  \n    <Name>Andy</Name>  \n  </Table1>  \n  <Table1>  \n    <ID>3</ID>  \n    <Name>Peter</Name>  \n  </Table1>  \n  <Table1>  \n    <ID>4</ID>  \n    <Name>Russ</Name>  \n  </Table1>  \n</NewDataSet>  \n==============================  \nCustomer table, with hierarchy  \n==============================  \n<NewDataSet>  \n  <xs:schema id=\"NewDataSet\" xmlns=\"\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema  \n\" xmlns:msdata=\"urn:schemas-microsoft-com:xml-msdata\">  \n    <xs:element name=\"NewDataSet\" msdata:IsDataSet=\"true\" msdata:MainDataTable=\"Table1\">  \n      <xs:complexType>  \n        <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">  \n          <xs:element name=\"Table1\">  \n            <xs:complexType>  \n              <xs:sequence>  \n                <xs:element name=\"ID\" type=\"xs:int\" />  \n                <xs:element name=\"Name\" type=\"xs:string\" minOccurs=\"0\" />  \n              </xs:sequence>  \n            </xs:complexType>  \n          </xs:element>  \n          <xs:element name=\"Table2\">  \n            <xs:complexType>  \n              <xs:sequence>  \n                <xs:element name=\"OrderID\" type=\"xs:int\" />  \n                <xs:element name=\"CustomerID\" type=\"xs:int\" minOccurs=\"0\" />  \n                <xs:element name=\"OrderDate\" type=\"xs:dateTime\" minOccurs=\"0\" />  \n  \n              </xs:sequence>  \n            </xs:complexType>  \n          </xs:element>  \n        </xs:choice>  \n      </xs:complexType>  \n      <xs:unique name=\"Constraint1\" msdata:PrimaryKey=\"true\">  \n        <xs:selector xpath=\".//Table1\" />  \n        <xs:field xpath=\"ID\" />  \n      </xs:unique>  \n      <xs:unique name=\"Table2_Constraint1\" msdata:ConstraintName=\"Constraint1\" m  \nsdata:PrimaryKey=\"true\">  \n        <xs:selector xpath=\".//Table2\" />  \n        <xs:field xpath=\"OrderID\" />  \n      </xs:unique>  \n      <xs:keyref name=\"CustomerOrder\" refer=\"Constraint1\">  \n        <xs:selector xpath=\".//Table2\" />  \n        <xs:field xpath=\"CustomerID\" />  \n      </xs:keyref>  \n    </xs:element>  \n  </xs:schema>  \n  <Table1>  \n    <ID>1</ID>  \n    <Name>Mary</Name>  \n  </Table1>  \n  <Table1>  \n    <ID>2</ID>  \n    <Name>Andy</Name>  \n  </Table1>  \n  <Table1>  \n    <ID>3</ID>  \n    <Name>Peter</Name>  \n  </Table1>  \n  <Table1>  \n    <ID>4</ID>  \n    <Name>Russ</Name>  \n  </Table1>  \n  <Table2>  \n    <OrderID>1</OrderID>  \n    <CustomerID>1</CustomerID>  \n    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  \n  </Table2>  \n  <Table2>  \n    <OrderID>2</OrderID>  \n    <CustomerID>1</CustomerID>  \n    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  \n  </Table2>  \n  <Table2>  \n    <OrderID>3</OrderID>  \n    <CustomerID>2</CustomerID>  \n    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  \n  </Table2>  \n  <Table2>  \n    <OrderID>4</OrderID>  \n    <CustomerID>3</CustomerID>  \n    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  \n  </Table2>  \n  <Table2>  \n    <OrderID>5</OrderID>  \n    <CustomerID>3</CustomerID>  \n    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  \n  </Table2>  \n  <Table2>  \n    <OrderID>6</OrderID>  \n    <CustomerID>4</CustomerID>  \n    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  \n  </Table2>  \n</NewDataSet>  \n```"
  syntax:
    content: public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>Используется для записи в документ.</xref:System.IO.TextWriter>"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "Один из <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> значения."
    - id: writeHierarchy
      type: System.Boolean
      description: "Если <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, запись содержимого текущей таблицы и всех его потомков. Если <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (значение по умолчанию), записать данные в текущей таблице."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)
  id: WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(String,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(String,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(String,XmlWriteMode,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущие данные и по возможности схемы для <xref href=&quot;System.Data.DataTable&quot;> </xref> с помощью указанного файла и <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>. Чтобы записать схему, задайте значение для <code> mode </code> параметр <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>. Чтобы сохранить данные для таблицы и всех его потомков, задайте <code> writeHierarchy </code> параметр <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые включают <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.       Как правило `WriteXml` метод сохраняет данные только для текущей таблицы. Если вы хотите сохранить данные для текущей таблицы и все схемы, <xref:System.Data.DataTable.WriteXml%2A>метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые включают <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.       Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всех потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);
    parameters:
    - id: fileName
      type: System.String
      description: "Имя файла, в который будут записываться данные."
    - id: mode
      type: System.Data.XmlWriteMode
      description: "Один из <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> значения."
    - id: writeHierarchy
      type: System.Boolean
      description: "Если <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, запись содержимого текущей таблицы и всех его потомков. Если <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (значение по умолчанию), записать данные в текущей таблице."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)
  id: WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXml(XmlWriter,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(XmlWriter,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(XmlWriter,XmlWriteMode,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущие данные и по возможности схемы для <xref href=&quot;System.Data.DataTable&quot;> </xref> с использованием указанного <xref:System.Xml.XmlWriter>и <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>.</xref:System.Xml.XmlWriter> Чтобы записать схему, задайте значение для <code> mode </code> параметр <xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>. Чтобы сохранить данные для таблицы и всех его потомков, задайте <code> writeHierarchy </code> параметр <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  remarks: "<xref:System.Data.DataTable.WriteXml%2A>Метод предоставляет способ записи только данных или данных вместе со схемой из <xref:System.Data.DataTable>в XML-документ, в то время как <xref:System.Data.DataTable.WriteXmlSchema%2A>метод записывает только схему.</xref:System.Data.DataTable.WriteXmlSchema%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXml%2A> Для записи данных и схемы, используйте одну из перегрузок, которые включают <xref:System.Data.XmlWriteMode>параметра и присвойте ему значение `WriteSchema`.</xref:System.Data.XmlWriteMode>       Обратите внимание, что то же самое справедливо для <xref:System.Data.DataTable.ReadXml%2A>и <xref:System.Data.DataTable.ReadXmlSchema%2A>методов, соответственно.</xref:System.Data.DataTable.ReadXmlSchema%2A> </xref:System.Data.DataTable.ReadXml%2A> Для считывания XML-данных или схемы и данных в `DataTable`, используйте `ReadXml` метод. Для чтения только схемы, используйте `ReadXmlSchema` метод.       Обычно `WriteXml` метод записывает данные только для текущей таблицы. Чтобы записать данные для текущей таблицы и всей потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`.      Настроек [!NOTE] настроек <xref:System.InvalidOperationException>будут созданы, если тип столбца в `DataRow` чтение и запись данных реализует <xref:System.Dynamic.IDynamicMetaObjectProvider>и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>Используется для записи в документ.</xref:System.Xml.XmlWriter>"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "Один из <xref href=&quot;System.Data.XmlWriteMode&quot;> </xref> значения."
    - id: writeHierarchy
      type: System.Boolean
      description: "Если <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, запись содержимого текущей таблицы и всех его потомков. Если <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (значение по умолчанию), записать данные в текущей таблице."
  overload: System.Data.DataTable.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.Stream)
  id: WriteXmlSchema(System.IO.Stream)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(Stream)
  nameWithType: DataTable.WriteXmlSchema(Stream)
  fullName: System.Data.DataTable.WriteXmlSchema(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущей структуры данных <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML-схемы в указанный поток."
  remarks: "Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A>способ записи схемы для <xref:System.Data.DataTable>в XML-документ.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> Схема содержит определения таблиц, связей и ограничений.       XML-схема записывается с использованием стандарта XSD.       Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A>метод.</xref:System.Data.DataTable.WriteXml%2A>"
  syntax:
    content: public void WriteXmlSchema (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "Поток, в который будут записываться XML-схемы."
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)
  id: WriteXmlSchema(System.IO.TextWriter)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(TextWriter)
  nameWithType: DataTable.WriteXmlSchema(TextWriter)
  fullName: System.Data.DataTable.WriteXmlSchema(TextWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущей структуры данных <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML-схемы с помощью указанного <xref:System.IO.TextWriter>.</xref:System.IO.TextWriter>"
  remarks: "Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A>способ записи схемы для <xref:System.Data.DataTable>в XML-документ.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> Схема содержит определения таблиц, связей и ограничений.       XML-схема записывается с использованием стандарта XSD.       Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A>метод.</xref:System.Data.DataTable.WriteXml%2A>"
  syntax:
    content: public void WriteXmlSchema (System.IO.TextWriter writer);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>С для записи.</xref:System.IO.TextWriter>"
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.String)
  id: WriteXmlSchema(System.String)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(String)
  nameWithType: DataTable.WriteXmlSchema(String)
  fullName: System.Data.DataTable.WriteXmlSchema(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущей структуры данных <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML-схемы в указанный файл."
  remarks: "Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A>способ записи схемы для <xref:System.Data.DataTable>в XML-документ.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> Схема содержит определения таблиц, связей и ограничений.       XML-схема записывается с использованием стандарта XSD.       Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A>метод.</xref:System.Data.DataTable.WriteXml%2A>"
  syntax:
    content: public void WriteXmlSchema (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "Имя файла для использования."
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)
  id: WriteXmlSchema(System.Xml.XmlWriter)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(XmlWriter)
  nameWithType: DataTable.WriteXmlSchema(XmlWriter)
  fullName: System.Data.DataTable.WriteXmlSchema(XmlWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущей структуры данных <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML-схемы с помощью указанного <xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter>"
  remarks: "Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A>способ записи схемы для <xref:System.Data.DataTable>в XML-документ.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> Схема содержит определения таблиц, связей и ограничений.       XML-схема записывается с использованием стандарта XSD.       Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A>метод.</xref:System.Data.DataTable.WriteXml%2A>"
  syntax:
    content: public void WriteXmlSchema (System.Xml.XmlWriter writer);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>Для использования.</xref:System.Xml.XmlWriter>"
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)
  id: WriteXmlSchema(System.IO.Stream,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(Stream,Boolean)
  nameWithType: DataTable.WriteXmlSchema(Stream,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(Stream,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущей структуры данных <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML-схемы в указанный поток. Чтобы сохранить схему для таблицы и всех его потомков, задайте <code> writeHierarchy </code> параметр <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  remarks: "Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A>способ записи схемы для <xref:System.Data.DataTable>в XML-документ.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> Схема содержит определения таблиц, связей и ограничений.       XML-схема записывается с использованием стандарта XSD.       Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A>метод.</xref:System.Data.DataTable.WriteXml%2A>       Обычно `WriteXmlSchema` метод записывает схему только для текущей таблицы. Чтобы записать схему для текущей таблицы и всей потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`."
  syntax:
    content: public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "Поток, в который будут записываться XML-схемы."
    - id: writeHierarchy
      type: System.Boolean
      description: "Если <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, записывает схему текущей таблицы и всех его потомков. Если <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (значение по умолчанию), записи схемы в текущей таблице."
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)
  id: WriteXmlSchema(System.IO.TextWriter,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(TextWriter,Boolean)
  nameWithType: DataTable.WriteXmlSchema(TextWriter,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(TextWriter,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущей структуры данных <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML-схемы с помощью указанного <xref:System.IO.TextWriter>.</xref:System.IO.TextWriter> Чтобы сохранить схему для таблицы и всех его потомков, задайте <code> writeHierarchy </code> параметр <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  remarks: "Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A>способ записи схемы для <xref:System.Data.DataTable>в XML-документ.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> Схема содержит определения таблиц, связей и ограничений.       XML-схема записывается с использованием стандарта XSD.       Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A>метод.</xref:System.Data.DataTable.WriteXml%2A>       Обычно `WriteXmlSchema` метод записывает схему только для текущей таблицы. Чтобы записать схему для текущей таблицы и всей потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`."
  example:
  - "The following console application creates two <xref:System.Data.DataTable> instances, adds each to a <xref:System.Data.DataSet>, creates a <xref:System.Data.DataRelation> relating the two tables, and then uses the WriteXmlSchema method to write the data contained within the parent table to a <xref:System.IO.TextWriter>. The example demonstrates the behavior when setting the `writeHierarchy` parameter to each of its values.  \n  \n [!code-cs[DataWorks DataTable.WriteXmlSchema#1](~/add/codesnippet/csharp/m-system.data.datatable._30_1.cs)]\n [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/add/codesnippet/visualbasic/m-system.data.datatable._30_1.vb)]  \n  \n The example displays the following output in the console window:  \n  \n```  \n==============================  \nCustomer table, without hierarchy  \n==============================  \n<?xml version=\"1.0\" encoding=\"utf-16\"?>  \n<xs:schema id=\"NewDataSet\" xmlns=\"\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"  \nxmlns:msdata=\"urn:schemas-microsoft-com:xml-msdata\">  \n  <xs:element name=\"NewDataSet\" msdata:IsDataSet=\"true\" msdata:MainDataTable=\"Ta  \nble1\">  \n    <xs:complexType>  \n      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">  \n        <xs:element name=\"Table1\">  \n          <xs:complexType>  \n            <xs:sequence>  \n              <xs:element name=\"ID\" type=\"xs:int\" />  \n              <xs:element name=\"Name\" type=\"xs:string\" minOccurs=\"0\" />  \n            </xs:sequence>  \n          </xs:complexType>  \n        </xs:element>  \n      </xs:choice>  \n    </xs:complexType>  \n    <xs:unique name=\"Constraint1\" msdata:PrimaryKey=\"true\">  \n      <xs:selector xpath=\".//Table1\" />  \n      <xs:field xpath=\"ID\" />  \n    </xs:unique>  \n  </xs:element>  \n</xs:schema>  \n==============================  \nCustomer table, with hierarchy  \n==============================  \n<?xml version=\"1.0\" encoding=\"utf-16\"?>  \n<xs:schema id=\"NewDataSet\" xmlns=\"\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"  \nxmlns:msdata=\"urn:schemas-microsoft-com:xml-msdata\">  \n  <xs:element name=\"NewDataSet\" msdata:IsDataSet=\"true\" msdata:MainDataTable=\"Table1\">  \n    <xs:complexType>  \n      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">  \n        <xs:element name=\"Table1\">  \n          <xs:complexType>  \n            <xs:sequence>  \n              <xs:element name=\"ID\" type=\"xs:int\" />  \n              <xs:element name=\"Name\" type=\"xs:string\" minOccurs=\"0\" />  \n            </xs:sequence>  \n          </xs:complexType>  \n        </xs:element>  \n        <xs:element name=\"Table2\">  \n          <xs:complexType>  \n            <xs:sequence>  \n              <xs:element name=\"OrderID\" type=\"xs:int\" />  \n              <xs:element name=\"CustomerID\" type=\"xs:int\" minOccurs=\"0\" />  \n              <xs:element name=\"OrderDate\" type=\"xs:dateTime\" minOccurs=\"0\" />  \n            </xs:sequence>  \n          </xs:complexType>  \n        </xs:element>  \n      </xs:choice>  \n    </xs:complexType>  \n    <xs:unique name=\"Constraint1\" msdata:PrimaryKey=\"true\">  \n      <xs:selector xpath=\".//Table1\" />  \n      <xs:field xpath=\"ID\" />  \n    </xs:unique>  \n    <xs:unique name=\"Table2_Constraint1\" msdata:ConstraintName=\"Constraint1\" msdata:PrimaryKey=\"true\">  \n      <xs:selector xpath=\".//Table2\" />  \n      <xs:field xpath=\"OrderID\" />  \n    </xs:unique>  \n    <xs:keyref name=\"CustomerOrder\" refer=\"Constraint1\">  \n      <xs:selector xpath=\".//Table2\" />  \n      <xs:field xpath=\"CustomerID\" />  \n    </xs:keyref>  \n  </xs:element>  \n</xs:schema>  \n```"
  syntax:
    content: public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>С для записи.</xref:System.IO.TextWriter>"
    - id: writeHierarchy
      type: System.Boolean
      description: "Если <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, записывает схему текущей таблицы и всех его потомков. Если <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (значение по умолчанию), записи схемы в текущей таблице."
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)
  id: WriteXmlSchema(System.String,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(String,Boolean)
  nameWithType: DataTable.WriteXmlSchema(String,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(String,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущей структуры данных <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML-схемы в указанный файл. Чтобы сохранить схему для таблицы и всех его потомков, задайте <code> writeHierarchy </code> параметр <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  remarks: "Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A>способ записи схемы для <xref:System.Data.DataTable>в XML-документ.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> Схема содержит определения таблиц, связей и ограничений.       XML-схема записывается с использованием стандарта XSD.       Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A>метод.</xref:System.Data.DataTable.WriteXml%2A>       Обычно `WriteXmlSchema` метод записывает схему только для текущей таблицы. Чтобы записать схему для текущей таблицы и всей потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`."
  syntax:
    content: public void WriteXmlSchema (string fileName, bool writeHierarchy);
    parameters:
    - id: fileName
      type: System.String
      description: "Имя файла для использования."
    - id: writeHierarchy
      type: System.Boolean
      description: "Если <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, записывает схему текущей таблицы и всех его потомков. Если <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (значение по умолчанию), записи схемы в текущей таблице."
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)
  id: WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)
  parent: System.Data.DataTable
  langs:
  - csharp
  name: WriteXmlSchema(XmlWriter,Boolean)
  nameWithType: DataTable.WriteXmlSchema(XmlWriter,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(XmlWriter,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Записывает текущей структуры данных <xref href=&quot;System.Data.DataTable&quot;> </xref> как XML-схемы с помощью указанного <xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter> Чтобы сохранить схему для таблицы и всех его потомков, задайте <code> writeHierarchy </code> параметр <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  remarks: "Используйте <xref:System.Data.DataTable.WriteXmlSchema%2A>способ записи схемы для <xref:System.Data.DataTable>в XML-документ.</xref:System.Data.DataTable> </xref:System.Data.DataTable.WriteXmlSchema%2A> Схема содержит определения таблиц, связей и ограничений.       XML-схема записывается с использованием стандарта XSD.       Чтобы записать данные в XML-документ, используйте <xref:System.Data.DataTable.WriteXml%2A>метод.</xref:System.Data.DataTable.WriteXml%2A>       Обычно `WriteXmlSchema` метод записывает схему только для текущей таблицы. Чтобы записать схему для текущей таблицы и всей потомков, связанных таблиц, вызовите метод с `writeHierarchy` равным `true`."
  syntax:
    content: public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>Используется для записи в документ.</xref:System.Xml.XmlWriter>"
    - id: writeHierarchy
      type: System.Boolean
      description: "Если <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, записывает схему текущей таблицы и всех его потомков. Если <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (значение по умолчанию), записи схемы в текущей таблице."
  overload: System.Data.DataTable.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.MarshalByValueComponent
  isExternal: false
  name: System.ComponentModel.MarshalByValueComponent
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.Data.ConstraintException
  parent: System.Data
  isExternal: false
  name: ConstraintException
  nameWithType: ConstraintException
  fullName: System.Data.ConstraintException
- uid: System.Data.NoNullAllowedException
  parent: System.Data
  isExternal: false
  name: NoNullAllowedException
  nameWithType: NoNullAllowedException
  fullName: System.Data.NoNullAllowedException
- uid: System.Data.DataException
  parent: System.Data
  isExternal: false
  name: DataException
  nameWithType: DataException
  fullName: System.Data.DataException
- uid: System.Data.DuplicateNameException
  parent: System.Data
  isExternal: false
  name: DuplicateNameException
  nameWithType: DuplicateNameException
  fullName: System.Data.DuplicateNameException
- uid: System.Data.DataTable.#ctor
  parent: System.Data.DataTable
  isExternal: false
  name: DataTable()
  nameWithType: DataTable.DataTable()
  fullName: System.Data.DataTable.DataTable()
- uid: System.Data.DataTable.#ctor(System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: DataTable(String)
  nameWithType: DataTable.DataTable(String)
  fullName: System.Data.DataTable.DataTable(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataTable
  isExternal: false
  name: DataTable(SerializationInfo,StreamingContext)
  nameWithType: DataTable.DataTable(SerializationInfo,StreamingContext)
  fullName: System.Data.DataTable.DataTable(SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Data.DataTable.#ctor(System.String,System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: DataTable(String,String)
  nameWithType: DataTable.DataTable(String,String)
  fullName: System.Data.DataTable.DataTable(String,String)
- uid: System.Data.DataTable.AcceptChanges
  parent: System.Data.DataTable
  isExternal: false
  name: AcceptChanges()
  nameWithType: DataTable.AcceptChanges()
  fullName: System.Data.DataTable.AcceptChanges()
- uid: System.Data.DataTable.BeginInit
  parent: System.Data.DataTable
  isExternal: false
  name: BeginInit()
  nameWithType: DataTable.BeginInit()
  fullName: System.Data.DataTable.BeginInit()
- uid: System.Data.DataTable.BeginLoadData
  parent: System.Data.DataTable
  isExternal: false
  name: BeginLoadData()
  nameWithType: DataTable.BeginLoadData()
  fullName: System.Data.DataTable.BeginLoadData()
- uid: System.Data.DataTable.CaseSensitive
  parent: System.Data.DataTable
  isExternal: false
  name: CaseSensitive
  nameWithType: DataTable.CaseSensitive
  fullName: System.Data.DataTable.CaseSensitive
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Data.DataTable.ChildRelations
  parent: System.Data.DataTable
  isExternal: false
  name: ChildRelations
  nameWithType: DataTable.ChildRelations
  fullName: System.Data.DataTable.ChildRelations
- uid: System.Data.DataRelationCollection
  parent: System.Data
  isExternal: false
  name: DataRelationCollection
  nameWithType: DataRelationCollection
  fullName: System.Data.DataRelationCollection
- uid: System.Data.DataTable.Clear
  parent: System.Data.DataTable
  isExternal: false
  name: Clear()
  nameWithType: DataTable.Clear()
  fullName: System.Data.DataTable.Clear()
- uid: System.Data.DataTable.Clone
  parent: System.Data.DataTable
  isExternal: false
  name: Clone()
  nameWithType: DataTable.Clone()
  fullName: System.Data.DataTable.Clone()
- uid: System.Data.DataTable
  parent: System.Data
  isExternal: false
  name: DataTable
  nameWithType: DataTable
  fullName: System.Data.DataTable
- uid: System.Data.DataTable.ColumnChanged
  parent: System.Data.DataTable
  isExternal: false
  name: ColumnChanged
  nameWithType: DataTable.ColumnChanged
  fullName: System.Data.DataTable.ColumnChanged
- uid: System.Data.DataColumnChangeEventHandler
  parent: System.Data
  isExternal: false
  name: DataColumnChangeEventHandler
  nameWithType: DataColumnChangeEventHandler
  fullName: System.Data.DataColumnChangeEventHandler
- uid: System.Data.DataTable.ColumnChanging
  parent: System.Data.DataTable
  isExternal: false
  name: ColumnChanging
  nameWithType: DataTable.ColumnChanging
  fullName: System.Data.DataTable.ColumnChanging
- uid: System.Data.DataTable.Columns
  parent: System.Data.DataTable
  isExternal: false
  name: Columns
  nameWithType: DataTable.Columns
  fullName: System.Data.DataTable.Columns
- uid: System.Data.DataColumnCollection
  parent: System.Data
  isExternal: false
  name: DataColumnCollection
  nameWithType: DataColumnCollection
  fullName: System.Data.DataColumnCollection
- uid: System.Data.DataTable.Compute(System.String,System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: Compute(String,String)
  nameWithType: DataTable.Compute(String,String)
  fullName: System.Data.DataTable.Compute(String,String)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Data.DataTable.Constraints
  parent: System.Data.DataTable
  isExternal: false
  name: Constraints
  nameWithType: DataTable.Constraints
  fullName: System.Data.DataTable.Constraints
- uid: System.Data.ConstraintCollection
  parent: System.Data
  isExternal: false
  name: ConstraintCollection
  nameWithType: ConstraintCollection
  fullName: System.Data.ConstraintCollection
- uid: System.Data.DataTable.Copy
  parent: System.Data.DataTable
  isExternal: false
  name: Copy()
  nameWithType: DataTable.Copy()
  fullName: System.Data.DataTable.Copy()
- uid: System.Data.DataTable.CreateDataReader
  parent: System.Data.DataTable
  isExternal: false
  name: CreateDataReader()
  nameWithType: DataTable.CreateDataReader()
  fullName: System.Data.DataTable.CreateDataReader()
- uid: System.Data.DataTableReader
  parent: System.Data
  isExternal: false
  name: DataTableReader
  nameWithType: DataTableReader
  fullName: System.Data.DataTableReader
- uid: System.Data.DataTable.CreateInstance
  parent: System.Data.DataTable
  isExternal: false
  name: CreateInstance()
  nameWithType: DataTable.CreateInstance()
  fullName: System.Data.DataTable.CreateInstance()
- uid: System.Data.DataTable.DataSet
  parent: System.Data.DataTable
  isExternal: false
  name: DataSet
  nameWithType: DataTable.DataSet
  fullName: System.Data.DataTable.DataSet
- uid: System.Data.DataSet
  parent: System.Data
  isExternal: false
  name: DataSet
  nameWithType: DataSet
  fullName: System.Data.DataSet
- uid: System.Data.DataTable.DefaultView
  parent: System.Data.DataTable
  isExternal: false
  name: DefaultView
  nameWithType: DataTable.DefaultView
  fullName: System.Data.DataTable.DefaultView
- uid: System.Data.DataView
  parent: System.Data
  isExternal: false
  name: DataView
  nameWithType: DataView
  fullName: System.Data.DataView
- uid: System.Data.DataTable.DisplayExpression
  parent: System.Data.DataTable
  isExternal: false
  name: DisplayExpression
  nameWithType: DataTable.DisplayExpression
  fullName: System.Data.DataTable.DisplayExpression
- uid: System.Data.DataTable.EndInit
  parent: System.Data.DataTable
  isExternal: false
  name: EndInit()
  nameWithType: DataTable.EndInit()
  fullName: System.Data.DataTable.EndInit()
- uid: System.Data.DataTable.EndLoadData
  parent: System.Data.DataTable
  isExternal: false
  name: EndLoadData()
  nameWithType: DataTable.EndLoadData()
  fullName: System.Data.DataTable.EndLoadData()
- uid: System.Data.DataTable.ExtendedProperties
  parent: System.Data.DataTable
  isExternal: false
  name: ExtendedProperties
  nameWithType: DataTable.ExtendedProperties
  fullName: System.Data.DataTable.ExtendedProperties
- uid: System.Data.PropertyCollection
  parent: System.Data
  isExternal: false
  name: PropertyCollection
  nameWithType: PropertyCollection
  fullName: System.Data.PropertyCollection
- uid: System.Data.DataTable.fInitInProgress
  parent: System.Data.DataTable
  isExternal: false
  name: fInitInProgress
  nameWithType: DataTable.fInitInProgress
  fullName: System.Data.DataTable.fInitInProgress
- uid: System.Data.DataTable.GetChanges
  parent: System.Data.DataTable
  isExternal: false
  name: GetChanges()
  nameWithType: DataTable.GetChanges()
  fullName: System.Data.DataTable.GetChanges()
- uid: System.Data.DataTable.GetChanges(System.Data.DataRowState)
  parent: System.Data.DataTable
  isExternal: false
  name: GetChanges(DataRowState)
  nameWithType: DataTable.GetChanges(DataRowState)
  fullName: System.Data.DataTable.GetChanges(DataRowState)
- uid: System.Data.DataRowState
  parent: System.Data
  isExternal: false
  name: DataRowState
  nameWithType: DataRowState
  fullName: System.Data.DataRowState
- uid: System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)
  parent: System.Data.DataTable
  isExternal: false
  name: GetDataTableSchema(XmlSchemaSet)
  nameWithType: DataTable.GetDataTableSchema(XmlSchemaSet)
  fullName: System.Data.DataTable.GetDataTableSchema(XmlSchemaSet)
- uid: System.Xml.Schema.XmlSchemaComplexType
  parent: System.Xml.Schema
  isExternal: false
  name: XmlSchemaComplexType
  nameWithType: XmlSchemaComplexType
  fullName: System.Xml.Schema.XmlSchemaComplexType
- uid: System.Xml.Schema.XmlSchemaSet
  parent: System.Xml.Schema
  isExternal: false
  name: XmlSchemaSet
  nameWithType: XmlSchemaSet
  fullName: System.Xml.Schema.XmlSchemaSet
- uid: System.Data.DataTable.GetErrors
  parent: System.Data.DataTable
  isExternal: false
  name: GetErrors()
  nameWithType: DataTable.GetErrors()
  fullName: System.Data.DataTable.GetErrors()
- uid: System.Data.DataRow[]
  parent: System.Data
  isExternal: false
  name: DataRow
  nameWithType: DataRow
  fullName: System.Data.DataRow[]
  spec.csharp:
  - uid: System.Data.DataRow
    name: DataRow
    nameWithType: DataRow
    fullName: DataRow[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataTable
  isExternal: false
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: DataTable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataTable.GetObjectData(SerializationInfo,StreamingContext)
- uid: System.Data.DataTable.GetRowType
  parent: System.Data.DataTable
  isExternal: false
  name: GetRowType()
  nameWithType: DataTable.GetRowType()
  fullName: System.Data.DataTable.GetRowType()
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Data.DataTable.GetSchema
  parent: System.Data.DataTable
  isExternal: false
  name: GetSchema()
  nameWithType: DataTable.GetSchema()
  fullName: System.Data.DataTable.GetSchema()
- uid: System.Xml.Schema.XmlSchema
  parent: System.Xml.Schema
  isExternal: true
  name: XmlSchema
  nameWithType: XmlSchema
  fullName: System.Xml.Schema.XmlSchema
- uid: System.Data.DataTable.HasErrors
  parent: System.Data.DataTable
  isExternal: false
  name: HasErrors
  nameWithType: DataTable.HasErrors
  fullName: System.Data.DataTable.HasErrors
- uid: System.Data.DataTable.ImportRow(System.Data.DataRow)
  parent: System.Data.DataTable
  isExternal: false
  name: ImportRow(DataRow)
  nameWithType: DataTable.ImportRow(DataRow)
  fullName: System.Data.DataTable.ImportRow(DataRow)
- uid: System.Data.DataRow
  parent: System.Data
  isExternal: false
  name: DataRow
  nameWithType: DataRow
  fullName: System.Data.DataRow
- uid: System.Data.DataTable.Initialized
  parent: System.Data.DataTable
  isExternal: false
  name: Initialized
  nameWithType: DataTable.Initialized
  fullName: System.Data.DataTable.Initialized
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Data.DataTable.IsInitialized
  parent: System.Data.DataTable
  isExternal: false
  name: IsInitialized
  nameWithType: DataTable.IsInitialized
  fullName: System.Data.DataTable.IsInitialized
- uid: System.Data.DataTable.Load(System.Data.IDataReader)
  parent: System.Data.DataTable
  isExternal: false
  name: Load(IDataReader)
  nameWithType: DataTable.Load(IDataReader)
  fullName: System.Data.DataTable.Load(IDataReader)
- uid: System.Data.IDataReader
  parent: System.Data
  isExternal: false
  name: IDataReader
  nameWithType: IDataReader
  fullName: System.Data.IDataReader
- uid: System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)
  parent: System.Data.DataTable
  isExternal: false
  name: Load(IDataReader,LoadOption)
  nameWithType: DataTable.Load(IDataReader,LoadOption)
  fullName: System.Data.DataTable.Load(IDataReader,LoadOption)
- uid: System.Data.LoadOption
  parent: System.Data
  isExternal: false
  name: LoadOption
  nameWithType: LoadOption
  fullName: System.Data.LoadOption
- uid: System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)
  parent: System.Data.DataTable
  isExternal: false
  name: Load(IDataReader,LoadOption,FillErrorEventHandler)
  nameWithType: DataTable.Load(IDataReader,LoadOption,FillErrorEventHandler)
  fullName: System.Data.DataTable.Load(IDataReader,LoadOption,FillErrorEventHandler)
- uid: System.Data.FillErrorEventHandler
  parent: System.Data
  isExternal: false
  name: FillErrorEventHandler
  nameWithType: FillErrorEventHandler
  fullName: System.Data.FillErrorEventHandler
- uid: System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: LoadDataRow(Object[],Boolean)
  nameWithType: DataTable.LoadDataRow(Object[],Boolean)
  fullName: System.Data.DataTable.LoadDataRow(Object[],Boolean)
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)
  parent: System.Data.DataTable
  isExternal: false
  name: LoadDataRow(Object[],LoadOption)
  nameWithType: DataTable.LoadDataRow(Object[],LoadOption)
  fullName: System.Data.DataTable.LoadDataRow(Object[],LoadOption)
- uid: System.Data.DataTable.Locale
  parent: System.Data.DataTable
  isExternal: false
  name: Locale
  nameWithType: DataTable.Locale
  fullName: System.Data.DataTable.Locale
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Data.DataTable.Merge(System.Data.DataTable)
  parent: System.Data.DataTable
  isExternal: false
  name: Merge(DataTable)
  nameWithType: DataTable.Merge(DataTable)
  fullName: System.Data.DataTable.Merge(DataTable)
- uid: System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: Merge(DataTable,Boolean)
  nameWithType: DataTable.Merge(DataTable,Boolean)
  fullName: System.Data.DataTable.Merge(DataTable,Boolean)
- uid: System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataTable
  isExternal: false
  name: Merge(DataTable,Boolean,MissingSchemaAction)
  nameWithType: DataTable.Merge(DataTable,Boolean,MissingSchemaAction)
  fullName: System.Data.DataTable.Merge(DataTable,Boolean,MissingSchemaAction)
- uid: System.Data.MissingSchemaAction
  parent: System.Data
  isExternal: false
  name: MissingSchemaAction
  nameWithType: MissingSchemaAction
  fullName: System.Data.MissingSchemaAction
- uid: System.Data.DataTable.MinimumCapacity
  parent: System.Data.DataTable
  isExternal: false
  name: MinimumCapacity
  nameWithType: DataTable.MinimumCapacity
  fullName: System.Data.DataTable.MinimumCapacity
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Data.DataTable.Namespace
  parent: System.Data.DataTable
  isExternal: false
  name: Namespace
  nameWithType: DataTable.Namespace
  fullName: System.Data.DataTable.Namespace
- uid: System.Data.DataTable.NewRow
  parent: System.Data.DataTable
  isExternal: false
  name: NewRow()
  nameWithType: DataTable.NewRow()
  fullName: System.Data.DataTable.NewRow()
- uid: System.Data.DataTable.NewRowArray(System.Int32)
  parent: System.Data.DataTable
  isExternal: false
  name: NewRowArray(Int32)
  nameWithType: DataTable.NewRowArray(Int32)
  fullName: System.Data.DataTable.NewRowArray(Int32)
- uid: System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)
  parent: System.Data.DataTable
  isExternal: false
  name: NewRowFromBuilder(DataRowBuilder)
  nameWithType: DataTable.NewRowFromBuilder(DataRowBuilder)
  fullName: System.Data.DataTable.NewRowFromBuilder(DataRowBuilder)
- uid: System.Data.DataRowBuilder
  parent: System.Data
  isExternal: false
  name: DataRowBuilder
  nameWithType: DataRowBuilder
  fullName: System.Data.DataRowBuilder
- uid: System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnColumnChanged(DataColumnChangeEventArgs)
  nameWithType: DataTable.OnColumnChanged(DataColumnChangeEventArgs)
  fullName: System.Data.DataTable.OnColumnChanged(DataColumnChangeEventArgs)
- uid: System.Data.DataColumnChangeEventArgs
  parent: System.Data
  isExternal: false
  name: DataColumnChangeEventArgs
  nameWithType: DataColumnChangeEventArgs
  fullName: System.Data.DataColumnChangeEventArgs
- uid: System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnColumnChanging(DataColumnChangeEventArgs)
  nameWithType: DataTable.OnColumnChanging(DataColumnChangeEventArgs)
  fullName: System.Data.DataTable.OnColumnChanging(DataColumnChangeEventArgs)
- uid: System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnPropertyChanging(PropertyChangedEventArgs)
  nameWithType: DataTable.OnPropertyChanging(PropertyChangedEventArgs)
  fullName: System.Data.DataTable.OnPropertyChanging(PropertyChangedEventArgs)
- uid: System.ComponentModel.PropertyChangedEventArgs
  parent: System.ComponentModel
  isExternal: true
  name: PropertyChangedEventArgs
  nameWithType: PropertyChangedEventArgs
  fullName: System.ComponentModel.PropertyChangedEventArgs
- uid: System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)
  parent: System.Data.DataTable
  isExternal: false
  name: OnRemoveColumn(DataColumn)
  nameWithType: DataTable.OnRemoveColumn(DataColumn)
  fullName: System.Data.DataTable.OnRemoveColumn(DataColumn)
- uid: System.Data.DataColumn
  parent: System.Data
  isExternal: false
  name: DataColumn
  nameWithType: DataColumn
  fullName: System.Data.DataColumn
- uid: System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowChanged(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowChanged(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowChanged(DataRowChangeEventArgs)
- uid: System.Data.DataRowChangeEventArgs
  parent: System.Data
  isExternal: false
  name: DataRowChangeEventArgs
  nameWithType: DataRowChangeEventArgs
  fullName: System.Data.DataRowChangeEventArgs
- uid: System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowChanging(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowChanging(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowChanging(DataRowChangeEventArgs)
- uid: System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowDeleted(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowDeleted(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowDeleted(DataRowChangeEventArgs)
- uid: System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowDeleting(DataRowChangeEventArgs)
  nameWithType: DataTable.OnRowDeleting(DataRowChangeEventArgs)
  fullName: System.Data.DataTable.OnRowDeleting(DataRowChangeEventArgs)
- uid: System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnTableCleared(DataTableClearEventArgs)
  nameWithType: DataTable.OnTableCleared(DataTableClearEventArgs)
  fullName: System.Data.DataTable.OnTableCleared(DataTableClearEventArgs)
- uid: System.Data.DataTableClearEventArgs
  parent: System.Data
  isExternal: false
  name: DataTableClearEventArgs
  nameWithType: DataTableClearEventArgs
  fullName: System.Data.DataTableClearEventArgs
- uid: System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnTableClearing(DataTableClearEventArgs)
  nameWithType: DataTable.OnTableClearing(DataTableClearEventArgs)
  fullName: System.Data.DataTable.OnTableClearing(DataTableClearEventArgs)
- uid: System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)
  parent: System.Data.DataTable
  isExternal: false
  name: OnTableNewRow(DataTableNewRowEventArgs)
  nameWithType: DataTable.OnTableNewRow(DataTableNewRowEventArgs)
  fullName: System.Data.DataTable.OnTableNewRow(DataTableNewRowEventArgs)
- uid: System.Data.DataTableNewRowEventArgs
  parent: System.Data
  isExternal: false
  name: DataTableNewRowEventArgs
  nameWithType: DataTableNewRowEventArgs
  fullName: System.Data.DataTableNewRowEventArgs
- uid: System.Data.DataTable.ParentRelations
  parent: System.Data.DataTable
  isExternal: false
  name: ParentRelations
  nameWithType: DataTable.ParentRelations
  fullName: System.Data.DataTable.ParentRelations
- uid: System.Data.DataTable.Prefix
  parent: System.Data.DataTable
  isExternal: false
  name: Prefix
  nameWithType: DataTable.Prefix
  fullName: System.Data.DataTable.Prefix
- uid: System.Data.DataTable.PrimaryKey
  parent: System.Data.DataTable
  isExternal: false
  name: PrimaryKey
  nameWithType: DataTable.PrimaryKey
  fullName: System.Data.DataTable.PrimaryKey
- uid: System.Data.DataColumn[]
  parent: System.Data
  isExternal: false
  name: DataColumn
  nameWithType: DataColumn
  fullName: System.Data.DataColumn[]
  spec.csharp:
  - uid: System.Data.DataColumn
    name: DataColumn
    nameWithType: DataColumn
    fullName: DataColumn[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.DataTable.ReadXml(System.IO.Stream)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXml(Stream)
  nameWithType: DataTable.ReadXml(Stream)
  fullName: System.Data.DataTable.ReadXml(Stream)
- uid: System.Data.XmlReadMode
  parent: System.Data
  isExternal: false
  name: XmlReadMode
  nameWithType: XmlReadMode
  fullName: System.Data.XmlReadMode
- uid: System.IO.Stream
  parent: System.IO
  isExternal: true
  name: Stream
  nameWithType: Stream
  fullName: System.IO.Stream
- uid: System.Data.DataTable.ReadXml(System.IO.TextReader)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXml(TextReader)
  nameWithType: DataTable.ReadXml(TextReader)
  fullName: System.Data.DataTable.ReadXml(TextReader)
- uid: System.IO.TextReader
  parent: System.IO
  isExternal: true
  name: TextReader
  nameWithType: TextReader
  fullName: System.IO.TextReader
- uid: System.Data.DataTable.ReadXml(System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXml(String)
  nameWithType: DataTable.ReadXml(String)
  fullName: System.Data.DataTable.ReadXml(String)
- uid: System.Data.DataTable.ReadXml(System.Xml.XmlReader)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXml(XmlReader)
  nameWithType: DataTable.ReadXml(XmlReader)
  fullName: System.Data.DataTable.ReadXml(XmlReader)
- uid: System.Xml.XmlReader
  parent: System.Xml
  isExternal: true
  name: XmlReader
  nameWithType: XmlReader
  fullName: System.Xml.XmlReader
- uid: System.Data.DataTable.ReadXmlSchema(System.IO.Stream)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXmlSchema(Stream)
  nameWithType: DataTable.ReadXmlSchema(Stream)
  fullName: System.Data.DataTable.ReadXmlSchema(Stream)
- uid: System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXmlSchema(TextReader)
  nameWithType: DataTable.ReadXmlSchema(TextReader)
  fullName: System.Data.DataTable.ReadXmlSchema(TextReader)
- uid: System.Data.DataTable.ReadXmlSchema(System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXmlSchema(String)
  nameWithType: DataTable.ReadXmlSchema(String)
  fullName: System.Data.DataTable.ReadXmlSchema(String)
- uid: System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXmlSchema(XmlReader)
  nameWithType: DataTable.ReadXmlSchema(XmlReader)
  fullName: System.Data.DataTable.ReadXmlSchema(XmlReader)
- uid: System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXmlSerializable(XmlReader)
  nameWithType: DataTable.ReadXmlSerializable(XmlReader)
  fullName: System.Data.DataTable.ReadXmlSerializable(XmlReader)
- uid: System.Data.DataTable.RejectChanges
  parent: System.Data.DataTable
  isExternal: false
  name: RejectChanges()
  nameWithType: DataTable.RejectChanges()
  fullName: System.Data.DataTable.RejectChanges()
- uid: System.Data.DataTable.RemotingFormat
  parent: System.Data.DataTable
  isExternal: false
  name: RemotingFormat
  nameWithType: DataTable.RemotingFormat
  fullName: System.Data.DataTable.RemotingFormat
- uid: System.Data.SerializationFormat
  parent: System.Data
  isExternal: false
  name: SerializationFormat
  nameWithType: SerializationFormat
  fullName: System.Data.SerializationFormat
- uid: System.Data.DataTable.Reset
  parent: System.Data.DataTable
  isExternal: false
  name: Reset()
  nameWithType: DataTable.Reset()
  fullName: System.Data.DataTable.Reset()
- uid: System.Data.DataTable.RowChanged
  parent: System.Data.DataTable
  isExternal: false
  name: RowChanged
  nameWithType: DataTable.RowChanged
  fullName: System.Data.DataTable.RowChanged
- uid: System.Data.DataRowChangeEventHandler
  parent: System.Data
  isExternal: false
  name: DataRowChangeEventHandler
  nameWithType: DataRowChangeEventHandler
  fullName: System.Data.DataRowChangeEventHandler
- uid: System.Data.DataTable.RowChanging
  parent: System.Data.DataTable
  isExternal: false
  name: RowChanging
  nameWithType: DataTable.RowChanging
  fullName: System.Data.DataTable.RowChanging
- uid: System.Data.DataTable.RowDeleted
  parent: System.Data.DataTable
  isExternal: false
  name: RowDeleted
  nameWithType: DataTable.RowDeleted
  fullName: System.Data.DataTable.RowDeleted
- uid: System.Data.DataTable.RowDeleting
  parent: System.Data.DataTable
  isExternal: false
  name: RowDeleting
  nameWithType: DataTable.RowDeleting
  fullName: System.Data.DataTable.RowDeleting
- uid: System.Data.DataTable.Rows
  parent: System.Data.DataTable
  isExternal: false
  name: Rows
  nameWithType: DataTable.Rows
  fullName: System.Data.DataTable.Rows
- uid: System.Data.DataRowCollection
  parent: System.Data
  isExternal: false
  name: DataRowCollection
  nameWithType: DataRowCollection
  fullName: System.Data.DataRowCollection
- uid: System.Data.DataTable.Select
  parent: System.Data.DataTable
  isExternal: false
  name: Select()
  nameWithType: DataTable.Select()
  fullName: System.Data.DataTable.Select()
- uid: System.Data.DataTable.Select(System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: Select(String)
  nameWithType: DataTable.Select(String)
  fullName: System.Data.DataTable.Select(String)
- uid: System.Data.DataTable.Select(System.String,System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: Select(String,String)
  nameWithType: DataTable.Select(String,String)
  fullName: System.Data.DataTable.Select(String,String)
- uid: System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)
  parent: System.Data.DataTable
  isExternal: false
  name: Select(String,String,DataViewRowState)
  nameWithType: DataTable.Select(String,String,DataViewRowState)
  fullName: System.Data.DataTable.Select(String,String,DataViewRowState)
- uid: System.Data.DataViewRowState
  parent: System.Data
  isExternal: false
  name: DataViewRowState
  nameWithType: DataViewRowState
  fullName: System.Data.DataViewRowState
- uid: System.Data.DataTable.Site
  parent: System.Data.DataTable
  isExternal: false
  name: Site
  nameWithType: DataTable.Site
  fullName: System.Data.DataTable.Site
- uid: System.ComponentModel.ISite
  parent: System.ComponentModel
  isExternal: false
  name: ISite
  nameWithType: ISite
  fullName: System.ComponentModel.ISite
- uid: System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection
  parent: System.Data.DataTable
  isExternal: false
  name: System.ComponentModel.IListSource.ContainsListCollection
  nameWithType: DataTable.System.ComponentModel.IListSource.ContainsListCollection
  fullName: System.Data.DataTable.System.ComponentModel.IListSource.ContainsListCollection
- uid: System.Data.DataTable.System#ComponentModel#IListSource#GetList
  parent: System.Data.DataTable
  isExternal: false
  name: System.ComponentModel.IListSource.GetList()
  nameWithType: DataTable.System.ComponentModel.IListSource.GetList()
  fullName: System.Data.DataTable.System.ComponentModel.IListSource.GetList()
- uid: System.Collections.IList
  parent: System.Collections
  isExternal: true
  name: IList
  nameWithType: IList
  fullName: System.Collections.IList
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema
  parent: System.Data.DataTable
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.GetSchema()
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.GetSchema()
  fullName: System.Data.DataTable.System.Xml.Serialization.IXmlSerializable.GetSchema()
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  parent: System.Data.DataTable
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  fullName: System.Data.DataTable.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  parent: System.Data.DataTable
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  fullName: System.Data.DataTable.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
- uid: System.Xml.XmlWriter
  parent: System.Xml
  isExternal: true
  name: XmlWriter
  nameWithType: XmlWriter
  fullName: System.Xml.XmlWriter
- uid: System.Data.DataTable.TableCleared
  parent: System.Data.DataTable
  isExternal: false
  name: TableCleared
  nameWithType: DataTable.TableCleared
  fullName: System.Data.DataTable.TableCleared
- uid: System.Data.DataTableClearEventHandler
  parent: System.Data
  isExternal: false
  name: DataTableClearEventHandler
  nameWithType: DataTableClearEventHandler
  fullName: System.Data.DataTableClearEventHandler
- uid: System.Data.DataTable.TableClearing
  parent: System.Data.DataTable
  isExternal: false
  name: TableClearing
  nameWithType: DataTable.TableClearing
  fullName: System.Data.DataTable.TableClearing
- uid: System.Data.DataTable.TableName
  parent: System.Data.DataTable
  isExternal: false
  name: TableName
  nameWithType: DataTable.TableName
  fullName: System.Data.DataTable.TableName
- uid: System.Data.DataTable.TableNewRow
  parent: System.Data.DataTable
  isExternal: false
  name: TableNewRow
  nameWithType: DataTable.TableNewRow
  fullName: System.Data.DataTable.TableNewRow
- uid: System.Data.DataTableNewRowEventHandler
  parent: System.Data
  isExternal: false
  name: DataTableNewRowEventHandler
  nameWithType: DataTableNewRowEventHandler
  fullName: System.Data.DataTableNewRowEventHandler
- uid: System.Data.DataTable.ToString
  parent: System.Data.DataTable
  isExternal: false
  name: ToString()
  nameWithType: DataTable.ToString()
  fullName: System.Data.DataTable.ToString()
- uid: System.Data.DataTable.WriteXml(System.IO.Stream)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(Stream)
  nameWithType: DataTable.WriteXml(Stream)
  fullName: System.Data.DataTable.WriteXml(Stream)
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(TextWriter)
  nameWithType: DataTable.WriteXml(TextWriter)
  fullName: System.Data.DataTable.WriteXml(TextWriter)
- uid: System.IO.TextWriter
  parent: System.IO
  isExternal: true
  name: TextWriter
  nameWithType: TextWriter
  fullName: System.IO.TextWriter
- uid: System.Data.DataTable.WriteXml(System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(String)
  nameWithType: DataTable.WriteXml(String)
  fullName: System.Data.DataTable.WriteXml(String)
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(XmlWriter)
  nameWithType: DataTable.WriteXml(XmlWriter)
  fullName: System.Data.DataTable.WriteXml(XmlWriter)
- uid: System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(Stream,Boolean)
  nameWithType: DataTable.WriteXml(Stream,Boolean)
  fullName: System.Data.DataTable.WriteXml(Stream,Boolean)
- uid: System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(Stream,XmlWriteMode)
  nameWithType: DataTable.WriteXml(Stream,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(Stream,XmlWriteMode)
- uid: System.Data.XmlWriteMode
  parent: System.Data
  isExternal: false
  name: XmlWriteMode
  nameWithType: XmlWriteMode
  fullName: System.Data.XmlWriteMode
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(TextWriter,Boolean)
  nameWithType: DataTable.WriteXml(TextWriter,Boolean)
  fullName: System.Data.DataTable.WriteXml(TextWriter,Boolean)
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(TextWriter,XmlWriteMode)
  nameWithType: DataTable.WriteXml(TextWriter,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(TextWriter,XmlWriteMode)
- uid: System.Data.DataTable.WriteXml(System.String,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(String,Boolean)
  nameWithType: DataTable.WriteXml(String,Boolean)
  fullName: System.Data.DataTable.WriteXml(String,Boolean)
- uid: System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(String,XmlWriteMode)
  nameWithType: DataTable.WriteXml(String,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(String,XmlWriteMode)
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(XmlWriter,Boolean)
  nameWithType: DataTable.WriteXml(XmlWriter,Boolean)
  fullName: System.Data.DataTable.WriteXml(XmlWriter,Boolean)
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(XmlWriter,XmlWriteMode)
  nameWithType: DataTable.WriteXml(XmlWriter,XmlWriteMode)
  fullName: System.Data.DataTable.WriteXml(XmlWriter,XmlWriteMode)
- uid: System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(Stream,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(Stream,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(Stream,XmlWriteMode,Boolean)
- uid: System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(TextWriter,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(TextWriter,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(TextWriter,XmlWriteMode,Boolean)
- uid: System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(String,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(String,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(String,XmlWriteMode,Boolean)
- uid: System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml(XmlWriter,XmlWriteMode,Boolean)
  nameWithType: DataTable.WriteXml(XmlWriter,XmlWriteMode,Boolean)
  fullName: System.Data.DataTable.WriteXml(XmlWriter,XmlWriteMode,Boolean)
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.Stream)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(Stream)
  nameWithType: DataTable.WriteXmlSchema(Stream)
  fullName: System.Data.DataTable.WriteXmlSchema(Stream)
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(TextWriter)
  nameWithType: DataTable.WriteXmlSchema(TextWriter)
  fullName: System.Data.DataTable.WriteXmlSchema(TextWriter)
- uid: System.Data.DataTable.WriteXmlSchema(System.String)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(String)
  nameWithType: DataTable.WriteXmlSchema(String)
  fullName: System.Data.DataTable.WriteXmlSchema(String)
- uid: System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(XmlWriter)
  nameWithType: DataTable.WriteXmlSchema(XmlWriter)
  fullName: System.Data.DataTable.WriteXmlSchema(XmlWriter)
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(Stream,Boolean)
  nameWithType: DataTable.WriteXmlSchema(Stream,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(Stream,Boolean)
- uid: System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(TextWriter,Boolean)
  nameWithType: DataTable.WriteXmlSchema(TextWriter,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(TextWriter,Boolean)
- uid: System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(String,Boolean)
  nameWithType: DataTable.WriteXmlSchema(String,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(String,Boolean)
- uid: System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema(XmlWriter,Boolean)
  nameWithType: DataTable.WriteXmlSchema(XmlWriter,Boolean)
  fullName: System.Data.DataTable.WriteXmlSchema(XmlWriter,Boolean)
- uid: System.Data.DataTable.#ctor*
  parent: System.Data.DataTable
  isExternal: false
  name: DataTable
  nameWithType: DataTable.DataTable
- uid: System.Data.DataTable.AcceptChanges*
  parent: System.Data.DataTable
  isExternal: false
  name: AcceptChanges
  nameWithType: DataTable.AcceptChanges
- uid: System.Data.DataTable.BeginInit*
  parent: System.Data.DataTable
  isExternal: false
  name: BeginInit
  nameWithType: DataTable.BeginInit
- uid: System.Data.DataTable.BeginLoadData*
  parent: System.Data.DataTable
  isExternal: false
  name: BeginLoadData
  nameWithType: DataTable.BeginLoadData
- uid: System.Data.DataTable.CaseSensitive*
  parent: System.Data.DataTable
  isExternal: false
  name: CaseSensitive
  nameWithType: DataTable.CaseSensitive
- uid: System.Data.DataTable.ChildRelations*
  parent: System.Data.DataTable
  isExternal: false
  name: ChildRelations
  nameWithType: DataTable.ChildRelations
- uid: System.Data.DataTable.Clear*
  parent: System.Data.DataTable
  isExternal: false
  name: Clear
  nameWithType: DataTable.Clear
- uid: System.Data.DataTable.Clone*
  parent: System.Data.DataTable
  isExternal: false
  name: Clone
  nameWithType: DataTable.Clone
- uid: System.Data.DataTable.Columns*
  parent: System.Data.DataTable
  isExternal: false
  name: Columns
  nameWithType: DataTable.Columns
- uid: System.Data.DataTable.Compute*
  parent: System.Data.DataTable
  isExternal: false
  name: Compute
  nameWithType: DataTable.Compute
- uid: System.Data.DataTable.Constraints*
  parent: System.Data.DataTable
  isExternal: false
  name: Constraints
  nameWithType: DataTable.Constraints
- uid: System.Data.DataTable.Copy*
  parent: System.Data.DataTable
  isExternal: false
  name: Copy
  nameWithType: DataTable.Copy
- uid: System.Data.DataTable.CreateDataReader*
  parent: System.Data.DataTable
  isExternal: false
  name: CreateDataReader
  nameWithType: DataTable.CreateDataReader
- uid: System.Data.DataTable.CreateInstance*
  parent: System.Data.DataTable
  isExternal: false
  name: CreateInstance
  nameWithType: DataTable.CreateInstance
- uid: System.Data.DataTable.DataSet*
  parent: System.Data.DataTable
  isExternal: false
  name: DataSet
  nameWithType: DataTable.DataSet
- uid: System.Data.DataTable.DefaultView*
  parent: System.Data.DataTable
  isExternal: false
  name: DefaultView
  nameWithType: DataTable.DefaultView
- uid: System.Data.DataTable.DisplayExpression*
  parent: System.Data.DataTable
  isExternal: false
  name: DisplayExpression
  nameWithType: DataTable.DisplayExpression
- uid: System.Data.DataTable.EndInit*
  parent: System.Data.DataTable
  isExternal: false
  name: EndInit
  nameWithType: DataTable.EndInit
- uid: System.Data.DataTable.EndLoadData*
  parent: System.Data.DataTable
  isExternal: false
  name: EndLoadData
  nameWithType: DataTable.EndLoadData
- uid: System.Data.DataTable.ExtendedProperties*
  parent: System.Data.DataTable
  isExternal: false
  name: ExtendedProperties
  nameWithType: DataTable.ExtendedProperties
- uid: System.Data.DataTable.GetChanges*
  parent: System.Data.DataTable
  isExternal: false
  name: GetChanges
  nameWithType: DataTable.GetChanges
- uid: System.Data.DataTable.GetDataTableSchema*
  parent: System.Data.DataTable
  isExternal: false
  name: GetDataTableSchema
  nameWithType: DataTable.GetDataTableSchema
- uid: System.Data.DataTable.GetErrors*
  parent: System.Data.DataTable
  isExternal: false
  name: GetErrors
  nameWithType: DataTable.GetErrors
- uid: System.Data.DataTable.GetObjectData*
  parent: System.Data.DataTable
  isExternal: false
  name: GetObjectData
  nameWithType: DataTable.GetObjectData
- uid: System.Data.DataTable.GetRowType*
  parent: System.Data.DataTable
  isExternal: false
  name: GetRowType
  nameWithType: DataTable.GetRowType
- uid: System.Data.DataTable.GetSchema*
  parent: System.Data.DataTable
  isExternal: false
  name: GetSchema
  nameWithType: DataTable.GetSchema
- uid: System.Data.DataTable.HasErrors*
  parent: System.Data.DataTable
  isExternal: false
  name: HasErrors
  nameWithType: DataTable.HasErrors
- uid: System.Data.DataTable.ImportRow*
  parent: System.Data.DataTable
  isExternal: false
  name: ImportRow
  nameWithType: DataTable.ImportRow
- uid: System.Data.DataTable.IsInitialized*
  parent: System.Data.DataTable
  isExternal: false
  name: IsInitialized
  nameWithType: DataTable.IsInitialized
- uid: System.Data.DataTable.Load*
  parent: System.Data.DataTable
  isExternal: false
  name: Load
  nameWithType: DataTable.Load
- uid: System.Data.DataTable.LoadDataRow*
  parent: System.Data.DataTable
  isExternal: false
  name: LoadDataRow
  nameWithType: DataTable.LoadDataRow
- uid: System.Data.DataTable.Locale*
  parent: System.Data.DataTable
  isExternal: false
  name: Locale
  nameWithType: DataTable.Locale
- uid: System.Data.DataTable.Merge*
  parent: System.Data.DataTable
  isExternal: false
  name: Merge
  nameWithType: DataTable.Merge
- uid: System.Data.DataTable.MinimumCapacity*
  parent: System.Data.DataTable
  isExternal: false
  name: MinimumCapacity
  nameWithType: DataTable.MinimumCapacity
- uid: System.Data.DataTable.Namespace*
  parent: System.Data.DataTable
  isExternal: false
  name: Namespace
  nameWithType: DataTable.Namespace
- uid: System.Data.DataTable.NewRow*
  parent: System.Data.DataTable
  isExternal: false
  name: NewRow
  nameWithType: DataTable.NewRow
- uid: System.Data.DataTable.NewRowArray*
  parent: System.Data.DataTable
  isExternal: false
  name: NewRowArray
  nameWithType: DataTable.NewRowArray
- uid: System.Data.DataTable.NewRowFromBuilder*
  parent: System.Data.DataTable
  isExternal: false
  name: NewRowFromBuilder
  nameWithType: DataTable.NewRowFromBuilder
- uid: System.Data.DataTable.OnColumnChanged*
  parent: System.Data.DataTable
  isExternal: false
  name: OnColumnChanged
  nameWithType: DataTable.OnColumnChanged
- uid: System.Data.DataTable.OnColumnChanging*
  parent: System.Data.DataTable
  isExternal: false
  name: OnColumnChanging
  nameWithType: DataTable.OnColumnChanging
- uid: System.Data.DataTable.OnPropertyChanging*
  parent: System.Data.DataTable
  isExternal: false
  name: OnPropertyChanging
  nameWithType: DataTable.OnPropertyChanging
- uid: System.Data.DataTable.OnRemoveColumn*
  parent: System.Data.DataTable
  isExternal: false
  name: OnRemoveColumn
  nameWithType: DataTable.OnRemoveColumn
- uid: System.Data.DataTable.OnRowChanged*
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowChanged
  nameWithType: DataTable.OnRowChanged
- uid: System.Data.DataTable.OnRowChanging*
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowChanging
  nameWithType: DataTable.OnRowChanging
- uid: System.Data.DataTable.OnRowDeleted*
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowDeleted
  nameWithType: DataTable.OnRowDeleted
- uid: System.Data.DataTable.OnRowDeleting*
  parent: System.Data.DataTable
  isExternal: false
  name: OnRowDeleting
  nameWithType: DataTable.OnRowDeleting
- uid: System.Data.DataTable.OnTableCleared*
  parent: System.Data.DataTable
  isExternal: false
  name: OnTableCleared
  nameWithType: DataTable.OnTableCleared
- uid: System.Data.DataTable.OnTableClearing*
  parent: System.Data.DataTable
  isExternal: false
  name: OnTableClearing
  nameWithType: DataTable.OnTableClearing
- uid: System.Data.DataTable.OnTableNewRow*
  parent: System.Data.DataTable
  isExternal: false
  name: OnTableNewRow
  nameWithType: DataTable.OnTableNewRow
- uid: System.Data.DataTable.ParentRelations*
  parent: System.Data.DataTable
  isExternal: false
  name: ParentRelations
  nameWithType: DataTable.ParentRelations
- uid: System.Data.DataTable.Prefix*
  parent: System.Data.DataTable
  isExternal: false
  name: Prefix
  nameWithType: DataTable.Prefix
- uid: System.Data.DataTable.PrimaryKey*
  parent: System.Data.DataTable
  isExternal: false
  name: PrimaryKey
  nameWithType: DataTable.PrimaryKey
- uid: System.Data.DataTable.ReadXml*
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXml
  nameWithType: DataTable.ReadXml
- uid: System.Data.DataTable.ReadXmlSchema*
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXmlSchema
  nameWithType: DataTable.ReadXmlSchema
- uid: System.Data.DataTable.ReadXmlSerializable*
  parent: System.Data.DataTable
  isExternal: false
  name: ReadXmlSerializable
  nameWithType: DataTable.ReadXmlSerializable
- uid: System.Data.DataTable.RejectChanges*
  parent: System.Data.DataTable
  isExternal: false
  name: RejectChanges
  nameWithType: DataTable.RejectChanges
- uid: System.Data.DataTable.RemotingFormat*
  parent: System.Data.DataTable
  isExternal: false
  name: RemotingFormat
  nameWithType: DataTable.RemotingFormat
- uid: System.Data.DataTable.Reset*
  parent: System.Data.DataTable
  isExternal: false
  name: Reset
  nameWithType: DataTable.Reset
- uid: System.Data.DataTable.Rows*
  parent: System.Data.DataTable
  isExternal: false
  name: Rows
  nameWithType: DataTable.Rows
- uid: System.Data.DataTable.Select*
  parent: System.Data.DataTable
  isExternal: false
  name: Select
  nameWithType: DataTable.Select
- uid: System.Data.DataTable.Site*
  parent: System.Data.DataTable
  isExternal: false
  name: Site
  nameWithType: DataTable.Site
- uid: System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection*
  parent: System.Data.DataTable
  isExternal: false
  name: System.ComponentModel.IListSource.ContainsListCollection
  nameWithType: DataTable.System.ComponentModel.IListSource.ContainsListCollection
- uid: System.Data.DataTable.System#ComponentModel#IListSource#GetList*
  parent: System.Data.DataTable
  isExternal: false
  name: System.ComponentModel.IListSource.GetList
  nameWithType: DataTable.System.ComponentModel.IListSource.GetList
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema*
  parent: System.Data.DataTable
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.GetSchema
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.GetSchema
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml*
  parent: System.Data.DataTable
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.ReadXml
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.ReadXml
- uid: System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml*
  parent: System.Data.DataTable
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.WriteXml
  nameWithType: DataTable.System.Xml.Serialization.IXmlSerializable.WriteXml
- uid: System.Data.DataTable.TableName*
  parent: System.Data.DataTable
  isExternal: false
  name: TableName
  nameWithType: DataTable.TableName
- uid: System.Data.DataTable.ToString*
  parent: System.Data.DataTable
  isExternal: false
  name: ToString
  nameWithType: DataTable.ToString
- uid: System.Data.DataTable.WriteXml*
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXml
  nameWithType: DataTable.WriteXml
- uid: System.Data.DataTable.WriteXmlSchema*
  parent: System.Data.DataTable
  isExternal: false
  name: WriteXmlSchema
  nameWithType: DataTable.WriteXmlSchema
