### YamlMime:ManagedReference
items:
- uid: System.Windows.Automation.Text.TextPatternRange
  id: TextPatternRange
  children:
  - System.Windows.Automation.Text.TextPatternRange.AddToSelection
  - System.Windows.Automation.Text.TextPatternRange.Clone
  - System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)
  - System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  - System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  - System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  - System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)
  - System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  - System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles
  - System.Windows.Automation.Text.TextPatternRange.GetChildren
  - System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement
  - System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)
  - System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  - System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  - System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  - System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection
  - System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)
  - System.Windows.Automation.Text.TextPatternRange.Select
  - System.Windows.Automation.Text.TextPatternRange.TextPattern
  langs:
  - csharp
  name: TextPatternRange
  nameWithType: TextPatternRange
  fullName: System.Windows.Automation.Text.TextPatternRange
  type: Class
  summary: "Представляет диапазон непрерывного текста в <xref href=&quot;System.Windows.Automation.TextPattern&quot;> </xref> контейнера."
  remarks: "Может представлять TextPatternRange точку вставки, часть или весь текст в <xref:System.Windows.Automation.TextPattern>контейнера.</xref:System.Windows.Automation.TextPattern>       TextPatternRange станет недействительным, если произойдет одно из следующих действий: текст в <xref:System.Windows.Automation.TextPattern>изменения контейнера из-за какого-либо действия пользователя или <xref:System.Windows.Automation.ValuePattern.SetValue%2A>метод <xref:System.Windows.Automation.ValuePattern>позволяет программно изменять значение текста в <xref:System.Windows.Automation.TextPattern>контейнера.</xref:System.Windows.Automation.TextPattern> </xref:System.Windows.Automation.ValuePattern> </xref:System.Windows.Automation.ValuePattern.SetValue%2A> </xref:System.Windows.Automation.TextPattern>"
  syntax:
    content: public class TextPatternRange
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.AddToSelection
  id: AddToSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: AddToSelection()
  nameWithType: TextPatternRange.AddToSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.AddToSelection()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Добавляет в коллекцию выделенного текста в текстовом контейнере, поддерживающем раздельное множественное выделение."
  remarks: "Точка вставки текста перемещается в область новое выделение.       Предоставление вырожденный диапазон перемещает курсор."
  syntax:
    content: public void AddToSelection ();
    parameters: []
  overload: System.Windows.Automation.Text.TextPatternRange.AddToSelection*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Если поставщик текста не поддерживает несколько раздельное множественное выделение (например, <xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>должно иметь значение <xref uid=&quot;langword_csharp_Multiple&quot; name=&quot;Multiple&quot; href=&quot;&quot;> </xref>).</xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Clone
  id: Clone
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Clone()
  nameWithType: TextPatternRange.Clone()
  fullName: System.Windows.Automation.Text.TextPatternRange.Clone()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Извлекает новый <xref href=&quot;System.Windows.Automation.Text.TextPatternRange&quot;> </xref> совпадают с исходными <xref href=&quot;System.Windows.Automation.Text.TextPatternRange&quot;> </xref> и наследующий все его свойства."
  remarks: "Кроме того, создать новый <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>из <xref:System.Windows.Automation.TextPattern>и переместить две конечные точки, в соответствии с конечными точками исходного текстового диапазона.</xref:System.Windows.Automation.TextPattern> </xref:System.Windows.Automation.TextPattern.DocumentRange%2A>       Новый диапазон можно управлять независимо от исходных."
  example:
  - "[!code-cs[UIATextPattern_snip#1060](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1060)]  \n  \n [!code-vb[UIATextPattern_snip#2060](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2060)]"
  syntax:
    content: public System.Windows.Automation.Text.TextPatternRange Clone ();
    parameters: []
    return:
      type: System.Windows.Automation.Text.TextPatternRange
      description: "Новый текстовый диапазон. Пустая ссылка (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> в [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)]) никогда не возвращается."
  overload: System.Windows.Automation.Text.TextPatternRange.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)
  id: Compare(System.Windows.Automation.Text.TextPatternRange)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Compare(TextPatternRange)
  nameWithType: TextPatternRange.Compare(TextPatternRange)
  fullName: System.Windows.Automation.Text.TextPatternRange.Compare(TextPatternRange)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Возвращает <xref:System.Boolean>значение, указывающее, является ли диапазон ( <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> в конечной точке <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> конечной точки) текстового диапазона совпадает со значением другого текстового диапазона.</xref:System.Boolean>"
  remarks: ''
  example:
  - "[!code-cs[UIATextPattern_snip#1061](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1061)]  \n  \n [!code-vb[UIATextPattern_snip#2061](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2061)]"
  syntax:
    content: public bool Compare (System.Windows.Automation.Text.TextPatternRange range);
    parameters:
    - id: range
      type: System.Windows.Automation.Text.TextPatternRange
      description: "Текстовый диапазон для сравнения."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если расположение текстовых диапазонов идентично; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Automation.Text.TextPatternRange.Compare*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Если сравниваемый диапазон поступающих не из того же поставщика текста."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  id: CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Возвращает <xref:System.Int32>, указывающее, имеют ли два текстовых диапазона одинаковые конечные точки.</xref:System.Int32>"
  remarks: "Сравнивая начальную и конечную точки того же текстового диапазона, можно определить при вырожденный диапазон текста или если конечные точки имеют порядок нескольких логических текстового потока."
  example:
  - "[!code-cs[UIATextPattern_snip#1062](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1062)]  \n  \n [!code-vb[UIATextPattern_snip#2062](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2062)]"
  syntax:
    content: public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);
    parameters:
    - id: endpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> Или <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> конечная точка вызывающего объекта."
    - id: targetRange
      type: System.Windows.Automation.Text.TextPatternRange
      description: "Целевой диапазон для сравнения."
    - id: targetEndpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> Или <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> конечной точки целевого объекта."
    return:
      type: System.Int32
      description: "Возвращает отрицательное значение, если конечная точка вызывающего ближе к началу, чем целевая конечная точка.       Возвращает нуль, если конечная точка вызывающего находится там же, где целевой конечной точки.       Возвращает положительное значение, если конечная точка вызывающего объекта размещена дальше конечной точки целевого."
  overload: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Если диапазон является пустой ссылкой (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> в [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Если диапазон из другого контейнера."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  id: ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: ExpandToEnclosingUnit(TextUnit)
  nameWithType: TextPatternRange.ExpandToEnclosingUnit(TextUnit)
  fullName: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(TextUnit)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Расширяет текстовый диапазон на заданный <xref href=&quot;System.Windows.Automation.Text.TextUnit&quot;> </xref>."
  remarks: "Если диапазон уже точное количество заданных единицах измерения, он остается неизменным.       Чтобы для успешного выполнения метода ExpandToEnclosingUnit последовательность действий выполняется в фоновом.      1.  Текстовый диапазон нормализован; то есть, диапазон текста он свернут до вырожденного диапазона в <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>конечной точки, делая <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>лишний конечной точки.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> Этот шаг необходим для устранения неоднозначности в случаях, когда текстовый диапазон охватывает `unit` границы; например,» {U} RL [http://www.microsoft.com](http://www.microsoft.com) внедряется в текст» где «{» и «}», конечные точки диапазона текста.      2.  Результирующий диапазон перемещается в <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>в начало запрошенной `unit` границ.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      3.  Диапазон перемещается вперед или назад в <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>запрошенное число `unit` границы.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      4.  Затем диапазон расширяется из вырожденного состояния путем перемещения <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>конечной точки на одну запрошенную `unit` границ.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>       ![Настройка диапазона перемещения & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png &quot;диапазона перемещения & ExpandToEnclosingUnit&quot;) примеры способ корректировки текстового диапазона для Move() и ExpandToEnclosingUnit() настроек [!NOTE] настроек эти шаги необходимы, так как часто для чтения с экрана считывают полного слова, предложение или абзац в точке вставки или другой виртуальной позиции курсора.       ExpandToEnclosingUnit уважает скрытым и видимым текстом. Клиент автоматизации пользовательского интерфейса можно проверить <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>видимость текста.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>       Откладывает ExpandToEnclosingUnit до следующего наибольшего <xref:System.Windows.Automation.Text.TextUnit>поддерживаемого Если данного <xref:System.Windows.Automation.Text.TextUnit>не поддерживается элементом управления.</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>       Порядок от наименьшей единицы к максимальному, указанных ниже.      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit>"
  example:
  - "[!code-cs[UIATextPattern_snip#1063](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1063)]  \n  \n [!code-vb[UIATextPattern_snip#2063](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2063)]"
  syntax:
    content: public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);
    parameters:
    - id: unit
      type: System.Windows.Automation.Text.TextUnit
      description: "Единица текста."
  overload: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  id: FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: FindAttribute(AutomationTextAttribute,Object,Boolean)
  nameWithType: TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Возвращает подмножество текстового диапазона, имеющее значение указанного атрибута."
  remarks: "Нет никакой разницы между скрытым и видимым текстом. Клиенты автоматизации пользовательского интерфейса можно использовать <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>для проверки видимости текста.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>      Настроек [!NOTE] настроек используйте <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>для поиска весь документ.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>"
  example:
  - "[!code-cs[UIATextPattern_snip#1064](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1064)]  \n  \n [!code-vb[UIATextPattern_snip#2064](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2064)]"
  syntax:
    content: public System.Windows.Automation.Text.TextPatternRange FindAttribute (System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward);
    parameters:
    - id: attribute
      type: System.Windows.Automation.AutomationTextAttribute
      description: "Искомый атрибут."
    - id: value
      type: System.Object
      description: "Значение атрибута для поиска. Это значение должно соответствовать заданному для атрибута типу."
    - id: backward
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если последнее вхождение текстового диапазона должны быть возвращены вместо первого; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Windows.Automation.Text.TextPatternRange
      description: "Текстовый диапазон, имеющий соответствующий атрибут и значение атрибута; в противном случае — значение null (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> в [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])."
  overload: System.Windows.Automation.Text.TextPatternRange.FindAttribute*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)
  id: FindText(System.String,System.Boolean,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: FindText(String,Boolean,Boolean)
  nameWithType: TextPatternRange.FindText(String,Boolean,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindText(String,Boolean,Boolean)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Возвращает подмножество текстового диапазона, содержащее заданный текст."
  remarks: "Нет никакой разницы между скрытым и видимым текстом. Клиенты автоматизации пользовательского интерфейса можно использовать <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>для проверки видимости текста.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>      Настроек [!NOTE] настроек используйте <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>для поиска весь документ.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>"
  example:
  - "[!code-cs[UIATextPattern_snip#1065](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1065)]  \n  \n [!code-vb[UIATextPattern_snip#2065](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2065)]"
  syntax:
    content: public System.Windows.Automation.Text.TextPatternRange FindText (string text, bool backward, bool ignoreCase);
    parameters:
    - id: text
      type: System.String
      description: "Текстовая строка для поиска."
    - id: backward
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если последнее вхождение текстового диапазона должны быть возвращены вместо первого; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    - id: ignoreCase
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если регистр следует игнорировать; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
    return:
      type: System.Windows.Automation.Text.TextPatternRange
      description: "Текстовый диапазон, соответствующий заданному тексту; в противном случае — значение null (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref> в [!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])."
  overload: System.Windows.Automation.Text.TextPatternRange.FindText*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  id: GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetAttributeValue(AutomationTextAttribute)
  nameWithType: TextPatternRange.GetAttributeValue(AutomationTextAttribute)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(AutomationTextAttribute)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Возвращает значение заданного атрибута для всего текстового диапазона."
  remarks: "Нет никакой разницы между скрытым и видимым текстом. Клиенты автоматизации пользовательского интерфейса можно использовать <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>для проверки видимости текста.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>"
  example:
  - "[!code-cs[UIATextPattern_snip#1066](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1066)]  \n  \n [!code-vb[UIATextPattern_snip#2066](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2066)]"
  syntax:
    content: public object GetAttributeValue (System.Windows.Automation.AutomationTextAttribute attribute);
    parameters:
    - id: attribute
      type: System.Windows.Automation.AutomationTextAttribute
      description: "Атрибут текста."
    return:
      type: System.Object
      description: "Возвращает значение указанного атрибута. Например GetAttributeValue(TextPattern.FontNameAttribute) вернет строку, представляющую имя шрифта, если уникальный текстового диапазона, а GetAttributeValue(TextPattern.IsItalicAttribute) вернет значение типа boolean.       Возвращает <xref href=&quot;System.Windows.Automation.TextPattern.MixedAttributeValue&quot;> </xref> Если значение заданного атрибута различается в пределах текстового диапазона.       Возвращает <xref href=&quot;System.Windows.Automation.AutomationElement.NotSupported&quot;> </xref> Если указанный атрибут не поддерживается поставщиком или элементом управления."
  overload: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Если указанный атрибут не является допустимым."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles
  id: GetBoundingRectangles
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetBoundingRectangles()
  nameWithType: TextPatternRange.GetBoundingRectangles()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Возвращает коллекцию ограничивающих прямоугольников для каждой полностью или частично видимой строки текста в текстовом диапазоне."
  remarks: ''
  example:
  - "[!code-cs[UIATextPattern_snip#1067](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1067)]  \n  \n [!code-vb[UIATextPattern_snip#2067](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2067)]"
  syntax:
    content: public System.Windows.Rect[] GetBoundingRectangles ();
    parameters: []
    return:
      type: System.Windows.Rect[]
      description: "Массив ограничивающих прямоугольников для каждой полной или частичной строки текста в текстовом диапазоне.       Для вырожденного диапазона — пустой массив.       Пустой массив с полностью находятся экранные координаты текстового диапазона результате прокрутки или заслонен другим окном."
  overload: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetChildren
  id: GetChildren
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetChildren()
  nameWithType: TextPatternRange.GetChildren()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetChildren()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Извлекает коллекцию всех внедренных объектов, попадающих в текстовый диапазон."
  remarks: ''
  example:
  - "[!code-vb[UIATextPattern_snip#StartTarget](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#starttarget)]\n [!code-cs[UIATextPattern_snip#StartTarget](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#starttarget)]  \n[!code-vb[UIATextPattern_snip#GetTextElement](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#gettextelement)]\n[!code-cs[UIATextPattern_snip#GetTextElement](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#gettextelement)]  \n[!code-vb[UIATextPattern_snip#GetEmbeddedObjects](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#getembeddedobjects)]\n[!code-cs[UIATextPattern_snip#GetEmbeddedObjects](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#getembeddedobjects)]"
  syntax:
    content: public System.Windows.Automation.AutomationElement[] GetChildren ();
    parameters: []
    return:
      type: System.Windows.Automation.AutomationElement[]
      description: "Коллекция всех дочерних объектов, попадающих в диапазон. Дочерние объекты, пересекающиеся с диапазоном, но не полностью в нем будут также включены в коллекции.       Возвращает пустую коллекцию, если нет ни одного дочернего объекта."
  overload: System.Windows.Automation.Text.TextPatternRange.GetChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement
  id: GetEnclosingElement
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetEnclosingElement()
  nameWithType: TextPatternRange.GetEnclosingElement()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Возвращает внутренний <xref href=&quot;System.Windows.Automation.AutomationElement&quot;> </xref> , охватывает диапазон текста."
  remarks: "Включающий <xref:System.Windows.Automation.AutomationElement>, обычно поставщик текста, предоставляющий текстовый диапазон.</xref:System.Windows.Automation.AutomationElement> Тем не менее если поставщик текста содержит дочерние элементы, такие как таблицы или гиперссылки, охватывающий элемент должен быть наследником поставщика текста."
  example:
  - "[!code-cs[UIATextPattern_snip#1069](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1069)]  \n  \n [!code-vb[UIATextPattern_snip#2069](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2069)]"
  syntax:
    content: public System.Windows.Automation.AutomationElement GetEnclosingElement ();
    parameters: []
    return:
      type: System.Windows.Automation.AutomationElement
      description: "Самый внутренний элемент, содержащий вызывающий объект."
  overload: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)
  id: GetText(System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetText(Int32)
  nameWithType: TextPatternRange.GetText(Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetText(Int32)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Возвращает текстового диапазона в виде обычного текста."
  remarks: "GetText уважает скрытым и видимым текстом. Клиент автоматизации пользовательского интерфейса можно проверить <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>видимость текста.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>       Если `maxLength` больше, чем длина диапазона текста вызывающего объекта, возвращаемая строка будет текстового диапазона в виде обычного текста.       GetText не будут затронуты порядком конечных точек в размещение текста; он всегда возвращает текст между конечными точками начала и окончания текстового диапазона в логическом порядке текстового потока."
  example:
  - "[!code-cs[UIATextPattern_snip#1070](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1070)]  \n  \n [!code-vb[UIATextPattern_snip#2070](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2070)]"
  syntax:
    content: public string GetText (int maxLength);
    parameters:
    - id: maxLength
      type: System.Int32
      description: "Максимальная длина возвращаемой строки. Используйте `-1` , если не ограничена."
    return:
      type: System.String
      description: "Обычный текст текстового диапазона, возможно, обрезанное до заданной в параметре <code> maxLength </code>."
  overload: System.Windows.Automation.Text.TextPatternRange.GetText*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Если <code> maxLength </code> меньше-1."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  id: Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Move(TextUnit,Int32)
  nameWithType: TextPatternRange.Move(TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.Move(TextUnit,Int32)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Перемещает текстовый диапазон заданное количество единиц текста."
  remarks: "При необходимости для обхода содержимого текстового диапазона, ряд шагов, участвующих в фоновом в порядке, для успешного выполнения метода Move.      1.  Текстовый диапазон нормализован; то есть, диапазон текста он свернут до вырожденного диапазона в <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>конечную точку, которая делает <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>лишний конечной точки.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> Этот шаг необходим для устранения неоднозначности в случаях, когда текстовый диапазон охватывает `unit` границы; например,» {U} RL [http://www.microsoft.com](http://www.microsoft.com) внедряется в текст» где «{» и «}», конечные точки диапазона текста.      2.  Результирующий диапазон перемещается в <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>в начало запрошенной `unit` границ.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      3.  Диапазон перемещается вперед или назад в <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>запрошенное число `unit` границы.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      4.  Затем диапазон расширяется из вырожденного состояния путем перемещения <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>конечной точки на одну запрошенную `unit` границ.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>       ![Настройка диапазона перемещения & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png &quot;диапазона перемещения & ExpandToEnclosingUnit&quot;) примеры способ корректировки текстового диапазона для Move() и ExpandToEnclosingUnit() текстовое содержимое (или внутренний текст) контейнера текста и внедренного объекта, например гиперссылки или ячейки таблицы, представляется как один непрерывный текстовый поток в представлении элемента управления и представление содержимого [!INCLUDE[TLA2#tla_uiautomation](~/add/includes/tla2sharptla-uiautomation-md.md)] дерева; границы объекта игнорируются. Если клиент автоматизации пользовательского интерфейса извлекает текст с целью вывода, интерпретации или анализа, текстовый диапазон следует проверить в особых случаях, например таблице с текстовым содержимым или другим внедренным объектам. Это можно сделать путем вызова <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>для получения <xref:System.Windows.Automation.AutomationElement>для каждого внедренного объекта и затем вызвать <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A>для получения текстового диапазона для каждого элемента; это выполняется рекурсивно, пока не будет получено все текстовое содержимое.</xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> </xref:System.Windows.Automation.AutomationElement> </xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>       ![Текст, разделенный вставленными объектами. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png &quot;Текст, разделенный вставленными объектами.&quot;)   Пример текстового потока с внедренными объектами и их диапазон охватывает перемещения отношениях как скрытые и отображается текст. Клиент автоматизации пользовательского интерфейса можно проверить <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>видимость текста.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>       Откладывает перемещение к следующему наибольшее <xref:System.Windows.Automation.Text.TextUnit>поддерживаемого Если данного <xref:System.Windows.Automation.Text.TextUnit>не поддерживается элементом управления.</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>       Порядок от наименьшей единицы к максимальному, указанных ниже.      - <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>Настроек [!NOTE] настроек текст не изменяется каким-либо образом, как текстовый диапазон просто распространяется в другую часть текста.</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>"
  example:
  - "[!code-vb[UIATextPattern_snip#StartTarget](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#starttarget)]\n [!code-cs[UIATextPattern_snip#StartTarget](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#starttarget)]  \n[!code-vb[UIATextPattern_snip#GetTextElement](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#gettextelement)]\n[!code-cs[UIATextPattern_snip#GetTextElement](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#gettextelement)]  \n[!code-vb[UIATextPattern_snip#MoveSelection](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#moveselection)]\n[!code-cs[UIATextPattern_snip#MoveSelection](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#moveselection)]"
  syntax:
    content: public int Move (System.Windows.Automation.Text.TextUnit unit, int count);
    parameters:
    - id: unit
      type: System.Windows.Automation.Text.TextUnit
      description: "Граница единицы текста."
    - id: count
      type: System.Int32
      description: "Количество единиц текста для перемещения. Положительное значение перемещению текстового диапазона вперед, отрицательное значение соответствует перемещению текстового диапазона обратной и 0 не оказывает влияния."
    return:
      type: System.Int32
      description: "Число единиц, на которое выполнено перемещение. Это может быть меньше запрошенного количества, если любой из конечных точек текстового диапазона больше или меньше чем <xref:System.Windows.Automation.TextPattern.DocumentRange*>конечных точек.</xref:System.Windows.Automation.TextPattern.DocumentRange*>"
  overload: System.Windows.Automation.Text.TextPatternRange.Move*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  id: MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Перемещает конечную точку текстового диапазона в заданную конечную точку второго текстового диапазона."
  remarks: "Если другой конечной точке же текстовый диапазон пересекает перемещения конечной точки, а затем этой конечной точки перемещаются также приведет к вырожденный диапазон и убедившись в правильный порядок конечных точек (то есть <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>, всегда меньше или равно <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>).</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>"
  example:
  - "[!code-cs[UIATextPattern_snip#1072](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1072)]  \n  \n [!code-vb[UIATextPattern_snip#2072](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2072)]"
  syntax:
    content: public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);
    parameters:
    - id: endpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "Перемещаемая конечная точка."
    - id: targetRange
      type: System.Windows.Automation.Text.TextPatternRange
      description: "Второй диапазон от того же поставщика текста."
    - id: targetEndpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "Конечная точка второго диапазона."
  overload: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  id: MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  nameWithType: TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Перемещает конечную точку текстового диапазона указанное число <xref href=&quot;System.Windows.Automation.Text.TextUnit&quot;> </xref>в диапазоне всего документа."
  remarks: "При необходимости для обхода содержимого текстового диапазона, ряд шагов, участвующих в фоновом в порядке для <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A>для успешного выполнения метода.</xref:System.Windows.Automation.Text.TextPatternRange.Move%2A>      1.  Текстовый диапазон нормализован; то есть, диапазон текста он свернут до вырожденного диапазона в <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>конечную точку, которая делает <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>лишний конечной точки.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> Этот шаг необходим для устранения неоднозначности в случаях, когда текстовый диапазон охватывает `unit` границы; например,» {U} RL [http://www.microsoft.com](http://www.microsoft.com) внедряется в текст» где «{» и «}», конечные точки диапазона текста.      2.  Результирующий диапазон перемещается в <xref:System.Windows.Automation.TextPattern.DocumentRange%2A>в начало запрошенной `unit` границ.</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      3.  Затем диапазон расширяется из вырожденного состояния путем перемещения <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>конечной точки на одну запрошенную `unit` границ.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>       ![Настройка диапазона перемещения & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png &quot;диапазона перемещения & ExpandToEnclosingUnit&quot;) примеры способ корректировки текстового диапазона для Move() и ExpandToEnclosingUnit() текстовое содержимое (или внутренний текст) контейнера текста и внедренного объекта, например гиперссылки или ячейки таблицы, представляется как один непрерывный текстовый поток в представлении элемента управления и представление содержимого [!INCLUDE[TLA2#tla_uiautomation](~/add/includes/tla2sharptla-uiautomation-md.md)] дерева; границы объекта игнорируются. Если клиент автоматизации пользовательского интерфейса извлекает текст с целью вывода, интерпретации или анализа, текстовый диапазон следует проверить в особых случаях, например таблице с текстовым содержимым или другим внедренным объектам. Это можно сделать путем вызова <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>для получения <xref:System.Windows.Automation.AutomationElement>для каждого внедренного объекта и затем вызвать <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A>для получения текстового диапазона для каждого элемента; это выполняется рекурсивно, пока не будет получено все текстовое содержимое.</xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> </xref:System.Windows.Automation.AutomationElement> </xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>       ![Текст, разделенный вставленными объектами. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png &quot;Текст, разделенный вставленными объектами.&quot;)   Пример текстового потока с внедренными объектами и их диапазонов, MoveEndpointByUnit откладывает до следующего наибольшего <xref:System.Windows.Automation.Text.TextUnit>поддерживаемого Если данного <xref:System.Windows.Automation.Text.TextUnit>не поддерживается элементом управления.</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>       Порядок от наименьшей единицы к максимальному, указанных ниже.      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit>"
  example:
  - "[!code-cs[UIATextPattern_snip#1073](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1073)]  \n  \n [!code-vb[UIATextPattern_snip#2073](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2073)]"
  syntax:
    content: public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);
    parameters:
    - id: endpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "Перемещаемая конечная точка."
    - id: unit
      type: System.Windows.Automation.Text.TextUnit
      description: "Перемещаемая единица текста."
    - id: count
      type: System.Int32
      description: "Число единиц для перемещения. При положительном значении выполняется перемещение вперед. При отрицательном значении выполняется перемещение назад. При значении 0 перемещение не влияет."
    return:
      type: System.Int32
      description: "Число единиц, на которое выполнено перемещение, оно может быть меньше, чем значение запрошенного, если при перемещении конечная точка достигает начала или конца документа."
  overload: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection
  id: RemoveFromSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: RemoveFromSelection()
  nameWithType: TextPatternRange.RemoveFromSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Удаляет выделенный текст, соответствующий вызывающего текстового диапазона <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> и <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> конечных точек, из существующей коллекции выделенного текста в текстовом контейнере, поддерживающем раздельное множественное выделение."
  remarks: "Точка вставки текста будет перемещаются в область удаленного выделения.       Предоставление вырожденный диапазон переместит курсор."
  syntax:
    content: public void RemoveFromSelection ();
    parameters: []
  overload: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Если поставщик текста не поддерживает несколько раздельное множественное выделение (например, <xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>должно иметь значение <xref uid=&quot;langword_csharp_Multiple&quot; name=&quot;Multiple&quot; href=&quot;&quot;> </xref>).</xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)
  id: ScrollIntoView(System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: ScrollIntoView(Boolean)
  nameWithType: TextPatternRange.ScrollIntoView(Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(Boolean)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Заставляет текстовый элемент управления выполнять вертикальную прокрутку, пока текстовый диапазон не появится в окне просмотра."
  remarks: "ScrollIntoView уважает скрытым и видимым текстом. Клиент автоматизации пользовательского интерфейса можно проверить <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>видимость текста.</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> Если текстовый диапазон является скрытым, текстовый элемент управления будет прокручиваться только в том случае, если скрытый текст имеет привязку в окне просмотра."
  example:
  - "[!code-cs[UIATextPattern_snip#1074](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1074)]  \n  \n [!code-vb[UIATextPattern_snip#2074](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2074)]"
  syntax:
    content: public void ScrollIntoView (bool alignToTop);
    parameters:
    - id: alignToTop
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если текстовый элемент управления должен выполнить прокрутку так текстовый диапазон отобразился у верхней границы окна просмотра; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если диапазон должен отобразиться у верхней границы окна просмотра."
  overload: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Если прокрутка не поддерживается элементом управления."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Select
  id: Select
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Select()
  nameWithType: TextPatternRange.Select()
  fullName: System.Windows.Automation.Text.TextPatternRange.Select()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Выделяет текст в элементе управления текст, соответствующий диапазону текста <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> и <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref> конечных точек."
  remarks: "Если указано вырожденного диапазона точка вставки текста перейдет <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>конечную точку текстового диапазона.</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>"
  example:
  - "[!code-cs[UIATextPattern_snip#1075](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1075)]  \n  \n [!code-vb[UIATextPattern_snip#2075](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2075)]"
  syntax:
    content: public void Select ();
    parameters: []
  overload: System.Windows.Automation.Text.TextPatternRange.Select*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Происходит, когда выделение текста не поддерживается в текстовом элементе управления."
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.TextPattern
  id: TextPattern
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: TextPattern
  nameWithType: TextPatternRange.TextPattern
  fullName: System.Windows.Automation.Text.TextPatternRange.TextPattern
  type: Property
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "Возвращает <xref href=&quot;System.Windows.Automation.TextPattern&quot;> </xref> связанный с текстовым диапазоном."
  remarks: ''
  example:
  - "[!code-cs[UIATextPattern_snip#1076](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1076)]  \n  \n [!code-vb[UIATextPattern_snip#2076](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2076)]"
  syntax:
    content: public System.Windows.Automation.TextPattern TextPattern { get; }
    return:
      type: System.Windows.Automation.TextPattern
      description: "Поставщик текста."
  overload: System.Windows.Automation.Text.TextPatternRange.TextPattern*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Windows.Automation.Text.TextPatternRange.AddToSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: AddToSelection()
  nameWithType: TextPatternRange.AddToSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.AddToSelection()
- uid: System.Windows.Automation.Text.TextPatternRange.Clone
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Clone()
  nameWithType: TextPatternRange.Clone()
  fullName: System.Windows.Automation.Text.TextPatternRange.Clone()
- uid: System.Windows.Automation.Text.TextPatternRange
  parent: System.Windows.Automation.Text
  isExternal: false
  name: TextPatternRange
  nameWithType: TextPatternRange
  fullName: System.Windows.Automation.Text.TextPatternRange
- uid: System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Compare(TextPatternRange)
  nameWithType: TextPatternRange.Compare(TextPatternRange)
  fullName: System.Windows.Automation.Text.TextPatternRange.Compare(TextPatternRange)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Automation.Text.TextPatternRangeEndpoint
  parent: System.Windows.Automation.Text
  isExternal: false
  name: TextPatternRangeEndpoint
  nameWithType: TextPatternRangeEndpoint
  fullName: System.Windows.Automation.Text.TextPatternRangeEndpoint
- uid: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ExpandToEnclosingUnit(TextUnit)
  nameWithType: TextPatternRange.ExpandToEnclosingUnit(TextUnit)
  fullName: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(TextUnit)
- uid: System.Windows.Automation.Text.TextUnit
  parent: System.Windows.Automation.Text
  isExternal: false
  name: TextUnit
  nameWithType: TextUnit
  fullName: System.Windows.Automation.Text.TextUnit
- uid: System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindAttribute(AutomationTextAttribute,Object,Boolean)
  nameWithType: TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
- uid: System.Windows.Automation.AutomationTextAttribute
  parent: System.Windows.Automation
  isExternal: false
  name: AutomationTextAttribute
  nameWithType: AutomationTextAttribute
  fullName: System.Windows.Automation.AutomationTextAttribute
- uid: System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindText(String,Boolean,Boolean)
  nameWithType: TextPatternRange.FindText(String,Boolean,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindText(String,Boolean,Boolean)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetAttributeValue(AutomationTextAttribute)
  nameWithType: TextPatternRange.GetAttributeValue(AutomationTextAttribute)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(AutomationTextAttribute)
- uid: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetBoundingRectangles()
  nameWithType: TextPatternRange.GetBoundingRectangles()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles()
- uid: System.Windows.Rect[]
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect[]
  spec.csharp:
  - uid: System.Windows.Rect
    name: Rect
    nameWithType: Rect
    fullName: Rect[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Automation.Text.TextPatternRange.GetChildren
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetChildren()
  nameWithType: TextPatternRange.GetChildren()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetChildren()
- uid: System.Windows.Automation.AutomationElement[]
  parent: System.Windows.Automation
  isExternal: false
  name: AutomationElement
  nameWithType: AutomationElement
  fullName: System.Windows.Automation.AutomationElement[]
  spec.csharp:
  - uid: System.Windows.Automation.AutomationElement
    name: AutomationElement
    nameWithType: AutomationElement
    fullName: AutomationElement[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetEnclosingElement()
  nameWithType: TextPatternRange.GetEnclosingElement()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement()
- uid: System.Windows.Automation.AutomationElement
  parent: System.Windows.Automation
  isExternal: false
  name: AutomationElement
  nameWithType: AutomationElement
  fullName: System.Windows.Automation.AutomationElement
- uid: System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetText(Int32)
  nameWithType: TextPatternRange.GetText(Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetText(Int32)
- uid: System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Move(TextUnit,Int32)
  nameWithType: TextPatternRange.Move(TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.Move(TextUnit,Int32)
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  nameWithType: TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
- uid: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: RemoveFromSelection()
  nameWithType: TextPatternRange.RemoveFromSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection()
- uid: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ScrollIntoView(Boolean)
  nameWithType: TextPatternRange.ScrollIntoView(Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(Boolean)
- uid: System.Windows.Automation.Text.TextPatternRange.Select
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Select()
  nameWithType: TextPatternRange.Select()
  fullName: System.Windows.Automation.Text.TextPatternRange.Select()
- uid: System.Windows.Automation.Text.TextPatternRange.TextPattern
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: TextPattern
  nameWithType: TextPatternRange.TextPattern
  fullName: System.Windows.Automation.Text.TextPatternRange.TextPattern
- uid: System.Windows.Automation.TextPattern
  parent: System.Windows.Automation
  isExternal: false
  name: TextPattern
  nameWithType: TextPattern
  fullName: System.Windows.Automation.TextPattern
- uid: System.Windows.Automation.Text.TextPatternRange.AddToSelection*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: AddToSelection
  nameWithType: TextPatternRange.AddToSelection
- uid: System.Windows.Automation.Text.TextPatternRange.Clone*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Clone
  nameWithType: TextPatternRange.Clone
- uid: System.Windows.Automation.Text.TextPatternRange.Compare*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Compare
  nameWithType: TextPatternRange.Compare
- uid: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: CompareEndpoints
  nameWithType: TextPatternRange.CompareEndpoints
- uid: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ExpandToEnclosingUnit
  nameWithType: TextPatternRange.ExpandToEnclosingUnit
- uid: System.Windows.Automation.Text.TextPatternRange.FindAttribute*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindAttribute
  nameWithType: TextPatternRange.FindAttribute
- uid: System.Windows.Automation.Text.TextPatternRange.FindText*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindText
  nameWithType: TextPatternRange.FindText
- uid: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetAttributeValue
  nameWithType: TextPatternRange.GetAttributeValue
- uid: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetBoundingRectangles
  nameWithType: TextPatternRange.GetBoundingRectangles
- uid: System.Windows.Automation.Text.TextPatternRange.GetChildren*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetChildren
  nameWithType: TextPatternRange.GetChildren
- uid: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetEnclosingElement
  nameWithType: TextPatternRange.GetEnclosingElement
- uid: System.Windows.Automation.Text.TextPatternRange.GetText*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetText
  nameWithType: TextPatternRange.GetText
- uid: System.Windows.Automation.Text.TextPatternRange.Move*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Move
  nameWithType: TextPatternRange.Move
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByRange
  nameWithType: TextPatternRange.MoveEndpointByRange
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByUnit
  nameWithType: TextPatternRange.MoveEndpointByUnit
- uid: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: RemoveFromSelection
  nameWithType: TextPatternRange.RemoveFromSelection
- uid: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ScrollIntoView
  nameWithType: TextPatternRange.ScrollIntoView
- uid: System.Windows.Automation.Text.TextPatternRange.Select*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Select
  nameWithType: TextPatternRange.Select
- uid: System.Windows.Automation.Text.TextPatternRange.TextPattern*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: TextPattern
  nameWithType: TextPatternRange.TextPattern
