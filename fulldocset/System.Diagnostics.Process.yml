### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.Process
  id: Process
  children:
  - System.Diagnostics.Process.#ctor
  - System.Diagnostics.Process.BasePriority
  - System.Diagnostics.Process.BeginErrorReadLine
  - System.Diagnostics.Process.BeginOutputReadLine
  - System.Diagnostics.Process.CancelErrorRead
  - System.Diagnostics.Process.CancelOutputRead
  - System.Diagnostics.Process.Close
  - System.Diagnostics.Process.CloseMainWindow
  - System.Diagnostics.Process.Dispose(System.Boolean)
  - System.Diagnostics.Process.EnableRaisingEvents
  - System.Diagnostics.Process.EnterDebugMode
  - System.Diagnostics.Process.ErrorDataReceived
  - System.Diagnostics.Process.ExitCode
  - System.Diagnostics.Process.Exited
  - System.Diagnostics.Process.ExitTime
  - System.Diagnostics.Process.GetCurrentProcess
  - System.Diagnostics.Process.GetProcessById(System.Int32)
  - System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - System.Diagnostics.Process.GetProcesses
  - System.Diagnostics.Process.GetProcesses(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  - System.Diagnostics.Process.Handle
  - System.Diagnostics.Process.HandleCount
  - System.Diagnostics.Process.HasExited
  - System.Diagnostics.Process.Id
  - System.Diagnostics.Process.Kill
  - System.Diagnostics.Process.LeaveDebugMode
  - System.Diagnostics.Process.MachineName
  - System.Diagnostics.Process.MainModule
  - System.Diagnostics.Process.MainWindowHandle
  - System.Diagnostics.Process.MainWindowTitle
  - System.Diagnostics.Process.MaxWorkingSet
  - System.Diagnostics.Process.MinWorkingSet
  - System.Diagnostics.Process.Modules
  - System.Diagnostics.Process.NonpagedSystemMemorySize
  - System.Diagnostics.Process.NonpagedSystemMemorySize64
  - System.Diagnostics.Process.OnExited
  - System.Diagnostics.Process.OutputDataReceived
  - System.Diagnostics.Process.PagedMemorySize
  - System.Diagnostics.Process.PagedMemorySize64
  - System.Diagnostics.Process.PagedSystemMemorySize
  - System.Diagnostics.Process.PagedSystemMemorySize64
  - System.Diagnostics.Process.PeakPagedMemorySize
  - System.Diagnostics.Process.PeakPagedMemorySize64
  - System.Diagnostics.Process.PeakVirtualMemorySize
  - System.Diagnostics.Process.PeakVirtualMemorySize64
  - System.Diagnostics.Process.PeakWorkingSet
  - System.Diagnostics.Process.PeakWorkingSet64
  - System.Diagnostics.Process.PriorityBoostEnabled
  - System.Diagnostics.Process.PriorityClass
  - System.Diagnostics.Process.PrivateMemorySize
  - System.Diagnostics.Process.PrivateMemorySize64
  - System.Diagnostics.Process.PrivilegedProcessorTime
  - System.Diagnostics.Process.ProcessName
  - System.Diagnostics.Process.ProcessorAffinity
  - System.Diagnostics.Process.Refresh
  - System.Diagnostics.Process.Responding
  - System.Diagnostics.Process.SafeHandle
  - System.Diagnostics.Process.SessionId
  - System.Diagnostics.Process.StandardError
  - System.Diagnostics.Process.StandardInput
  - System.Diagnostics.Process.StandardOutput
  - System.Diagnostics.Process.Start
  - System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  - System.Diagnostics.Process.Start(System.String)
  - System.Diagnostics.Process.Start(System.String,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  - System.Diagnostics.Process.StartInfo
  - System.Diagnostics.Process.StartTime
  - System.Diagnostics.Process.SynchronizingObject
  - System.Diagnostics.Process.Threads
  - System.Diagnostics.Process.ToString
  - System.Diagnostics.Process.TotalProcessorTime
  - System.Diagnostics.Process.UserProcessorTime
  - System.Diagnostics.Process.VirtualMemorySize
  - System.Diagnostics.Process.VirtualMemorySize64
  - System.Diagnostics.Process.WaitForExit
  - System.Diagnostics.Process.WaitForExit(System.Int32)
  - System.Diagnostics.Process.WaitForInputIdle
  - System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  - System.Diagnostics.Process.WorkingSet
  - System.Diagnostics.Process.WorkingSet64
  langs:
  - csharp
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
  type: Class
  summary: "Предоставляет доступ к локальным и удаленным процессам и позволяет запускать и останавливать локальные системные процессы.       Для просмотра исходного кода .NET Framework для этого типа, в разделе [ссылки на источник](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04)."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n A Process component provides access to a process that is running on a computer. A process, in the simplest terms, is a running app. A thread is the basic unit to which the operating system allocates processor time. A thread can execute any part of the code of the process, including parts currently being executed by another thread.  \n  \n The Process component is a useful tool for starting, stopping, controlling, and monitoring apps. You can use the Process component, to obtain a list of the processes that are running, or you can start a new process. A Process component is used to access system processes. After a Process component has been initialized, it can be used to obtain information about the running process. Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.  \n  \n This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n> [!NOTE]\n>  32-bit processes cannot access the modules of a 64-bit process. If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref:System.ComponentModel.Win32Exception> exception. A 64-bit process, on the other hand, can access the modules of a 32-bit process.  \n  \n The process component obtains information about a group of properties all at once. After the Process component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref:System.Diagnostics.Process.Refresh%2A> method. Therefore, a property value is not guaranteed to be any newer than the last call to the <xref:System.Diagnostics.Process.Refresh%2A> method. The group breakdowns are operating-system dependent.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n A system process is uniquely identified on the system by its process identifier. Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer. A handle is the generic term for an identifier of a resource. The operating system persists the process handle, which is accessed through the <xref:System.Diagnostics.Process.Handle%2A> property of the Process component, even when the process has exited. Thus, you can get the process's administrative information, such as the <xref:System.Diagnostics.Process.ExitCode%2A> (usually either zero for success or a nonzero error code) and the <xref:System.Diagnostics.Process.ExitTime%2A>. Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.  \n  \n> [!NOTE]\n>  This class contains a link demand and an inheritance demand at the class level that applies to all members. A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission. For details about security demands, see [Link Demands](~/add/includes/ajax-current-ext-md.md).  \n  \n<a name=\"Core\"></a>   \n## [!INCLUDE[net_core](~/add/includes/net-core-md.md)] Notes  \n In the .NET Framework on the desktop, the Process class by default uses <xref:System.Console> encodings, which are typically code page encodings, for the input, output, and error streams. For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the <xref:System.Console> class. However, [!INCLUDE[net_core](~/add/includes/net-core-md.md)] may make only a limited subset of these encodings available. If this is the case, it uses <xref:System.Text.Encoding.UTF8%2A?displayProperty=fullName> as the default encoding.  \n  \n If a Process object depends on specific code page encodings, you can still make them available by doing the following *before* you call any Process methods:  \n  \n1.  Add a reference to the System.Text.Encoding.CodePages.dll assembly to your project.  \n  \n2.  Retrieve the <xref:System.Text.EncodingProvider> object from the <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=fullName> property.  \n  \n3.  Pass the <xref:System.Text.EncodingProvider> object to the <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=fullName> method to make the additional encodings supported by the encoding provider available.  \n  \n The Process class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any Process methods."
  example:
  - "The following example uses an instance of the Process class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_1.cs)]  \n  \n The following example uses the Process class itself and a static <xref:System.Diagnostics.Process.Start%2A> method to start a process.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_1_2.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_1_2.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_1_2.cpp)]  \n  \n The following F# example defines a `runProc` function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.  The `runProc` function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.  \n  \n [!code-fs[System.Diagnostics.Process#1](~/add/codesnippet/fsharp/t-system.diagnostics.pro_1_3.fs)]  \n  \n The code for the `runProc` function was written by [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) and is available under the [Microsoft Public License](http://opensource.org/licenses/ms-pl)."
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Exited")]

      [System.ComponentModel.DefaultProperty("StartInfo")]

      [System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("ProcessDesc")]

      public class Process : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.Process.#ctor
  id: '#ctor'
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Diagnostics.Process&quot;> </xref> класса."
  remarks: "Если вы не укажете <xref:System.Diagnostics.Process.MachineName%2A>Свойства, значение по умолчанию — локальный компьютер, («.»).</xref:System.Diagnostics.Process.MachineName%2A>       Есть два способа сопоставления нового <xref:System.Diagnostics.Process>компонент с процесс на компьютере.</xref:System.Diagnostics.Process> Первый вариант — использовать конструктор для создания <xref:System.Diagnostics.Process>набор компонентов, соответствующих членов <xref:System.Diagnostics.Process.StartInfo%2A>свойство и вызвать <xref:System.Diagnostics.Process.Start%2A>связываемый <xref:System.Diagnostics.Process>с новым системным процессом.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.Process> Второй параметр — для связывания <xref:System.Diagnostics.Process>с выполняющийся процесс системы с помощью <xref:System.Diagnostics.Process.GetProcessById%2A>или один из <xref:System.Diagnostics.Process.GetProcesses%2A>возвращаемые значения.</xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process>       Если вы используете `static` перегрузки <xref:System.Diagnostics.Process.Start%2A>метод для запуска нового процесса системы, метод создает новый <xref:System.Diagnostics.Process>компонента и связывает его с процессом.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>       При <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>задано значение по умолчанию `true`, вы можете запустить приложения и документы в способом, который аналогичен использованию `Run` диалогового окна `Start` меню.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> Если <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>является `false`, можно запускать только исполняемые файлы.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>       Любой исполняемый файл, который можно вызвать из командной строки можно запустить одним из двух способов:, задав соответствующие члены <xref:System.Diagnostics.Process.StartInfo%2A>и вызова <xref:System.Diagnostics.Process.Start%2A>метод без параметров, либо путем передачи соответствующего параметра `static` <xref:System.Diagnostics.Process.Start%2A>член.</xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A>       Можно создать <xref:System.Diagnostics.Process>компонент с помощью конструктора, одного из статических <xref:System.Diagnostics.Process.Start%2A>или любой из перегрузки <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, или <xref:System.Diagnostics.Process.GetProcessesByName%2A>методы.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process> После этого делали, имеется представление связанного процесса. Это не динамическое представление, которое автоматически обновляется при изменении свойства процесса в памяти. Вместо этого необходимо вызвать метод <xref:System.Diagnostics.Process.Refresh%2A>для компонента, чтобы обновить <xref:System.Diagnostics.Process>сведения о свойстве в приложении.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  syntax:
    content: public Process ();
    parameters: []
  overload: System.Diagnostics.Process.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.BasePriority
  id: BasePriority
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает базовый приоритет связанного процесса."
  remarks: "BasePriority процесса является стартовым приоритетом для потоков, созданных в связанном процессе. Можно просмотреть сведения о базовом приоритете через базовый приоритет счетчик системного монитора.       На основе времени, затраченного или других показателях, операционной системы можно изменить базовый приоритет, если процесс следует поместить впереди других.       Свойства BasePriority позволяет посмотреть стартовый приоритет, присвоенный процессу. Тем не менее так как он доступен только для чтения, нельзя использовать для задания приоритета процесса BasePriority. Чтобы изменить приоритет, используйте <xref:System.Diagnostics.Process.PriorityClass%2A>свойство.</xref:System.Diagnostics.Process.PriorityClass%2A> BasePriority можно просматривать с помощью системного монитора, а <xref:System.Diagnostics.Process.PriorityClass%2A>не.</xref:System.Diagnostics.Process.PriorityClass%2A> Оба BasePriority и <xref:System.Diagnostics.Process.PriorityClass%2A>можно просмотреть программно.</xref:System.Diagnostics.Process.PriorityClass%2A> В следующей таблице показаны связи между значениями BasePriority и <xref:System.Diagnostics.Process.PriorityClass%2A>значения.</xref:System.Diagnostics.Process.PriorityClass%2A>      | BasePriority | PriorityClass |   |------------------|-------------------|   |&4; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&8; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&13; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&24; | <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public int BasePriority { get; }
    return:
      type: System.Int32
      description: "Базовый приоритет, который вычисляется на основе <xref:System.Diagnostics.Process.PriorityClass*>связанного процесса.</xref:System.Diagnostics.Process.PriorityClass*>"
  overload: System.Diagnostics.Process.BasePriority*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа — Windows 98 или Windows Millennium Edition (Windows Me); задать &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; свойства <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для доступа к этому свойству в Windows 98 и Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс завершен.       - или - процесс не запущен, поэтому нет идентификатора процесса."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginErrorReadLine
  id: BeginErrorReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Начинает операции асинхронного чтения в перенаправленном <xref:System.Diagnostics.Process.StandardError*>потока приложения.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "<xref:System.Diagnostics.Process.StandardError%2A>Возможность чтения потока, синхронно или асинхронно.</xref:System.Diagnostics.Process.StandardError%2A> Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A>синхронной операции чтения в поток вывода ошибок в процессе выполнения.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Эти синхронного чтения операций не завершены, пока не связанный с ним <xref:System.Diagnostics.Process>записывает его <xref:System.Diagnostics.Process.StandardError%2A>потока или закрывает поток.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Напротив, запускает BeginErrorReadLine асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A>потока.</xref:System.Diagnostics.Process.StandardError%2A> Этот метод включает маршрутизируемый обработчик событий вывода потока и сразу возвращается вызывающему объекту, который может выполнять другую работу, пока вывод потока направлен обработчику событий.       Выполните следующие действия для выполнения асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A>для <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>      3.  Добавьте обработчик событий <xref:System.Diagnostics.Process.ErrorDataReceived>событий.</xref:System.Diagnostics.Process.ErrorDataReceived> Обработчик событий должен соответствовать <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>сигнатуре делегата.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Запуск <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  Вызов BeginErrorReadLine для <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> Этот вызов начинает операции асинхронного чтения <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A>       Если запуск асинхронных операций чтения, обработчик событий вызывается при каждом запуске связанного <xref:System.Diagnostics.Process>записывает строку текста, чтобы его <xref:System.Diagnostics.Process.StandardError%2A>потока.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Можно отменить асинхронную операцию чтения, вызвав <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> Операция чтения может быть отменено, вызывающим или обработчик событий. После отмены, вы можете вызвать BeginErrorReadLine еще раз, чтобы возобновить операции асинхронного чтения.      Настроек [!NOTE] настроек нельзя смешивать асинхронная и синхронная операции чтения в перенаправленном потоке. Один раз перенаправленный поток <xref:System.Diagnostics.Process>открывается в режиме синхронной или асинхронной, все дополнительные чтения операции в этом потоке должны быть в том же режиме.</xref:System.Diagnostics.Process> Например, не выполняйте BeginErrorReadLine вызовом <xref:System.IO.StreamReader.ReadLine%2A>на <xref:System.Diagnostics.Process.StandardError%2A>поток, или наоборот.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> Однако можно считать два различных потоков в различных режимах. Например, можно вызвать BeginErrorReadLine и затем вызвать метод <xref:System.IO.StreamReader.ReadLine%2A>для <xref:System.Diagnostics.Process.StandardOutput%2A>потока.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/m-system.diagnostics.pro_4_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/m-system.diagnostics.pro_4_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_4_1.vb)]"
  syntax:
    content: public void BeginErrorReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginErrorReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardError*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardError*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.BeginOutputReadLine
  id: BeginOutputReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Начинает операции асинхронного чтения в перенаправленном <xref:System.Diagnostics.Process.StandardOutput*>потока приложения.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "<xref:System.Diagnostics.Process.StandardOutput%2A>Возможность чтения потока, синхронно или асинхронно.</xref:System.Diagnostics.Process.StandardOutput%2A> Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A>выполнения синхронных операций чтения в выходной поток процесса.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Эти синхронного чтения операций не завершены, пока не связанный с ним <xref:System.Diagnostics.Process>записывает его <xref:System.Diagnostics.Process.StandardOutput%2A>потока или закрывает поток.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Напротив, запускает BeginOutputReadLine асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A>потока.</xref:System.Diagnostics.Process.StandardOutput%2A> Этот метод включает назначенный обработчик событий для выходного потока и немедленно возвращается вызывающему объекту, который может выполнять другую работу, пока вывод потока направлен обработчику событий.       Выполните следующие действия для выполнения асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A>для <xref:System.Diagnostics.Process>: 1.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A>  Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>      2.  Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> to `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>      3.  Добавьте обработчик событий <xref:System.Diagnostics.Process.OutputDataReceived>событий.</xref:System.Diagnostics.Process.OutputDataReceived> Обработчик событий должен соответствовать <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>сигнатуре делегата.</xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=fullName>      4.  Запуск <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process>      5.  Вызов BeginOutputReadLine для <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> Этот вызов начинает операции асинхронного чтения <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A>       Если запуск асинхронных операций чтения, обработчик событий вызывается при каждом запуске связанного <xref:System.Diagnostics.Process>записывает строку текста, чтобы его <xref:System.Diagnostics.Process.StandardOutput%2A>потока.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Можно отменить асинхронную операцию чтения, вызвав <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> Операция чтения может быть отменено, вызывающим или обработчик событий. После отмены, вы можете вызвать BeginOutputReadLine еще раз, чтобы возобновить операции асинхронного чтения.      Настроек [!NOTE] настроек нельзя смешивать асинхронная и синхронная операции чтения в перенаправленном потоке. Один раз перенаправленный поток <xref:System.Diagnostics.Process>открывается в режиме синхронной или асинхронной, все дополнительные чтения операции в этом потоке должны быть в том же режиме.</xref:System.Diagnostics.Process> Например, не выполняйте BeginOutputReadLine вызовом <xref:System.IO.StreamReader.ReadLine%2A>на <xref:System.Diagnostics.Process.StandardOutput%2A>поток, или наоборот.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.IO.StreamReader.ReadLine%2A> Однако можно считать два различных потоков в различных режимах. Например, можно вызвать BeginOutputReadLine и затем вызвать метод <xref:System.IO.StreamReader.ReadLine%2A>для <xref:System.Diagnostics.Process.StandardError%2A>потока.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `sort` command. The `sort` command is a console application that reads and sorts text input.  \n  \n The example creates an event delegate for the `SortOutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and writes the text to the screen.  \n  \n [!code-cpp[Process_AsyncStreams#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_13_1.cpp)]\n [!code-vb[Process_AsyncStreams#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_13_1.vb)]\n [!code-cs[Process_AsyncStreams#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_13_1.cs)]"
  syntax:
    content: public void BeginOutputReadLine ();
    parameters: []
  overload: System.Diagnostics.Process.BeginOutputReadLine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An asynchronous read operation is already in progress on the <xref:System.Diagnostics.Process.StandardOutput*> stream.  \n  \n \\- or -  \n  \n The <xref:System.Diagnostics.Process.StandardOutput*> stream has been used by a synchronous read operation."
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelErrorRead
  id: CancelErrorRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Отменяет операцию асинхронного чтения в перенаправленном <xref:System.Diagnostics.Process.StandardError*>потока приложения.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>Начинает асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardError%2A>потока.</xref:System.Diagnostics.Process.StandardError%2A></xref:System.Diagnostics.Process.BeginErrorReadLine%2A> CancelErrorRead завершает операцию асинхронного чтения.       После отмены, можно возобновить операцию асинхронного чтения путем вызова <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>еще раз.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A>       При вызове CancelErrorRead все выполняющиеся операции чтения для <xref:System.Diagnostics.Process.StandardError%2A>завершены, а затем выключено обработчик события.</xref:System.Diagnostics.Process.StandardError%2A> Все дополнительные перенаправление вывода <xref:System.Diagnostics.Process.StandardError%2A>сохраняются в буфер.</xref:System.Diagnostics.Process.StandardError%2A> Если повторно включить обработчик событий с помощью вызова <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, сохраненные данные выводятся в обработчик событий и возобновить операции асинхронного чтения.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Если вы хотите изменить обработчик событий перед возобновлением асинхронных операций чтения, необходимо удалить существующий обработчик событий перед добавлением нового обработчика событий: ```   // At this point the DataReceivedEventHandler(ErrorHandler1)    // has executed a CancelErrorRead.      // Remove the prior event handler.   process.ErrorDataReceived -=        new DataReceivedEventHandler(ErrorHandler1);      // Register a new event handler.   process.ErrorDataReceived +=        new DataReceivedEventHandler(ErrorHandler2);      // Call the corresponding BeginErrorReadLine.   process.BeginErrorReadLine();   ```       >  [!NOTE] настроек нельзя смешивать асинхронная и синхронная операции чтения в перенаправленном <xref:System.Diagnostics.Process.StandardError%2A>потока.</xref:System.Diagnostics.Process.StandardError%2A> Один раз перенаправленный поток <xref:System.Diagnostics.Process>открывается в режиме синхронной или асинхронной, все дополнительные чтения операции в этом потоке должны быть в том же режиме.</xref:System.Diagnostics.Process> Если отменить асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardError%2A>и затем нужно прочитать из потока, необходимо использовать <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>Возобновление операции асинхронного чтения.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process.StandardError%2A> Не выполняйте CancelErrorRead на вызов синхронных методов чтения из <xref:System.Diagnostics.Process.StandardError%2A>например <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, или <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardError%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_7_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_7_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_7_1.vb)]"
  syntax:
    content: public void CancelErrorRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelErrorRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Diagnostics.Process.StandardError*>Поток не включен для асинхронных операций чтения.</xref:System.Diagnostics.Process.StandardError*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.CancelOutputRead
  id: CancelOutputRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Отменяет операцию асинхронного чтения в перенаправленном <xref:System.Diagnostics.Process.StandardOutput*>потока приложения.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>Начинает асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardOutput%2A>потока.</xref:System.Diagnostics.Process.StandardOutput%2A></xref:System.Diagnostics.Process.BeginOutputReadLine%2A> CancelOutputRead завершает операцию асинхронного чтения.       После отмены, можно возобновить асинхронных операций чтения путем вызова <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>еще раз.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A>       При вызове CancelOutputRead все выполняющиеся операции чтения для <xref:System.Diagnostics.Process.StandardOutput%2A>завершены, а затем выключено обработчик события.</xref:System.Diagnostics.Process.StandardOutput%2A> Все дополнительные перенаправление вывода <xref:System.Diagnostics.Process.StandardOutput%2A>сохраняются в буфер.</xref:System.Diagnostics.Process.StandardOutput%2A> Если повторно включить обработчик событий с помощью вызова <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, сохраненные данные выводятся в обработчик событий и возобновить операции асинхронного чтения.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Если вы хотите изменить обработчик событий перед возобновлением асинхронных операций чтения, необходимо удалить существующий обработчик событий перед добавлением нового обработчика событий: ```   // At this point the DataReceivedEventHandler(OutputHandler1)    // has executed a CancelOutputRead.      // Remove the prior event handler.   process.OutputDataReceived -=        new DataReceivedEventHandler(OutputHandler1);      // Register a new event handler.   process.OutputDataReceived +=        new DataReceivedEventHandler(OutputHandler2);      // Call the corresponding BeginOutputReadLine.   process.BeginOutputReadLine();   ```       >  [!NOTE] настроек нельзя смешивать асинхронная и синхронная операции чтения в перенаправленном <xref:System.Diagnostics.Process.StandardOutput%2A>потока.</xref:System.Diagnostics.Process.StandardOutput%2A> Один раз перенаправленный поток <xref:System.Diagnostics.Process>открывается в режиме синхронной или асинхронной, все дополнительные чтения операции в этом потоке должны быть в том же режиме.</xref:System.Diagnostics.Process> Если отменить асинхронную операцию чтения на <xref:System.Diagnostics.Process.StandardOutput%2A>и затем нужно прочитать из потока, необходимо использовать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>Возобновление операции асинхронного чтения.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process.StandardOutput%2A> Не выполняйте CancelOutputRead на вызов синхронных методов чтения из <xref:System.Diagnostics.Process.StandardOutput%2A>например <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, или <xref:System.IO.StreamReader.ReadToEnd%2A>.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>"
  example:
  - "The following example starts the `nmake` command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.  \n  \n [!code-cpp[Process_AsyncStreams#3](~/add/codesnippet/cpp/m-system.diagnostics.pro_3_1.cpp)]\n [!code-cs[Process_AsyncStreams#3](~/add/codesnippet/csharp/m-system.diagnostics.pro_3_1.cs)]\n [!code-vb[Process_AsyncStreams#3](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_3_1.vb)]"
  syntax:
    content: public void CancelOutputRead ();
    parameters: []
  overload: System.Diagnostics.Process.CancelOutputRead*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Diagnostics.Process.StandardOutput*>Поток не включен для асинхронных операций чтения.</xref:System.Diagnostics.Process.StandardOutput*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.Close
  id: Close
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Освобождает все ресурсы, связанные с этим компонентом."
  remarks: "Метод Close вызывает обработку прекратить ожидание выхода, если он ожидал закрывает дескриптор процесса и очищает свойства, относящиеся к процессу. Закрыть без закрытия стандартные выходные данные, входные и ошибки чтения и записи в случае, если они ссылаются извне.      Настроек [!NOTE] настроек <xref:System.Diagnostics.Process.Dispose%2A>метод вызывает метод Close.</xref:System.Diagnostics.Process.Dispose%2A> Размещение <xref:System.Diagnostics.Process>объекта в `using` блок освобождает ресурсы, без необходимости вызова Close.</xref:System.Diagnostics.Process>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2-second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_0_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.Process.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.CloseMainWindow
  id: CloseMainWindow
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Закрывает процесс, имеющий пользовательский интерфейс, посылая сообщение о закрытии главному окну процесса."
  remarks: "При выполнении процесса его цикл сообщений находится в состоянии ожидания. Цикл обработки сообщений выполняется каждый раз, посылает сообщение Windows для процесса операционной системой. Вызов CloseMainWindow отправляет запрос на закрытие главного окна, который закрывает дочерние окна и отменяет все выполняющиеся циклы сообщений для приложения в приложении правильного формата. Запрос на завершение процесса путем вызова CloseMainWindow не вынуждает приложение, чтобы выйти из программы. Приложение может запросить проверку пользователя перед завершением работы или она может отказаться закрыться. Чтобы принудительно завершить работу приложения, используйте <xref:System.Diagnostics.Process.Kill%2A>метод.</xref:System.Diagnostics.Process.Kill%2A> Поведение CloseMainWindow идентична Закрыть главное окно приложения с помощью системного меню пользователь. Таким образом запрос на завершение процесса закрытием главного окна не вынуждает приложение немедленно завершиться.       Данные, изменять процессом или ресурсы, выделенные для процесса могут быть потеряны при вызове метода <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>вызывает аварийного завершения процесса и должен использоваться только при необходимости.</xref:System.Diagnostics.Process.Kill%2A> CloseMainWindow включает упорядоченной остановки процесса и закрывает все окна, поэтому рекомендуется для приложений с интерфейсом. Если CloseMainWindow завершается ошибкой, можно использовать <xref:System.Diagnostics.Process.Kill%2A>на завершение процесса.</xref:System.Diagnostics.Process.Kill%2A> <xref:System.Diagnostics.Process.Kill%2A>Это единственный способ завершения процессов, не имеющих графического интерфейса.</xref:System.Diagnostics.Process.Kill%2A>       Можно вызвать <xref:System.Diagnostics.Process.Kill%2A>и CloseMainWindow только для процессов, запущенных на локальном компьютере.</xref:System.Diagnostics.Process.Kill%2A> Не удается вызвать процессов на удаленных компьютерах, чтобы выйти из. Кроме того, могут только просматривать информацию для процессов, запущенных на удаленных компьютерах."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_18_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public bool CloseMainWindow ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если сообщение о закрытии было успешно отправлено; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если связанный процесс не имеет главного окна или если главное окно отключено (например, если отображается модальное диалоговое окно)."
  overload: System.Diagnostics.Process.CloseMainWindow*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа — Windows 98 или Windows Millennium Edition (Windows Me); задать &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; свойства <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для доступа к этому свойству в Windows 98 и Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Этот процесс уже завершился.       - или - процесс не связан с этим <xref href=&quot;System.Diagnostics.Process&quot;> </xref> объекта."
  platform:
  - net462
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Освобождает все ресурсы, используемые этим процессом."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>для освобождения управляемых и неуправляемых ресурсов; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для освобождения только неуправляемых ресурсов."
  overload: System.Diagnostics.Process.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает ли <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> событие должно вызываться при завершении процесса."
  remarks: "Свойство EnableRaisingEvents указывает ли компонент уведомляться операционной системы завершил работу процесса. Свойство EnableRaisingEvents используется в асинхронной обработке для уведомления приложения о завершении процесса. Чтобы принудительно выполнить приложение синхронно ожидания событие выхода (которое прерывает обработку приложения, пока не произошло событие выхода), используйте <xref:System.Diagnostics.Process.WaitForExit%2A>метод.</xref:System.Diagnostics.Process.WaitForExit%2A>      Настроек [!NOTE] настроек, если вы используете Visual Studio и дважды щелкните <xref:System.Diagnostics.Process>компонента в своем проекте <xref:System.Diagnostics.Process.Exited>делегат события и обработчик событий создаются автоматически.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.Process> Дополнительный код задает свойство EnableRaisingEvents `false`. Необходимо изменить это свойство, чтобы `true` для обработчика событий должен выполняться при завершении связанного процесса.       Если связанный процесс завершает операционной системой либо нормальное или аварийное завершение операционная система уведомляет каждый компонент процесса, к которому был связан процесс, при условии, что значение EnableRaisingEvents компонента `true`. Если компонент запустил процесс, может получить доступ к административной информации для связанного процесса, которая все еще хранится операционной системой. Такая информация включает <xref:System.Diagnostics.Process.ExitTime%2A>и <xref:System.Diagnostics.Process.ExitCode%2A>.</xref:System.Diagnostics.Process.ExitCode%2A> </xref:System.Diagnostics.Process.ExitTime%2A>       После выхода из процесса, <xref:System.Diagnostics.Process.Handle%2A>компонента больше не указывает на существующий ресурс процесса.</xref:System.Diagnostics.Process.Handle%2A> Вместо этого он может использоваться только для доступа к информации операционной системы о ресурсе процесса. Операционная система не знать о дескрипторах завершенных процессов, которые не были освобождены <xref:System.Diagnostics.Process>компонентов, поэтому она хранит <xref:System.Diagnostics.Process.ExitTime%2A>и <xref:System.Diagnostics.Process.Handle%2A>данные из памяти.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Нет затраты, связанные с наблюдением за завершением процесса. Если EnableRaisingEvents `true`, <xref:System.Diagnostics.Process.Exited>событие вызывается при завершении связанного процесса.</xref:System.Diagnostics.Process.Exited> Процедуры, которые были выбраны для <xref:System.Diagnostics.Process.Exited>событий, в это время выполняются.</xref:System.Diagnostics.Process.Exited>       В некоторых случаях приложение запускает процесс, но не требуется получать уведомления о его завершении. Например приложение может Запустите Блокнот, чтобы разрешить пользователю редактировать текст, но больше не использовать приложение «Блокнот». Вы можете не получать уведомления при завершении процесса, так как он не имеет значения для продолжения работы приложения. Установите значение EnableRaisingEvents `false` позволяет сэкономить системные ресурсы."
  example:
  - "The following code example creates a process that prints a file. It sets the EnableRaisingEvents property to cause the process to raise the <xref:System.Diagnostics.Process.Exited> event when it exits. The <xref:System.Diagnostics.Process.Exited> event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_38_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_38_1.cs)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> событие должно вызываться при завершении связанного процесса (выход или вызов <xref:System.Diagnostics.Process.Kill*>); в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.Kill*> Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.EnableRaisingEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.EnterDebugMode
  id: EnterDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Помещает <xref href=&quot;System.Diagnostics.Process&quot;> </xref> обрабатывает компонент в состояние взаимодействия с операционной системой, выполняющимся в специальном режиме путем включения встроенного свойства <xref uid=&quot;langword_csharp_SeDebugPrivilege&quot; name=&quot;SeDebugPrivilege&quot; href=&quot;&quot;> </xref> в текущем потоке."
  remarks: "Некоторые процессы операционной системы, выполняются в специальном режиме. Попытка чтения свойства или присоединения к процессам невозможна, если только после вызова метода EnterDebugMode в компоненте. Вызовите <xref:System.Diagnostics.Process.LeaveDebugMode%2A>при больше не нужен доступ к процессам, выполняющимся в специальном режиме.</xref:System.Diagnostics.Process.LeaveDebugMode%2A>"
  syntax:
    content: public static void EnterDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.EnterDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ErrorDataReceived
  id: ErrorDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Происходит, когда приложение выполняет запись в свой перенаправленный <xref:System.Diagnostics.Process.StandardError*>потока.</xref:System.Diagnostics.Process.StandardError*>"
  remarks: "Событие ErrorDataReceived означает, что процесса записал в свой перенаправленный <xref:System.Diagnostics.Process.StandardError%2A>потока.</xref:System.Diagnostics.Process.StandardError%2A>       Это событие происходит только во время операции асинхронного чтения <xref:System.Diagnostics.Process.StandardError%2A>.</xref:System.Diagnostics.Process.StandardError%2A> Запуск асинхронных операций чтения, необходимо перенаправить <xref:System.Diagnostics.Process.StandardError%2A>поток <xref:System.Diagnostics.Process>, добавьте обработчик событий к событию ErrorDataReceived и вызвать <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A> После этого ErrorDataReceived сигналы событие каждый раз процесс записывает строку в перенаправленный <xref:System.Diagnostics.Process.StandardError%2A>поток, пока существует процесс или вызовы <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</xref:System.Diagnostics.Process.CancelErrorRead%2A> </xref:System.Diagnostics.Process.StandardError%2A>      Настроек [!NOTE] настроек приложения, которое обрабатывает асинхронный выход должен вызывать <xref:System.Diagnostics.Process.WaitForExit%2A>метод, чтобы гарантировать записан выходной буфер.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example uses the `net view` command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.  \n  \n [!code-cpp[Process_AsyncStreams#2](~/add/codesnippet/cpp/e-system.diagnostics.pro_0_1.cpp)]\n [!code-cs[Process_AsyncStreams#2](~/add/codesnippet/csharp/e-system.diagnostics.pro_0_1.cs)]\n [!code-vb[Process_AsyncStreams#2](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitCode
  id: ExitCode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает значение, который задал связанный процесс при завершении."
  remarks: "Используйте ExitCode для получения статуса, которое вернул системный процесс при завершении. Можно использовать код выхода гораздо похож на возвращаемое значение из `main()` процедуры.       Значение ExitCode для процесса отражает конкретное соглашение, реализованные разработчиком приложения для этого процесса. Если используется значение кода выхода для принятия решений в коде, быть вы знаете, что соглашения кода выхода, используемой процессом приложения.       Разработчики обычно указывают успешный выход с нулевым значением ExitCode и ошибки обозначают ненулевыми значениями, которые вызывающий метод можно использовать для определения причины аварийного завершения процесса. Придерживайтесь следующих правил необязательно, но они являются соглашением.       При попытке получить ExitCode перед процесс завершился создаст исключение. Изучите <xref:System.Diagnostics.Process.HasExited%2A>сначала, чтобы проверить, является ли связанный процесс завершился.</xref:System.Diagnostics.Process.HasExited%2A>      Настроек [!NOTE] настроек когда стандартный вывод был перенаправлен обработчикам асинхронных событий, это возможно, что обработка вывода будет не завершена при <xref:System.Diagnostics.Process.HasExited%2A>возвращает `true`.</xref:System.Diagnostics.Process.HasExited%2A> Чтобы обеспечить завершение асинхронной обработки событий, вызовите <xref:System.Diagnostics.Process.WaitForExit>перегрузку, принимающую параметр отсутствует, прежде чем вернуть <xref:System.Diagnostics.Process.HasExited%2A>.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.WaitForExit>       Можно использовать <xref:System.Diagnostics.Process.CloseMainWindow%2A>или <xref:System.Diagnostics.Process.Kill%2A>метод для завершения связанного процесса.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A>       Существует два способа уведомления о завершении связанного процесса: синхронный и асинхронный. Синхронное уведомление основывается на вызове <xref:System.Diagnostics.Process.WaitForExit%2A>метода для приостановки обработки приложения до выхода из сопоставленного компонента.</xref:System.Diagnostics.Process.WaitForExit%2A> Асинхронное уведомление основывается на <xref:System.Diagnostics.Process.Exited>событий.</xref:System.Diagnostics.Process.Exited> При использовании асинхронного уведомления <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>должно быть присвоено `true` для <xref:System.Diagnostics.Process>компонент для получения уведомления, процесс завершен.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.EnableRaisingEvents%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_6_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_6_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_6_1.vb)]"
  syntax:
    content: public int ExitCode { get; }
    return:
      type: System.Int32
      description: "Код, который задал связанный процесс при завершении."
  overload: System.Diagnostics.Process.ExitCode*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс не был завершен.       - или - процесс <xref:System.Diagnostics.Process.Handle*>является недопустимым.</xref:System.Diagnostics.Process.Handle*>"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству ExitCode для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.Process.Exited
  id: Exited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Происходит при завершении процесса."
  remarks: "Событие Exited указывает, что завершения связанного процесса. Данное событие означает, что процесс прекращен (прерван) или успешно завершился. Это событие может возникать только в том случае, если значение <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>свойство `true`.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       Существует два способа уведомления о завершении связанного процесса: синхронный и асинхронный. Синхронное уведомление означает вызов <xref:System.Diagnostics.Process.WaitForExit%2A>метод блокирует текущий поток до завершения процесса.</xref:System.Diagnostics.Process.WaitForExit%2A> Асинхронное уведомление использует события завершил работу, что позволяет вызывающему потоку продолжить выполнение в то же время. В последнем случае <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>должно быть присвоено `true` для вызывающего приложения получать событие Exited.</xref:System.Diagnostics.Process.EnableRaisingEvents%2A>       При завершении работы процесса операционной системы он уведомляет все процессы, зарегистрированные обработчики события завершил работу. В настоящее время дескриптор процесса, который только что завершил работу можно использовать для доступа к некоторые свойства, такие как <xref:System.Diagnostics.Process.ExitTime%2A>и <xref:System.Diagnostics.Process.HasExited%2A>, операционная система поддерживает до полностью освобождает этот дескриптор.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.ExitTime%2A>      Настроек [!NOTE] настроек даже при наличии дескриптор завершенного процесса невозможно вызвать <xref:System.Diagnostics.Process.Start%2A>вновь для связи с тем же процессом.</xref:System.Diagnostics.Process.Start%2A> Вызов <xref:System.Diagnostics.Process.Start%2A>автоматически освобождает связанный процесс и подключается к процессу с того же файла, но совершенно новыми <xref:System.Diagnostics.Process.Handle%2A>.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.Start%2A>       Дополнительные сведения об использовании событий завершил работу в приложениях Windows Forms см. в разделе <xref:System.Diagnostics.Process.SynchronizingObject%2A>свойство.</xref:System.Diagnostics.Process.SynchronizingObject%2A>"
  example:
  - "The following code example creates a process that prints a file. It raises the Exited event when the process exits because the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property was set when the process was created. The Exited event handler displays process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_1_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/e-system.diagnostics.pro_1_1.cs)]"
  syntax:
    content: public event EventHandler Exited;
    return:
      type: System.EventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.ExitTime
  id: ExitTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает время завершения связанного процесса."
  remarks: "Если процесс не был завершен, при попытке получить свойство ExitTime создает исключение. Используйте <xref:System.Diagnostics.Process.HasExited%2A>перед получением свойства ExitTime, чтобы определить, является ли связанный процесс завершился.</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example creates a process that prints a file. The process raises the <xref:System.Diagnostics.Process.Exited> event when it exits, and the event handler displays the ExitTime property and other process information.  \n  \n [!code-vb[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_14_1.vb)]\n [!code-cs[System.Diagnostics.Process.EnableExited#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public DateTime ExitTime { get; }
    return:
      type: System.DateTime
      description: "Объект <xref:System.DateTime>, показывающий время связанного процесса.</xref:System.DateTime>"
  overload: System.Diagnostics.Process.ExitTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству ExitTime для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetCurrentProcess
  id: GetCurrentProcess
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает новый <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонента и связывает его с активного процесса."
  remarks: "Используйте этот метод для создания нового <xref:System.Diagnostics.Process>экземпляра и связать его с ресурсом процесса на локальном компьютере.</xref:System.Diagnostics.Process>       Как и подобные <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, и <xref:System.Diagnostics.Process.GetProcesses%2A>методы GetCurrentProcess связывает существующий ресурс с новым <xref:System.Diagnostics.Process>компонента.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> </xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetCurrentProcess ();
    parameters: []
    return:
      type: System.Diagnostics.Process
      description: "Новый <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонент, связанный с ресурсом процесса, на котором выполняется приложение."
  overload: System.Diagnostics.Process.GetCurrentProcess*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  id: GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает новый <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонента, заданному идентификатору процесса на локальном компьютере."
  remarks: "Используйте этот метод для создания нового <xref:System.Diagnostics.Process>компонента и связать его с ресурсом процесса на локальном компьютере.</xref:System.Diagnostics.Process> Ресурс процесса должен уже существовать на компьютере, так как GetProcessById не создает системного ресурса, а связывает ресурс с созданным приложением <xref:System.Diagnostics.Process>компонента.</xref:System.Diagnostics.Process> Процесс <xref:System.Diagnostics.Process.Id%2A>можно получить только для процесса, которая запущена на компьютере.</xref:System.Diagnostics.Process.Id%2A> После завершения процесса GetProcessById вызывает исключение, если передать его идентификатор с истекшим сроком действия.       На любом конкретном компьютере идентификатор процесса является уникальным. GetProcessById возвращает один процесс не более. Если вы хотите получить все процессы, выполняющие определенное приложение, используйте <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Если существует несколько процессов на компьютере, работающим с приложением указанного <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>возвращает массив, содержащий все связанные процессы.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Вы можете запрашивать каждый из этих процессов, в свою очередь по его идентификатору. Идентификатор процесса можно просмотреть в `Processes` панели диспетчера задач Windows. `PID` Столбец отображает идентификатор, присвоенный процессу."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_19_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_19_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_19_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId);
    parameters:
    - id: processId
      type: System.Int32
      description: "Уникальный в системе идентификатор ресурса процесса."
    return:
      type: System.Diagnostics.Process
      description: "Объект <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонент, связанный с локальным ресурсом процесса определяется <code> processId </code> параметра."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Процесс, указанный параметром <code> processId </code> не выполняется. Идентификатор может быть просрочен."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс не был запущен этим объектом."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  id: GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает новый <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонента, заданному идентификатору процесса и имени компьютера в сети."
  remarks: "Используйте этот метод для создания нового <xref:System.Diagnostics.Process>компонента и связать его с ресурсом процесса на удаленном компьютере в сети.</xref:System.Diagnostics.Process> Ресурс процесса должен уже существовать на указанном компьютере, так как GetProcessById не создает системного ресурса, а связывает ресурс с созданным приложением <xref:System.Diagnostics.Process>компонента.</xref:System.Diagnostics.Process> Процесс <xref:System.Diagnostics.Process.Id%2A>можно получить только для процесса, которая запущена на компьютере.</xref:System.Diagnostics.Process.Id%2A> После завершения процесса GetProcessById вызывает исключение, если передать его идентификатор с истекшим сроком действия.       На любом конкретном компьютере идентификатор процесса является уникальным. GetProcessById возвращает один процесс не более. Если вы хотите получить все процессы, выполняющие определенное приложение, используйте <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Если существует несколько процессов на компьютере, работающим с приложением указанного <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>возвращает массив, содержащий все связанные процессы.</xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> Вы можете запрашивать каждый из этих процессов, в свою очередь по его идентификатору. Идентификатор процесса можно просмотреть в `Processes` панели диспетчера задач Windows. `PID` Столбец отображает идентификатор, присвоенный процессу.       Если вы не укажете `machineName`, используется локальный компьютер. Кроме того, можно указать локальный компьютер, задав `machineName` значение «.» или пустая строка (»»)."
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_8_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_8_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_8_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process GetProcessById (int processId, string machineName);
    parameters:
    - id: processId
      type: System.Int32
      description: "Уникальный в системе идентификатор ресурса процесса."
    - id: machineName
      type: System.String
      description: "Имя компьютера в сети."
    return:
      type: System.Diagnostics.Process
      description: "Объект <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонент, связанный с удаленным ресурсом процесса определяется <code> processId </code> параметра."
  overload: System.Diagnostics.Process.GetProcessById*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Процесс, указанный параметром <code> processId </code> не выполняется. Идентификатор может быть просрочен.       - или - <code> machineName </code> недопустимый синтаксис параметра. Возможно, имя имеет нулевую длину (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс не был запущен этим объектом."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses
  id: GetProcesses
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Создает новый <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонент для каждого ресурса процесса на локальном компьютере."
  remarks: "Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process>компоненты и связать их со всеми ресурсами процесса на локальном компьютере.</xref:System.Diagnostics.Process> Ресурсы процесса уже должен существовать на локальном компьютере, так как GetProcesses создает системных ресурсов, а связывает ресурсы с сформированные <xref:System.Diagnostics.Process>компонентов.</xref:System.Diagnostics.Process> Так как операционная система сама выполняет фоновые процессы, этот массив никогда не пуст.       Если вы не хотите получить все процессы, запущенные на компьютере, их количество можно ограничить с помощью <xref:System.Diagnostics.Process.GetProcessById%2A>или <xref:System.Diagnostics.Process.GetProcessesByName%2A>метод.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>Создает <xref:System.Diagnostics.Process>компонент, связанный с процессом, определяется в системе, идентификатор процесса, который передается методу.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>Создает массив из <xref:System.Diagnostics.Process>компоненты которого связанные ресурсы используют исполняемый файл, передайте методу.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>      Настроек [!NOTE] настроек служб несколько окон могут загружаться в одном экземпляре процесса узла службы (svchost.exe). GetProcesses не определяет таких отдельных служб. для этого в разделе <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_15_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_15_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_15_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses ();
    parameters: []
    return:
      type: System.Diagnostics.Process[]
      description: "Массив объектов типа <xref href=&quot;System.Diagnostics.Process&quot;> </xref> , представляющий все ресурсы процесса, выполняющегося на локальном компьютере."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  id: GetProcesses(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Создает новый <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонент для каждого ресурса процесса на указанном компьютере."
  remarks: "Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process>компоненты и связать их со всеми ресурсами процесса на указанном компьютере (обычно удаленном).</xref:System.Diagnostics.Process> Ресурсы процесса уже должен существовать на локальном компьютере, так как <xref:System.Diagnostics.Process.GetProcesses%2A>создает системных ресурсов, а связывает ресурсы с сформированные <xref:System.Diagnostics.Process>компонентов.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A> Так как операционная система сама выполняет фоновые процессы, этот массив никогда не пуст.       Если вы не хотите получить все процессы, запущенные на компьютере, их количество можно ограничить с помощью <xref:System.Diagnostics.Process.GetProcessById%2A>или <xref:System.Diagnostics.Process.GetProcessesByName%2A>метод.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessById%2A>Создает <xref:System.Diagnostics.Process>компонент, связанный с процессом, определяется в системе, идентификатор процесса, который передается методу.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A> <xref:System.Diagnostics.Process.GetProcessesByName%2A>Создает массив из <xref:System.Diagnostics.Process>компоненты которого связанные ресурсы используют исполняемый файл, передайте методу.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessesByName%2A>       Эта перегрузка <xref:System.Diagnostics.Process.GetProcesses%2A>метод обычно используется для получения списка ресурсов процесса, выполняющегося на удаленном компьютере в сети, но можно указать локальный компьютер, передав «.».</xref:System.Diagnostics.Process.GetProcesses%2A>      Настроек [!NOTE] настроек служб несколько окон могут загружаться в одном экземпляре процесса узла службы (svchost.exe). GetProcesses не определяет таких отдельных служб. для этого в разделе <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</xref:System.ServiceProcess.ServiceController.GetServices%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_11_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_11_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcesses (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "Компьютер, из которого читается список процессов."
    return:
      type: System.Diagnostics.Process[]
      description: "Массив объектов типа <xref href=&quot;System.Diagnostics.Process&quot;> </xref> , представляющий все ресурсы процесса, выполняющегося на указанном компьютере."
  overload: System.Diagnostics.Process.GetProcesses*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code> Недопустимый синтаксис параметра. Он может иметь нулевую длину (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Операционная система не поддерживает эту операцию на удаленных компьютерах."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Существуют проблемы при доступе к счетчика производительности, которые используются API-Интерфейсы для получения сведений о процессе. Это исключение характерно для Windows NT, Windows 2000 и Windows XP."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ошибка доступа к базовому системному API."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  id: GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Создает массив из новых <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компоненты и связывает их со всеми ресурсами процесса на локальном компьютере, для которых имя указанного процесса."
  remarks: "Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process>компоненты и связать их со всеми ресурсами процесса, работающих под управлением того же исполняемого файла на локальном компьютере.</xref:System.Diagnostics.Process> Ресурсы процесса должны уже существовать на компьютере, так как GetProcessesByName не создает системных ресурсов, а связывает их с сформированные <xref:System.Diagnostics.Process>компонентов.</xref:System.Diagnostics.Process> Объект `processName` могут быть указаны для исполняемого файла, который в настоящий момент не выполняется на локальном компьютере, поэтому этот метод возвращает массив может быть пустым.       Имя процесса: понятное имя для процесса, например Outlook, который не поддерживает расширения .exe или путь. GetProcessesByName является полезным для получения и обработки всех процессов, которые связаны с тот же исполняемый файл. Например, можно передать имя исполняемого файла как `processName` параметр, чтобы завершить работу всех выполняющихся экземпляров этого исполняемого файла.       Хотя процесс <xref:System.Diagnostics.Process.Id%2A>является уникальным для одного ресурса процесса в системе, несколько процессов на локальном компьютере могут выполнять приложение, заданное параметром `processName` параметр.</xref:System.Diagnostics.Process.Id%2A> Таким образом <xref:System.Diagnostics.Process.GetProcessById%2A>не более возвращает один процесс Однако GetProcessesByName возвращает массив, содержащий все связанные процессы.</xref:System.Diagnostics.Process.GetProcessById%2A> Если необходимо работать с процессом, используя стандартные вызовы API, можно запросить каждый процесс по очереди по его идентификатору. Не удается доступ к ресурсам процесса процесса только через имя, но, получив массив <xref:System.Diagnostics.Process>компонентов, которые были связаны с ресурсами процесса, можно запустить, окончания и управлять ресурсами системы.</xref:System.Diagnostics.Process>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_6_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_6_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_6_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName);
    parameters:
    - id: processName
      type: System.String
      description: "Понятное имя процесса."
    return:
      type: System.Diagnostics.Process[]
      description: "Массив объектов типа <xref href=&quot;System.Diagnostics.Process&quot;> </xref> , представляющий ресурсы процесса, выполняющего указанное приложение или файл."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Существуют проблемы при доступе к счетчика производительности, которые используются API-Интерфейсы для получения сведений о процессе. Это исключение характерно для Windows NT, Windows 2000 и Windows XP."
  platform:
  - net462
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  id: GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Создает массив из новых <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компоненты и связывает их со всеми ресурсами процесса на удаленном компьютере, для которых имя указанного процесса."
  remarks: "Используйте этот метод для создания массива из новых <xref:System.Diagnostics.Process>компоненты и связать их со всеми ресурсами процесса, работающих под управлением того же исполняемого файла на указанном компьютере.</xref:System.Diagnostics.Process> Ресурсы процесса должны уже существовать на компьютере, так как <xref:System.Diagnostics.Process.GetProcessesByName%2A>создает системных ресурсов, а связывает их с сформированные <xref:System.Diagnostics.Process>компонентов.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcessesByName%2A> Объект `processName` могут быть указаны для исполняемого файла, который в настоящий момент не выполняется на локальном компьютере, поэтому этот метод возвращает массив может быть пустым.       Имя процесса: понятное имя для процесса, например Outlook, который не поддерживает расширения .exe или путь. <xref:System.Diagnostics.Process.GetProcessesByName%2A>полезно для получения и обработки всех процессов, которые связаны с тот же исполняемый файл.</xref:System.Diagnostics.Process.GetProcessesByName%2A> Например, можно передать имя исполняемого файла как `processName` параметр, чтобы завершить работу всех выполняющихся экземпляров этого исполняемого файла.       Хотя процесс <xref:System.Diagnostics.Process.Id%2A>является уникальным для одного ресурса процесса в системе, несколько процессов на локальном компьютере могут выполнять приложение, заданное параметром `processName` параметр.</xref:System.Diagnostics.Process.Id%2A> Таким образом <xref:System.Diagnostics.Process.GetProcessById%2A>возвращает не более одного процесса, но <xref:System.Diagnostics.Process.GetProcessesByName%2A>возвращает массив, содержащий все связанные процессы.</xref:System.Diagnostics.Process.GetProcessesByName%2A> </xref:System.Diagnostics.Process.GetProcessById%2A> Если необходимо работать с процессом, используя стандартные вызовы API, можно запросить каждый процесс по очереди по его идентификатору. Не удается доступ к ресурсам процесса процесса только через имя, но, получив массив <xref:System.Diagnostics.Process>компонентов, которые были связаны с ресурсами процесса, можно запустить, окончания и управлять ресурсами системы.</xref:System.Diagnostics.Process>       Можно использовать эту перегрузку для получения процессов на локальном компьютере, а также на удаленном компьютере. Используйте «.» для указания локального компьютера. Существует другая перегрузка, которая по умолчанию используется локальный компьютер.       Можно получить доступ к процессам на удаленных компьютерах только для просмотра сведений о процессах, например статистики. Невозможно закрыть, завершать (с помощью <xref:System.Diagnostics.Process.Kill%2A>), или запуск процессов на удаленных компьютерах.</xref:System.Diagnostics.Process.Kill%2A>"
  example:
  - "The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.  \n  \n [!code-cpp[Process.GetProcesses_noexception#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_14_1.cpp)]\n [!code-vb[Process.GetProcesses_noexception#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_14_1.vb)]\n [!code-cs[Process.GetProcesses_noexception#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_14_1.cs)]"
  syntax:
    content: public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);
    parameters:
    - id: processName
      type: System.String
      description: "Понятное имя процесса."
    - id: machineName
      type: System.String
      description: "Имя компьютера в сети."
    return:
      type: System.Diagnostics.Process[]
      description: "Массив объектов типа <xref href=&quot;System.Diagnostics.Process&quot;> </xref> , представляющий ресурсы процесса, выполняющего указанное приложение или файл."
  overload: System.Diagnostics.Process.GetProcessesByName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code> Недопустимый синтаксис параметра. Он может иметь нулевую длину (0)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>machineName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Операционная система не поддерживает эту операцию на удаленных компьютерах."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Существуют проблемы при доступе к счетчика производительности, которые используются API-Интерфейсы для получения сведений о процессе. Это исключение характерно для Windows NT, Windows 2000 и Windows XP."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Ошибка доступа к базовому системному API."
  platform:
  - net462
- uid: System.Diagnostics.Process.Handle
  id: Handle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает собственный дескриптор связанного процесса."
  remarks: "Приложение может получить дескриптор процесса, который может использоваться в качестве параметра для многих функций управления и обработки информации. Этот дескриптор можно использовать для инициализации <xref:System.Threading.WaitHandle>или вызова собственных методов с платформой неуправляемого кода.</xref:System.Threading.WaitHandle>       Дескриптор этого процесса является закрытым в приложение — другими словами, процессы, которые могут использоваться только маркеры. Процесс также имеет <xref:System.Diagnostics.Process.Id%2A>, в отличие от дескриптора, является уникальным и, следовательно, действителен во всей системе.</xref:System.Diagnostics.Process.Id%2A>       Только процессы, запущенные посредством вызова <xref:System.Diagnostics.Process.Start%2A>дескриптор свойства для соответствующего <xref:System.Diagnostics.Process>экземпляров.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A>"
  syntax:
    content: public IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "Дескриптор, который назначен процесса операционной системы при запуске процесса. Система использует этот дескриптор для хранения атрибутов процесса."
  overload: System.Diagnostics.Process.Handle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс не был запущен или был завершен. Не удалось прочитать свойство дескриптора, так как нет процессов, связанных с этим <xref href=&quot;System.Diagnostics.Process&quot;> </xref> экземпляра.       - или - <xref href=&quot;System.Diagnostics.Process&quot;> </xref> экземпляр был присоединен к выполняющемуся процессу, но нет необходимых разрешений для получения маркера с полными правами доступа."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству дескриптор для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.Process.HandleCount
  id: HandleCount
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает число дескрипторов, открытых процессом."
  remarks: "Дескрипторы предоставляют способ для процесса для ссылки на объекты. Процесс может получать дескрипторы файлов, ресурсов, очередей сообщений и многих других объектов операционной системы. Операционная система освобождает память, связанные с процессом только в том случае, когда число дескрипторов равно нулю."
  syntax:
    content: public int HandleCount { get; }
    return:
      type: System.Int32
      description: "Число дескрипторов операционной системы, открытых процессом."
  overload: System.Diagnostics.Process.HandleCount*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа — Windows 98 или Windows Millennium Edition (Windows Me); задать &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; свойства <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для доступа к этому свойству в Windows 98 и Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.HasExited
  id: HasExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает значение, определяющее завершение связанного процесса."
  remarks: "Значение `true` для HasExited указывает, что связанный процесс был завершен обычным способом или аварийно. Вы можете запросить или принудить связанный процесс завершиться вызовом <xref:System.Diagnostics.Process.CloseMainWindow%2A>или <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Если дескриптор открыт для процесса, операционная система освобождает память процесса, когда процесс был завершен, но сохраняет административную информацию о процессе, например дескриптор, код выхода и время выхода. Чтобы получить эти сведения, можно использовать <xref:System.Diagnostics.Process.ExitCode%2A>и <xref:System.Diagnostics.Process.ExitTime%2A>Свойства.</xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process.ExitCode%2A> Эти свойства заполняются автоматически для процессов, запущенных этим компонентом. Административная информация освобождается при всех <xref:System.Diagnostics.Process>компоненты, связанные с системным процессом, разрушены и больше не содержат дескрипторов завершенных процессов.</xref:System.Diagnostics.Process>       Процесс может завершиться независимо от кода. Если вы начали с помощью этого компонента, система обновляет значение HasExited автоматически, даже если связанный процесс завершается независимо друг от друга.      Настроек [!NOTE] настроек когда стандартный вывод был перенаправлен обработчикам асинхронных событий, это возможно, что обработка вывода не имеют завершена, когда это свойство возвращает `true`. Чтобы обеспечить завершение асинхронной обработки событий, вызовите <xref:System.Diagnostics.Process.WaitForExit>перегрузку, принимающую параметр отсутствует перед проверкой HasExited.</xref:System.Diagnostics.Process.WaitForExit>"
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_33_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_33_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_33_1.vb)]"
  syntax:
    content: public bool HasExited { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если процесс операционной системы, на который ссылается <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонент был завершен; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.HasExited*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Не существует процесса, связанного с объектом."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Не удалось получить код выхода для процесса."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству HasExited для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.Process.Id
  id: Id
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает уникальный идентификатор связанного процесса."
  remarks: "Процесс идентификатор не является допустимым, если связанный процесс не выполняется. Таким образом следует убедиться, что процесс выполняется до получения свойства Id. До завершения процесса, идентификатор процесса однозначно идентифицирует процесс во всей системе.       Можно связать процесс, на котором выполняется на локальном или удаленном компьютере в новую <xref:System.Diagnostics.Process>экземпляра, передавая идентификатор процесса для <xref:System.Diagnostics.Process.GetProcessById%2A>метод.</xref:System.Diagnostics.Process.GetProcessById%2A> </xref:System.Diagnostics.Process> <xref:System.Diagnostics.Process.GetProcessById%2A>— `static` метод, который создает новый компонент и задает свойство идентификатора для нового <xref:System.Diagnostics.Process>экземпляр автоматически.</xref:System.Diagnostics.Process></xref:System.Diagnostics.Process.GetProcessById%2A>       Идентификаторы процесса могут использоваться повторно в системе. Значение свойства идентификатор уникален только во время выполнения процесса. После завершения процесса система может заново использовать значение свойства идентификатора для несвязанного процесса.       Поскольку этот идентификатор уникален в системе, можно передать его в другие потоки, в качестве альтернативы для передачи <xref:System.Diagnostics.Process>экземпляра.</xref:System.Diagnostics.Process> Это действие может сэкономить ресурсы системы, но гарантирует, что правильно задан процесс."
  example:
  - "The following example demonstrates how to obtain the Id for all running instances of an application. The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the Id number to remove a specific instance.  \n  \n [!code-cs[System.Diagnostics.Process.Id#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_36_1.cs)]\n [!code-vb[System.Diagnostics.Process.Id#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_36_1.vb)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "Созданный системой уникальный идентификатор процесса, на который ссылается это <xref href=&quot;System.Diagnostics.Process&quot;> </xref> экземпляра."
  overload: System.Diagnostics.Process.Id*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Свойство идентификатора процесса не задано.       - или - никакие процессы, связанные с этим <xref href=&quot;System.Diagnostics.Process&quot;> </xref> объекта."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа — Windows 98 или Windows Millennium Edition (Windows Me); задать &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; свойства <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для доступа к этому свойству в Windows 98 и Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.Kill
  id: Kill
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Немедленно останавливает связанный процесс."
  remarks: "KILL принудительное завершение процесса, пока <xref:System.Diagnostics.Process.CloseMainWindow%2A>только запрашивает завершения.</xref:System.Diagnostics.Process.CloseMainWindow%2A> При выполнении процесса с графическим интерфейсом его цикл сообщений находится в состоянии ожидания. Цикл обработки сообщений выполняется каждый раз, посылает сообщение Windows для процесса операционной системой. Вызов <xref:System.Diagnostics.Process.CloseMainWindow%2A>отправляет запрос на закрытие главного окна, который закрывает дочерние окна и отменяет все выполняющиеся циклы сообщений для приложения в приложении правильного формата.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Запрос на завершение процесса путем вызова <xref:System.Diagnostics.Process.CloseMainWindow%2A>не вынуждает приложение, чтобы выйти из программы.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Приложение может запросить проверку пользователя перед завершением работы или она может отказаться закрыться. Чтобы принудительно завершить работу приложения, используйте метод Kill. Поведение <xref:System.Diagnostics.Process.CloseMainWindow%2A>идентична Закрыть главное окно приложения с помощью системного меню пользователь.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Таким образом запрос на завершение процесса закрытием главного окна не вынуждает приложение немедленно завершиться.      Настроек [!NOTE] настроек Kill метод выполняется асинхронно. После вызова метода завершения, вызовите <xref:System.Diagnostics.Process.WaitForExit%2A>метод для ожидания завершения выполнения или проверка процесса <xref:System.Diagnostics.Process.HasExited%2A>Свойства, чтобы определить, если процесс завершился.</xref:System.Diagnostics.Process.HasExited%2A> </xref:System.Diagnostics.Process.WaitForExit%2A>       Данные, изменять процессом или ресурсы, выделенные для процесса могут быть потеряны при вызове инструкции Kill. KILL приводит аварийного завершения процесса и должен использоваться только при необходимости. <xref:System.Diagnostics.Process.CloseMainWindow%2A>включает упорядоченной остановки процесса и закрывает все окна, поэтому рекомендуется для приложений с интерфейсом.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Если <xref:System.Diagnostics.Process.CloseMainWindow%2A>завершается ошибкой, можно использовать Kill для завершения процесса.</xref:System.Diagnostics.Process.CloseMainWindow%2A> KILL является единственным способом для завершения процессов, не имеющих графического интерфейса.       Вы можете вызвать Kill и <xref:System.Diagnostics.Process.CloseMainWindow%2A>только для процессов, запущенных на локальном компьютере.</xref:System.Diagnostics.Process.CloseMainWindow%2A> Не удается вызвать процессов на удаленных компьютерах, чтобы выйти из. Кроме того, могут только просматривать информацию для процессов, запущенных на удаленных компьютерах.      Настроек [!NOTE] настроек, если вызов метода Kill внесенные в настоящее время выполняется завершение процесса, <xref:System.ComponentModel.Win32Exception>выдается в случае доступ запрещен.</xref:System.ComponentModel.Win32Exception>"
  syntax:
    content: public void Kill ();
    parameters: []
  overload: System.Diagnostics.Process.Kill*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Не удалось завершить связанный процесс.       - или - процесс завершается.       - или - связанный процесс является исполняемым файлом Win16."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь вызвать метод Kill для процесса, запущенного на удаленном компьютере. Метод доступен только для процессов, запущенных на локальном компьютере."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Этот процесс уже завершился.       - или - никакие процессы, связанные с этим <xref href=&quot;System.Diagnostics.Process&quot;> </xref> объекта."
  platform:
  - net462
- uid: System.Diagnostics.Process.LeaveDebugMode
  id: LeaveDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Принимает <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонента из состояния, позволяющего ему взаимодействовать с процессами операционной системы, выполняющимся в специальном режиме."
  remarks: "Некоторые процессы операционной системы, выполняются в специальном режиме. Попытка чтения свойства или присоединения к процессам возможна только после вызова метода <xref:System.Diagnostics.Process.EnterDebugMode%2A>в компоненте.</xref:System.Diagnostics.Process.EnterDebugMode%2A> Вызов LeaveDebugMode вам больше не нужен доступ к процессам, выполняющимся в специальном режиме."
  syntax:
    content: public static void LeaveDebugMode ();
    parameters: []
  overload: System.Diagnostics.Process.LeaveDebugMode*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.MachineName
  id: MachineName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает имя компьютера, на котором выполняется связанный процесс."
  remarks: "Можно просмотреть статистические данные и сведения о процессе для процессов, запущенных на удаленном компьютере, но не может вызвать <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, или <xref:System.Diagnostics.Process.Kill%2A>на удаленных компьютерах.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> </xref:System.Diagnostics.Process.Start%2A>      Настроек [!NOTE] настроек при выполнении процесса на локальном компьютере это свойство возвращает точку (&quot;.») для имени компьютера. Следует использовать <xref:System.Environment.MachineName%2A?displayProperty=fullName>Свойства, чтобы получить имя компьютера правильно.</xref:System.Environment.MachineName%2A?displayProperty=fullName>"
  example:
  - "To use the following example you must first start at least one instance of Notepad on a remote computer. The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, and MachineName properties for each instance.  \n  \n [!code-cs[process_GetProcessesByName2_2#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_26_1.cs)]\n [!code-cpp[process_GetProcessesByName2_2#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_26_1.cpp)]\n [!code-vb[process_GetProcessesByName2_2#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_26_1.vb)]"
  syntax:
    content: public string MachineName { get; }
    return:
      type: System.String
      description: "Имя компьютера, на котором выполняется связанный процесс."
  overload: System.Diagnostics.Process.MachineName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Не существует процесса, связанного с этим <xref href=&quot;System.Diagnostics.Process&quot;> </xref> объекта."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainModule
  id: MainModule
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает главный модуль связанного процесса."
  remarks: "Модуль процесса представляет файл.dll или .exe, загруженный в определенный процесс. Свойство MainModule позволяет просматривать информацию об исполняемом файле, используемая для запуска процесса, включая имя модуля, имя файла и сведения о модуле памяти."
  syntax:
    content: public System.Diagnostics.ProcessModule MainModule { get; }
    return:
      type: System.Diagnostics.ProcessModule
      description: "<xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> , Использованный для запуска процесса."
  overload: System.Diagnostics.Process.MainModule*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству MainModule для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "32-разрядный процесс пытается получить доступ к модулям 64-разрядном процессе."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа — Windows 98 или Windows Millennium Edition (Windows Me); задать &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; для <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для доступа к этому свойству в Windows 98 и Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс <xref:System.Diagnostics.Process.Id*>недоступна.</xref:System.Diagnostics.Process.Id*>       - или - процесс завершился."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowHandle
  id: MainWindowHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает дескриптор главного окна связанного процесса."
  remarks: "Главное окно — это окно, открытых процессом в настоящий момент фокус ( <xref:System.Windows.Forms.Form.TopLevel%2A>формы).</xref:System.Windows.Forms.Form.TopLevel%2A> Необходимо использовать <xref:System.Diagnostics.Process.Refresh%2A>метод для обновления <xref:System.Diagnostics.Process>объекта, чтобы получить текущий дескриптор главного окна, если он был изменен.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A> Как правило, поскольку кэшируется дескриптор окна, используйте <xref:System.Diagnostics.Process.Refresh%2A>порт заранее, чтобы гарантировать, что можно будет получить текущий дескриптор.</xref:System.Diagnostics.Process.Refresh%2A>       Свойство MainWindowHandle можно получить только для процессов, запущенных на локальном компьютере. Свойство MainWindowHandle является значение, которое однозначно определяет окно, связанный с процессом.       Процесс имеет главное окно, связанное с ним только в том случае, если процесс имеет графический интерфейс. Если связанный процесс не имеет главного окна, MainWindowHandle значение равно нулю. Значение является ноль, для процессов, которые были скрыты, то есть, процессов, которые не отображаются на панели задач. Это может быть случай для процессов, которые отображаются в виде значков в области уведомлений в правой части панели задач.       Если вы только что запущен процесс и хотите использовать дескриптор главного окна, рассмотрите возможность использования <xref:System.Diagnostics.Process.WaitForInputIdle%2A>метод, который позволяет процессу завершить запуск, убедившись, что дескриптор главного окна был создан.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> В противном случае будет создано исключение."
  syntax:
    content: public IntPtr MainWindowHandle { get; }
    return:
      type: System.IntPtr
      description: "Созданный системой дескриптор главного окна связанного процесса."
  overload: System.Diagnostics.Process.MainWindowHandle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "MainWindowHandle не определен, так как процесс завершился."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству MainWindowHandle для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа — Windows 98 или Windows Millennium Edition (Windows Me); задать &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; для <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для доступа к этому свойству в Windows 98 и Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.MainWindowTitle
  id: MainWindowTitle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает заголовок главного окна процесса."
  remarks: "Процесс имеет главное окно, связанное с ним только в том случае, если процесс имеет графический интерфейс. Если связанный процесс не имеет главного окна (, чтобы <xref:System.Diagnostics.Process.MainWindowHandle%2A>равно нулю), MainWindowTitle — пустая строка (»»).</xref:System.Diagnostics.Process.MainWindowHandle%2A> Если вы только что запущен процесс и хотите использовать заголовок главного окна, рассмотрите возможность использования <xref:System.Diagnostics.Process.WaitForInputIdle%2A>метод, который позволяет процессу завершить запуск, убедившись, что дескриптор главного окна был создан.</xref:System.Diagnostics.Process.WaitForInputIdle%2A> В противном случае система создает исключение.      Настроек [!NOTE] настроек главное окно — окно, в данный момент имеет фокус; Обратите внимание, что это может быть основного окна для процесса. Необходимо использовать <xref:System.Diagnostics.Process.Refresh%2A>метод для обновления <xref:System.Diagnostics.Process>объекта, чтобы получить текущий дескриптор главного окна, если он был изменен.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Refresh%2A>"
  example:
  - "The following example starts an instance of Notepad and retrieves the caption of the main window of the process.  \n  \n [!code-cpp[process_MainWindowTitle#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_45_1.cpp)]\n [!code-cs[process_MainWindowTitle#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_45_1.cs)]\n [!code-vb[process_MainWindowTitle#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_45_1.vb)]"
  syntax:
    content: public string MainWindowTitle { get; }
    return:
      type: System.String
      description: "Заголовок главного окна процесса."
  overload: System.Diagnostics.Process.MainWindowTitle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Свойство MainWindowTitle не определен, так как процесс завершился."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству MainWindowTitle для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа — Windows 98 или Windows Millennium Edition (Windows Me); задать &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; для <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для доступа к этому свойству в Windows 98 и Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.MaxWorkingSet
  id: MaxWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает максимальный допустимый размер рабочего множества, в байтах для связанного процесса."
  remarks: "Рабочий набор процесса — набор страниц, доступных процессу в физической Оперативной памяти. Эти страницы находятся в памяти и доступны для приложения для использования без создания сбоя страницы.       Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые приложения, включая страницы в DLL-файлов и файлов system.dll. При увеличении размера рабочего набора, увеличивает объем памяти.       Процесс имеет минимальный и Максимальный рабочий набор размеров. Каждый раз при создании ресурса процесса, система резервирует объем памяти равен минимальному размеру рабочего набора процесса. Диспетчер виртуальной памяти пытается сохранить по крайней мере минимальный объем памяти резидентной, когда процесс активен, но никогда не хранит больше максимального размера.       Система задает размеры рабочего множества по умолчанию. Вы можете изменить эти размеры, используя MaxWorkingSet и <xref:System.Diagnostics.Process.MinWorkingSet%2A>члены.</xref:System.Diagnostics.Process.MinWorkingSet%2A> Однако задание этих значений не гарантирует, память будет зарезервированной или находящейся.      Настроек [!NOTE] настроек при увеличении размера рабочего множества процесса, можно воспользоваться физической памяти от остальной части системы. Убедитесь, не запрашивают размер минимального или максимального рабочего набора, в которой слишком велика, так как производительность системы может ухудшиться."
  syntax:
    content: public IntPtr MaxWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "Максимальный размер рабочего множества, допустимый в памяти для процесса, в байтах."
  overload: System.Diagnostics.Process.MaxWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Максимальный размер рабочего множества является недопустимым. Он должен быть больше или равен минимальному размеру рабочего набора."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Не удается получить сведения о рабочем множестве из ресурса связанного процесса.       - или - идентификатор процесса или дескриптор процесса равен нулю, так как процесс не запущен."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству MaxWorkingSet для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс <xref:System.Diagnostics.Process.Id*>недоступна.</xref:System.Diagnostics.Process.Id*>       - или - процесс завершился."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.MinWorkingSet
  id: MinWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает минимальный допустимый размер рабочего множества, в байтах для связанного процесса."
  remarks: "Рабочий набор процесса — набор страниц, доступных процессу в физической Оперативной памяти. Эти страницы находятся в памяти и доступны для приложения для использования без создания сбоя страницы.       Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые приложения, включая страницы в DLL-файлов и файлов system.dll. При увеличении размера рабочего набора, увеличивает объем памяти.       Процесс имеет минимальный и Максимальный рабочий набор размеров. Каждый раз при создании ресурса процесса, система резервирует объем памяти равен минимальному размеру рабочего набора процесса. Диспетчер виртуальной памяти пытается сохранить по крайней мере минимальный объем памяти резидентной, когда процесс активен, но никогда не хранит больше максимального размера.       Система задает размеры рабочего множества по умолчанию. Вы можете изменить эти размеры, используя <xref:System.Diagnostics.Process.MaxWorkingSet%2A>и члены MinWorkingSet.</xref:System.Diagnostics.Process.MaxWorkingSet%2A> Однако задание этих значений не гарантирует, память будет зарезервированной или находящейся.      Настроек [!NOTE] настроек при увеличении размера рабочего множества процесса, можно воспользоваться физической памяти от остальной части системы. Убедитесь, не запрашивают размер минимального или максимального рабочего набора, в которой слишком велика, так как производительность системы может ухудшиться."
  syntax:
    content: public IntPtr MinWorkingSet { get; set; }
    return:
      type: System.IntPtr
      description: "Минимальный размер рабочего множества, необходимые в памяти для процесса, в байтах."
  overload: System.Diagnostics.Process.MinWorkingSet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Минимальный размер рабочего множества является недопустимым. Он должен быть меньше или равно максимальному размеру рабочего набора."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Не удается получить сведения о рабочем множестве из ресурса связанного процесса.       - или - идентификатор процесса или дескриптор процесса равен нулю, так как процесс не запущен."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству MinWorkingSet для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс <xref:System.Diagnostics.Process.Id*>недоступна.</xref:System.Diagnostics.Process.Id*>       - или - процесс завершился."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.Modules
  id: Modules
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает модули, которые были загружены связанным процессом."
  remarks: "Модуль процесса представляет файл.dll или .exe, загруженный в определенный процесс. Объект <xref:System.Diagnostics.ProcessModule>экземпляра позволяет просматривать информацию о модуле, включая имя модуля, имя файла и сведения о модуле памяти.</xref:System.Diagnostics.ProcessModule>       Процесс можно загрузить несколько модулей в память. Например файлы .exe, которые загружают Дополнительные DLL-файлы имеют несколько модулей.       После запуска процесса, эта коллекция будет пустой, пока процесс загрузки системы. Если процесс имеет главное окно, можно вызвать <xref:System.Diagnostics.Process.WaitForInputIdle%2A>перед считыванием этого свойства, чтобы убедиться, что коллекция не пуста при получить список.</xref:System.Diagnostics.Process.WaitForInputIdle%2A>"
  syntax:
    content: public System.Diagnostics.ProcessModuleCollection Modules { get; }
    return:
      type: System.Diagnostics.ProcessModuleCollection
      description: "Массив объектов типа <xref href=&quot;System.Diagnostics.ProcessModule&quot;> </xref> , представляющий модули, которые были загружены связанным процессом."
  overload: System.Diagnostics.Process.Modules*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству модули для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс <xref:System.Diagnostics.Process.Id*>недоступна.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа — Windows 98 или Windows Millennium Edition (Windows Me); задать &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; для <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для доступа к этому свойству в Windows 98 и Windows Me."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Вы пытаетесь получить доступ к свойству модули для системы или бездействующего процесса. Эти процессы не имеют модулей."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  id: NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает объем невыгружаемой системной памяти в байтах, выделенной для связанного процесса."
  syntax:
    content: public int NonpagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "Объем памяти в байтах, выделенной системой для связанного процесса, которую нельзя записать в файл подкачки виртуальной памяти."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  id: NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает объем невыгружаемой системной памяти в байтах, выделенной для связанного процесса."
  remarks: "Значение, возвращаемое этим свойством, представляет текущий размер невыгружаемой системной памяти, используемой процессом, в байтах. Системной памяти — это физическая память, используемые операционной системой и состоит из выгружаемого и невыгружаемого пулы. Выделение памяти в невыгружаемом страничном остаются в системной памяти и не выгружаются в файл подкачки виртуальной памяти.       Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **байт в невыгружаемом страничном пуле** счетчика производительности для процесса."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_28_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_28_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_28_1.vb)]"
  syntax:
    content: public long NonpagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Объем системной памяти в байтах, выделенной для связанного процесса, которую нельзя записать в файл подкачки виртуальной памяти."
  overload: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.OnExited
  id: OnExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Вызывает <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> событий."
  remarks: "OnExited является методом API, который вызывает <xref:System.Diagnostics.Process.Exited>событий.</xref:System.Diagnostics.Process.Exited> Вызов OnExited заставляет <xref:System.Diagnostics.Process.Exited>возникновения события и является единственным способом для вызова событий, используя <xref:System.Diagnostics.Process>компонента.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Exited> OnExited используется главным образом при создании производных классов из компонента.       В качестве альтернативы OnExited можно написать собственный обработчик событий. Создание собственных делегата обработчика событий и собственного метода обработки событий.      Настроек [!NOTE] настроек при использовании среды Visual Studio делегата обработчика событий (AddOnExited) и метод обработки событий (Process1_Exited) создаются автоматически при перетаскивании <xref:System.Diagnostics.Process>компонента на форму и дважды щелкните значок.</xref:System.Diagnostics.Process> Создаваемый код, необходимо выполнить после <xref:System.Diagnostics.Process.Exited>событием вводится в процедуру Process1_Exited.</xref:System.Diagnostics.Process.Exited> Не нужно создать элемент OnExited, так как она реализована для вас.       При возникновении события вызывается обработчик события в делегате. Общие сведения см. в разделе [события](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to use the OnExited method in a derived class.  \n  \n [!code-cs[OnExitSample#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_9_1.cs)]\n [!code-vb[OnExitSample#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_9_1.vb)]"
  syntax:
    content: protected void OnExited ();
    parameters: []
  overload: System.Diagnostics.Process.OnExited*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.OutputDataReceived
  id: OutputDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Происходит каждый раз, когда приложение записывает строку в свой перенаправленный <xref:System.Diagnostics.Process.StandardOutput*>потока.</xref:System.Diagnostics.Process.StandardOutput*>"
  remarks: "Указывает, что событие OutputDataReceived связанного <xref:System.Diagnostics.Process>записал строки, завершается символом перевода строки в свой перенаправленный <xref:System.Diagnostics.Process.StandardOutput%2A>потока.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Событие включается во время операции асинхронного чтения <xref:System.Diagnostics.Process.StandardOutput%2A>.</xref:System.Diagnostics.Process.StandardOutput%2A> Запуск асинхронных операций чтения, необходимо перенаправить <xref:System.Diagnostics.Process.StandardOutput%2A>поток <xref:System.Diagnostics.Process>, добавьте обработчик событий к событию OutputDataReceived и вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardOutput%2A> После этого OutputDataReceived сигналы событие каждый раз процесс записывает строку в перенаправленный <xref:System.Diagnostics.Process.StandardOutput%2A>поток, пока существует процесс или вызовы <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</xref:System.Diagnostics.Process.CancelOutputRead%2A> </xref:System.Diagnostics.Process.StandardOutput%2A>      Настроек [!NOTE] настроек приложения, которое обрабатывает асинхронный выход должен вызывать <xref:System.Diagnostics.Process.WaitForExit%2A>метод, чтобы гарантировать записан выходной буфер.</xref:System.Diagnostics.Process.WaitForExit%2A>"
  example:
  - "The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `ipconfig` command.  \n  \n The example creates an event delegate for the `OutputHandler` event handler and associates it with the OutputDataReceived event. The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and saves it in an output string that’s later shown in the example’s console window.  \n  \n [!code-cpp[Process_AsyncStreams#4](~/add/codesnippet/cpp/e-system.diagnostics.pro_2_1.cpp)]\n [!code-cs[Process_AsyncStreams#4](~/add/codesnippet/csharp/e-system.diagnostics.pro_2_1.cs)]\n [!code-vb[Process_AsyncStreams#4](~/add/codesnippet/visualbasic/e-system.diagnostics.pro_2_1.vb)]"
  syntax:
    content: public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;
    return:
      type: System.Diagnostics.DataReceivedEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize
  id: PagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает объем выгружаемой системной памяти в байтах, выделенной для связанного процесса."
  syntax:
    content: public int PagedMemorySize { get; }
    return:
      type: System.Int32
      description: "Объем памяти в байтах, выделенной связанным процессом, который можно записать в файл подкачки виртуальной памяти."
  overload: System.Diagnostics.Process.PagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedMemorySize64
  id: PagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает объем выгружаемой системной памяти в байтах, выделенной для связанного процесса."
  remarks: "Значение, возвращаемое этим свойством, представляет текущий размер памяти в файле подкачки виртуальной памяти, используемой процессом, в байтах. Операционная система использует файл подкачки виртуальной памяти в сочетании с физической памяти для управления виртуального адресного пространства для каждого процесса. Не используется выгружаемой памяти, могут передаваться в файл подкачки виртуальной памяти на диске. Чтобы получить объем памяти, используемой операционной системы для процесса, используйте <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>свойство.</xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>       Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **байт файла подкачки** счетчика производительности для процесса."
  example:
  - "The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public long PagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Объем памяти в байтах, выделенной в файле подкачки виртуальной памяти для связанного процесса."
  overload: System.Diagnostics.Process.PagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  id: PagedSystemMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает объем выгружаемой системной памяти в байтах, выделенной для связанного процесса."
  syntax:
    content: public int PagedSystemMemorySize { get; }
    return:
      type: System.Int32
      description: "Объем памяти в байтах, выделенной системой для связанного процесса, который можно записать в файл подкачки виртуальной памяти."
  overload: System.Diagnostics.Process.PagedSystemMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  id: PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает объем выгружаемой системной памяти в байтах, выделенной для связанного процесса."
  remarks: "Значение, возвращаемое значение этого свойства представляет текущий размер выгружаемой системной памяти, используемой процессом, в байтах. Системной памяти — это физическая память, используемые операционной системой и состоит из выгружаемого и невыгружаемого пулы. Не используется выгружаемой памяти, могут передаваться в файл подкачки виртуальной памяти на диске. Чтобы получить объем памяти приложения, используемой процессом, используйте <xref:System.Diagnostics.Process.PagedMemorySize64%2A>свойство.</xref:System.Diagnostics.Process.PagedMemorySize64%2A>       Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **байт в выгружаемом страничном пуле** счетчика производительности для процесса."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_18_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_18_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_18_1.vb)]"
  syntax:
    content: public long PagedSystemMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Объем системной памяти в байтах, выделенной для связанного процесса, который можно записать в файл подкачки виртуальной памяти."
  overload: System.Diagnostics.Process.PagedSystemMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  id: PeakPagedMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает максимальный объем памяти в файле подкачки виртуальной памяти в байтах, используемой связанным процессом."
  syntax:
    content: public int PeakPagedMemorySize { get; }
    return:
      type: System.Int32
      description: "Максимальный объем памяти в байтах, выделенной связанным процессом, который можно записать в файл подкачки виртуальной памяти."
  overload: System.Diagnostics.Process.PeakPagedMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  id: PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает максимальный объем памяти в файле подкачки виртуальной памяти в байтах, используемой связанным процессом."
  remarks: "Значение, возвращаемое значение этого свойства представляет максимальный размер памяти в файле подкачки виртуальной памяти, используемой процессом с момента его запуска, в байтах. Операционная система использует файл подкачки виртуальной памяти в сочетании с физической памяти для управления виртуального адресного пространства для каждого процесса. Не используется выгружаемой памяти, могут передаваться в файл подкачки виртуальной памяти на диске.       Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **байт файла подкачки (пик)** счетчика производительности для процесса."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_24_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_24_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_24_1.vb)]"
  syntax:
    content: public long PeakPagedMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Максимальный объем памяти в байтах, выделенной в файле подкачки виртуальной памяти для связанного процесса с момента его запуска."
  overload: System.Diagnostics.Process.PeakPagedMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  id: PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает максимальный объем виртуальной памяти в байтах, используемой связанным процессом."
  syntax:
    content: public int PeakVirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "Максимальный объем виртуальной памяти в байтах, запрошенной связанным процессом."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  id: PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает максимальный объем виртуальной памяти в байтах, используемой связанным процессом."
  remarks: "Значение, возвращаемое этим свойством представляет максимальный объем виртуальной памяти, используемой процессом с момента его запуска, в байтах. Операционная система сопоставляет виртуального адресного пространства для каждого процесса, либо на страницы загрузки в физическую память или со страницами, сохраненными в файле подкачки виртуальной памяти на диске.       Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **виртуальных байт (пик)** счетчика производительности для процесса."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_23_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_23_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_23_1.vb)]"
  syntax:
    content: public long PeakVirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Максимальный объем виртуальной памяти в байтах, выделенной для связанного процесса с момента его запуска."
  overload: System.Diagnostics.Process.PeakVirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet
  id: PeakWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает максимальный размер рабочего множества для связанного процесса в байтах."
  remarks: "Рабочий набор процесса — набор страниц, доступных процессу в физической Оперативной памяти. Эти страницы находятся в памяти и доступны для приложения для использования без создания сбоя страницы.       Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая модули процессов и библиотеки системы."
  syntax:
    content: public int PeakWorkingSet { get; }
    return:
      type: System.Int32
      description: "Максимальный объем физической памяти, запрошенной связанным процессом в байтах."
  overload: System.Diagnostics.Process.PeakWorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.PeakWorkingSet64
  id: PeakWorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает максимальный объем физической памяти в байтах, используемой связанным процессом."
  remarks: "Значение, возвращаемое этим свойством представляет максимальный размер памяти рабочего множества, используемой процессом с момента его запуска, в байтах. Рабочий набор процесса — набор страниц, доступных процессу в физической Оперативной памяти. Эти страницы находятся в памяти и доступны для приложения для использования без создания сбоя страницы.       Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая инструкции из модулей процесса и библиотеки системы.       Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **рабочий набор (пик)** счетчика производительности для процесса."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_34_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_34_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_34_1.vb)]"
  syntax:
    content: public long PeakWorkingSet64 { get; }
    return:
      type: System.Int64
      description: "Максимальный объем физической памяти в байтах, выделенной для связанного процесса с момента его запуска."
  overload: System.Diagnostics.Process.PeakWorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  id: PriorityBoostEnabled
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает значение, указывающее, является ли приоритет связанного процесса временно быть увеличить операционной системой, если фокус находится на главном окне."
  remarks: "Если поток выполняется в процессе, для которого класс приоритета имеет одно из значений перечисления динамического приоритета (<xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, или <xref:System.Diagnostics.ProcessPriorityClass>), система временно увеличивает приоритет потока, когда он берется из состояния ожидания.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> Это действие предотвращает прерывание выполнения текущего потока другими процессами. Установка PriorityBoostEnabled затрагивает все существующие потоки и каких-либо потоков, создаваемых в последующем процессом. Чтобы восстановить нормальное поведение, задайте свойство PriorityBoostEnabled `false`.      Настроек [!NOTE] настроек повышение приоритета слишком высокого приоритета может лишить ресурсов может вызвать операционную систему и сетевые функции, вызывающих проблемы с другими задачами операционной системы."
  syntax:
    content: public bool PriorityBoostEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если требуется динамическое увеличение приоритета процесса приоритета для процесса выбирается из состояния ожидания; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.PriorityBoostEnabled*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Не удается получить информацию о повышении приоритета из ресурса связанного процесса."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство.       - или - идентификатор процесса или дескриптор процесса равен нулю. (Процесс не был запущен.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству PriorityBoostEnabled для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс <xref:System.Diagnostics.Process.Id*>недоступна.</xref:System.Diagnostics.Process.Id*>"
  platform:
  - net462
- uid: System.Diagnostics.Process.PriorityClass
  id: PriorityClass
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает общую категорию приоритета для связанного процесса."
  remarks: "Класс приоритета процесса включает диапазон уровней приоритета потоков. Потоки с различными приоритетами, которые выполняются в процессе запуска относительно класс приоритета процесса. Win32 использует четыре класса приоритетов с семью основными уровнями приоритета каждого класса. Эти классы приоритета процесса, сохраняются в <xref:System.Diagnostics.ProcessPriorityClass>приоритета процесса значение перечисления, который позволяет <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, или <xref:System.Diagnostics.ProcessPriorityClass>.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> На основе времени, затраченного или других показателях, базовый уровень приоритета можно изменить в операционной системе, если процесс должен поместить впереди других для доступа к процессору. Кроме того, можно задать <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>для временного увеличения уровня приоритета потоков, взятых из состояния ожидания.</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Приоритет сбрасывается при возвращении процесса в состояние ожидания.       <xref:System.Diagnostics.Process.BasePriority%2A>Позволяет посмотреть стартовый приоритет, присвоенный процессу.</xref:System.Diagnostics.Process.BasePriority%2A> Однако, так как он доступен только для чтения, его нельзя использовать <xref:System.Diagnostics.Process.BasePriority%2A>свойство для задания приоритета процесса.</xref:System.Diagnostics.Process.BasePriority%2A> Чтобы изменить приоритет, используйте свойство PriorityClass, которое возвращает или задает общую категорию приоритета для процесса.       Класс приоритета нельзя просмотреть с помощью системного монитора. В следующей таблице показаны связи между <xref:System.Diagnostics.Process.BasePriority%2A>и значения PriorityClass.</xref:System.Diagnostics.Process.BasePriority%2A>      | BasePriority | PriorityClass |   |------------------|-------------------|   |&4; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&8; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&13; | <xref:System.Diagnostics.ProcessPriorityClass>|   |&24; | <xref:System.Diagnostics.ProcessPriorityClass>|</xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass></xref:System.Diagnostics.ProcessPriorityClass>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_29_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_29_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_29_1.vb)]"
  syntax:
    content: public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }
    return:
      type: System.Diagnostics.ProcessPriorityClass
      description: "Категория приоритета для связанного процесса, из которой <xref:System.Diagnostics.Process.BasePriority*>процесса рассчитывается.</xref:System.Diagnostics.Process.BasePriority*>"
  overload: System.Diagnostics.Process.PriorityClass*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Сведения о приоритете процесса не может быть задана или получена из ресурса связанного процесса.       - или - идентификатор процесса или дескриптор процесса равен нулю. (Процесс не был запущен.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству PriorityClass процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс <xref:System.Diagnostics.Process.Id*>недоступна.</xref:System.Diagnostics.Process.Id*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Установлено в качестве PriorityClass <xref uid=&quot;langword_csharp_AboveNormal&quot; name=&quot;AboveNormal&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_BelowNormal&quot; name=&quot;BelowNormal&quot; href=&quot;&quot;> </xref> при использовании Windows 98 или Windows Millennium Edition (Windows Me). Эти платформы не поддерживают эти значения для класса приоритета."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "Класс приоритета невозможно задать, поскольку он не использует допустимое значение, как определено в <xref href=&quot;System.Diagnostics.ProcessPriorityClass&quot;> </xref> перечисления."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize
  id: PrivateMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает объем закрытой системной памяти в байтах, выделенной для связанного процесса."
  syntax:
    content: public int PrivateMemorySize { get; }
    return:
      type: System.Int32
      description: "Число байтов, выделенных связанным процессом, который нельзя использовать совместно с другими процессами."
  overload: System.Diagnostics.Process.PrivateMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivateMemorySize64
  id: PrivateMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает объем закрытой системной памяти в байтах, выделенной для связанного процесса."
  remarks: "Значение, возвращаемое этим свойством, представляет текущий размер памяти, используемой процессом, в байтах, который не может совместно использоваться другими процессами.       Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **байт исключительного пользования** счетчика производительности для процесса."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_17_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_17_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_17_1.vb)]"
  syntax:
    content: public long PrivateMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Объем памяти в байтах, выделенной для связанного процесса, который нельзя использовать совместно с другими процессами."
  overload: System.Diagnostics.Process.PrivateMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  id: PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает время привилегированных процессора для этого процесса."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_37_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_37_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_37_1.vb)]"
  syntax:
    content: public TimeSpan PrivilegedProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Объект <xref:System.TimeSpan>, показывающий количество времени, которое процесс потратил на выполнение кода внутри ядра операционной системы.</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.PrivilegedProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству PrivilegedProcessorTime для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessName
  id: ProcessName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает имя процесса."
  remarks: "Свойство ProcessName содержит имя исполняемого файла, например Outlook, который не поддерживает расширения .exe или путь. Это полезно для получения и обработки всех процессов, которые связаны с тот же исполняемый файл.      Настроек [!NOTE] настроек на [!INCLUDE[Win2kFamily](~/add/includes/win2kfamily-md.md)] операционные системы, свойства ProcessName может быть усечено до 15 символов, если не удается получить сведения о процессе модуля.       Можно вызвать <xref:System.Diagnostics.Process.GetProcessesByName%2A>, передавая ему имя исполняемого файла, для получения массива, содержащего каждый выполняющийся экземпляр на указанном компьютере.</xref:System.Diagnostics.Process.GetProcessesByName%2A> Можно использовать этот массив, например, завершить работу всех выполняющихся экземпляров исполняемого файла."
  syntax:
    content: public string ProcessName { get; }
    return:
      type: System.String
      description: "Имя, которое использует система для идентификации процесса для пользователя."
  overload: System.Diagnostics.Process.ProcessName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс не имеет идентификатора, или нет процесса, связанного с <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.       - или - связанный процесс завершился."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа — Windows 98 или Windows Millennium Edition (Windows Me); задать &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; для <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для доступа к этому свойству в Windows 98 и Windows Me."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Процесс не существует на этом компьютере."
  platform:
  - net462
- uid: System.Diagnostics.Process.ProcessorAffinity
  id: ProcessorAffinity
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает процессоры, на которых этот процесс может быть запланировано выполнение потоков."
  remarks: "В Windows 2000 и более поздних версиях поток в процессе может перемещаться с процессора на процессор, с каждым перемещением обновление кэша процессора. При больших системных нагрузках Указание определенного процессора для обработки определенного потока может повысить производительность за счет сокращения числа перезагрузок кэша процессора. Связь между процессор и поток называется соответствием процессоров.       Каждый процессор представляется как бит. Бит 0 — это первый процессор, 1-й бит — второй процессор и т. д. Если бит устанавливается в значение 1, соответствующий процессор будет выбран для назначения потоков. При установке параметру нулевое значение ProcessorAffinity, алгоритмы планирования операционной системы задается схожесть потоков. Если значение ProcessorAffinity задано любое ненулевое значение, значение интерпретируется как битовую маску, определяющую процессоры, годные для выбора.       В следующей таблице показаны выбора значений ProcessorAffinity восемью процессорами системы.      | Битовая маска | Двоичное значение | Подходящие процессоры |   |-------------|------------------|-------------------------|   | 0x0001 | 00000000 00000001 | 1 |   | 0x0003 | 00000000 00000011 | 1 и 2 |   | 0x0007 | 00000000 00000111 | 1, 2 и 3 |   | 0x0009 | 00000000 00001001 | 1 и 4 |   | 0x007F | 00000000 01111111 | 1, 2, 3, 4, 5, 6 и 7 |"
  syntax:
    content: public IntPtr ProcessorAffinity { get; set; }
    return:
      type: System.IntPtr
      description: "Битовая маска, представляющая процессоры, которые могут выполняться потоки связанного процесса. Значение по умолчанию зависит от количества процессоров на компьютере. Значение по умолчанию — 2 <sup>n</sup> -1, где n — число процессоров."
  overload: System.Diagnostics.Process.ProcessorAffinity*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Сведения ProcessorAffinity не может быть задана или получена из ресурса связанного процесса.       - или - идентификатор процесса или дескриптор процесса равен нулю. (Процесс не был запущен.)"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству ProcessorAffinity для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс <xref:System.Diagnostics.Process.Id*>недоступен.</xref:System.Diagnostics.Process.Id*>       - или - процесс завершился."
  platform:
  - net462
- uid: System.Diagnostics.Process.Refresh
  id: Refresh
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Удаляет любые сведения о связанном процессе кэшированные внутри компонента процесса."
  remarks: "После обновления первого запроса для получения сведений о каждом свойстве компонент процесса получает новое значение из связанного процесса.       При <xref:System.Diagnostics.Process>компонента связан с ресурсом процесса, значения свойств <xref:System.Diagnostics.Process>немедленно заполняются по состоянию процесса.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> Если сведения о связанном процессе впоследствии изменяется, эти изменения не отражаются в <xref:System.Diagnostics.Process>компонента кэшированные значения.</xref:System.Diagnostics.Process> <xref:System.Diagnostics.Process>Компонент является моментальным снимком ресурса процесса на момент они связаны.</xref:System.Diagnostics.Process> Чтобы просмотреть текущие значения для связанного процесса, вызовите метод обновления."
  example:
  - "The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.  \n  \n [!code-cpp[process_refresh#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_1_1.cpp)]\n [!code-cs[process_refresh#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_1_1.cs)]\n [!code-vb[process_refresh#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_1_1.vb)]"
  syntax:
    content: public void Refresh ();
    parameters: []
  overload: System.Diagnostics.Process.Refresh*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Responding
  id: Responding
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает значение, указывающее, отвечает или нет пользовательский интерфейс процесса."
  remarks: "Если процесс имеет пользовательский интерфейс, свойство Responding обращается пользовательский интерфейс, чтобы определить, отвечает ли процесс на ввод данных пользователем. Если интерфейс не отвечает немедленно, это свойство возвращает отвечает `false`. Используйте это свойство, чтобы определить, является ли интерфейс связанного процесса перестал отвечать на запросы.       Если процесс не имеет <xref:System.Diagnostics.Process.MainWindowHandle%2A>, это свойство возвращает `true`.</xref:System.Diagnostics.Process.MainWindowHandle%2A>"
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_39_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_39_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_39_1.vb)]"
  syntax:
    content: public bool Responding { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если пользовательский интерфейс связанного процесса отвечает системе; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.Responding*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа — Windows 98 или Windows Millennium Edition (Windows Me); задать &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; для <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для доступа к этому свойству в Windows 98 и Windows Me."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Не существует процесса, связанного с этим <xref href=&quot;System.Diagnostics.Process&quot;> </xref> объекта."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству Responding для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.Process.SafeHandle
  id: SafeHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает собственный дескриптор этого процесса."
  remarks: "Дескриптор доступен только в том случае, если вызывающий компонент запущен процесс."
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeProcessHandle
      description: "Собственный дескриптор этого процесса."
  overload: System.Diagnostics.Process.SafeHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.SessionId
  id: SessionId
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает идентификатор сеанса служба терминалов для связанного процесса."
  remarks: "Свойство SessionId указывает сеанс, в котором выполняется приложение."
  syntax:
    content: public int SessionId { get; }
    return:
      type: System.Int32
      description: "Идентификатор сеанса служба терминалов для связанного процесса."
  overload: System.Diagnostics.Process.SessionId*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "Нет сеанса, связанный с этим процессом."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Не существует процесса, связанного с этим идентификатором сеанса.       - или - на этом компьютере нет связанного процесса."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Свойство SessionId не поддерживается в Windows 98."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardError
  id: StandardError
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает поток, используемый для чтения вывода ошибок приложения."
  remarks: "Когда <xref:System.Diagnostics.Process>записывает текст в его стандартный поток ошибок, что текст обычно отображается на консоли.</xref:System.Diagnostics.Process> Путем перенаправления поток StandardError, можно управлять или подавлять вывод ошибок процесса. Например можно фильтровать текст, отформатировать его по-разному или записать выходные данные в консоль и назначенный файл журнала.      Настроек [!NOTE] настроек для использования StandardError, необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>для `false`, и необходимо задать <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName>для `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> В противном случае чтение из потока StandardError вызывает исключение.       Перенаправленный поток StandardError могут считываться синхронно или асинхронно. Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A>синхронной операции чтения в поток вывода ошибок в процессе выполнения.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Эти синхронного чтения операций не завершены, пока не связанный с ним <xref:System.Diagnostics.Process>записывает его поток StandardError или закрывает поток.</xref:System.Diagnostics.Process>       Напротив <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>запуска асинхронной операции считывания в поток StandardError.</xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Этот метод включает назначенный обработчик событий для выходного потока и немедленно возвращается вызывающему объекту, который может выполнять другую работу, пока вывод потока направлен обработчику событий.       Синхронные операции чтения устанавливают зависимость между считыванием вызывающего оператора из поток StandardError и записи в поток дочерний процесс. Эти зависимости может привести к условиям взаимоблокировки. Если вызывающий объект считывает из перенаправленного потока дочернего процесса, он зависит от дочернего. Вызывающий объект ожидает операции считывания дочерний элемент записывает в поток или закрывает поток. Если дочерний процесс записывает достаточно данных для заполнения своего перенаправленного потока, он зависит от родительского. Дочерний процесс ожидает следующей операции записи, пока родительский элемент считывает из полного потока или закрывает поток. Взаимоблокировка возникает, когда вызывающий объект и дочерний процесс ожидают друг друга для завершения операции, и не может происходить. Взаимоблокировок можно избежать, оценивая зависимости между вызывающим объектом и дочерним процессом.       Например, следующий код C#, показано, как считывание из перенаправленного потока и ожидание завершения дочернего процесса.      ```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```В примере кода позволяет избежать состояния взаимоблокировки, вызвав `p.StandardError.ReadToEnd` перед `p.WaitForExit`. Условие взаимоблокировки могут случиться, если родительский процесс вызывает `p.WaitForExit` перед `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения перенаправленного потока. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса. Дочерний процесс неограниченно долго будет ожидать родительским для чтения из полный поток StandardError.       Нет аналогичная проблема возникает при считывании всего текста из стандартный выход и Стандартная ошибка потоков. Например, следующий код C#, выполняет операции чтения в обоих потоках.      ```   // Do not perform a synchronous read to the end of both    // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```В примере кода позволяет избежать состояния взаимоблокировки, выполняя асинхронные операции чтения на <xref:System.Diagnostics.Process.StandardOutput%2A>потока.</xref:System.Diagnostics.Process.StandardOutput%2A> Условие взаимоблокировки возникает, если родительский процесс вызывает `p.StandardOutput.ReadToEnd` следуют `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения его поток сообщений об ошибках. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса его <xref:System.Diagnostics.Process.StandardOutput%2A>потока.</xref:System.Diagnostics.Process.StandardOutput%2A> Дочерний процесс неограниченно долго будет ожидать родительским для чтения из полный поток StandardError.       Чтобы избежать этих зависимостей возможных взаимоблокировок можно использовать операции асинхронного чтения. Кроме того можно избежать состояния взаимоблокировки путем создания двух потоков и считывания выходных данных каждого потока в отдельном потоке.      Настроек [!NOTE] настроек нельзя смешивать асинхронная и синхронная операции чтения в перенаправленном потоке. Один раз перенаправленный поток <xref:System.Diagnostics.Process>открывается в режиме синхронной или асинхронной, все дополнительные чтения операции в этом потоке должны быть в том же режиме.</xref:System.Diagnostics.Process> Например, не выполняйте <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>вызовом <xref:System.IO.StreamReader.ReadLine%2A>на поток StandardError или наоборот.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Однако можно считать два различных потоков в различных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>и затем вызвать метод <xref:System.IO.StreamReader.ReadLine%2A>для поток StandardError.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example uses the `net use` command together with a user supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.  \n  \n [!code-cs[Process_StandardError#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_41_1.cs)]\n [!code-cpp[Process_StandardError#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_41_1.cpp)]\n [!code-vb[Process_StandardError#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_41_1.vb)]"
  syntax:
    content: public System.IO.StreamReader StandardError { get; }
    return:
      type: System.IO.StreamReader
      description: "Объект <xref:System.IO.StreamReader>может использоваться для чтения стандартного потока ошибок приложения.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardError*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardError stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardError stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginErrorReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardInput
  id: StandardInput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает поток, используемый для записи ввода приложения."
  remarks: "Объект <xref:System.Diagnostics.Process>может считывать введенный текст из его стандартный входной поток, обычно это клавиатурный.</xref:System.Diagnostics.Process> Перенаправление потока StandardInput, можно программно указать входные данные. Например вместо ввода с клавиатуры, чтобы обеспечить текст из содержимого назначенного файла или выходных данных другого приложения.      Настроек [!NOTE] настроек для использования StandardInput, необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>для `false`, и необходимо задать <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName>для `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> В противном случае запись в StandardInput поток вызывает исключение."
  example:
  - "The following example illustrates how to redirect the StandardInput stream of a process. The example starts the `sort` command with redirected input. It then prompts the user for text, and passes that to the `sort` process by means of the redirected StandardInput stream. The `sort` results are displayed to the user on the console.  \n  \n [!code-cs[Process_StandardInput#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_0_1.cs)]\n [!code-cpp[Process_StandardInput#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_0_1.cpp)]\n [!code-vb[Process_StandardInput#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_0_1.vb)]"
  syntax:
    content: public System.IO.StreamWriter StandardInput { get; }
    return:
      type: System.IO.StreamWriter
      description: "Объект <xref:System.IO.StreamWriter>может использоваться для записи стандартного входного потока приложения.</xref:System.IO.StreamWriter>"
  overload: System.Diagnostics.Process.StandardInput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Так как не был определен в поток StandardInput &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt; равно <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StandardOutput
  id: StandardOutput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает поток, используемый для чтения текстовых выходных данных приложения."
  remarks: "Когда <xref:System.Diagnostics.Process>записывает текст в его стандартный поток, что текст обычно отображается на консоли.</xref:System.Diagnostics.Process> Путем перенаправления потока StandardOutput, можно управлять или подавлять вывод процесса. Например можно фильтровать текст, отформатировать его по-разному или записать выходные данные в консоль и назначенный файл журнала.      Настроек [!NOTE] настроек для использования StandardOutput, необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName>для `false`, и необходимо задать <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName>для `true`.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName> В противном случае чтение из потока StandardOutput вызывает исключение.       Перенаправленный поток StandardOutput могут считываться синхронно или асинхронно. Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A>выполнения синхронных операций чтения в выходной поток процесса.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Эти синхронного чтения операций не завершены, пока не связанный с ним <xref:System.Diagnostics.Process>записывает его StandardOutput поток или закрывает поток.</xref:System.Diagnostics.Process>       Напротив <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>начинается асинхронного чтения операции с потоком StandardOutput.</xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Этот метод включает назначенный обработчик событий для выходного потока и немедленно возвращается вызывающему объекту, который может выполнять другую работу, пока вывод потока направлен обработчику событий.       Синхронные операции чтения устанавливают зависимость между считыванием вызывающего оператора из потока StandardOutput и записи в поток дочерний процесс. Эти зависимости может привести к условиям взаимоблокировки. Если вызывающий объект считывает из перенаправленного потока дочернего процесса, он зависит от дочернего. Вызывающий объект ожидает операции считывания дочерний элемент записывает в поток или закрывает поток. Если дочерний процесс записывает достаточно данных для заполнения своего перенаправленного потока, он зависит от родительского. Дочерний процесс ожидает следующей операции записи, пока родительский элемент считывает из полного потока или закрывает поток. Взаимоблокировка возникает, когда вызывающий объект и дочерний процесс ожидают друг друга для завершения операции, и не может происходить. Взаимоблокировок можно избежать, оценивая зависимости между вызывающим объектом и дочерним процессом.       Например, следующий код C#, показано, как считывание из перенаправленного потока и ожидание завершения дочернего процесса.      ```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```В примере кода позволяет избежать состояния взаимоблокировки, вызвав `p.StandardOutput.ReadToEnd` перед `p.WaitForExit`. Условие взаимоблокировки могут случиться, если родительский процесс вызывает `p.WaitForExit` перед `p.StandardOutput.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения перенаправленного потока. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса. Дочерний процесс неограниченно долго будет ожидать родительского, считанных из потока полного StandardOutput.       Нет аналогичная проблема возникает при считывании всего текста из стандартный выход и Стандартная ошибка потоков. Например, следующий код C#, выполняет операции чтения в обоих потоках.      ```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```В примере кода позволяет избежать состояния взаимоблокировки, выполняя операции асинхронного чтения потока StandardOutput. Условие взаимоблокировки возникает, если родительский процесс вызывает `p.StandardOutput.ReadToEnd` следуют `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения его поток сообщений об ошибках. Родительский процесс неограниченно долго будет ожидать дочерний процесс закрыть его потоком StandardOutput. Дочерний процесс неограниченно долго будет ожидать родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A>потока.</xref:System.Diagnostics.Process.StandardError%2A>       Чтобы избежать этих зависимостей возможных взаимоблокировок можно использовать операции асинхронного чтения. Кроме того можно избежать состояния взаимоблокировки путем создания двух потоков и считывания выходных данных каждого потока в отдельном потоке.      Настроек [!NOTE] настроек нельзя смешивать асинхронная и синхронная операции чтения в перенаправленном потоке. Один раз перенаправленный поток <xref:System.Diagnostics.Process>открывается в режиме синхронной или асинхронной, все дополнительные чтения операции в этом потоке должны быть в том же режиме.</xref:System.Diagnostics.Process> Например, не выполняйте <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>вызовом <xref:System.IO.StreamReader.ReadLine%2A>StandardOutput потоке, или наоборот.</xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Однако можно считать два различных потоков в различных режимах. Например, можно вызвать <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>и затем вызвать метод <xref:System.IO.StreamReader.ReadLine%2A>для <xref:System.Diagnostics.Process.StandardError%2A>потока.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A>"
  example:
  - "The following example runs the ipconfig.exe command and redirects its standard output to the example’s console window.  \n  \n [!code-vb[Process_StandardOutput#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_11_1.vb)]\n [!code-cs[Process_StandardOutput#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_11_1.cs)]\n [!code-cpp[Process_StandardOutput#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_11_1.cpp)]"
  syntax:
    content: public System.IO.StreamReader StandardOutput { get; }
    return:
      type: System.IO.StreamReader
      description: "Объект <xref:System.IO.StreamReader>может использоваться для чтения в стандартный выходной поток приложения.</xref:System.IO.StreamReader>"
  overload: System.Diagnostics.Process.StandardOutput*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The StandardOutput stream has not been defined for redirection; ensure &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref> and &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; is set to <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The StandardOutput stream has been opened for asynchronous read operations with <xref:System.Diagnostics.Process.BeginOutputReadLine*>."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start
  id: Start
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Запускает (или повторно использует) ресурс процесса, который задается параметром <xref:System.Diagnostics.Process.StartInfo*>этого <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонента и связывает его с компонентом.</xref:System.Diagnostics.Process.StartInfo*>"
  remarks: "Use this overload to start a process resource and associate it with the current <xref:System.Diagnostics.Process> component. The return value `true` indicates that a new process resource was started. If the process resource specified by the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property is already running on the computer, no additional process resource is started. Instead, the running process resource is reused and `false` is returned.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n> [!NOTE]\n>  If you are using Visual Studio, this overload of the Start method is the one that you insert into your code after you drag a <xref:System.Diagnostics.Process> component onto the designer. Use the `Properties` window to expand the `StartInfo` category and write the appropriate value into the `FileName` property. Your changes will appear in the form's `InitializeComponent` procedure.  \n  \n This overload of Start is not a `static` method. You must call it from an instance of the <xref:System.Diagnostics.Process> class. Before calling Start, you must first specify <xref:System.Diagnostics.Process.StartInfo%2A> property information for this <xref:System.Diagnostics.Process> instance, because that information is used to determine the process resource to start.  \n  \n The other overloads of the Start method are `static` members. You do not need to create an instance of the <xref:System.Diagnostics.Process> component before you call those overloads of the method. Instead, you can call Start for the <xref:System.Diagnostics.Process> class itself, and a new <xref:System.Diagnostics.Process> component is created if the process was started. Or, `null` is returned if a process was reused. The process resource is automatically associated with the new <xref:System.Diagnostics.Process> component that is returned by the Start method.  \n  \n The <xref:System.Diagnostics.Process.StartInfo%2A> members can be used to duplicate the functionality of the `Run` dialog box of the Windows `Start` menu. Anything that can be typed into a command line can be started by setting the appropriate values in the <xref:System.Diagnostics.Process.StartInfo%2A> property. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not have to be an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n In the command line, you can specify actions to take for certain types of files. For example, you can print documents or edit text files. Specify these actions using the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property. For other types of files, you can specify command-line arguments when you start the file from the `Run` dialog box. For example, you can pass a URL as an argument if you specify your browser as the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. These arguments can be specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> member.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use Start to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_16_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_16_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_16_1.cs)]"
  syntax:
    content: public bool Start ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если ресурс процесса запущен; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если новый ресурс процесса не запущен (например, при повторном использовании существующего процесса)."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Имя файла не было указано в <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонента <> </> *настроек.       - или - &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; членом <> </> *настроек свойство <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> при &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=fullName&gt;, &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=fullName&gt;, или &lt;xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=fullName&gt; — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при открытии связанного файла."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Объект процесса уже удален."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  id: Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Запускает ресурс процесса, который задается параметром, содержащим стартовую информацию процесса (например, имя файла процесса для запуска) и связывает ресурс с новым <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонента."
  remarks: "Use this overload to start a process resource by specifying a <xref:System.Diagnostics.ProcessStartInfo> instance. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. Using this overload with a <xref:System.Diagnostics.ProcessStartInfo> parameter is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting its <xref:System.Diagnostics.Process.StartInfo%2A> properties, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Using a <xref:System.Diagnostics.ProcessStartInfo> instance as the parameter lets you call <xref:System.Diagnostics.Process.Start%2A> with the most control over what is passed into the call to start the process. If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref:System.Diagnostics.ProcessStartInfo> instance, although that is an option. The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property. The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.  \n  \n You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n If the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> instance are set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> property value is <xref:System.Diagnostics.ProcessWindowStyle>.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref:System.Diagnostics.ProcessStartInfo> instance.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the `startInfo` parameter, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n For additional examples of other uses of this method, refer to the individual properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_17_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_17_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_17_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);
    parameters:
    - id: startInfo
      type: System.Diagnostics.ProcessStartInfo
      description: "<xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> , Содержащий сведения, который используется для запуска процесса, включая имя файла и все аргументы командной строки."
    return:
      type: System.Diagnostics.Process
      description: "Новый <xref href=&quot;System.Diagnostics.Process&quot;> </xref> , связанный с ресурсом процесса, или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой процесс с его <xref:System.Diagnostics.Process.HasExited*>свойство уже задано значение <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> В этом случае запущенный процесс может активировать существующий экземпляр самого себя и затем завершить работу."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Имя файла не было указано в <code> startInfo </code> параметра <> </> *настроек свойств.       -or-       The <>*> property of the <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref> and the <>*>, <>*>, or <>*> property is also <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>.       - или - <> </> *настроек свойство <code> startInfo </code> параметр <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> и <> </> *настроек свойство не <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> или пустой или <> </> *настроек свойство не <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>startInfo</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Объект процесса уже удален."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Файл, указанный в <code> startInfo </code> параметра <xref:System.Diagnostics.ProcessStartInfo.FileName*>свойство не найдено.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при открытии связанного файла.       - или - Сумма длины аргументов и длины полного пути к процессу превышает 2080. Сообщение об ошибке, связанной с этим исключением может принимать одно из следующих: «область данных, переданная системному вызову, слишком мал.» или «Доступ запрещен»."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String)
  id: Start(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Запускает ресурс процесса путем указания имени документа или файла приложения и связывает ресурс с новым <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонента."
  remarks: "Use this overload to start a process resource by specifying its file name. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n You can start a ClickOnce application by setting the `fileName` parameter to the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.  \n  \n Starting a process by specifying its file name is similar to typing the information in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\".  \n  \n This overload does not allow command-line arguments for the process. If you need to specify one or more command-line arguments for the process, use the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> or <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=fullName> overloads.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_2_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "Имя документа или файла приложения для запуска в процессе."
    return:
      type: System.Diagnostics.Process
      description: "Новый <xref href=&quot;System.Diagnostics.Process&quot;> </xref> , связанный с ресурсом процесса, или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой процесс с его <xref:System.Diagnostics.Process.HasExited*>свойство уже задано значение <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> В этом случае запущенный процесс может активировать существующий экземпляр самого себя и затем завершить работу."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при открытии связанного файла."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Объект процесса уже удален."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Переменная среды PATH содержит строку с кавычками."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  id: Start(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Запускает ресурс процесса путем указания имени приложения и набора аргументов командной строки и связывает ресурс с новым <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонента."
  remarks: "Use this overload to start a process resource by specifying its file name and command-line arguments. The overload associates the resource with a new <xref:System.Diagnostics.Process> object.  \n  \n> [!NOTE]\n>  If the address of the executable file to start is a URL, the process is not started and `null` is returned.  \n  \n This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance. The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> members of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.  \n  \n Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the `Run` dialog box of the Windows `Start` menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter. For example, you can set the `fileName` parameter to either \"Notepad.exe\" or \"Notepad\". If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`. If the `fileName` parameter represents a command (.cmd) file, the `arguments` parameter must include either a \"`/c`\" or \"`/k`\" argument to specify whether the command window exits or remains after completion.  \n  \n Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member. Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance. Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.  \n  \n If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if `c:\\mypath` is not in your path, and you add it using quotation marks: `path = %path%;\"c:\\mypath\"`, you must fully qualify any process in `c:\\mypath` when starting it.  \n  \n> [!NOTE]\n>  ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.  \n  \n Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>. You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..  \n  \n A note about apartment states in managed threads is necessary here. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method. Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`. Some methods require that the apartment state not be `unknown`. If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed. However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread."
  example:
  - "The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_20_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_20_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_20_1.cpp)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments);
    parameters:
    - id: fileName
      type: System.String
      description: "Имя файла приложения для запуска в процессе."
    - id: arguments
      type: System.String
      description: "Аргументы командной строки для передачи при запуске процесса."
    return:
      type: System.Diagnostics.Process
      description: "Новый <xref href=&quot;System.Diagnostics.Process&quot;> </xref> , связанный с ресурсом процесса, или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой процесс с его <xref:System.Diagnostics.Process.HasExited*>свойство уже задано значение <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> В этом случае запущенный процесс может активировать существующий экземпляр самого себя и затем завершить работу."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <code>fileName</code> or <code>arguments</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при открытии связанного файла.       - или - Сумма длины аргументов и длины полного пути к процессу превышает 2080. Сообщение об ошибке, связанной с этим исключением может принимать одно из следующих: «область данных, переданная системному вызову, слишком мал.» или «Доступ запрещен»."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Объект процесса уже удален."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Переменная среды PATH содержит строку с кавычками."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Запускает ресурс процесса путем указания имени приложения, имени пользователя, пароля и домена и связывает ресурс с новым <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонента."
  remarks: "Используйте этот перегруженный метод для создания нового процесса и основной поток, указав имя файла, имя пользователя, пароль и домен. Затем новый процесс запускает указанный исполняемый файл в контексте безопасности указанные учетные данные (пользователя, домен и пароль).      Настроек [!NOTE] настроек при исполняемый файл находится на удаленном диске, необходимо определить общей сетевой папке с помощью универсальный код ресурса (URI), не связанный с буквой диска.      Настроек [!NOTE] настроек при URL-адрес, адрес исполняемый файл, чтобы запустить процесс не запущен и `null` возвращается.       Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process>экземпляра.</xref:System.Diagnostics.Process> Перегрузка является альтернативой явным шагам создания нового <xref:System.Diagnostics.Process>экземпляр, задание <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, и <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>Свойства <xref:System.Diagnostics.Process.StartInfo%2A>Свойства, а вызов метода <xref:System.Diagnostics.Process.Start%2A>для <xref:System.Diagnostics.Process>экземпляра.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       Аналогичным образом, в том же, как **запуска** диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширением .exe является необязательным в `fileName` параметра. Например, можно задать `fileName` параметр «Notepad.exe» или «Блокнот». Если `fileName` параметр представляет собой исполняемый файл, `arguments` параметр может представлять действия, такие как текстового файла в файл `Notepad.exe myfile.txt`.      Настроек [!NOTE] настроек имя файла должно представлять исполняемый файл в <xref:System.Diagnostics.Process.Start%2A>перегрузок, имеющих `userName`, `password`, и `domain` параметров.</xref:System.Diagnostics.Process.Start%2A>       При использовании <xref:System.Diagnostics.Process.Start%2A>для запуска процесса, может потребоваться закрыть его или появляется риск потери системных ресурсов.</xref:System.Diagnostics.Process.Start%2A> Закройте процессов, использующих <xref:System.Diagnostics.Process.CloseMainWindow%2A>или <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Вы можете проверить ли процесс уже закрыт, используя его <xref:System.Diagnostics.Process.HasExited%2A>свойство...</xref:System.Diagnostics.Process.HasExited%2A>"
  example:
  - "The following code example shows the use of this overload to start an executable file and also demonstrates the throwing of a <xref:System.ComponentModel.Win32Exception> when an attempt is made to start an application associated with a nonexecutable file.  \n  \n [!code-cs[System.Diagnostics.Process.Start#1](~/add/codesnippet/csharp/fff1e658-5eee-484b-80e5-_1.cs)]\n [!code-vb[System.Diagnostics.Process.Start#1](~/add/codesnippet/visualbasic/fff1e658-5eee-484b-80e5-_1.vb)]"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "Имя файла приложения для запуска в процессе."
    - id: userName
      type: System.String
      description: "Имя пользователя для использования при запуске процесса."
    - id: password
      type: System.Security.SecureString
      description: "Объект <xref href=&quot;System.Security.SecureString&quot;> </xref> , содержащее пароль, используемый при запуске процесса."
    - id: domain
      type: System.String
      description: "Домен, используемый при запуске процесса."
    return:
      type: System.Diagnostics.Process
      description: "Новый <xref href=&quot;System.Diagnostics.Process&quot;> </xref> , связанный с ресурсом процесса, или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой процесс с его <xref:System.Diagnostics.Process.HasExited*>свойство уже задано значение <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> В этом случае запущенный процесс может активировать существующий экземпляр самого себя и затем завершить работу."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Имя файла не было указано."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при открытии связанного файла."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Объект процесса уже удален."
  platform:
  - net462
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  id: Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Запускает ресурс процесса путем указания имени приложения, набора аргументов командной строки, имени пользователя, пароля и домена и связывает ресурс с новым <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонента."
  remarks: "Используйте этот перегруженный метод для создания нового процесса и основной поток, указав имя файла, аргументы командной строки, имя пользователя, пароль и домен. Затем новый процесс запускает указанный исполняемый файл в контексте безопасности указанные учетные данные (пользователя, домен и пароль).      Настроек [!NOTE] настроек при исполняемый файл находится на удаленном диске, необходимо определить общей сетевой папке с помощью универсальный код ресурса (URI), не связанный с буквой диска.      Настроек [!NOTE] настроек при URL-адрес, адрес исполняемый файл, чтобы запустить процесс не запущен и `null` возвращается.       Эта перегрузка позволяет запускать процесс без создания нового <xref:System.Diagnostics.Process>экземпляра.</xref:System.Diagnostics.Process> Перегрузка является альтернативой явным шагам создания нового <xref:System.Diagnostics.Process>экземпляр, задание <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, и <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>Свойства <xref:System.Diagnostics.Process.StartInfo%2A>Свойства, а вызов метода <xref:System.Diagnostics.Process.Start%2A>для <xref:System.Diagnostics.Process>экземпляра.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> </xref:System.Diagnostics.Process.StartInfo%2A> </xref:System.Diagnostics.ProcessStartInfo.Domain%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process>       Аналогичным образом, в том же, как **запуска** диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширением .exe является необязательным в `fileName` параметра. Например, можно задать `fileName` параметр «Notepad.exe» или «Блокнот». Если `fileName` параметр представляет собой исполняемый файл, `arguments` параметр может представлять действия, такие как текстового файла в файл `Notepad.exe myfile.txt`.      Настроек [!NOTE] настроек имя файла должно представлять исполняемый файл в <xref:System.Diagnostics.Process.Start%2A>перегрузок, имеющих `userName`, `password`, и `domain` параметров.</xref:System.Diagnostics.Process.Start%2A>       При использовании <xref:System.Diagnostics.Process.Start%2A>для запуска процесса, может потребоваться закрыть его или появляется риск потери системных ресурсов.</xref:System.Diagnostics.Process.Start%2A> Закройте процессов, использующих <xref:System.Diagnostics.Process.CloseMainWindow%2A>или <xref:System.Diagnostics.Process.Kill%2A>.</xref:System.Diagnostics.Process.Kill%2A> </xref:System.Diagnostics.Process.CloseMainWindow%2A> Вы можете проверить ли процесс уже закрыт, используя его <xref:System.Diagnostics.Process.HasExited%2A>свойство...</xref:System.Diagnostics.Process.HasExited%2A>"
  syntax:
    content: public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);
    parameters:
    - id: fileName
      type: System.String
      description: "Имя файла приложения для запуска в процессе."
    - id: arguments
      type: System.String
      description: "Аргументы командной строки для передачи при запуске процесса."
    - id: userName
      type: System.String
      description: "Имя пользователя для использования при запуске процесса."
    - id: password
      type: System.Security.SecureString
      description: "Объект <xref href=&quot;System.Security.SecureString&quot;> </xref> , содержащее пароль, используемый при запуске процесса."
    - id: domain
      type: System.String
      description: "Домен, используемый при запуске процесса."
    return:
      type: System.Diagnostics.Process
      description: "Новый <xref href=&quot;System.Diagnostics.Process&quot;> </xref> , связанный с ресурсом процесса, или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если ресурс процесса не запущен. Обратите внимание, что новый процесс, запущенный наряду с уже выполняющимися экземплярами того же процесса, будет независимым от других. Кроме того, метод Start может вернуть ненулевой процесс с его <xref:System.Diagnostics.Process.HasExited*>свойство уже задано значение <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Diagnostics.Process.HasExited*> В этом случае запущенный процесс может активировать существующий экземпляр самого себя и затем завершить работу."
  overload: System.Diagnostics.Process.Start*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Имя файла не было указано."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при открытии связанного файла.       - или - Сумма длины аргументов и длины полного пути к соответствующему файлу превышает 2080. Сообщение об ошибке, связанной с этим исключением может принимать одно из следующих: «область данных, переданная системному вызову, слишком мал.» или «Доступ запрещен»."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Объект процесса уже удален."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartInfo
  id: StartInfo
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает свойства для передачи <xref:System.Diagnostics.Process.Start*>метод <xref href=&quot;System.Diagnostics.Process&quot;> </xref>.</xref:System.Diagnostics.Process.Start*>"
  remarks: "StartInfo представляет набор параметров, используемых для запуска процесса. Если <xref:System.Diagnostics.Process.Start%2A>является именем, StartInfo используется для указания процесса для запуска.</xref:System.Diagnostics.Process.Start%2A> Элемент StartInfo только необходимые для установки <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>свойство.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Запуск процесса путем указания <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>свойство похож на запуск с **запуска** диалогового окна **запустить** меню.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Таким образом <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>свойство не требуется предоставлять исполняемый файл.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Это может быть файл любого типа, для которого модуль был связан с приложением, установленных в системе. Например <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>может иметь расширение .txt, если текстовые файлы связаны с редактором, например в блокноте, или он может иметь расширение .doc, при наличии файлов с инструментом обработки текстов, например Microsoft Word.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Аналогичным образом, в том же, как **запуска** диалоговое окно может принимать имя исполняемого файла с расширением .exe или без, расширением .exe является необязательным в <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>член.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Например, можно задать <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>свойство «Notepad.exe» или «Блокнот».</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>       Можно запустить приложение ClickOnce, задав <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>свойство расположение (например, веб-адрес), из которого изначально устанавливалось приложение.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Не запускать приложение ClickOnce, указав расположение его установки на жестком диске.       Если неисполняемые файла, например DOC-файл включает в себя имя файла можно включить команду, задающую какое действие необходимо выполнить для файла. Например, можно задать <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>«Print» для файла с расширением .doc.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Имя файла, указанное в <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>свойство не обязательно иметь расширение, если вручную ввести значение для <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>свойство.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Тем не менее если вы используете <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>доступны свойства, чтобы определить, какие команды, должен включать расширение.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>       Можно изменить параметры, заданные в свойстве StartInfo до времени, которые можно вызвать <xref:System.Diagnostics.Process.Start%2A>метод процесса.</xref:System.Diagnostics.Process.Start%2A> После запуска процесса изменение значений StartInfo не влияют на или перезапустите связанного процесса. При вызове <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>метода с <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName>и <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName>набором свойств, неуправляемой `CreateProcessWithLogonW` вызывается функция, которая запускает процесс в новое окно даже в случае <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>значение свойства `true` или <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>свойство имеет значение <xref:System.Diagnostics.ProcessWindowStyle>.</xref:System.Diagnostics.ProcessWindowStyle> </xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> </xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> </xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=fullName> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=fullName> </xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>       Если вы не использовали <xref:System.Diagnostics.Process.Start%2A>метод для запуска процесса, а свойство StartInfo не отражает параметры, используемые для запуска процесса.</xref:System.Diagnostics.Process.Start%2A> Например, если вы используете <xref:System.Diagnostics.Process.GetProcesses%2A>для получения массива процессов, запущенных на компьютере, а свойство StartInfo каждого <xref:System.Diagnostics.Process>не содержит исходное имя файла или аргументы, используемые для запуска процесса.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.GetProcesses%2A>       При запуске процесса имя файла — это файл, заполняющий (только для чтения) <xref:System.Diagnostics.Process.MainModule%2A>свойство.</xref:System.Diagnostics.Process.MainModule%2A> Если вы хотите получить исполняемый файл, который связан с процессом после начала процесса, используйте <xref:System.Diagnostics.Process.MainModule%2A>свойство.</xref:System.Diagnostics.Process.MainModule%2A> Если вы хотите задать исполняемый файл <xref:System.Diagnostics.Process>экземпляра, для которого связанный процесс не запущен, используйте свойство StartInfo <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>член.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process> Из-за свойства StartInfo аргументы, передаваемые <xref:System.Diagnostics.Process.Start%2A>метод процесса, изменение <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>свойство после начала процесса не приведет к сбросу <xref:System.Diagnostics.Process.MainModule%2A>свойство.</xref:System.Diagnostics.Process.MainModule%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.Process.Start%2A> Эти свойства используются только для инициализации связанного процесса."
  example:
  - "The following example populates a StartInfo with the file to execute, the action performed on it and whether it should displays a user interface. For additional examples, refer to the reference pages for properties of the <xref:System.Diagnostics.ProcessStartInfo> class.  \n  \n [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_10_1.cpp)]\n [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_10_1.vb)]\n [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_10_1.cs)]"
  syntax:
    content: public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }
    return:
      type: System.Diagnostics.ProcessStartInfo
      description: "<xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> , Представляющий данные для запуска процесса. Эти аргументы включают имя исполняемого файла или документа, использованного для запуска процесса."
  overload: System.Diagnostics.Process.StartInfo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Значение, указывающее StartInfo — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Diagnostics.Process.StartTime
  id: StartTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает время запуска связанного процесса."
  syntax:
    content: public DateTime StartTime { get; }
    return:
      type: System.DateTime
      description: "Объект, который указывает время запуска процесса. Исключение возникает в том случае, если процесс не выполняется."
  overload: System.Diagnostics.Process.StartTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству StartTime для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс завершен.       - или - процесс не запущен."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "В вызове функции Windows произошла ошибка."
  platform:
  - net462
- uid: System.Diagnostics.Process.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает объект, используемый для маршалинга вызовов обработчика событий, происходящих в результате события завершения процесса."
  remarks: "Когда <xref:System.Diagnostics.EventLog.SynchronizingObject%2A>— `null`, методы, обрабатывающие <xref:System.Diagnostics.Process.Exited>события вызываются в поток из пула потоков системы.</xref:System.Diagnostics.Process.Exited> </xref:System.Diagnostics.EventLog.SynchronizingObject%2A> Дополнительные сведения о системной группе потоков см. в разделе <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       Если <xref:System.Diagnostics.Process.Exited>событие обрабатывается компонентом Windows Forms, такие как <xref:System.Windows.Forms.Button>, обращение к компоненту через пул потоков системы могут не работать или может привести к возникновению исключения.</xref:System.Windows.Forms.Button> </xref:System.Diagnostics.Process.Exited> Избежать этого, задав SynchronizingObject компоненту Windows Forms, который вызывает методы, обрабатывающие <xref:System.Diagnostics.Process.Exited>событий для вызова в том же потоке, в котором был создан компонент.</xref:System.Diagnostics.Process.Exited>       Если <xref:System.Diagnostics.Process>используется внутри [!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] SynchronizingObject автоматически устанавливается в конструкторе Windows Forms, чтобы элемент управления, содержащий <xref:System.Diagnostics.Process>.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process> Например, если поместить <xref:System.Diagnostics.Process>конструктору `Form1` (наследуется от класса <xref:System.Windows.Forms.Form>) свойство SynchronizingObject <xref:System.Diagnostics.Process>устанавливается на экземпляр `Form1`: [!code-cpp [Process_SynchronizingObject&#2;](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_1.cpp)][!code-cs[Process_SynchronizingObject&#2;](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_1.cs)][!code-vb[Process_SynchronizingObject&#2;](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_1.vb) ] как правило, это свойство задается при помещении компонента внутри элемента управления или формы, так как эти компоненты привязаны к определенному потоку.    </xref:System.Diagnostics.Process> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.Process>"
  example:
  - >-
    [!code-vb[Process_SynchronizingObject#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_35_2.vb)]
     [!code-cpp[Process_SynchronizingObject#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_35_2.cpp)]
     [!code-cs[Process_SynchronizingObject#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_35_2.cs)]
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "<xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> Используемый для маршалинга вызовов обработчика событий, происходящих в результате использования <xref href=&quot;System.Diagnostics.Process.Exited&quot;> </xref> событий для процесса."
  overload: System.Diagnostics.Process.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.Process.Threads
  id: Threads
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает множество потоков, выполняющихся в связанном процессе."
  remarks: "Поток выполняет код в процессе. Каждый процесс запускается с одним потоком, а основной поток. Любой поток может создавать дополнительные потоки. Потоки процесса разделяют адресное пространство процесса.       Используйте <xref:System.Diagnostics.ProcessThread>для получения всех потоков, связанных с текущим процессом.</xref:System.Diagnostics.ProcessThread> Основной поток не обязательно с нулевым индексом в массиве."
  syntax:
    content: public System.Diagnostics.ProcessThreadCollection Threads { get; }
    return:
      type: System.Diagnostics.ProcessThreadCollection
      description: "Массив объектов типа <xref href=&quot;System.Diagnostics.ProcessThread&quot;> </xref> представляющий операционную систему, потоки, выполняющихся в связанном процессе."
  overload: System.Diagnostics.Process.Threads*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Процесс не имеет <xref:System.Diagnostics.Process.Id*>, или нет процесса, связанного с <xref href=&quot;System.Diagnostics.Process&quot;> </xref> экземпляра.</xref:System.Diagnostics.Process.Id*>       - или - связанный процесс завершился."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа — Windows 98 или Windows Millennium Edition (Windows Me); задать &lt;xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=fullName&gt; для <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для доступа к этому свойству в Windows 98 и Windows Me."
  platform:
  - net462
- uid: System.Diagnostics.Process.ToString
  id: ToString
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Преобразует имя процесса в строку, объединенную с родительским типом компонента, если это применимо."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/m-system.diagnostics.pro_12_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/m-system.diagnostics.pro_12_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/m-system.diagnostics.pro_12_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "<> </> *Настроек, вместе с основной компонент <> </> *настроек возвращаемое значение."
  overload: System.Diagnostics.Process.ToString*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "ToString не поддерживается в Windows 98."
  platform:
  - net462
- uid: System.Diagnostics.Process.TotalProcessorTime
  id: TotalProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает полное время процессора для этого процесса."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_15_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_15_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_15_1.vb)]"
  syntax:
    content: public TimeSpan TotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Объект <xref:System.TimeSpan>, указывающее количество времени, которое связанный процесс потратил на использование ЦПУ.</xref:System.TimeSpan> Это значение является суммой <> </> *настроек и <> </> *настроек."
  overload: System.Diagnostics.Process.TotalProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству TotalProcessorTime для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.Process.UserProcessorTime
  id: UserProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает пользовательское время процессора для этого процесса."
  remarks: ''
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_21_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_21_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_21_1.vb)]"
  syntax:
    content: public TimeSpan UserProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Объект <xref:System.TimeSpan>, показывающий количество времени, которое связанный процесс потратил на выполнение кода внутри приложения (не внутри ядра операционной системы).</xref:System.TimeSpan>"
  overload: System.Diagnostics.Process.UserProcessorTime*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Вы пытаетесь получить доступ к свойству UserProcessorTime для процесса, запущенного на удаленном компьютере. Это свойство доступно только для процессов, запущенных на локальном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize
  id: VirtualMemorySize
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает размер виртуальной памяти процесса, в байтах."
  syntax:
    content: public int VirtualMemorySize { get; }
    return:
      type: System.Int32
      description: "Объем виртуальной памяти в байтах, запрошенной связанным процессом."
  overload: System.Diagnostics.Process.VirtualMemorySize*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.VirtualMemorySize64
  id: VirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает объем виртуальной памяти в байтах, выделенной для связанного процесса."
  remarks: "Значение, возвращаемое этим свойством, представляет текущий размер виртуальной памяти, используемой процессом, в байтах. Операционная система сопоставляет виртуального адресного пространства для каждого процесса, либо на страницы загрузки в физическую память или со страницами, сохраненными в файле подкачки виртуальной памяти на диске.       Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **байт виртуальной памяти** счетчика производительности для процесса."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_13_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_13_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_13_1.vb)]"
  syntax:
    content: public long VirtualMemorySize64 { get; }
    return:
      type: System.Int64
      description: "Объем виртуальной памяти в байтах, выделенной для связанного процесса."
  overload: System.Diagnostics.Process.VirtualMemorySize64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit
  id: WaitForExit
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Указывает, что <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонент бесконечно ожидать завершения связанного процесса."
  remarks: "WaitForExit делает текущий поток ожидать завершения связанного процесса.  Его следует вызывать после всех других методов вызываются в процессе. Чтобы избежать блокировки текущего потока, используйте <xref:System.Diagnostics.Process.Exited>событий.</xref:System.Diagnostics.Process.Exited>       Указывает, что этот метод <xref:System.Diagnostics.Process>компонент ждать неограниченное количество времени для процесса и обработчики событий для выхода.</xref:System.Diagnostics.Process> Это может привести к зависанию приложения. Например, при вызове метода <xref:System.Diagnostics.Process.CloseMainWindow%2A>для процесса, которое имеет пользовательский интерфейс, запрос операционную систему на завершение процесса может быть не обработан запись процесса на никогда не войти в цикл сообщений.</xref:System.Diagnostics.Process.CloseMainWindow%2A>      Настроек [!NOTE] настроек в [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] и более ранних версиях перегрузки WaitForExit ожидания <xref:System.Int32.MaxValue>миллисекунд (приблизительно 24 дня), не бесконечно.</xref:System.Int32.MaxValue> Кроме того, предыдущие версии была ожидает обработчики событий для выхода, если полный <xref:System.Int32.MaxValue>время была достигнута.</xref:System.Int32.MaxValue>       Эта перегрузка гарантирует, что вся обработка завершения, включая обработку асинхронных событий для перенаправленного стандартного вывода. Эту перегрузку следует использовать после вызова <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>перегрузки, когда стандартный вывод был перенаправлен обработчикам асинхронных событий.</xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>       При завершении связанного процесса (то есть, когда она завершит работу операционной системы через нормальное или аварийное завершение), система сохраняет административную информацию о процессе и возвращает ее компоненту, вызвавшему метод WaitForExit. <xref:System.Diagnostics.Process>Может получить доступ к информации, включая <xref:System.Diagnostics.Process.ExitTime%2A>, с помощью <xref:System.Diagnostics.Process.Handle%2A>завершенных процессов.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Так как связанный процесс завершился, <xref:System.Diagnostics.Process.Handle%2A>Свойства компонента больше не указывает на существующий ресурс процесса.</xref:System.Diagnostics.Process.Handle%2A> Вместо этого дескриптор может использоваться только для доступа к информации операционной системы о ресурсе процесса. Система известно о дескрипторах завершенных процессов, которые не были освобождены <xref:System.Diagnostics.Process>компонентов, поэтому она хранит <xref:System.Diagnostics.Process.ExitTime%2A>и <xref:System.Diagnostics.Process.Handle%2A>данные в память до <xref:System.Diagnostics.Process>компонент специально не освободит ресурсы.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> По этой причине при каждом вызове <xref:System.Diagnostics.Process.Start%2A>для <xref:System.Diagnostics.Process>экземпляра, вызов, <xref:System.Diagnostics.Process.Close%2A>Если связанный процесс был завершен и вы больше не требуется административной информации о его.</xref:System.Diagnostics.Process.Close%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>Освобождает память, выделенную для завершенных процессов.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the Remarks section of the <xref:System.Diagnostics.Process.StandardError%2A> property reference page.
  syntax:
    content: public void WaitForExit ();
    parameters: []
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Не удается получить доступ к параметру ожидания."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Процесс не <> </> *настроек задана и <> </> *настроек откуда <xref:System.Diagnostics.Process.Id*>можно определить свойство не существует.</xref:System.Diagnostics.Process.Id*>       - или - никакие процессы, связанные с этим <xref href=&quot;System.Diagnostics.Process&quot;> </xref> объекта.       - или - вы пытаетесь вызвать метод WaitForExit для процесса, запущенного на удаленном компьютере. Этот метод доступен только для процессов, запущенных на локальном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  id: WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Указывает, что <xref href=&quot;System.Diagnostics.Process&quot;> </xref> команду ожидать указанное число миллисекунд для завершения связанного процесса."
  remarks: "WaitForExit делает текущий поток ожидать завершения связанного процесса. Его следует вызывать после всех других методов вызываются в процессе. Чтобы избежать блокировки текущего потока, используйте <xref:System.Diagnostics.Process.Exited>событий.</xref:System.Diagnostics.Process.Exited>       Указывает, что этот метод <xref:System.Diagnostics.Process>компонент ожидать конечное количество времени для завершения процесса.</xref:System.Diagnostics.Process> Если связанный процесс не завершится к концу интервал из-за отказа в запросе на завершение `false` возвращается в вызывающую процедуру. Можно задать отрицательное число (<xref:System.Threading.Timeout.Infinite>) для `milliseconds`, и WaitForExit будет работать так же, как <xref:System.Diagnostics.Process.WaitForExit>перегрузить.</xref:System.Diagnostics.Process.WaitForExit> </xref:System.Threading.Timeout.Infinite> Если передается значение 0 (ноль) метод, он возвращает `true` только в том случае, если процесс уже завершился; в противном случае он немедленно возвращает `false`.      Настроек [!NOTE] настроек в [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)] и более ранних версий, если `milliseconds` был -1, WaitForExit, ожидавших перегрузки <xref:System.Int32.MaxValue>миллисекунд (приблизительно 24 дня), не бесконечно.</xref:System.Int32.MaxValue>       Когда стандартный вывод был перенаправлен обработчикам асинхронных событий, возможно, что обработка вывода не имеют завершена при возвращении этим методом. Чтобы обеспечить завершение асинхронной обработки событий, вызовите <xref:System.Diagnostics.Process.WaitForExit>перегрузку, которая не получает параметра после получения `true` из этой перегрузки.</xref:System.Diagnostics.Process.WaitForExit> Чтобы обеспечить <xref:System.Diagnostics.Process.Exited>правильной обработки событий в приложениях Windows Forms, задайте <xref:System.Diagnostics.Process.SynchronizingObject%2A>свойство.</xref:System.Diagnostics.Process.SynchronizingObject%2A> </xref:System.Diagnostics.Process.Exited>       При завершении связанного процесса (завершает работу операционной системы через нормальное или аварийное завершение), система сохраняет административную информацию о процессе и возвращает ее компоненту, вызвавшему метод WaitForExit. <xref:System.Diagnostics.Process>Может получить доступ к информации, включая <xref:System.Diagnostics.Process.ExitTime%2A>, с помощью <xref:System.Diagnostics.Process.Handle%2A>завершенных процессов.</xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process>       Так как связанный процесс завершился, <xref:System.Diagnostics.Process.Handle%2A>Свойства компонента больше не указывает на существующий ресурс процесса.</xref:System.Diagnostics.Process.Handle%2A> Вместо этого дескриптор может использоваться только для доступа к информации операционной системы о ресурсе процесса. Система известно о дескрипторах завершенных процессов, которые не были освобождены <xref:System.Diagnostics.Process>компонентов, поэтому она хранит <xref:System.Diagnostics.Process.ExitTime%2A>и <xref:System.Diagnostics.Process.Handle%2A>данные в память до <xref:System.Diagnostics.Process>компонент специально не освободит ресурсы.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Handle%2A> </xref:System.Diagnostics.Process.ExitTime%2A> </xref:System.Diagnostics.Process> По этой причине при каждом вызове <xref:System.Diagnostics.Process.Start%2A>для <xref:System.Diagnostics.Process>экземпляра, вызов, <xref:System.Diagnostics.Process.Close%2A>Если связанный процесс был завершен и вы больше не требуется административной информации о его.</xref:System.Diagnostics.Process.Close%2A> </xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Start%2A> <xref:System.Diagnostics.Process.Close%2A>Освобождает память, выделенную для завершенных процессов.</xref:System.Diagnostics.Process.Close%2A>"
  example:
  - See the code example for the <xref:System.Diagnostics.Process.ExitCode%2A> property.
  syntax:
    content: public bool WaitForExit (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "Количество времени, в миллисекундах для ожидания завершения связанного процесса. Максимальное значение — наибольшее возможное значение 32-разрядное целое число, которое представляет для операционной системы бесконечность."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если связанный процесс завершился; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForExit*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Не удается получить доступ к параметру ожидания."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "Процесс не <> </> *настроек задана и <> </> *настроек откуда <xref:System.Diagnostics.Process.Id*>можно определить свойство не существует.</xref:System.Diagnostics.Process.Id*>       - или - никакие процессы, связанные с этим <xref href=&quot;System.Diagnostics.Process&quot;> </xref> объекта.       - или - вы пытаетесь вызвать метод WaitForExit для процесса, запущенного на удаленном компьютере. Этот метод доступен только для процессов, запущенных на локальном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle
  id: WaitForInputIdle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Вызывает <xref href=&quot;System.Diagnostics.Process&quot;> </xref> компонента для неограниченного времени ожидания для связанного процесса в состояние простоя. Эта перегрузка применяется только к процессам с интерфейсом пользователя и, следовательно, цикл обработки сообщений."
  remarks: "Используйте WaitForInputIdle для принудительного выполнения приложение ожидает возвращения цикла сообщений в состояние бездействия. При выполнении процесса с пользовательским интерфейсом цикл сообщений выполняется каждый раз, посылает сообщение Windows для процесса операционной системой. Затем процесс возвращается в цикл обработки сообщений. Процесс считается в состоянии простоя при ожидании сообщения внутри цикла обработки сообщений. Это состояние полезно, например, когда приложению для ожидания запуска процесса завершить создание основного окна до взаимодействия приложения с этим окном.       Если процесс не имеет цикла обработки сообщений, WaitForInputIdle вызывает <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       Указывает, что перегрузка метода WaitForInputIdle <xref:System.Diagnostics.Process>компонента для неограниченного времени ожидания для процесса в состояние бездействия в цикл обработки сообщений.</xref:System.Diagnostics.Process> Эта инструкция может вызвать приложение перестает отвечать на запросы. Например, если процесс всегда записывается в сразу завершить работу цикла сообщений, как показано в фрагменте кода `while(true)`."
  syntax:
    content: public bool WaitForInputIdle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если связанный процесс достиг состояния простоя."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс не имеет графического интерфейса.       - или - произошла неизвестная ошибка. Процессу не удалось перейти в состояние бездействия.       - или - этот процесс уже завершился.       - или - процесс не связан с этим <xref href=&quot;System.Diagnostics.Process&quot;> </xref> объекта."
  platform:
  - net462
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  id: WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Вызывает <xref href=&quot;System.Diagnostics.Process&quot;> </xref> команду ожидать указанное число миллисекунд для связанного процесса в состояние простоя. Эта перегрузка применяется только к процессам с интерфейсом пользователя и, следовательно, цикл обработки сообщений."
  remarks: "Используйте WaitForInputIdle для принудительного выполнения приложение ожидает возвращения цикла сообщений в состояние бездействия. При выполнении процесса с пользовательским интерфейсом цикл сообщений выполняется каждый раз, посылает сообщение Windows для процесса операционной системой. Затем процесс возвращается в цикл обработки сообщений. Процесс считается в состоянии простоя при ожидании сообщения внутри цикла обработки сообщений. Это состояние полезно, например, когда приложению для ожидания запуска процесса завершить создание основного окна до взаимодействия приложения с этим окном.       Если процесс не имеет цикла обработки сообщений, WaitForInputIdle вызывает <xref:System.InvalidOperationException>.</xref:System.InvalidOperationException>       Указывает, что перегрузка метода WaitForInputIdle <xref:System.Diagnostics.Process>компоненту ожидать конечное количество времени для процесса в состояние бездействия в цикл обработки сообщений.</xref:System.Diagnostics.Process> Если связанный процесс имеет переходит в состояние простоя в конце интервала, так как цикл обработки сообщений, `false` возвращается в вызывающую процедуру.       Дополнительные сведения об обработке событий см. в разделе [события](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public bool WaitForInputIdle (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "Значение от 1 до <xref:System.Int32>задает количество времени, в миллисекундах для ожидания перехода связанного процесса в состояние бездействия.</xref:System.Int32> Значение 0 указывает немедленный возврат, а значение -1 указывает на бесконечное ожидание."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если связанный процесс достиг состояния простоя; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.Process.WaitForInputIdle*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Процесс не имеет графического интерфейса.       - или - произошла неизвестная ошибка. Процессу не удалось перейти в состояние бездействия.       - или - этот процесс уже завершился.       - или - процесс не связан с этим <xref href=&quot;System.Diagnostics.Process&quot;> </xref> объекта."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet
  id: WorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает использование физической памяти связанного процесса в байтах."
  remarks: "Значение, возвращаемое этим свойством, представляет текущий размер памяти рабочего множества используемой процессом, в байтах. Рабочий набор процесса — набор страниц, доступных процессу в физической Оперативной памяти. Эти страницы находятся в памяти и доступны для приложения для использования без создания сбоя страницы.       Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая модули процессов и библиотеки системы."
  example:
  - "The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process' exit code.  \n  \n [!code-vb[process_sample#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_40_1.vb)]\n [!code-cpp[process_sample#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_40_1.cpp)]\n [!code-cs[process_sample#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_40_1.cs)]"
  syntax:
    content: public int WorkingSet { get; }
    return:
      type: System.Int32
      description: "Общий объем физической памяти связанного процесса использует, в байтах."
  overload: System.Diagnostics.Process.WorkingSet*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
- uid: System.Diagnostics.Process.WorkingSet64
  id: WorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает объем физической памяти в байтах, выделенной для связанного процесса."
  remarks: "Значение, возвращаемое этим свойством, представляет текущий размер памяти рабочего множества используемой процессом, в байтах. Рабочий набор процесса — набор страниц, доступных процессу в физической Оперативной памяти. Эти страницы находятся в памяти и доступны для приложения для использования без создания сбоя страницы.       Рабочее множество включает общие и закрытые данные. Общие данные включают страницы, содержащие все инструкции, выполняемые процессом, включая инструкции в модулях процесса и библиотеки системы.       Это свойство может использоваться для мониторинга использования памяти на компьютерах с процессорами 32-разрядной или 64-разрядных процессоров. Значение свойства эквивалентно **рабочее множество** счетчика производительности для процесса."
  example:
  - "The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.  \n  \n [!code-cpp[Diag_Process_MemoryProperties64#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_32_1.cpp)]\n [!code-cs[Diag_Process_MemoryProperties64#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_32_1.cs)]\n [!code-vb[Diag_Process_MemoryProperties64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_32_1.vb)]"
  syntax:
    content: public long WorkingSet64 { get; }
    return:
      type: System.Int64
      description: "Объем физической памяти в байтах, выделенной для связанного процесса."
  overload: System.Diagnostics.Process.WorkingSet64*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Windows Me), которая не поддерживает это свойство."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.Diagnostics.Process.#ctor
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process()
  nameWithType: Process.Process()
  fullName: System.Diagnostics.Process.Process()
- uid: System.Diagnostics.Process.BasePriority
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
  fullName: System.Diagnostics.Process.BasePriority
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.Process.BeginErrorReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine()
  nameWithType: Process.BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
- uid: System.Diagnostics.Process.BeginOutputReadLine
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine()
  nameWithType: Process.BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
- uid: System.Diagnostics.Process.CancelErrorRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead()
  nameWithType: Process.CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
- uid: System.Diagnostics.Process.CancelOutputRead
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead()
  nameWithType: Process.CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
- uid: System.Diagnostics.Process.Close
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close()
  nameWithType: Process.Close()
  fullName: System.Diagnostics.Process.Close()
- uid: System.Diagnostics.Process.CloseMainWindow
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow()
  nameWithType: Process.CloseMainWindow()
  fullName: System.Diagnostics.Process.CloseMainWindow()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Process.Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(Boolean)
- uid: System.Diagnostics.Process.EnableRaisingEvents
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode()
  nameWithType: Process.EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
- uid: System.Diagnostics.Process.ErrorDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: ErrorDataReceived
  nameWithType: Process.ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
- uid: System.Diagnostics.DataReceivedEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: DataReceivedEventHandler
  nameWithType: DataReceivedEventHandler
  fullName: System.Diagnostics.DataReceivedEventHandler
- uid: System.Diagnostics.Process.ExitCode
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
  fullName: System.Diagnostics.Process.ExitCode
- uid: System.Diagnostics.Process.Exited
  parent: System.Diagnostics.Process
  isExternal: false
  name: Exited
  nameWithType: Process.Exited
  fullName: System.Diagnostics.Process.Exited
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Diagnostics.Process.ExitTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
  fullName: System.Diagnostics.Process.ExitTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Diagnostics.Process.GetCurrentProcess
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess()
  nameWithType: Process.GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
- uid: System.Diagnostics.Process
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32)
  nameWithType: Process.GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(Int32)
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById(Int32,String)
  nameWithType: Process.GetProcessById(Int32,String)
  fullName: System.Diagnostics.Process.GetProcessById(Int32,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.Process.GetProcesses
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses()
  nameWithType: Process.GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
- uid: System.Diagnostics.Process[]
  parent: System.Diagnostics
  isExternal: false
  name: Process
  nameWithType: Process
  fullName: System.Diagnostics.Process[]
  spec.csharp:
  - uid: System.Diagnostics.Process
    name: Process
    nameWithType: Process
    fullName: Process[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses(String)
  nameWithType: Process.GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String)
  nameWithType: Process.GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String)
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName(String,String)
  nameWithType: Process.GetProcessesByName(String,String)
  fullName: System.Diagnostics.Process.GetProcessesByName(String,String)
- uid: System.Diagnostics.Process.Handle
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
  fullName: System.Diagnostics.Process.Handle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.Process.HandleCount
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
  fullName: System.Diagnostics.Process.HandleCount
- uid: System.Diagnostics.Process.HasExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
  fullName: System.Diagnostics.Process.HasExited
- uid: System.Diagnostics.Process.Id
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
  fullName: System.Diagnostics.Process.Id
- uid: System.Diagnostics.Process.Kill
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill()
  nameWithType: Process.Kill()
  fullName: System.Diagnostics.Process.Kill()
- uid: System.Diagnostics.Process.LeaveDebugMode
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode()
  nameWithType: Process.LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
- uid: System.Diagnostics.Process.MachineName
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
  fullName: System.Diagnostics.Process.MachineName
- uid: System.Diagnostics.Process.MainModule
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
  fullName: System.Diagnostics.Process.MainModule
- uid: System.Diagnostics.ProcessModule
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModule
  nameWithType: ProcessModule
  fullName: System.Diagnostics.ProcessModule
- uid: System.Diagnostics.Process.MainWindowHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
  fullName: System.Diagnostics.Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
  fullName: System.Diagnostics.Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
  fullName: System.Diagnostics.Process.Modules
- uid: System.Diagnostics.ProcessModuleCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModuleCollection
  nameWithType: ProcessModuleCollection
  fullName: System.Diagnostics.ProcessModuleCollection
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.Process.OnExited
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited()
  nameWithType: Process.OnExited()
  fullName: System.Diagnostics.Process.OnExited()
- uid: System.Diagnostics.Process.OutputDataReceived
  parent: System.Diagnostics.Process
  isExternal: false
  name: OutputDataReceived
  nameWithType: Process.OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
- uid: System.Diagnostics.Process.PagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
  fullName: System.Diagnostics.Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
  fullName: System.Diagnostics.Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
  fullName: System.Diagnostics.Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
  fullName: System.Diagnostics.Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
- uid: System.Diagnostics.ProcessPriorityClass
  parent: System.Diagnostics
  isExternal: false
  name: ProcessPriorityClass
  nameWithType: ProcessPriorityClass
  fullName: System.Diagnostics.ProcessPriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
  fullName: System.Diagnostics.Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Diagnostics.Process.ProcessName
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
  fullName: System.Diagnostics.Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh()
  nameWithType: Process.Refresh()
  fullName: System.Diagnostics.Process.Refresh()
- uid: System.Diagnostics.Process.Responding
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
  fullName: System.Diagnostics.Process.Responding
- uid: System.Diagnostics.Process.SafeHandle
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
- uid: Microsoft.Win32.SafeHandles.SafeProcessHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeProcessHandle
  nameWithType: SafeProcessHandle
  fullName: Microsoft.Win32.SafeHandles.SafeProcessHandle
- uid: System.Diagnostics.Process.SessionId
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
  fullName: System.Diagnostics.Process.SessionId
- uid: System.Diagnostics.Process.StandardError
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
  fullName: System.Diagnostics.Process.StandardError
- uid: System.IO.StreamReader
  parent: System.IO
  isExternal: true
  name: StreamReader
  nameWithType: StreamReader
  fullName: System.IO.StreamReader
- uid: System.Diagnostics.Process.StandardInput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
  fullName: System.Diagnostics.Process.StandardInput
- uid: System.IO.StreamWriter
  parent: System.IO
  isExternal: true
  name: StreamWriter
  nameWithType: StreamWriter
  fullName: System.IO.StreamWriter
- uid: System.Diagnostics.Process.StandardOutput
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
- uid: System.Diagnostics.Process.Start
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start()
  nameWithType: Process.Start()
  fullName: System.Diagnostics.Process.Start()
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(ProcessStartInfo)
  nameWithType: Process.Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(ProcessStartInfo)
- uid: System.Diagnostics.ProcessStartInfo
  parent: System.Diagnostics
  isExternal: false
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
- uid: System.Diagnostics.Process.Start(System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String)
  nameWithType: Process.Start(String)
  fullName: System.Diagnostics.Process.Start(String)
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String)
  nameWithType: Process.Start(String,String)
  fullName: System.Diagnostics.Process.Start(String,String)
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,SecureString,String)
  nameWithType: Process.Start(String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,SecureString,String)
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start(String,String,String,SecureString,String)
  nameWithType: Process.Start(String,String,String,SecureString,String)
  fullName: System.Diagnostics.Process.Start(String,String,String,SecureString,String)
- uid: System.Diagnostics.Process.StartInfo
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
  fullName: System.Diagnostics.Process.StartInfo
- uid: System.Diagnostics.Process.StartTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
  fullName: System.Diagnostics.Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
  fullName: System.Diagnostics.Process.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.Process.Threads
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
  fullName: System.Diagnostics.Process.Threads
- uid: System.Diagnostics.ProcessThreadCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessThreadCollection
  nameWithType: ProcessThreadCollection
  fullName: System.Diagnostics.ProcessThreadCollection
- uid: System.Diagnostics.Process.ToString
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString()
  nameWithType: Process.ToString()
  fullName: System.Diagnostics.Process.ToString()
- uid: System.Diagnostics.Process.TotalProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
  fullName: System.Diagnostics.Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit()
  nameWithType: Process.WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit(Int32)
  nameWithType: Process.WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(Int32)
- uid: System.Diagnostics.Process.WaitForInputIdle
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle()
  nameWithType: Process.WaitForInputIdle()
  fullName: System.Diagnostics.Process.WaitForInputIdle()
- uid: System.Diagnostics.Process.WaitForInputIdle(System.Int32)
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle(Int32)
  nameWithType: Process.WaitForInputIdle(Int32)
  fullName: System.Diagnostics.Process.WaitForInputIdle(Int32)
- uid: System.Diagnostics.Process.WorkingSet
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
  fullName: System.Diagnostics.Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
- uid: System.Diagnostics.Process.#ctor*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Process
  nameWithType: Process.Process
- uid: System.Diagnostics.Process.BasePriority*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BasePriority
  nameWithType: Process.BasePriority
- uid: System.Diagnostics.Process.BeginErrorReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginErrorReadLine
  nameWithType: Process.BeginErrorReadLine
- uid: System.Diagnostics.Process.BeginOutputReadLine*
  parent: System.Diagnostics.Process
  isExternal: false
  name: BeginOutputReadLine
  nameWithType: Process.BeginOutputReadLine
- uid: System.Diagnostics.Process.CancelErrorRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelErrorRead
  nameWithType: Process.CancelErrorRead
- uid: System.Diagnostics.Process.CancelOutputRead*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CancelOutputRead
  nameWithType: Process.CancelOutputRead
- uid: System.Diagnostics.Process.Close*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Close
  nameWithType: Process.Close
- uid: System.Diagnostics.Process.CloseMainWindow*
  parent: System.Diagnostics.Process
  isExternal: false
  name: CloseMainWindow
  nameWithType: Process.CloseMainWindow
- uid: System.Diagnostics.Process.Dispose*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Dispose
  nameWithType: Process.Dispose
- uid: System.Diagnostics.Process.EnableRaisingEvents*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: Process.EnableRaisingEvents
- uid: System.Diagnostics.Process.EnterDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: EnterDebugMode
  nameWithType: Process.EnterDebugMode
- uid: System.Diagnostics.Process.ExitCode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitCode
  nameWithType: Process.ExitCode
- uid: System.Diagnostics.Process.ExitTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ExitTime
  nameWithType: Process.ExitTime
- uid: System.Diagnostics.Process.GetCurrentProcess*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetCurrentProcess
  nameWithType: Process.GetCurrentProcess
- uid: System.Diagnostics.Process.GetProcessById*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessById
  nameWithType: Process.GetProcessById
- uid: System.Diagnostics.Process.GetProcesses*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcesses
  nameWithType: Process.GetProcesses
- uid: System.Diagnostics.Process.GetProcessesByName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: GetProcessesByName
  nameWithType: Process.GetProcessesByName
- uid: System.Diagnostics.Process.Handle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Handle
  nameWithType: Process.Handle
- uid: System.Diagnostics.Process.HandleCount*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HandleCount
  nameWithType: Process.HandleCount
- uid: System.Diagnostics.Process.HasExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: HasExited
  nameWithType: Process.HasExited
- uid: System.Diagnostics.Process.Id*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Id
  nameWithType: Process.Id
- uid: System.Diagnostics.Process.Kill*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Kill
  nameWithType: Process.Kill
- uid: System.Diagnostics.Process.LeaveDebugMode*
  parent: System.Diagnostics.Process
  isExternal: false
  name: LeaveDebugMode
  nameWithType: Process.LeaveDebugMode
- uid: System.Diagnostics.Process.MachineName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MachineName
  nameWithType: Process.MachineName
- uid: System.Diagnostics.Process.MainModule*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainModule
  nameWithType: Process.MainModule
- uid: System.Diagnostics.Process.MainWindowHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowHandle
  nameWithType: Process.MainWindowHandle
- uid: System.Diagnostics.Process.MainWindowTitle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MainWindowTitle
  nameWithType: Process.MainWindowTitle
- uid: System.Diagnostics.Process.MaxWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MaxWorkingSet
  nameWithType: Process.MaxWorkingSet
- uid: System.Diagnostics.Process.MinWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: MinWorkingSet
  nameWithType: Process.MinWorkingSet
- uid: System.Diagnostics.Process.Modules*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Modules
  nameWithType: Process.Modules
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize
  nameWithType: Process.NonpagedSystemMemorySize
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: NonpagedSystemMemorySize64
  nameWithType: Process.NonpagedSystemMemorySize64
- uid: System.Diagnostics.Process.OnExited*
  parent: System.Diagnostics.Process
  isExternal: false
  name: OnExited
  nameWithType: Process.OnExited
- uid: System.Diagnostics.Process.PagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize
  nameWithType: Process.PagedMemorySize
- uid: System.Diagnostics.Process.PagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedMemorySize64
  nameWithType: Process.PagedMemorySize64
- uid: System.Diagnostics.Process.PagedSystemMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize
  nameWithType: Process.PagedSystemMemorySize
- uid: System.Diagnostics.Process.PagedSystemMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PagedSystemMemorySize64
  nameWithType: Process.PagedSystemMemorySize64
- uid: System.Diagnostics.Process.PeakPagedMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize
  nameWithType: Process.PeakPagedMemorySize
- uid: System.Diagnostics.Process.PeakPagedMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakPagedMemorySize64
  nameWithType: Process.PeakPagedMemorySize64
- uid: System.Diagnostics.Process.PeakVirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize
  nameWithType: Process.PeakVirtualMemorySize
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakVirtualMemorySize64
  nameWithType: Process.PeakVirtualMemorySize64
- uid: System.Diagnostics.Process.PeakWorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet
  nameWithType: Process.PeakWorkingSet
- uid: System.Diagnostics.Process.PeakWorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PeakWorkingSet64
  nameWithType: Process.PeakWorkingSet64
- uid: System.Diagnostics.Process.PriorityBoostEnabled*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: Process.PriorityBoostEnabled
- uid: System.Diagnostics.Process.PriorityClass*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PriorityClass
  nameWithType: Process.PriorityClass
- uid: System.Diagnostics.Process.PrivateMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize
  nameWithType: Process.PrivateMemorySize
- uid: System.Diagnostics.Process.PrivateMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivateMemorySize64
  nameWithType: Process.PrivateMemorySize64
- uid: System.Diagnostics.Process.PrivilegedProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: Process.PrivilegedProcessorTime
- uid: System.Diagnostics.Process.ProcessName*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessName
  nameWithType: Process.ProcessName
- uid: System.Diagnostics.Process.ProcessorAffinity*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ProcessorAffinity
  nameWithType: Process.ProcessorAffinity
- uid: System.Diagnostics.Process.Refresh*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Refresh
  nameWithType: Process.Refresh
- uid: System.Diagnostics.Process.Responding*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Responding
  nameWithType: Process.Responding
- uid: System.Diagnostics.Process.SafeHandle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SafeHandle
  nameWithType: Process.SafeHandle
- uid: System.Diagnostics.Process.SessionId*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SessionId
  nameWithType: Process.SessionId
- uid: System.Diagnostics.Process.StandardError*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardError
  nameWithType: Process.StandardError
- uid: System.Diagnostics.Process.StandardInput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardInput
  nameWithType: Process.StandardInput
- uid: System.Diagnostics.Process.StandardOutput*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StandardOutput
  nameWithType: Process.StandardOutput
- uid: System.Diagnostics.Process.Start*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Start
  nameWithType: Process.Start
- uid: System.Diagnostics.Process.StartInfo*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartInfo
  nameWithType: Process.StartInfo
- uid: System.Diagnostics.Process.StartTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: StartTime
  nameWithType: Process.StartTime
- uid: System.Diagnostics.Process.SynchronizingObject*
  parent: System.Diagnostics.Process
  isExternal: false
  name: SynchronizingObject
  nameWithType: Process.SynchronizingObject
- uid: System.Diagnostics.Process.Threads*
  parent: System.Diagnostics.Process
  isExternal: false
  name: Threads
  nameWithType: Process.Threads
- uid: System.Diagnostics.Process.ToString*
  parent: System.Diagnostics.Process
  isExternal: false
  name: ToString
  nameWithType: Process.ToString
- uid: System.Diagnostics.Process.TotalProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: TotalProcessorTime
  nameWithType: Process.TotalProcessorTime
- uid: System.Diagnostics.Process.UserProcessorTime*
  parent: System.Diagnostics.Process
  isExternal: false
  name: UserProcessorTime
  nameWithType: Process.UserProcessorTime
- uid: System.Diagnostics.Process.VirtualMemorySize*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize
  nameWithType: Process.VirtualMemorySize
- uid: System.Diagnostics.Process.VirtualMemorySize64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: VirtualMemorySize64
  nameWithType: Process.VirtualMemorySize64
- uid: System.Diagnostics.Process.WaitForExit*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForExit
  nameWithType: Process.WaitForExit
- uid: System.Diagnostics.Process.WaitForInputIdle*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WaitForInputIdle
  nameWithType: Process.WaitForInputIdle
- uid: System.Diagnostics.Process.WorkingSet*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet
  nameWithType: Process.WorkingSet
- uid: System.Diagnostics.Process.WorkingSet64*
  parent: System.Diagnostics.Process
  isExternal: false
  name: WorkingSet64
  nameWithType: Process.WorkingSet64
