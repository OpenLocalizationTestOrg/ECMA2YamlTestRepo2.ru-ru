### YamlMime:ManagedReference
items:
- uid: System.Messaging.Message
  id: Message
  children:
  - System.Messaging.Message.#ctor
  - System.Messaging.Message.#ctor(System.Object)
  - System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)
  - System.Messaging.Message.AcknowledgeType
  - System.Messaging.Message.Acknowledgment
  - System.Messaging.Message.AdministrationQueue
  - System.Messaging.Message.AppSpecific
  - System.Messaging.Message.ArrivedTime
  - System.Messaging.Message.AttachSenderId
  - System.Messaging.Message.Authenticated
  - System.Messaging.Message.AuthenticationProviderName
  - System.Messaging.Message.AuthenticationProviderType
  - System.Messaging.Message.Body
  - System.Messaging.Message.BodyStream
  - System.Messaging.Message.BodyType
  - System.Messaging.Message.ConnectorType
  - System.Messaging.Message.CorrelationId
  - System.Messaging.Message.DestinationQueue
  - System.Messaging.Message.DestinationSymmetricKey
  - System.Messaging.Message.DigitalSignature
  - System.Messaging.Message.EncryptionAlgorithm
  - System.Messaging.Message.Extension
  - System.Messaging.Message.Formatter
  - System.Messaging.Message.HashAlgorithm
  - System.Messaging.Message.Id
  - System.Messaging.Message.InfiniteTimeout
  - System.Messaging.Message.IsFirstInTransaction
  - System.Messaging.Message.IsLastInTransaction
  - System.Messaging.Message.Label
  - System.Messaging.Message.LookupId
  - System.Messaging.Message.MessageType
  - System.Messaging.Message.Priority
  - System.Messaging.Message.Recoverable
  - System.Messaging.Message.ResponseQueue
  - System.Messaging.Message.SecurityContext
  - System.Messaging.Message.SenderCertificate
  - System.Messaging.Message.SenderId
  - System.Messaging.Message.SenderVersion
  - System.Messaging.Message.SentTime
  - System.Messaging.Message.SourceMachine
  - System.Messaging.Message.TimeToBeReceived
  - System.Messaging.Message.TimeToReachQueue
  - System.Messaging.Message.TransactionId
  - System.Messaging.Message.TransactionStatusQueue
  - System.Messaging.Message.UseAuthentication
  - System.Messaging.Message.UseDeadLetterQueue
  - System.Messaging.Message.UseEncryption
  - System.Messaging.Message.UseJournalQueue
  - System.Messaging.Message.UseTracing
  langs:
  - csharp
  name: Message
  nameWithType: Message
  fullName: System.Messaging.Message
  type: Class
  summary: "Предоставляет доступ к свойствам, необходимым для задания сообщения Message Queuing."
  remarks: "Чтобы просматривать и получать сообщения из очереди или для детального управления свойствами сообщения при отправке сообщения в очередь, использующие класс Message.       <xref:System.Messaging.MessageQueue>использует класс сообщений при чтении или получении сообщений из очереди, так как оба <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=fullName>и <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=fullName>методы создания нового экземпляра класса сообщений и задайте свойства этого экземпляра.</xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=fullName> </xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=fullName></xref:System.Messaging.MessageQueue> Свойства только для чтения класса сообщений применяются для извлечения сообщений из очереди, то время как свойства чтения/записи относятся к отправке и получении сообщений. Когда <xref:System.Messaging.MessageQueue>просматривает или получает сообщение из очереди, его <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>свойство определяет, какие из свойств сообщений берутся.</xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> </xref:System.Messaging.MessageQueue>       <xref:System.Messaging.MessageQueue>Класса <xref:System.Messaging.MessageQueue.Send%2A>метод позволяет указать любой тип объекта для сообщения, передаваемого в эту очередь.</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.MessageQueue> Можно использовать <xref:System.Messaging.MessageQueue>экземпляра <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>для описания параметров универсальных сообщений, отправленных в очередь.</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> </xref:System.Messaging.MessageQueue> Типы параметров включают модуль форматирования, метку, шифрование и проверку подлинности. Можно также указать значения для соответствующих <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>членов при координации приложения обмена сообщениями для обработки сообщений подтверждения и отчетов.</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> С помощью экземпляра сообщения для отправки сообщения в очередь обеспечивает гибкость доступа и изменения многие из этих свойств — для одного сообщения, либо на основе сообщений. Свойства сообщения имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>       Данные сообщения хранятся в <xref:System.Messaging.Message.Body%2A>свойство и в меньшей степени <xref:System.Messaging.Message.AppSpecific%2A>и <xref:System.Messaging.Message.Extension%2A>Свойства.</xref:System.Messaging.Message.Extension%2A> </xref:System.Messaging.Message.AppSpecific%2A> </xref:System.Messaging.Message.Body%2A> Когда данные сообщения шифруются, сериализуемых или десериализуемых, только содержимое <xref:System.Messaging.Message.Body%2A>влияет свойство.</xref:System.Messaging.Message.Body%2A>       Содержимое <xref:System.Messaging.Message.Body%2A>свойства сериализуются в том случае, когда сообщение отправляется с использованием <xref:System.Messaging.Message.Formatter%2A>свойство, указанное.</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A> Сериализованное содержимое находится в <xref:System.Messaging.Message.BodyStream%2A>свойство.</xref:System.Messaging.Message.BodyStream%2A> Можно также задать <xref:System.Messaging.Message.BodyStream%2A>свойство напрямую, например, чтобы отправить файл как содержимое данных сообщения.</xref:System.Messaging.Message.BodyStream%2A> Вы можете изменить <xref:System.Messaging.Message.Body%2A>или <xref:System.Messaging.Message.Formatter%2A>в любое время перед отправкой сообщения и данные будут сериализованы свойства соответствующим образом при вызове <xref:System.Messaging.MessageQueue.Send%2A>.</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A>       Свойства, определенные <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=fullName>свойство применяется только к сообщениям, которые не относятся к типу сообщений.</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=fullName> При указании <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>свойство <xref:System.Messaging.MessageQueue>, таким же именем свойства в экземпляр сообщения, передаваемого в очередь вызывают эти свойства по умолчанию пропускаются.</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>       Список начальных значений свойств для экземпляра класса сообщений см. в разделе <xref:System.Messaging.Message.%23ctor%2A>конструктор.</xref:System.Messaging.Message.%23ctor%2A>"
  example:
  - "The following code example demonstrates formatting a message body using <xref:System.Messaging.BinaryMessageFormatter>.  \n  \n [!code-cpp[MessagingBinaryFormatter#1](~/add/codesnippet/cpp/t-system.messaging.message_1.cpp)]\n [!code-cs[MessagingBinaryFormatter#1](~/add/codesnippet/csharp/t-system.messaging.message_1.cs)]\n [!code-vb[MessagingBinaryFormatter#1](~/add/codesnippet/visualbasic/t-system.messaging.message_1.vb)]  \n  \n The following code example demonstrates formatting a message body using <xref:System.Messaging.XmlMessageFormatter>.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/t-system.messaging.message_2.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/t-system.messaging.message_2.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/t-system.messaging.message_2.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      public class Message : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Dispose(System.Boolean)
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Messaging.Message.#ctor
  id: '#ctor'
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Message()
  nameWithType: Message.Message()
  fullName: System.Messaging.Message.Message()
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Messaging.Message&quot;> </xref> класса с пустым телом."
  remarks: "Используйте этот перегруженный метод для создания нового экземпляра <xref:System.Messaging.Message>класс с пустым телом.</xref:System.Messaging.Message>       Укажите либо <xref:System.Messaging.Message.Body%2A>свойство или <xref:System.Messaging.Message.BodyStream%2A>до передачи <xref:System.Messaging.Message>объекта.</xref:System.Messaging.Message> </xref:System.Messaging.Message.BodyStream%2A> </xref:System.Messaging.Message.Body%2A> <xref:System.Messaging.Message.Body%2A>Свойство может быть любой объект, который может быть сериализован, например текстовая строка, структурный объект, экземпляр класса или внедренный объект.</xref:System.Messaging.Message.Body%2A>       Если содержимое сообщения записывается непосредственно в <xref:System.Messaging.Message.BodyStream%2A>свойстве <xref:System.Messaging.Message.Formatter%2A>перед передачей сообщения.</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.BodyStream%2A> Текст сериализуется с помощью <xref:System.Messaging.Message.Formatter%2A>значения свойства во время <xref:System.Messaging.MessageQueue.Send%2A>метод будет вызван на <xref:System.Messaging.MessageQueue>экземпляра.</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A>       <xref:System.Messaging.XmlMessageFormatter>Слабо связанный, поэтому нет необходимости иметь объект того же типа на отправителя и получателя, при применении этого формата.</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>И <xref:System.Messaging.BinaryMessageFormatter>сериализации данных в двоичное представление.</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>Используется при отправке и получении COM-компонентов.</xref:System.Messaging.ActiveXMessageFormatter>       В следующей таблице показаны исходные значения свойств для экземпляра класса <xref:System.Messaging.Message>.</xref:System.Messaging.Message>      | Свойство | Начальное значение |   |--------------|-------------------|   | <xref:System.Messaging.Message.AcknowledgeType%2A>| `AcknowledgeType.None`|   | <xref:System.Messaging.Message.AdministrationQueue%2A>| `null`|   | <xref:System.Messaging.Message.AppSpecific%2A>|0|   | <xref:System.Messaging.Message.AttachSenderId%2A>| `true`|   | <xref:System.Messaging.Message.AuthenticationProviderName%2A>| Microsoft Base Cryptographic Provider версии 1.0 |   | <xref:System.Messaging.Message.AuthenticationProviderType%2A>| `CryptoProviderType.RSA_FULL`|   | <xref:System.Messaging.Message.Body%2A>| `null`|   | <xref:System.Messaging.Message.BodyStream%2A>| `Stream.null`|   | <xref:System.Messaging.Message.BodyType%2A>|0|   | <xref:System.Messaging.Message.ConnectorType%2A>| `Guid.Empty`|   | <xref:System.Messaging.Message.CorrelationId%2A>| Пустая строка (»») |   | <xref:System.Messaging.Message.DestinationSymmetricKey%2A>| Массив байтов нулевой длины |   | <xref:System.Messaging.Message.DigitalSignature%2A>| Массив байтов нулевой длины |   | <xref:System.Messaging.Message.EncryptionAlgorithm%2A>| `EncryptionAlgorithm.RC2`|   | <xref:System.Messaging.Message.Extension%2A>| Массив байтов нулевой длины |   | <xref:System.Messaging.Message.Formatter%2A>| `XmlMessageFormatter`|   | <xref:System.Messaging.Message.HashAlgorithm%2A>| `HashAlgorithm.MD5`|   | <xref:System.Messaging.Message.Label%2A>| Пустая строка (»») |   | <xref:System.Messaging.Message.Priority%2A>| `MessagePriority.Normal`|   | <xref:System.Messaging.Message.Recoverable%2A>| `false`|   | <xref:System.Messaging.Message.ResponseQueue%2A>| `null`|   | <xref:System.Messaging.Message.SenderCertificate%2A>| Массив байтов нулевой длины |   | <xref:System.Messaging.Message.TimeToBeReceived%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TimeToReachQueue%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TransactionStatusQueue%2A>| `null`|   | <xref:System.Messaging.Message.UseAuthentication%2A>| `false`|   | <xref:System.Messaging.Message.UseDeadLetterQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseEncryption%2A>| `false`|   | <xref:System.Messaging.Message.UseJournalQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseTracing%2A>| `false`|</xref:System.Messaging.Message.UseTracing%2A></xref:System.Messaging.Message.UseJournalQueue%2A></xref:System.Messaging.Message.UseEncryption%2A></xref:System.Messaging.Message.UseDeadLetterQueue%2A></xref:System.Messaging.Message.UseAuthentication%2A></xref:System.Messaging.Message.TransactionStatusQueue%2A></xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A></xref:System.Messaging.Message.SenderCertificate%2A></xref:System.Messaging.Message.ResponseQueue%2A></xref:System.Messaging.Message.Recoverable%2A></xref:System.Messaging.Message.Priority%2A></xref:System.Messaging.Message.Label%2A></xref:System.Messaging.Message.HashAlgorithm%2A></xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Extension%2A></xref:System.Messaging.Message.EncryptionAlgorithm%2A></xref:System.Messaging.Message.DigitalSignature%2A></xref:System.Messaging.Message.DestinationSymmetricKey%2A></xref:System.Messaging.Message.CorrelationId%2A></xref:System.Messaging.Message.ConnectorType%2A></xref:System.Messaging.Message.BodyType%2A></xref:System.Messaging.Message.BodyStream%2A></xref:System.Messaging.Message.Body%2A></xref:System.Messaging.Message.AuthenticationProviderType%2A></xref:System.Messaging.Message.AuthenticationProviderName%2A></xref:System.Messaging.Message.AttachSenderId%2A></xref:System.Messaging.Message.AppSpecific%2A></xref:System.Messaging.Message.AdministrationQueue%2A></xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - "The following code example sends two messages of different priorities to the queue, and retrieves them subsequently.  \n  \n [!code-cpp[Message.DefaultPropertiesToSend#1](~/add/codesnippet/cpp/m-system.messaging.messa_16_1.cpp)]\n [!code-vb[Message.DefaultPropertiesToSend#1](~/add/codesnippet/visualbasic/m-system.messaging.messa_16_1.vb)]\n [!code-cs[Message.DefaultPropertiesToSend#1](~/add/codesnippet/csharp/m-system.messaging.messa_16_1.cs)]"
  syntax:
    content: public Message ();
    parameters: []
  overload: System.Messaging.Message.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.#ctor(System.Object)
  id: '#ctor(System.Object)'
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Message(Object)
  nameWithType: Message.Message(Object)
  fullName: System.Messaging.Message.Message(Object)
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Messaging.Message&quot;> </xref> класс с помощью <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref> для сериализации заданного объекта в текст сообщения."
  remarks: "Используйте этот перегруженный метод для создания нового экземпляра <xref:System.Messaging.Message>класс, содержащий <xref:System.Messaging.Message.Body%2A>заданные `body` параметр.</xref:System.Messaging.Message.Body%2A> </xref:System.Messaging.Message> `body` Параметр может быть любой объект, который может быть сериализован, например текстовая строка, структурный объект, экземпляр класса или внедренный объект. Текст сериализуется с помощью <xref:System.Messaging.XmlMessageFormatter>только после изменения <xref:System.Messaging.Message.Formatter%2A>свойства перед <xref:System.Messaging.Message>отправляется.</xref:System.Messaging.Message> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.XmlMessageFormatter> При изменении <xref:System.Messaging.Message.Body%2A>или <xref:System.Messaging.Message.Formatter%2A>в любой момент перед вызовом <xref:System.Messaging.MessageQueue.Send%2A>, сообщения сериализуются в соответствии с новым значением свойства.</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A>       <xref:System.Messaging.XmlMessageFormatter>Слабо связанный, поэтому нет необходимости иметь объект того же типа на отправителя и получателя, при применении этого формата.</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>И <xref:System.Messaging.BinaryMessageFormatter>сериализации данных в двоичное представление.</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>Используется при отправке и получении COM-компонентов.</xref:System.Messaging.ActiveXMessageFormatter>       В следующей таблице показаны исходные значения свойств для экземпляра класса <xref:System.Messaging.Message>.</xref:System.Messaging.Message>      | Свойство | Начальное значение |   |--------------|-------------------|   | <xref:System.Messaging.Message.AcknowledgeType%2A>| `AcknowledgeType.None`|   | <xref:System.Messaging.Message.AdministrationQueue%2A>| `null`|   | <xref:System.Messaging.Message.AppSpecific%2A>|0|   | <xref:System.Messaging.Message.AttachSenderId%2A>| `true`|   | <xref:System.Messaging.Message.AuthenticationProviderName%2A>| Microsoft Base Cryptographic Provider версии 1.0 |   | <xref:System.Messaging.Message.AuthenticationProviderType%2A>| `CryptoProviderType.RSA_FULL`|   | <xref:System.Messaging.Message.Body%2A>| `body` Параметр. |   | <xref:System.Messaging.Message.BodyStream%2A>| `Stream.null`|   | <xref:System.Messaging.Message.BodyType%2A>|0|   | <xref:System.Messaging.Message.ConnectorType%2A>| `Guid.Empty`|   | <xref:System.Messaging.Message.CorrelationId%2A>| Пустая строка (»») |   | <xref:System.Messaging.Message.DestinationSymmetricKey%2A>| Массив байтов нулевой длины |   | <xref:System.Messaging.Message.DigitalSignature%2A>| Массив байтов нулевой длины |   | <xref:System.Messaging.Message.EncryptionAlgorithm%2A>| `EncryptionAlgorithm.RC2`|   | <xref:System.Messaging.Message.Extension%2A>| Массив байтов нулевой длины |   | <xref:System.Messaging.Message.Formatter%2A>| `XmlMessageFormatter`|   | <xref:System.Messaging.Message.HashAlgorithm%2A>| `HashAlgorithm.MD5`|   | <xref:System.Messaging.Message.Label%2A>| Пустая строка (»») |   | <xref:System.Messaging.Message.Priority%2A>| `MessagePriority.Normal`|   | <xref:System.Messaging.Message.Recoverable%2A>| `false`|   | <xref:System.Messaging.Message.ResponseQueue%2A>| `null`|   | <xref:System.Messaging.Message.SenderCertificate%2A>| Массив байтов нулевой длины |   | <xref:System.Messaging.Message.TimeToBeReceived%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TimeToReachQueue%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TransactionStatusQueue%2A>| `null`|   | <xref:System.Messaging.Message.UseAuthentication%2A>| `false`|   | <xref:System.Messaging.Message.UseDeadLetterQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseEncryption%2A>| `false`|   | <xref:System.Messaging.Message.UseJournalQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseTracing%2A>| `false`|</xref:System.Messaging.Message.UseTracing%2A></xref:System.Messaging.Message.UseJournalQueue%2A></xref:System.Messaging.Message.UseEncryption%2A></xref:System.Messaging.Message.UseDeadLetterQueue%2A></xref:System.Messaging.Message.UseAuthentication%2A></xref:System.Messaging.Message.TransactionStatusQueue%2A></xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A></xref:System.Messaging.Message.SenderCertificate%2A></xref:System.Messaging.Message.ResponseQueue%2A></xref:System.Messaging.Message.Recoverable%2A></xref:System.Messaging.Message.Priority%2A></xref:System.Messaging.Message.Label%2A></xref:System.Messaging.Message.HashAlgorithm%2A></xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Extension%2A></xref:System.Messaging.Message.EncryptionAlgorithm%2A></xref:System.Messaging.Message.DigitalSignature%2A></xref:System.Messaging.Message.DestinationSymmetricKey%2A></xref:System.Messaging.Message.CorrelationId%2A></xref:System.Messaging.Message.ConnectorType%2A></xref:System.Messaging.Message.BodyType%2A></xref:System.Messaging.Message.BodyStream%2A></xref:System.Messaging.Message.Body%2A></xref:System.Messaging.Message.AuthenticationProviderType%2A></xref:System.Messaging.Message.AuthenticationProviderName%2A></xref:System.Messaging.Message.AttachSenderId%2A></xref:System.Messaging.Message.AppSpecific%2A></xref:System.Messaging.Message.AdministrationQueue%2A></xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - "The following code example creates a new queue, sends a message that contains an order to it, and then retrieves it.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/m-system.messaging.messa_33_1.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/m-system.messaging.messa_33_1.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/m-system.messaging.messa_33_1.vb)]"
  syntax:
    content: public Message (object body);
    parameters:
    - id: body
      type: System.Object
      description: "Объект, который сериализуется в текст сообщения."
  overload: System.Messaging.Message.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)
  id: '#ctor(System.Object,System.Messaging.IMessageFormatter)'
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Message(Object,IMessageFormatter)
  nameWithType: Message.Message(Object,IMessageFormatter)
  fullName: System.Messaging.Message.Message(Object,IMessageFormatter)
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Messaging.Message&quot;> </xref> класса с помощью заданного модуля форматирования для сериализации заданного объекта в текст сообщения."
  remarks: "Используйте этот перегруженный метод для создания нового экземпляра <xref:System.Messaging.Message>класс, содержащий <xref:System.Messaging.Message.Body%2A>заданные `body` , с применением любого допустимого форматера для сериализации текста сообщения.</xref:System.Messaging.Message.Body%2A> </xref:System.Messaging.Message> `body` Параметр — это любой объект, который может быть сериализован, например текстовая строка, структурный объект, экземпляр класса или внедренный объект. При изменении <xref:System.Messaging.Message.Body%2A>или <xref:System.Messaging.Message.Formatter%2A>в любой момент перед вызовом <xref:System.Messaging.MessageQueue.Send%2A>, сообщения сериализуются в соответствии с новым значением свойства.</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A>       <xref:System.Messaging.XmlMessageFormatter>Слабо связанный, поэтому нет необходимости иметь объект того же типа на отправителя и получателя, при применении этого формата.</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>И <xref:System.Messaging.BinaryMessageFormatter>сериализации данных в двоичное представление.</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>Используется при отправке и получении COM-компонентов.</xref:System.Messaging.ActiveXMessageFormatter>       В следующей таблице показаны исходные значения свойств для экземпляра класса <xref:System.Messaging.Message>.</xref:System.Messaging.Message>      | Свойство | Начальное значение |   |--------------|-------------------|   | <xref:System.Messaging.Message.AcknowledgeType%2A>| `AcknowledgeType.None`|   | <xref:System.Messaging.Message.AdministrationQueue%2A>| `null`|   | <xref:System.Messaging.Message.AppSpecific%2A>|0|   | <xref:System.Messaging.Message.AttachSenderId%2A>| `true`|   | <xref:System.Messaging.Message.AuthenticationProviderName%2A>| Microsoft Base Cryptographic Provider версии 1.0 |   | <xref:System.Messaging.Message.AuthenticationProviderType%2A>| `CryptoProviderType.RSA_FULL`|   | <xref:System.Messaging.Message.Body%2A>| `body` Параметр. |   | <xref:System.Messaging.Message.BodyStream%2A>| `Stream.null`|   | <xref:System.Messaging.Message.BodyType%2A>|0|   | <xref:System.Messaging.Message.ConnectorType%2A>| `Guid.Empty`|   | <xref:System.Messaging.Message.CorrelationId%2A>| Пустая строка (»») |   | <xref:System.Messaging.Message.DestinationSymmetricKey%2A>| Массив байтов нулевой длины |   | <xref:System.Messaging.Message.DigitalSignature%2A>| Массив байтов нулевой длины |   | <xref:System.Messaging.Message.EncryptionAlgorithm%2A>| `EncryptionAlgorithm.RC2`|   | <xref:System.Messaging.Message.Extension%2A>| Массив байтов нулевой длины |   | <xref:System.Messaging.Message.Formatter%2A>| `formatter` Параметр. |   | <xref:System.Messaging.Message.HashAlgorithm%2A>| `HashAlgorithm.MD5`|   | <xref:System.Messaging.Message.Label%2A>| Пустая строка (»») |   | <xref:System.Messaging.Message.Priority%2A>| `MessagePriority.Normal`|   | <xref:System.Messaging.Message.Recoverable%2A>| `false`|   | <xref:System.Messaging.Message.ResponseQueue%2A>| `null`|   | <xref:System.Messaging.Message.SenderCertificate%2A>| Массив байтов нулевой длины |   | <xref:System.Messaging.Message.TimeToBeReceived%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TimeToReachQueue%2A>| `Message.InfiniteTimeout`|   | <xref:System.Messaging.Message.TransactionStatusQueue%2A>| `null`|   | <xref:System.Messaging.Message.UseAuthentication%2A>| `false`|   | <xref:System.Messaging.Message.UseDeadLetterQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseEncryption%2A>| `false`|   | <xref:System.Messaging.Message.UseJournalQueue%2A>| `false`|   | <xref:System.Messaging.Message.UseTracing%2A>| `false`|</xref:System.Messaging.Message.UseTracing%2A></xref:System.Messaging.Message.UseJournalQueue%2A></xref:System.Messaging.Message.UseEncryption%2A></xref:System.Messaging.Message.UseDeadLetterQueue%2A></xref:System.Messaging.Message.UseAuthentication%2A></xref:System.Messaging.Message.TransactionStatusQueue%2A></xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A></xref:System.Messaging.Message.SenderCertificate%2A></xref:System.Messaging.Message.ResponseQueue%2A></xref:System.Messaging.Message.Recoverable%2A></xref:System.Messaging.Message.Priority%2A></xref:System.Messaging.Message.Label%2A></xref:System.Messaging.Message.HashAlgorithm%2A></xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Extension%2A></xref:System.Messaging.Message.EncryptionAlgorithm%2A></xref:System.Messaging.Message.DigitalSignature%2A></xref:System.Messaging.Message.DestinationSymmetricKey%2A></xref:System.Messaging.Message.CorrelationId%2A></xref:System.Messaging.Message.ConnectorType%2A></xref:System.Messaging.Message.BodyType%2A></xref:System.Messaging.Message.BodyStream%2A></xref:System.Messaging.Message.Body%2A></xref:System.Messaging.Message.AuthenticationProviderType%2A></xref:System.Messaging.Message.AuthenticationProviderName%2A></xref:System.Messaging.Message.AttachSenderId%2A></xref:System.Messaging.Message.AppSpecific%2A></xref:System.Messaging.Message.AdministrationQueue%2A></xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - >-
    [!code-cpp[MessagingBinaryFormatter#1](~/add/codesnippet/cpp/6734a59e-0a86-49d1-96b9-_1.cpp)]
     [!code-cs[MessagingBinaryFormatter#1](~/add/codesnippet/csharp/6734a59e-0a86-49d1-96b9-_1.cs)]
     [!code-vb[MessagingBinaryFormatter#1](~/add/codesnippet/visualbasic/6734a59e-0a86-49d1-96b9-_1.vb)]
  syntax:
    content: public Message (object body, System.Messaging.IMessageFormatter formatter);
    parameters:
    - id: body
      type: System.Object
      description: "Объект, который сериализуется в текст сообщения."
    - id: formatter
      type: System.Messaging.IMessageFormatter
      description: "Объект <xref href=&quot;System.Messaging.IMessageFormatter&quot;> </xref> , указывающий форматирования для сериализации текста сообщения."
  overload: System.Messaging.Message.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.AcknowledgeType
  id: AcknowledgeType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AcknowledgeType
  nameWithType: Message.AcknowledgeType
  fullName: System.Messaging.Message.AcknowledgeType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает тип подтверждающего сообщения должны быть возвращены в передающее приложение."
  remarks: "Значение свойства AcknowledgeType указывает тип сообщений подтверждения, запрашиваемых передающим приложением. Задать значение свойства AcknowledgeType перед отправкой сообщения для запроса уведомления об определенных событиях — например, сообщение достигло очереди назначения, сообщение извлекается или истечения времени ожидания, предотвращая или из очереди назначения сообщения.       Служба Message Queuing возвращает уведомления путем отправки сообщений подтверждения <xref:System.Messaging.Message.AdministrationQueue%2A>свойство, указанное на исходное сообщение.</xref:System.Messaging.Message.AdministrationQueue%2A> Сообщение подтверждения <xref:System.Messaging.Message.Acknowledgment%2A>свойство указывает тип подтверждения, который он представляет.</xref:System.Messaging.Message.Acknowledgment%2A> Например, если подтверждающее сообщение было отправлено, так как сообщение не достигло пункта назначения до <xref:System.Messaging.Message.TimeToReachQueue%2A>истекло, <xref:System.Messaging.Message.Acknowledgment%2A>свойства подтверждающего сообщения будет содержать значение `ReachQueueTimeout`.</xref:System.Messaging.Message.Acknowledgment%2A> </xref:System.Messaging.Message.TimeToReachQueue%2A>"
  example:
  - "The following code example sends and receives a message containing an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_11_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_11_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_11_1.vb)]"
  syntax:
    content: public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }
    return:
      type: System.Messaging.AcknowledgeTypes
      description: "Один из <xref href=&quot;System.Messaging.AcknowledgeTypes&quot;> </xref> значения, которые представляют типы сообщений подтверждения, размещаемых системой в очереди администрирования и условия, при которых подтверждения возвращаются в передающее приложение. Значение по умолчанию — <xref uid=&quot;langword_csharp_None&quot; name=&quot;None&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.AcknowledgeType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Чтобы игнорировать свойства AcknowledgeType фильтруется сообщения."
  platform:
  - net462
- uid: System.Messaging.Message.Acknowledgment
  id: Acknowledgment
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Acknowledgment
  nameWithType: Message.Acknowledgment
  fullName: System.Messaging.Message.Acknowledgment
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Получение классификации подтверждения, представляемого данным сообщением."
  remarks: "При получении сообщения из очереди администрирования, прочитать в свойстве подтверждений для проверки состояния исходного сообщения.       Когда сообщение отправляется в очередь назначения, очереди сообщений может запросить подтверждающее сообщение. Такое сообщение может указывать, к примеру, ли сообщение получено и получены в течение указанного времени ожидания, или он может указывать, что пошло не так, в случае сбоя доставки. Очередь назначения возвращает подтверждающие сообщения и размещает их в очередь администрирования, указанную в исходном сообщении <xref:System.Messaging.Message.AdministrationQueue%2A>свойство.</xref:System.Messaging.Message.AdministrationQueue%2A> <xref:System.Messaging.Message.Id%2A>Свойства подтверждающего сообщения идентифицирует сообщение подтверждения, а не исходное сообщение.</xref:System.Messaging.Message.Id%2A> Идентификатор исходного сообщения можно найти в Подтверждение <xref:System.Messaging.Message>экземпляра <xref:System.Messaging.Message.CorrelationId%2A>свойство.</xref:System.Messaging.Message.CorrelationId%2A> </xref:System.Messaging.Message>       Если этот <xref:System.Messaging.Message>экземпляр представляет подтверждающее сообщение, подтверждающее свойство задает тип подтверждения.</xref:System.Messaging.Message> В противном случае свойство подтверждения содержит значение `Normal`.       Используйте <xref:System.Messaging.Message.AcknowledgeType%2A>свойство исходного сообщения для определения условий, при которых возвращения подтверждения.</xref:System.Messaging.Message.AcknowledgeType%2A>"
  syntax:
    content: public System.Messaging.Acknowledgment Acknowledgment { get; }
    return:
      type: System.Messaging.Acknowledgment
      description: "Один из <xref href=&quot;System.Messaging.Acknowledgment&quot;> </xref> значений перечисления."
  overload: System.Messaging.Message.Acknowledgment*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Сообщение не отправлено. Это свойство могут быть прочитаны только сообщения, отбираемые из очереди.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать <xref:System.Messaging.MessagePropertyFilter.Acknowledgment*>свойство.</xref:System.Messaging.MessagePropertyFilter.Acknowledgment*>"
  platform:
  - net462
- uid: System.Messaging.Message.AdministrationQueue
  id: AdministrationQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AdministrationQueue
  nameWithType: Message.AdministrationQueue
  fullName: System.Messaging.Message.AdministrationQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает очередь, принимающую подтверждающие сообщения, созданные Message Queuing."
  remarks: "Очередь, указанная в свойстве AdministrationQueue может быть любой нетранзакционную очередь. Подтверждающие сообщения, отправленные в очередь администрирования могут указывать, достигло ли исходное сообщение своей конечной очереди, и оно было удалено из очереди.       Когда <xref:System.Messaging.Message.AcknowledgeType%2A>свойство имеет любое значение, отличное от `None`, передающее приложение должно указать очереди для использования в качестве очереди администрирования.</xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - "The following code example sends and receives a message containing an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_47_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_47_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_47_1.vb)]"
  syntax:
    content: public System.Messaging.MessageQueue AdministrationQueue { get; set; }
    return:
      type: System.Messaging.MessageQueue
      description: "<xref href=&quot;System.Messaging.MessageQueue&quot;> </xref> , Указывающий очередь администрирования, используемую для системно генерируемого подтверждения сообщения. Значение по умолчанию — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.AdministrationQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства AdministrationQueue."
  platform:
  - net462
- uid: System.Messaging.Message.AppSpecific
  id: AppSpecific
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AppSpecific
  nameWithType: Message.AppSpecific
  fullName: System.Messaging.Message.AppSpecific
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает дополнительные, относящихся к приложению данные."
  remarks: "Свойство дл. целое содержит сведения о приложении, которое можно использовать для организации различных типов сообщений. Например можно использовать индексы, связанные с приложением. Это приложение следует интерпретировать сведения о свойстве дл. целое.       Когда это возможно, данные сообщения следует включать в тело сообщения, а не свойство дл. целое.       При работе с внешними очередями используйте <xref:System.Messaging.Message.Extension%2A>свойство для задания свойств сообщения, которые не существуют в очереди сообщений.</xref:System.Messaging.Message.Extension%2A> Со свойством дл. целое, это приложение, чтобы понять содержимое <xref:System.Messaging.Message.Extension%2A>свойство.</xref:System.Messaging.Message.Extension%2A>"
  syntax:
    content: public int AppSpecific { get; set; }
    return:
      type: System.Int32
      description: "Сведения, относящиеся к приложению. Значение по умолчанию равно нулю."
  overload: System.Messaging.Message.AppSpecific*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства дл. целое."
  platform:
  - net462
- uid: System.Messaging.Message.ArrivedTime
  id: ArrivedTime
  parent: System.Messaging.Message
  langs:
  - csharp
  name: ArrivedTime
  nameWithType: Message.ArrivedTime
  fullName: System.Messaging.Message.ArrivedTime
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Получает время поступления сообщения в очередь назначения."
  remarks: "Сообщение <xref:System.Messaging.Message.TimeToBeReceived%2A>свойство указывает, насколько быстро сообщение должно быть получено из очереди назначения.</xref:System.Messaging.Message.TimeToBeReceived%2A> <xref:System.Messaging.Message.TimeToBeReceived%2A>Свойство таймер запускается, когда сообщение отправляется не в том случае, когда сообщение поступает в очередь.</xref:System.Messaging.Message.TimeToBeReceived%2A>"
  example:
  - "The following code example displays the value of a message's ArrivedTime property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public DateTime ArrivedTime { get; }
    return:
      type: System.DateTime
      description: "Объект <xref:System.DateTime>, представляющий время прибытия сообщения в конечную очередь.</xref:System.DateTime> Локальное время компьютера, на котором находится очередь назначения регулируется время от времени GMT."
  overload: System.Messaging.Message.ArrivedTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Сообщение не отправлено. Это свойство могут быть прочитаны только сообщения, отбираемые из очереди.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойство ArrivedTime."
  platform:
  - net462
- uid: System.Messaging.Message.AttachSenderId
  id: AttachSenderId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AttachSenderId
  nameWithType: Message.AttachSenderId
  fullName: System.Messaging.Message.AttachSenderId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает значение, указывающее, следует ли прикреплять идентификатор отправителя сообщения."
  remarks: "<xref:System.Messaging.Message.SenderId%2A>Свойство представляет собой массив байтов, представляющий идентификатор пользователя, отправившего сообщение.</xref:System.Messaging.Message.SenderId%2A> Идентификатор отправителя устанавливается службой Message Queuing и используется принимающим диспетчером очереди для проверки прав доступа к очереди отправителя.       Отсутствие идентификатора отправителя служит указанием отправляющего приложения, служба очереди сообщений не проверки отправителя сообщения и не должны проверить доступ отправителя права на принимающей очереди. <xref:System.Messaging.Message.SenderId%2A>Заслуживает доверия только в том случае, если сообщение прошло проверку подлинности, при его поступлении в очередь назначения.</xref:System.Messaging.Message.SenderId%2A> Сообщение будет отклонено при поступлении в очередь назначения, если очередь принимает только проверенные сообщения и либо <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>или <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>свойство `false`.</xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> </xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>      Настроек [!CAUTION] настроек сообщение отклоняется, том, что либо передается в очередь недоставленных сообщений (если <xref:System.Messaging.Message.UseDeadLetterQueue%2A>— `true`), или он обрабатывается.</xref:System.Messaging.Message.UseDeadLetterQueue%2A> Может запрашивать подтверждения, когда сообщение не удается достичь очереди. В противном случае, если <xref:System.Messaging.Message.UseDeadLetterQueue%2A>является `false` сообщения могут быть потеряны без предупреждения.</xref:System.Messaging.Message.UseDeadLetterQueue%2A>"
  example:
  - "The following code example gets and sets the value of a message's AttachSenderId property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool AttachSenderId { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref:System.Messaging.Message.SenderId*>должен быть вложен в сообщение, в противном случае — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Messaging.Message.SenderId*> Значение по умолчанию — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.AttachSenderId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства AttachSenderId."
  platform:
  - net462
- uid: System.Messaging.Message.Authenticated
  id: Authenticated
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Authenticated
  nameWithType: Message.Authenticated
  fullName: System.Messaging.Message.Authenticated
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает значение, указывающее, прошло ли сообщение проверку подлинности."
  remarks: "Свойство проверкой подлинности используется только приложением, пока он взаимодействует с сообщением и пытается определить, была ли запрошена проверка подлинности. Если в очереди есть сообщения, сообщение прошло проверку подлинности. И наоборот Если свойство проверкой подлинности `true`, диспетчер принимающей очереди с проверкой подлинности сообщения при его поступлении.       Не удается определить, если сообщение не прошел проверку подлинности, просмотрев его свойства. Служба Message Queuing отклоняет сообщения, не прошедшие проверку подлинности, прежде чем они попадут в очередь. Тем не менее можно запросить подтверждающее сообщение, когда сбоя доставки сообщение на попадает в очередь."
  example:
  - "The following code example displays the value of a message's Authenticated property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool Authenticated { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если была запрошена проверка подлинности сообщения при его вводе очереди. в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.Authenticated*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Сообщение не отправлено. Это свойство могут быть прочитаны только сообщения, отбираемые из очереди.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойство проверкой подлинности."
  platform:
  - net462
- uid: System.Messaging.Message.AuthenticationProviderName
  id: AuthenticationProviderName
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AuthenticationProviderName
  nameWithType: Message.AuthenticationProviderName
  fullName: System.Messaging.Message.AuthenticationProviderName
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает имя поставщика служб шифрования, используемый для создания цифровой подписи сообщения."
  remarks: "При работе с внешними очередями обычно используется в именах. Служба Message Queuing требуется имя поставщика проверки подлинности и тип поставщика проверки подлинности поставщика служб шифрования (поставщик проверки подлинности) для проверки цифровых подписей сообщений, отправленных в очередь внешнего и сообщений, поступающих в Message Queuing из внешней очереди.       При отправке сообщения всегда устанавливается именах и <xref:System.Messaging.Message.ConnectorType%2A>свойства вместе.</xref:System.Messaging.Message.ConnectorType%2A> При отправке сообщения Message Queuing не обрабатывает имя поставщика проверки подлинности, если не установлен тип соединителя.       Именах свойство не может быть `null`, но это может быть пустая строка (»»)."
  syntax:
    content: public string AuthenticationProviderName { get; set; }
    return:
      type: System.String
      description: "Имя поставщика служб шифрования, используемый для создания цифровой подписи сообщения. Значение по умолчанию — Microsoft Base Cryptographic Provider версии 1.0."
  overload: System.Messaging.Message.AuthenticationProviderName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Не удалось задать свойство именах.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойство именах."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Было присвоено значение именах <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.AuthenticationProviderType
  id: AuthenticationProviderType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AuthenticationProviderType
  nameWithType: Message.AuthenticationProviderType
  fullName: System.Messaging.Message.AuthenticationProviderType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает тип поставщика служб шифрования, используемый для создания цифровой подписи сообщения."
  remarks: "Обычно свойство AuthenticationProviderType при работе с внешними очередями для указания того, какие службы криптографии, связанного с сообщением. Служба Message Queuing требуется имя поставщика проверки подлинности и тип поставщика проверки подлинности поставщика служб шифрования (поставщик проверки подлинности) для проверки цифровых подписей сообщений, отправленных в очередь внешнего и сообщений, поступающих в Message Queuing из внешней очереди.       Только `RsaFull` предназначен для использования в обмене сообщениями.       При отправке сообщения всегда устанавливается AuthenticationProviderType и <xref:System.Messaging.Message.ConnectorType%2A>свойства вместе.</xref:System.Messaging.Message.ConnectorType%2A> При отправке сообщения Message Queuing не обрабатывает тип поставщика проверки подлинности, если не установлен тип соединителя."
  syntax:
    content: public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }
    return:
      type: System.Messaging.CryptographicProviderType
      description: "Один из <xref href=&quot;System.Messaging.CryptographicProviderType&quot;> </xref> значения. Значение по умолчанию — <xref uid=&quot;langword_csharp_RSA_FULL&quot; name=&quot;RSA_FULL&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.AuthenticationProviderType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Не удалось задать свойство AuthenticationProviderType.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойство AuthenticationProviderType."
  platform:
  - net462
- uid: System.Messaging.Message.Body
  id: Body
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Body
  nameWithType: Message.Body
  fullName: System.Messaging.Message.Body
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает содержимое сообщения."
  remarks: "Свойство текста сообщения обычно содержит данные, связанные с данным сообщением. Несмотря на то, что можно также отправлять данные приложения в <xref:System.Messaging.Message.AppSpecific%2A>и <xref:System.Messaging.Message.Extension%2A>Свойства, данные сообщения следует включать в тело сообщения, когда это возможно.</xref:System.Messaging.Message.Extension%2A> </xref:System.Messaging.Message.AppSpecific%2A> Сериализация или шифрование выполняются только содержимое тела свойства.       Свойства Body может содержать любой объект, размер которого не превышает 4 МБ. Если вы используете <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=fullName>для отправки любого объекта, который имеет не тип <xref:System.Messaging.Message> <xref:System.Messaging.MessageQueue>который объект находится в свойстве &quot;текст&quot;, <xref:System.Messaging.Message> <xref:System.Messaging.MessageQueue.Peek%2A>или <xref:System.Messaging.MessageQueue.Receive%2A>.</xref:System.Messaging.MessageQueue.Receive%2A> </xref:System.Messaging.MessageQueue.Peek%2A> возвращает экземпляр</xref:System.Messaging.Message> </xref:System.Messaging.MessageQueue> </xref:System.Messaging.Message> </xref:System.Messaging.MessageQueue.Send%2A?displayProperty=fullName>       Строковый аргумент в `MessageQueue.Send(&quot;hello.&quot;)` приведен пример универсального объекта.       <xref:System.Messaging.Message.BodyType%2A>Указывает тип данных, хранящихся в тексте сообщения.</xref:System.Messaging.Message.BodyType%2A> Служба Message Queuing использует эти сведения для определения типа содержимого тела свойства.       Укажите свойства Body или <xref:System.Messaging.Message.BodyStream%2A>до передачи <xref:System.Messaging.Message>объекта.</xref:System.Messaging.Message> </xref:System.Messaging.Message.BodyStream%2A> Свойство текста может быть любой сериализуемый объект, например текстовая строка, объекта структуры, экземпляр класса или внедренный объект.       Если содержимое сообщения записывается непосредственно в <xref:System.Messaging.Message.BodyStream%2A>свойстве <xref:System.Messaging.Message.Formatter%2A>перед передачей сообщения.</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.BodyStream%2A> Когда <xref:System.Messaging.MessageQueue.Send%2A>метод будет вызван на <xref:System.Messaging.MessageQueue>экземпляра, текст сериализуется с помощью модуля форматирования, содержащихся в <xref:System.Messaging.Message.Formatter%2A>свойство.</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> При отправке сообщения без указания значения для <xref:System.Messaging.Message.Formatter%2A>Свойства форматирования по умолчанию используется <xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter> </xref:System.Messaging.Message.Formatter%2A>      Настроек [!NOTE] настроек попытка задать текст сообщения для <xref:System.Decimal.MaxValue>вызовет <xref:System.OverflowException>при `Send` метод <xref:System.Messaging.MessageQueue>класса вызывается и <xref:System.Messaging.ActiveXMessageFormatter>используется.</xref:System.Messaging.ActiveXMessageFormatter> </xref:System.Messaging.MessageQueue> </xref:System.OverflowException> </xref:System.Decimal.MaxValue>"
  example:
  - "The following code example sends two messages of different priorities to the queue, and retrieves them subsequently.  \n  \n [!code-cpp[Message.DefaultPropertiesToSend#1](~/add/codesnippet/cpp/p-system.messaging.messa_13_1.cpp)]\n [!code-vb[Message.DefaultPropertiesToSend#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_13_1.vb)]\n [!code-cs[Message.DefaultPropertiesToSend#1](~/add/codesnippet/csharp/p-system.messaging.messa_13_1.cs)]"
  syntax:
    content: public object Body { get; set; }
    return:
      type: System.Object
      description: "Объект, задающий содержимое сообщения. Объект может быть строка, даты, валюты, число, массив байтов или любого управляемого объекта."
  overload: System.Messaging.Message.Body*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Messaging.Message.Formatter*>Свойство <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.</xref:System.Messaging.Message.Formatter*>       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойства Body."
  platform:
  - net462
- uid: System.Messaging.Message.BodyStream
  id: BodyStream
  parent: System.Messaging.Message
  langs:
  - csharp
  name: BodyStream
  nameWithType: Message.BodyStream
  fullName: System.Messaging.Message.BodyStream
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает сведения в тексте сообщения."
  remarks: "Тело сообщения может состоять из любой тип данных — например, строки, даты, валюты, число, массив байтов или любого управляемого объекта. Эти сведения, сериализуется в <xref:System.IO.Stream>должен быть передан в очередь.</xref:System.IO.Stream>       Укажите либо <xref:System.Messaging.Message.Body%2A>свойства или свойства BodyStream перед отправкой <xref:System.Messaging.Message>объекта.</xref:System.Messaging.Message> </xref:System.Messaging.Message.Body%2A> Если задать <xref:System.Messaging.Message.Body%2A>Свойства, содержимое сериализуется в свойство BodyStream.</xref:System.Messaging.Message.Body%2A> Тем не менее можно напрямую записать свойства BodyStream. Это полезно, например, если вы хотите установить соединение с файлом и передать его содержимое в теле сообщения.       Если свойству BodyStream записи содержимого сообщения, заданным <xref:System.Messaging.Message.Formatter%2A>перед передачей сообщения.</xref:System.Messaging.Message.Formatter%2A> Когда <xref:System.Messaging.MessageQueue.Send%2A>метод будет вызван на <xref:System.Messaging.MessageQueue>экземпляра, текст сериализуется с помощью модуля форматирования, содержащихся в <xref:System.Messaging.Message.Formatter%2A>свойство.</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> При отправке сообщения без указания значения для <xref:System.Messaging.Message.Formatter%2A>Свойства форматирования по умолчанию используется <xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter> </xref:System.Messaging.Message.Formatter%2A>       Если задать <xref:System.Messaging.Message.UseEncryption%2A>Свойства `true` тело данного сообщения, сообщения будут зашифрованы при передаче, не настраивая <xref:System.Messaging.Message.Body%2A>свойство.</xref:System.Messaging.Message.Body%2A> </xref:System.Messaging.Message.UseEncryption%2A> Таким образом свойства BodyStream никогда не шифруются."
  syntax:
    content: public System.IO.Stream BodyStream { get; set; }
    return:
      type: System.IO.Stream
      description: "Объект <xref:System.IO.Stream>, содержащий сериализованные сведения, включенные в <xref:System.Messaging.Message.Body*>сообщения.</xref:System.Messaging.Message.Body*> </xref:System.IO.Stream>"
  overload: System.Messaging.Message.BodyStream*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений будет отфильтрован, чтобы игнорировать <xref:System.Messaging.Message.Body*>свойство.</xref:System.Messaging.Message.Body*>"
  platform:
  - net462
- uid: System.Messaging.Message.BodyType
  id: BodyType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: BodyType
  nameWithType: Message.BodyType
  fullName: System.Messaging.Message.BodyType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает тип данных, содержащего текст сообщения."
  remarks: "Служба Message Queuing распознает содержимое тела как объект или как сериализованный поток. Свойство BodyType указывает тип объекта внутри <xref:System.Messaging.Message.Body%2A>Свойства сообщения.</xref:System.Messaging.Message.Body%2A>       <xref:System.Messaging.XmlMessageFormatter>Выполняет привязку собственных типов и объект в теле сообщения.</xref:System.Messaging.XmlMessageFormatter> Если вы используете <xref:System.Messaging.XmlMessageFormatter>, оно задает свойство BodyType для вас.</xref:System.Messaging.XmlMessageFormatter>       Другие модули форматирования может обеспечить функционирование привязки также, как показано в следующем коде C#.      ```   message.Formatter = new ActiveXMessageFormatter();   object myObject message.Body;   if (myObject is string) {   }   if (myObject is int) {   }   if (myObject is float) {   }   ```"
  example:
  - "The following code example displays the value of a message's BodyType property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public int BodyType { get; set; }
    return:
      type: System.Int32
      description: "Тело сообщения истинный тип, например строки, даты, валюты или число."
  overload: System.Messaging.Message.BodyType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений будет отфильтрован, чтобы игнорировать <xref:System.Messaging.Message.Body*>свойство.</xref:System.Messaging.Message.Body*>"
  platform:
  - net462
- uid: System.Messaging.Message.ConnectorType
  id: ConnectorType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: ConnectorType
  nameWithType: Message.ConnectorType
  fullName: System.Messaging.Message.ConnectorType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает значение, указывающее, что передающим приложением заданы некоторые свойства сообщения, обычно задаваемые MSMQ."
  remarks: "Служба Message Queuing требуется задать свойство ConnectorType всякий раз, когда приложение задает свойство сообщения, которое обычно задается службой Message Queuing. Обычно приложения используют ConnectorType в следующих двух случаях: - всякий раз, когда приложение-подключатель передает сообщение. Свойство ConnectorType указывает передающее и принимающее приложения, как интерпретировать свойства безопасности и подтверждения сообщения.      -Каждый раз, когда сообщение шифруется отправляющего приложения, а не службой Message Queuing. Свойство ConnectorType указывает очереди сообщений для использования <xref:System.Messaging.Message.DestinationSymmetricKey%2A>значение свойства для расшифровки сообщения.</xref:System.Messaging.Message.DestinationSymmetricKey%2A>       Если задается любое из следующих свойств, необходимо задать свойство ConnectorType (в противном случае очередь не обрабатывает эти свойства при передаче сообщения):- <xref:System.Messaging.Message.AuthenticationProviderName%2A>- <xref:System.Messaging.Message.AuthenticationProviderType%2A>- <xref:System.Messaging.Message.DestinationSymmetricKey%2A>- <xref:System.Messaging.Message.DigitalSignature%2A>- <xref:System.Messaging.Message.MessageType%2A>- <xref:System.Messaging.Message.SenderId%2A></xref:System.Messaging.Message.SenderId%2A> </xref:System.Messaging.Message.MessageType%2A> </xref:System.Messaging.Message.DigitalSignature%2A> </xref:System.Messaging.Message.DestinationSymmetricKey%2A> </xref:System.Messaging.Message.AuthenticationProviderType%2A> </xref:System.Messaging.Message.AuthenticationProviderName%2A>"
  syntax:
    content: public Guid ConnectorType { get; set; }
    return:
      type: System.Guid
      description: "Объект <xref:System.Guid>определяется приложением и используется совместно с приложениями соединителя или шифрования сообщений.</xref:System.Guid> Это <xref:System.Guid>позволяет принимающему приложению интерпретировать установленные передающим приложением свойства, которые обычно задаются службой Message Queuing.</xref:System.Guid>"
  overload: System.Messaging.Message.ConnectorType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Чтобы не учитывать свойство ConnectorType фильтруется очереди сообщений."
  platform:
  - net462
- uid: System.Messaging.Message.CorrelationId
  id: CorrelationId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: CorrelationId
  nameWithType: Message.CorrelationId
  fullName: System.Messaging.Message.CorrelationId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает идентификатор сообщения, используемый подтверждениями, отчетами и ответные сообщения для ссылки на исходное сообщение."
  remarks: "При подтверждающего сообщения или отчета создается службой Message Queuing, он использует свойство идентификатора корреляции для указания идентификатора исходного сообщения. Таким образом код корреляции связывает отчет или подтверждение с исходным сообщением.       Передающее приложение может согласовать подтверждение или отчет с исходным сообщением, используя свойство CorrelationId для определения исходного сообщения <xref:System.Messaging.Message.Id%2A>свойство.</xref:System.Messaging.Message.Id%2A>       Приложения-подключатели также необходимо задать для свойства CorrelationId подтверждения и сообщения-отчеты равным идентификатору исходного сообщения.       Когда приложение отправляет ответное сообщение передающему приложению, можно задать свойства CorrelationId ответного сообщения равным идентификатору исходного сообщения. Передающее приложение может согласовать ответное сообщение, отправленное сообщение."
  example:
  - "The following code example sends and receives a message that contains an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_95_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_95_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_95_1.vb)]"
  syntax:
    content: public string CorrelationId { get; set; }
    return:
      type: System.String
      description: "Идентификатор сообщения, задается <xref:System.Messaging.Message.Id*>свойства исходного сообщения.</xref:System.Messaging.Message.Id*> Идентификатор корреляции используется службой Message Queuing при создании подтверждающих сообщений и отчетов и приложением при создании ответного сообщения."
  overload: System.Messaging.Message.CorrelationId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства CorrelationId."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "— CorrelationId <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.DestinationQueue
  id: DestinationQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: DestinationQueue
  nameWithType: Message.DestinationQueue
  fullName: System.Messaging.Message.DestinationQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает очередь пункта назначения для сообщения."
  remarks: "Свойство Конечная_очередь чаще всего используется для определения первоначального места назначения сообщения, поступившего в журнал или очередь недоставленных сообщений. Как правило не необходимо проверять это свойство, поскольку обычно получения сообщения из очереди назначения."
  example:
  - "The following code example displays the value of a message's DestinationQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageQueue DestinationQueue { get; }
    return:
      type: System.Messaging.MessageQueue
      description: "Объект <xref href=&quot;System.Messaging.MessageQueue&quot;> </xref> , указывающий очередь пункта назначения для сообщения."
  overload: System.Messaging.Message.DestinationQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Сообщение не отправлено. Это свойство могут быть прочитаны только сообщения, отбираемые из очереди.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать Конечная_очередь свойство."
  platform:
  - net462
- uid: System.Messaging.Message.DestinationSymmetricKey
  id: DestinationSymmetricKey
  parent: System.Messaging.Message
  langs:
  - csharp
  name: DestinationSymmetricKey
  nameWithType: Message.DestinationSymmetricKey
  fullName: System.Messaging.Message.DestinationSymmetricKey
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает симметричный ключ, используемый для шифрования сообщений, зашифрованных приложением или сообщений, отправляемых во внешние очереди."
  remarks: "Два сценария требуется использовать свойство DestinationSymmetricKey. Во-первых, когда сообщение шифруется с приложением, а не службой Message Queuing. Второе — при отправке зашифрованного сообщения в очереди системы, отличной от очереди сообщений.       Перед установкой этого свойства необходимо зашифровать симметричный ключ с помощью открытого ключа диспетчера принимающей очереди. При отправке сообщений, зашифрованных приложением, диспетчер принимающей очереди использует симметричный ключ для расшифровки сообщения перед отправкой в очередь назначения.       При отправке сообщения во внешнюю очередь, сначала сообщение с соответствующим связующим приложением, которое направляет зашифрованное сообщение с присоединенным симметричным ключом в принимающее приложение. Он отвечает затем принимающее приложение расшифровать сообщение с помощью симметричного ключа.       При установке свойства DestinationSymmetricKey, необходимо также задать <xref:System.Messaging.Message.ConnectorType%2A>Свойства.</xref:System.Messaging.Message.ConnectorType%2A> При отправке сообщения Message Queuing не обрабатывает свойство DestinationSymmetricKey Если <xref:System.Messaging.Message.ConnectorType%2A>не задано свойство.</xref:System.Messaging.Message.ConnectorType%2A>       Свойство DestinationSymmetricKey имеет максимальный размер массива 256."
  syntax:
    content: public byte[] DestinationSymmetricKey { get; set; }
    return:
      type: System.Byte[]
      description: "Массив байтовых значений, задающий целевой симметричный ключ, используемый для шифрования сообщений. Значение по умолчанию — массив нулевой длины."
  overload: System.Messaging.Message.DestinationSymmetricKey*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства DestinationSymmetricKey."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "— DestinationSymmetricKey <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.DigitalSignature
  id: DigitalSignature
  parent: System.Messaging.Message
  langs:
  - csharp
  name: DigitalSignature
  nameWithType: Message.DigitalSignature
  fullName: System.Messaging.Message.DigitalSignature
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает цифровую подпись, Message Queuing для проверки подлинности сообщения."
  remarks: "Очередь сообщений использует цифровой подписи при проверке подлинности сообщений, отправленных службой Message Queuing версии 1.0. В большинстве случаев Message Queuing создает и устанавливает свойство DigitalSignature при передающее приложение запрашивает проверку подлинности. Принимающее приложение использует это свойство для извлечения цифровой подписи, вложенной в сообщение.       Свойство DigitalSignature можно использовать только в том случае, когда очереди сообщений версии 2.0. Отправляющее приложение должно указать подписи Message Queuing версии 1.0, при запросе проверки подлинности. Если отправляющее приложение отправляет подпись очереди сообщений версии 2.0, это свойство содержит буфера четыре байта каждого содержащего ноль.       Свойство DigitalSignature вместе с <xref:System.Messaging.Message.SenderCertificate%2A>свойство, также используется приложения-подключатели при отправке сообщения.</xref:System.Messaging.Message.SenderCertificate%2A> В этом случае приложение-подключатель, вместо того чтобы служба очереди сообщений — цифровая подпись, основана на сертификат пользователя, отправляющий сообщение, она создается.       Свойство DigitalSignature имеет максимальный размер массива 256.       При установке свойства DigitalSignature, необходимо также задать <xref:System.Messaging.Message.ConnectorType%2A>Свойства.</xref:System.Messaging.Message.ConnectorType%2A> При отправке сообщения Message Queuing не обрабатывает свойство DigitalSignature Если <xref:System.Messaging.Message.ConnectorType%2A>не задано свойство.</xref:System.Messaging.Message.ConnectorType%2A>"
  syntax:
    content: public byte[] DigitalSignature { get; set; }
    return:
      type: System.Byte[]
      description: "Массив байтовых значений, задающий цифровую подпись Message Queuing 1.0, используемую для проверки подлинности сообщения. Значение по умолчанию — массив нулевой длины."
  overload: System.Messaging.Message.DigitalSignature*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства DigitalSignature."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Свойство DigitalSignature <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.EncryptionAlgorithm
  id: EncryptionAlgorithm
  parent: System.Messaging.Message
  langs:
  - csharp
  name: EncryptionAlgorithm
  nameWithType: Message.EncryptionAlgorithm
  fullName: System.Messaging.Message.EncryptionAlgorithm
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает алгоритм шифрования, используемый для шифрования текста конфиденциального сообщения."
  remarks: "Если сообщение является закрытым (шифрованный), оно шифруется перед отправкой и расшифровывается при получении. Свойство EncryptionAlgorithm указывает алгоритм, используемый для шифрования текста конфиденциального сообщения.       Очередь может потребовать, чтобы входящие сообщения были зашифрованы. Если приложение отправляет сообщение (отличным от private) без шифрования в очередь, принимающую только конфиденциальные сообщения, или если отправляет закрытого сообщения в очередь, принимающую только неконфиденциальные сообщения, сообщение будет отклонено очереди. Передающее приложение может запросить, отрицательное подтверждение возвращаться в таком случае."
  syntax:
    content: public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }
    return:
      type: System.Messaging.EncryptionAlgorithm
      description: "Один из <xref href=&quot;System.Messaging.EncryptionAlgorithm&quot;> </xref> значений перечисления. Значение по умолчанию — <xref uid=&quot;langword_csharp_RC2&quot; name=&quot;RC2&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.EncryptionAlgorithm*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства EncryptionAlgorithm."
  platform:
  - net462
- uid: System.Messaging.Message.Extension
  id: Extension
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Extension
  nameWithType: Message.Extension
  fullName: System.Messaging.Message.Extension
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает дополнительные, определяемые приложением сведения, связанные с данным сообщением."
  remarks: "Свойство расширения предоставляет дополнительные сведения, определяемые приложением, например большой двоичный объект, который связан с сообщением. Он отвечает принимающему приложению интерпретировать содержимое свойства расширения.       Если это возможно, следует включить данные сообщения в <xref:System.Messaging.Message.Body%2A>свойство сообщения, а не свойство расширения.</xref:System.Messaging.Message.Body%2A>       При работе с внешними очередями, используйте свойство расширения для задания свойств сообщения, которые не существуют в очереди сообщений.       Внешнюю очередь существует в очереди системы, отличной от Microsoft Message Queuing. Служба Message Queuing связывается с другими очередями через приложение-подключатель."
  syntax:
    content: public byte[] Extension { get; set; }
    return:
      type: System.Byte[]
      description: "Массив байтовых значений, обеспечивающий определяемые приложением сведения, связанные с данным сообщением. Значение по умолчанию — массив нулевой длины."
  overload: System.Messaging.Message.Extension*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства расширения."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Свойства расширения является <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.Formatter
  id: Formatter
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Formatter
  nameWithType: Message.Formatter
  fullName: System.Messaging.Message.Formatter
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает модуль форматирования для сериализации или десериализации объекта из тела сообщения."
  remarks: "Используйте свойство форматирования при чтении и записи сообщения. Когда сообщение отправляется в очередь, модуль форматирования сериализует <xref:System.Messaging.Message.Body%2A>свойство в поток, который можно отправлять сообщения в очередь.</xref:System.Messaging.Message.Body%2A> При чтении из очереди форматер десериализует данные сообщения в <xref:System.Messaging.Message.Body%2A>свойство.</xref:System.Messaging.Message.Body%2A>       Если содержимое сообщения записывается непосредственно в <xref:System.Messaging.Message.BodyStream%2A>, установите свойства форматирования данных перед отправкой сообщения.</xref:System.Messaging.Message.BodyStream%2A> Когда <xref:System.Messaging.MessageQueue.Send%2A>метод будет вызван на <xref:System.Messaging.MessageQueue>экземпляра, текст сериализуется с использованием модуля форматирования, содержащиеся в свойстве модуля форматирования.</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> При отправке сообщения без указания значения для свойства форматирования, модуль форматирования по умолчанию <xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter>       <xref:System.Messaging.XmlMessageFormatter>Слабо связанный, поэтому нет необходимости иметь объект того же типа на отправителя и получателя, при применении этого формата.</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>И <xref:System.Messaging.BinaryMessageFormatter>сериализации данных в двоичное представление.</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>Используется при отправке и получении COM-компонентов.</xref:System.Messaging.ActiveXMessageFormatter>"
  example:
  - "The following code example demonstrates formatting a message body using <xref:System.Messaging.BinaryMessageFormatter>.  \n  \n [!code-cpp[MessagingBinaryFormatter#1](~/add/codesnippet/cpp/p-system.messaging.messa_5_1.cpp)]\n [!code-cs[MessagingBinaryFormatter#1](~/add/codesnippet/csharp/p-system.messaging.messa_5_1.cs)]\n [!code-vb[MessagingBinaryFormatter#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_5_1.vb)]  \n  \n The following code example demonstrates formatting a message body using <xref:System.Messaging.XmlMessageFormatter>.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/p-system.messaging.messa_5_2.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/p-system.messaging.messa_5_2.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_5_2.vb)]"
  syntax:
    content: public System.Messaging.IMessageFormatter Formatter { get; set; }
    return:
      type: System.Messaging.IMessageFormatter
      description: "<xref href=&quot;System.Messaging.IMessageFormatter&quot;> </xref> , Создающий поток для записи или чтения из тела сообщения. Значение по умолчанию — <xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref>."
  overload: System.Messaging.Message.Formatter*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Свойство форматирования <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Messaging.Message.HashAlgorithm
  id: HashAlgorithm
  parent: System.Messaging.Message
  langs:
  - csharp
  name: HashAlgorithm
  nameWithType: Message.HashAlgorithm
  fullName: System.Messaging.Message.HashAlgorithm
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает алгоритм хеширования, используемого MSMQ при проверке подлинности сообщения или при создании цифровой подписи сообщения."
  remarks: "На исходном компьютере Message Queuing алгоритм хеширования при создании цифровой подписи сообщения. Целевой диспетчер очереди, затем использует один и тот же алгоритм хэширования для проверки подлинности сообщения при его получении."
  syntax:
    content: public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }
    return:
      type: System.Messaging.HashAlgorithm
      description: "Один из <xref href=&quot;System.Messaging.HashAlgorithm&quot;> </xref> значений перечисления. Windows XP, значение по умолчанию — <xref uid=&quot;langword_csharp_SHA&quot; name=&quot;SHA&quot; href=&quot;&quot;> </xref>. В противном случае — значение по умолчанию — <xref uid=&quot;langword_csharp_MD5&quot; name=&quot;MD5&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.HashAlgorithm*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства HashAlgorithm."
  platform:
  - net462
- uid: System.Messaging.Message.Id
  id: Id
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Id
  nameWithType: Message.Id
  fullName: System.Messaging.Message.Id
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Получает идентификатор сообщения."
  remarks: "Служба Message Queuing создает идентификатор сообщения при отправке сообщения. Идентификатор состоит из 20 байт и двух элементов: компьютер <xref:System.Guid>от передающего компьютера и уникального идентификатора для сообщения на этом компьютере.</xref:System.Guid> Объединение двух этих элементов создает идентификатор сообщения, уникальный в данной сети.       Сообщение message Queuing создает идентификаторы для всех сообщений, включая подтверждения и сообщения-отчеты. Подтверждающее сообщение обычно передается службой Message Queuing в ответ на доставку или сбой исходного, отправленного сообщения. Можно найти значение свойства идентификатора исходного сообщения в <xref:System.Messaging.Message.CorrelationId%2A>свойства подтверждающего сообщения.</xref:System.Messaging.Message.CorrelationId%2A>       Свойство идентификатора может использоваться при передаче ответного сообщения в очередь ответов. Чтобы включить идентификатор исходного сообщения в сообщение ответа, задайте <xref:System.Messaging.Message.CorrelationId%2A>Свойства сообщения ответа свойству идентификатора исходного сообщения.</xref:System.Messaging.Message.CorrelationId%2A> Затем приложение, считывающее сообщение ответа можно использовать идентификатор корреляции сообщения-ответа для определения исходного сообщения."
  example:
  - "The following code example sends and receives a message containing an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_19_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_19_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_19_1.vb)]"
  syntax:
    content: public string Id { get; }
    return:
      type: System.String
      description: "Уникальный идентификатор сообщения, который создается службой Message Queuing."
  overload: System.Messaging.Message.Id*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Сообщение не отправлено. Это свойство могут быть прочитаны только сообщения, отбираемые из очереди.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойство идентификатора."
  platform:
  - net462
- uid: System.Messaging.Message.InfiniteTimeout
  id: InfiniteTimeout
  parent: System.Messaging.Message
  langs:
  - csharp
  name: InfiniteTimeout
  nameWithType: Message.InfiniteTimeout
  fullName: System.Messaging.Message.InfiniteTimeout
  type: Field
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Указывает, что время ожидания не существует."
  remarks: "<xref:System.Messaging.Message.TimeToBeReceived%2A>и <xref:System.Messaging.Message.TimeToReachQueue%2A>требуется значение, указывающее время ожидания.</xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A> Для первого из упомянутых тайм-аута является максимальное время ожидания для сообщения должно быть получено из очереди. Для последнего время ожидания — это время, в течение сообщение должно дойти до очереди. В обоих случаях можно указать время ожидания в секундах или использовать InfiniteTimeout, чтобы указать, что время ожидания не существует."
  example:
  - "The following code example demonstrates the use of the InfiniteTimeout field.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public static readonly TimeSpan InfiniteTimeout;
    return:
      type: System.TimeSpan
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.IsFirstInTransaction
  id: IsFirstInTransaction
  parent: System.Messaging.Message
  langs:
  - csharp
  name: IsFirstInTransaction
  nameWithType: Message.IsFirstInTransaction
  fullName: System.Messaging.Message.IsFirstInTransaction
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает значение, указывающее, является ли сообщение было первым сообщением в транзакции."
  remarks: "Принимающими приложениями свойство IsFirstInTransaction убедитесь, что сообщение было первым сообщением в единой транзакции для одной очереди.       Это свойство доступно только в Message Queuing версии 2.0 и более поздних версий.       Для проверки границ транзакции можно использовать свойство IsFirstInTransaction вместе с двумя свойствами: <xref:System.Messaging.Message.IsLastInTransaction%2A>до <xref:System.Messaging.Message.TransactionId%2A>.</xref:System.Messaging.Message.TransactionId%2A> </xref:System.Messaging.Message.IsLastInTransaction%2A> Используйте первое из них для проверки, было ли сообщение отправлено последним в транзакции, а второе — для извлечения идентификатора транзакции.       Если только одно сообщение отправляется в виде транзакции, IsFirstInTransaction и <xref:System.Messaging.Message.IsLastInTransaction%2A>заданы оба свойства `true`.</xref:System.Messaging.Message.IsLastInTransaction%2A>"
  example:
  - "The following code example displays the value of a message's IsFirstInTransaction property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool IsFirstInTransaction { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если сообщение было первым сообщением в транзакции; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.IsFirstInTransaction*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Сообщение не отправлено. Это свойство могут быть прочитаны только сообщения, отбираемые из очереди.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойство IsFirstInTransaction."
  platform:
  - net462
- uid: System.Messaging.Message.IsLastInTransaction
  id: IsLastInTransaction
  parent: System.Messaging.Message
  langs:
  - csharp
  name: IsLastInTransaction
  nameWithType: Message.IsLastInTransaction
  fullName: System.Messaging.Message.IsLastInTransaction
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает значение, указывающее, является ли сообщение было последним сообщением, переданным в транзакции."
  remarks: "Принимающими приложениями свойство IsLastInTransaction убедитесь, что сообщение было последним сообщением в одной транзакции в единственную очередь.       Это свойство доступно только в Message Queuing версии 2.0 и более поздних версий.       Для проверки границ транзакции можно использовать свойство IsLastInTransaction вместе с двумя свойствами: <xref:System.Messaging.Message.IsFirstInTransaction%2A>до <xref:System.Messaging.Message.TransactionId%2A>.</xref:System.Messaging.Message.TransactionId%2A> </xref:System.Messaging.Message.IsFirstInTransaction%2A> Используйте первое из них для проверки, было ли сообщение отправлено первым в транзакции, а второе — для извлечения идентификатора транзакции.       Если только одно сообщение отправляется в виде транзакции, <xref:System.Messaging.Message.IsFirstInTransaction%2A>и IsLastInTransaction заданы оба свойства `true`.</xref:System.Messaging.Message.IsFirstInTransaction%2A>"
  example:
  - "The following code example displays the value of a message's IsLastInTransaction property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool IsLastInTransaction { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если сообщение было последним сообщением, переданным в транзакции; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.IsLastInTransaction*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Сообщение не отправлено. Это свойство могут быть прочитаны только сообщения, отбираемые из очереди.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойство IsLastInTransaction."
  platform:
  - net462
- uid: System.Messaging.Message.Label
  id: Label
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Label
  nameWithType: Message.Label
  fullName: System.Messaging.Message.Label
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает определяемую приложением строку в кодировке Юникод, описывающую данное сообщение."
  remarks: "Метку сообщения можно использовать для нескольких целей. Например можно использовать его для отображения или выборочной обработки сообщений на основании значений этой метки. Метка не обязательно быть уникальным для сообщения.       Очередей сообщений и метки сообщений представляют определяемые приложением значения, которые могут помочь в идентификации очереди или сообщения в понятных для человека терминах. Он отвечает содержимое метки, которое не имеет внутреннего смысла для приложения Message Queuing, интерпретируется приложением."
  example:
  - "The following code example gets and sets the value of a message's Label property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public string Label { get; set; }
    return:
      type: System.String
      description: "Метка сообщения. Значение по умолчанию — пустая строка (»»)."
  overload: System.Messaging.Message.Label*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства Label."
  platform:
  - net462
- uid: System.Messaging.Message.LookupId
  id: LookupId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: LookupId
  nameWithType: Message.LookupId
  fullName: System.Messaging.Message.LookupId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Представлено в MSMQ 3.0. Получает идентификатор сообщения уточняющего запроса."
  remarks: "Свойством LookupId предоставляет доступ только для чтения к код поиска сообщения. Код просмотра, введенный в MSMQ 3.0 является 64-разрядный идентификатор, который создается службой Message Queuing и назначается каждому сообщению, когда сообщение будет помещено в очередь. Код просмотра не совпадает с идентификатором сообщения, который создается при отправке сообщения.       Служба Message Queuing создает идентификатор просмотра для всех сообщений, которые помещаются в очередь, включая назначения, созданный приложением, администрирования и очереди отчетов, а также создаваемые системой журнала, недоставленных сообщений соединителя и исходящих сообщений. Другими словами такие как сообщения, отправляемые передающими приложениями и службой очереди сообщений. Код поиска является уникальным в очередь и не имеет смысла вне очереди.       Если сообщение отправляется в несколько конечных очередей или если копия сообщения хранится в журнале компьютера или журнале очереди, каждая копия сообщения будет иметь свой собственный код просмотра, помещенный в соответствующую очередь.       Свойством LookupId могут быть прочитаны только сообщения, отбираемые из очереди.       Идентификатор просмотра используется для чтения конкретного сообщения в очереди. После получения идентификатора поиска сообщения принимающее приложение может вызвать <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>или <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>функцию, чтобы перейти непосредственно на это сообщение и просмотра или получения его из очереди, в отличие от курсоры, которые должно начинаться в начале очереди и перейдите к концу очереди, получение кодов просмотра сообщений в очереди отвечает приложение.</xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> </xref:System.Messaging.MessageQueue.PeekByLookupId%2A> Один из возможных способов получения кодов просмотра является создание триггера для очереди назначения, который вызывает компонент, кэширующий коды каждого сообщения, как они помещаются в очередь."
  syntax:
    content: public long LookupId { get; }
    return:
      type: System.Int64
      description: "Код поиска сообщения, который создается службой Message Queuing и является уникальным для очереди, где находится сообщение."
  overload: System.Messaging.Message.LookupId*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "MSMQ 3.0 не установлена."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Сообщение не отправлено. Это свойство могут быть прочитаны только сообщения, отбираемые из очереди.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойством LookupId."
  platform:
  - net462
- uid: System.Messaging.Message.MessageType
  id: MessageType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: MessageType
  nameWithType: Message.MessageType
  fullName: System.Messaging.Message.MessageType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: 'Gets the message type: <xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Acknowledgment&quot; name=&quot;Acknowledgment&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Report&quot; name=&quot;Report&quot; href=&quot;&quot;></xref>.'
  remarks: "Служба Message Queuing обычно устанавливает это свойство при передаче сообщения. Сообщение Message Queuing может принимать одно из следующих типов:- `Normal`, которому обычное сообщение отправляется из приложения в очередь или ответное сообщение, возвращаемое в передающее приложение.      - `Acknowledgement`, который создается службой Message Queuing при каждом передающего приложения. Например служба Message Queuing может создавать положительные или отрицательные сообщения для указания того, что исходное сообщение было доставлено или прочитано. Служба Message Queuing возвращает соответствующее подтверждающее сообщение в очередь администрирования, указанную передающим приложением.      - `Report`, который создается службой Message Queuing всякий раз, когда в источнике диспетчера очереди определена очередь отчетов. Если трассировка включена, служба Message Queuing передает сообщение-отчет в очередь отчетов Message Queuing при каждом исходного сообщения или выходе из сервера очереди сообщений."
  example:
  - "The following code example displays the value of a message's MessageType property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageType MessageType { get; }
    return:
      type: System.Messaging.MessageType
      description: "Одно из значений класса MessageType."
  overload: System.Messaging.Message.MessageType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Сообщение не отправлено. Это свойство могут быть прочитаны только сообщения, отбираемые из очереди.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойство MessageType."
  platform:
  - net462
- uid: System.Messaging.Message.Priority
  id: Priority
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Priority
  nameWithType: Message.Priority
  fullName: System.Messaging.Message.Priority
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает приоритет сообщения, используемый для определения места сообщения при его поступлении в очередь."
  remarks: "Свойство приоритет влияет на обработку службой Message Queuing сообщения как на маршруте, так и при достижении места назначения. Сообщения с более высоким приоритетом отдается предпочтение при маршрутизации и помещаются ближе к началу конечной очереди. Сообщения, имеющие одинаковый приоритет, помещаются в очередь в порядке поступления.       Можно задать приоритет может применяться только для нетранзакционных сообщений. Служба Message Queuing автоматически устанавливает приоритет транзактных сообщений равным `Lowest`, вследствие чего приоритет транзакционных сообщений пропускаются."
  example:
  - "The following code example sends two messages of different priorities to the queue, and retrieves them subsequently.  \n  \n [!code-cpp[Message.DefaultPropertiesToSend#1](~/add/codesnippet/cpp/p-system.messaging.messa_87_1.cpp)]\n [!code-vb[Message.DefaultPropertiesToSend#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_87_1.vb)]\n [!code-cs[Message.DefaultPropertiesToSend#1](~/add/codesnippet/csharp/p-system.messaging.messa_87_1.cs)]"
  syntax:
    content: public System.Messaging.MessagePriority Priority { get; set; }
    return:
      type: System.Messaging.MessagePriority
      description: "Один из <xref href=&quot;System.Messaging.MessagePriority&quot;> </xref> значения, которые представляют уровни приоритета не транзактных сообщений. Значение по умолчанию — <xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.Priority*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства Priority."
  platform:
  - net462
- uid: System.Messaging.Message.Recoverable
  id: Recoverable
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Recoverable
  nameWithType: Message.Recoverable
  fullName: System.Messaging.Message.Recoverable
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает значение, указывающее, будет ли сообщение гарантированно доставлено в случае отказа компьютера или сети неисправности."
  remarks: "Свойство Recoverable определяет, гарантируется ли доставка сообщения — даже в случае отказа компьютера во время прохождения очереди назначения сообщения.       Если доставка сообщения гарантируется, оно сохраняется локально на каждом этапе маршрута, пока не будет успешно перенаправлено на следующий компьютер. Восстановить свойства `true` может повлиять на пропускную способность.       Если сообщение является транзакционной, очереди сообщений автоматически считает сообщение восстановимых независимо от значения свойства, восстановить."
  example:
  - "The following code example gets and sets the value of a message's Recoverable property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool Recoverable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если доставка сообщения гарантируется (за счет сохранения сообщения на диске во время нахождения на маршруте); <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если доставки не подтверждена. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.Recoverable*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета восстановить свойством."
  platform:
  - net462
- uid: System.Messaging.Message.ResponseQueue
  id: ResponseQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: ResponseQueue
  nameWithType: Message.ResponseQueue
  fullName: System.Messaging.Message.ResponseQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает очередь, принимающую ответные сообщения, создаваемые приложением."
  remarks: "Свойство ResponseQueue идентифицирует очередь, принимающую сформированные приложениями ответные сообщения, которые принимающее приложение возвращает в передающее приложение. Передающее приложение задает очереди ответов при передаче их сообщений. Любая доступная очередь может быть указан в качестве очереди ответов.       Сообщения, возвращаемые в очередь ответов зависят от приложения. Приложение должно определить содержимое сообщений, а также действие необходимо выполнить при приеме сообщения."
  example:
  - "The following code example gets and sets the value of a message's ResponseQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageQueue ResponseQueue { get; set; }
    return:
      type: System.Messaging.MessageQueue
      description: "<xref href=&quot;System.Messaging.MessageQueue&quot;> </xref> В какой ответ, созданный приложением возвращаются сообщения. Значение по умолчанию — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.ResponseQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства ResponseQueue."
  platform:
  - net462
- uid: System.Messaging.Message.SecurityContext
  id: SecurityContext
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SecurityContext
  nameWithType: Message.SecurityContext
  fullName: System.Messaging.Message.SecurityContext
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает контекст безопасности для сообщения."
  syntax:
    content: public System.Messaging.SecurityContext SecurityContext { get; set; }
    return:
      type: System.Messaging.SecurityContext
      description: "Объект <xref href=&quot;System.Messaging.SecurityContext&quot;> </xref> , содержащий контекст безопасности для сообщения, если свойство уже был задан; в противном случае значение NULL."
  overload: System.Messaging.Message.SecurityContext*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.SenderCertificate
  id: SenderCertificate
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SenderCertificate
  nameWithType: Message.SenderCertificate
  fullName: System.Messaging.Message.SenderCertificate
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает сертификат безопасности, используемый для проверки подлинности сообщений."
  remarks: "Принимающее приложение использует свойство SenderCertificate, когда сообщение включает внешний сертификат безопасности.       Служба Message Queuing может проверять подлинность сообщения с помощью либо сертификат внутренней или внешней безопасности. Служба Message Queuing предоставляет внутренние сертификаты, которые используются для проверки целостности сообщения. В центре сертификации предоставляет внешний сертификат, к которому можно получить через свойство SenderCertificate сообщения. Для проверки подлинности сообщения очереди сообщений, внешний сертификат позволяет провести дополнительную проверку отправителя принимающим приложением. Внутренний сертификат не имеет подходящего значения принимающему приложению.       Внешний сертификат должны регистрироваться в службе каталога системы очереди сообщений. Внешний сертификат содержит сведения о центре сертификации, пользователь сертификата, срок действия сертификата, открытый ключ пользователя сертификата и подпись центра сертификации."
  syntax:
    content: public byte[] SenderCertificate { get; set; }
    return:
      type: System.Byte[]
      description: "Массив байтовых значений, представляющий сертификат безопасности, который Message Queuing использует для проверки отправителя сообщения. Значение по умолчанию — массив нулевой длины."
  overload: System.Messaging.Message.SenderCertificate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства SenderCertificate."
  platform:
  - net462
- uid: System.Messaging.Message.SenderId
  id: SenderId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SenderId
  nameWithType: Message.SenderId
  fullName: System.Messaging.Message.SenderId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает идентификатор пользователя, отправившего сообщение."
  remarks: "Если <xref:System.Messaging.Message.AttachSenderId%2A>свойство `false`, идентификатор отправителя, указанный в свойстве идентификатор отправителя не присоединен к сообщения при его передаче.</xref:System.Messaging.Message.AttachSenderId%2A> Это указывает очереди сообщений не проверки отправителя при отправке сообщения в очередь назначения. Если <xref:System.Messaging.Message.AttachSenderId%2A>свойство `true`, значение свойства SenderId заслуживает только в том случае, если сообщение прошло проверку подлинности.</xref:System.Messaging.Message.AttachSenderId%2A> Используйте <xref:System.Messaging.Message.Authenticated%2A>свойство в сочетании со свойством для проверки прав доступа отправителя SenderId.</xref:System.Messaging.Message.Authenticated%2A>       Приложение-подключатель является приложение, использующее сервера соединителя для обеспечения связи между другими системами очередей и сообщений. Служба Message Queuing требует соединителя приложения для предоставления идентификацию отправителя. Необходимо задать <xref:System.Messaging.Message.ConnectorType%2A>свойства при отправке сообщений через приложение-подключатель.</xref:System.Messaging.Message.ConnectorType%2A>"
  syntax:
    content: public byte[] SenderId { get; }
    return:
      type: System.Byte[]
      description: "Массив байтовых значений, определяющий отправителя. Диспетчер принимающей очереди использует идентификатор при проверке подлинности сообщения проверяет отправителя сообщения и его прав доступа к очереди."
  overload: System.Messaging.Message.SenderId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Сообщение не отправлено. Это свойство могут быть прочитаны только сообщения, отбираемые из очереди.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойство SenderId."
  platform:
  - net462
- uid: System.Messaging.Message.SenderVersion
  id: SenderVersion
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SenderVersion
  nameWithType: Message.SenderVersion
  fullName: System.Messaging.Message.SenderVersion
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает версию MSMQ, используемый для отправки сообщения."
  remarks: "Свойство SenderVersion важно для некоторых функций. Например обработка транзакций поддерживается только по очереди сообщений версии 2.0 и более поздних версий и цифровые подписи используются для проверки подлинности сообщений, передаваемых MSMQ 1.0.       Диспетчер передающей очереди при отправке сообщения задается SenderVersion."
  example:
  - "The following code example displays the value of a message's SenderVersion property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public long SenderVersion { get; }
    return:
      type: System.Int64
      description: "Версия MSMQ, используемый для отправки сообщения."
  overload: System.Messaging.Message.SenderVersion*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Сообщение не отправлено. Это свойство могут быть прочитаны только сообщения, отбираемые из очереди.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойство SenderVersion."
  platform:
  - net462
- uid: System.Messaging.Message.SentTime
  id: SentTime
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SentTime
  nameWithType: Message.SentTime
  fullName: System.Messaging.Message.SentTime
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает дату и время на момент передачи данного сообщения диспетчером исходной очереди компьютера-отправителя."
  remarks: "Свойство SentTime корректируется в локальное время компьютера, на котором эта экземпляр <xref:System.Messaging.Message>был создан класс.</xref:System.Messaging.Message> Этот часовой пояс может отличаться от тех исходных и конечных очередей."
  example:
  - "The following code example displays the value of a message's SentTime property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public DateTime SentTime { get; }
    return:
      type: System.DateTime
      description: "Объект <xref:System.DateTime>, представляющий время, сообщение было отправлено.</xref:System.DateTime>"
  overload: System.Messaging.Message.SentTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Сообщение не отправлено. Это свойство могут быть прочитаны только сообщения, отбираемые из очереди.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойство SentTime."
  platform:
  - net462
- uid: System.Messaging.Message.SourceMachine
  id: SourceMachine
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SourceMachine
  nameWithType: Message.SourceMachine
  fullName: System.Messaging.Message.SourceMachine
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Получает имя компьютера, из которого было создано сообщение."
  remarks: "Формат свойства SourceMachine не включает предшествующий две косые черты (\\\\\\\\). Например `myServer` является допустимым SourceMachine."
  example:
  - "The following code example displays the value of a message's SourceMachine property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public string SourceMachine { get; }
    return:
      type: System.String
      description: "Имя компьютера, с которого было отправлено сообщение."
  overload: System.Messaging.Message.SourceMachine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Сообщение не отправлено. Это свойство могут быть прочитаны только сообщения, отбираемые из очереди.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойство SourceMachine."
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "О компьютере или каталог службе будет недоступен."
  platform:
  - net462
- uid: System.Messaging.Message.TimeToBeReceived
  id: TimeToBeReceived
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TimeToBeReceived
  nameWithType: Message.TimeToBeReceived
  fullName: System.Messaging.Message.TimeToBeReceived
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает максимальное количество времени, за которое сообщение должно быть получено из очереди назначения."
  remarks: "Свойства TimeToBeReceived указывает общее время для отправленного сообщения должно быть получено из очереди назначения. Этот лимит включает время, затраченное на получение для очереди назначения и время ожидания в очереди до получения сообщения.      Настроек [!CAUTION] настроек при использовании зависимых клиентских компьютеров, убедитесь, что часы на клиентском компьютере синхронизированы с часами на сервере, на котором выполняется служба очереди сообщений. В противном случае может привести к непредсказуемому поведению при отправке сообщения, свойство которого TimeToBeReceived <xref:System.Messaging.Message.InfiniteTimeout>.</xref:System.Messaging.Message.InfiniteTimeout>       Если по истечении интервала, указанного в свойстве TimeToBeReceived перед удалением сообщения из очереди, Message Queuing отвергает это сообщение одним из двух способов. Если сообщение <xref:System.Messaging.Message.UseDeadLetterQueue%2A>свойство `true`, сообщение отправляется в очередь недоставленных сообщений.</xref:System.Messaging.Message.UseDeadLetterQueue%2A> Если <xref:System.Messaging.Message.UseDeadLetterQueue%2A>является `false`, сообщение пропускается.</xref:System.Messaging.Message.UseDeadLetterQueue%2A>       Можно задать сообщения <xref:System.Messaging.Message.AcknowledgeType%2A>свойство для запроса, что очереди сообщений отправить сообщение отрицательного подтверждения резервное передающее приложение, если сообщения не получаются, до истечения срока действия таймера.</xref:System.Messaging.Message.AcknowledgeType%2A>       Если значение, указанное в свойстве TimeToBeReceived меньше значения, указанного в <xref:System.Messaging.Message.TimeToReachQueue%2A>, TimeToBeReceived имеет приоритет.</xref:System.Messaging.Message.TimeToReachQueue%2A>       Свойство TimeToBeReceived первого сообщения очереди сообщений используется несколько сообщений, отправленных в одной транзакции."
  example:
  - "The following code example gets and sets the value of a message's TimeToBeReceived property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public TimeSpan TimeToBeReceived { get; set; }
    return:
      type: System.TimeSpan
      description: "Общее время для отправленного сообщения должно быть получено из очереди назначения. Значение по умолчанию — <xref href=&quot;System.Messaging.Message.InfiniteTimeout&quot;> </xref>."
  overload: System.Messaging.Message.TimeToBeReceived*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Чтобы игнорировать свойства TimeToBeReceived фильтруется очереди сообщений."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Указано недопустимое значение для TimeToBeReceived."
  platform:
  - net462
- uid: System.Messaging.Message.TimeToReachQueue
  id: TimeToReachQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TimeToReachQueue
  nameWithType: Message.TimeToReachQueue
  fullName: System.Messaging.Message.TimeToReachQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает максимальное количество времени, за которое сообщение должно дойти до очереди."
  remarks: "При истечении интервала, указанного в свойстве TimeToReachQueue сообщение достигнет конечной, Message Queuing отвергает это сообщение одним из двух способов. Если сообщение <xref:System.Messaging.Message.UseDeadLetterQueue%2A>свойство `true`, сообщение отправляется в очередь недоставленных сообщений.</xref:System.Messaging.Message.UseDeadLetterQueue%2A> Если <xref:System.Messaging.Message.UseDeadLetterQueue%2A>является `false`, сообщение пропускается можно задать сообщения <xref:System.Messaging.Message.AcknowledgeType%2A>свойство для запроса, что очереди сообщений отправить сообщение отрицательного подтверждения обратно в передающее приложение, если сообщение пришло до истечения времени ожидания.</xref:System.Messaging.Message.AcknowledgeType%2A> </xref:System.Messaging.Message.UseDeadLetterQueue%2A>       Если свойство TimeToReachQueue имеет значение 0 секунд, Message Queuing пытается отправить его в место назначения, если очередь ожидает сообщения. Если очередь локальная, сообщение всегда достигает очереди.       Если значение, указанное в свойстве TimeToReachQueue больше, чем значение, заданное параметром <xref:System.Messaging.Message.TimeToBeReceived%2A>Свойства <xref:System.Messaging.Message.TimeToBeReceived%2A>имеет более высокий приоритет.</xref:System.Messaging.Message.TimeToBeReceived%2A> </xref:System.Messaging.Message.TimeToBeReceived%2A>       Свойство TimeToReachQueue первого сообщения очереди сообщений используется несколько сообщений, отправленных в одной транзакции."
  example:
  - "The following code example gets and sets the value of a message's TimeToReachQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public TimeSpan TimeToReachQueue { get; set; }
    return:
      type: System.TimeSpan
      description: "Промежуток времени, за которое сообщение должно достичь очереди назначения, начиная от времени сообщение будет отправлено. Значение по умолчанию — <xref href=&quot;System.Messaging.Message.InfiniteTimeout&quot;> </xref>."
  overload: System.Messaging.Message.TimeToReachQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства TimeToReachQueue."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Указано недопустимое значение для TimeToReachQueue. Она может представлять отрицательное число."
  platform:
  - net462
- uid: System.Messaging.Message.TransactionId
  id: TransactionId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TransactionId
  nameWithType: Message.TransactionId
  fullName: System.Messaging.Message.TransactionId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает идентификатор для транзакции, в которой сообщение было часть."
  remarks: "Принимающими приложениями свойство TransactionId убедитесь, что сообщение было отправлено в рамках отдельной транзакции. Идентификатор транзакции содержит идентификатор передающего компьютера (первые 16 битов) следуют 4-байтовый порядковый номер транзакции.       Это свойство доступно только для очереди сообщений версии 2.0 и более поздней версии.       Не гарантируется, что идентификаторы транзакций будут уникальными, так как последовательные номера транзакций не сохраняются, и они начинаются сначала после достижения 2 <sup>20</sup>. Служба Message Queuing гарантирует только то, что последующие транзакции будет иметь различные транзакции порядковые номера.       Можно использовать свойство TransactionId вместе с <xref:System.Messaging.Message.IsFirstInTransaction%2A>и <xref:System.Messaging.Message.IsLastInTransaction%2A>Свойства для проверки границ транзакции.</xref:System.Messaging.Message.IsLastInTransaction%2A> </xref:System.Messaging.Message.IsFirstInTransaction%2A>"
  example:
  - "The following code example displays the value of a message's TransactionId property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public string TransactionId { get; }
    return:
      type: System.String
      description: "Идентификатор транзакции, связанные с данным сообщением."
  overload: System.Messaging.Message.TransactionId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Сообщение не отправлено. Это свойство могут быть прочитаны только сообщения, отбираемые из очереди.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойство TransactionId."
  platform:
  - net462
- uid: System.Messaging.Message.TransactionStatusQueue
  id: TransactionStatusQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TransactionStatusQueue
  nameWithType: Message.TransactionStatusQueue
  fullName: System.Messaging.Message.TransactionStatusQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Получает очереди состояния транзакции на исходном компьютере."
  remarks: "Свойство TransactionStatusQueue описывает транзактную очередь на исходном компьютере, который получает подтверждение получения чтения из приложения-подключатели. Служба Message Queuing устанавливает свойство и соединителя приложения используют его при поиске транзактных сообщений, переданных во внешние очереди.       Внешнюю очередь существует в очереди системы, отличной от Microsoft Message Queuing. Служба Message Queuing связывается с другими очередями через приложение-подключатель.       Приложение-подключатель можно использовать очереди состояния транзакции для отправки подтверждающих сообщений в передающее приложение. Очереди состояния транзакции должна получать эти подтверждения, даже если отправляющее приложение не запрашивает других подтверждений."
  example:
  - "The following code example displays the value of a message's TransactionStatusQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }
    return:
      type: System.Messaging.MessageQueue
      description: "Очереди состояния транзакции на исходном компьютере, который используется для отправки сообщений подтверждения передающее приложение. Значение по умолчанию — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.TransactionStatusQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Сообщение не отправлено. Это свойство могут быть прочитаны только сообщения, отбираемые из очереди.       - или - очереди сообщений будет отфильтрован, чтобы игнорировать свойство TransactionStatusQueue."
  platform:
  - net462
- uid: System.Messaging.Message.UseAuthentication
  id: UseAuthentication
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseAuthentication
  nameWithType: Message.UseAuthentication
  fullName: System.Messaging.Message.UseAuthentication
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает значение, указывающее, сообщение было (или необходимо) прошедшего проверку подлинности перед отправкой."
  remarks: "Свойство UseAuthentication указывает, должна ли сообщение проверку подлинности. Если отправляющее приложение запрашивает проверку подлинности, Message Queuing создает цифровую подпись и использует ее для подписи сообщения при его передаче и проверки подлинности сообщения при его получении.       Если UseAuthentication `false` и сообщение отправляется в очередь, принимающую только сообщения, прошедшие проверку подлинности, сообщение будет отклонено при поступлении в очередь.       Не удается определить, если сообщение не прошел проверку подлинности, просмотрев его свойства. Служба Message Queuing отклоняет такие сообщения, прежде чем они попадут в очередь. Тем не менее можно запросить подтверждающее сообщение, когда сбоя доставки сообщение на попадает в очередь."
  syntax:
    content: public bool UseAuthentication { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если отправляющее приложение запрашивает проверку подлинности для сообщения. в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.UseAuthentication*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства UseAuthentication."
  platform:
  - net462
- uid: System.Messaging.Message.UseDeadLetterQueue
  id: UseDeadLetterQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseDeadLetterQueue
  nameWithType: Message.UseDeadLetterQueue
  fullName: System.Messaging.Message.UseDeadLetterQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает значение, указывающее, следует ли отправлять копию сообщения, которое не может быть доставлено в очередь недоставленных сообщений."
  remarks: "<xref:System.Messaging.Message.UseJournalQueue%2A>И UseDeadLetterQueue свойства указывают, как очереди сообщений отслеживает сообщения.</xref:System.Messaging.Message.UseJournalQueue%2A> Если UseDeadLetterQueue `true`, сообщение об ошибке доставки (для нетранзакционных сообщений), в результате сообщение отправлено в нетранзакционную очередь недоставленных сообщений на компьютере, который не удалось доставить сообщение. Может быть причиной сбоя доставки сообщение таймера истекает, например.       В случае сбоя доставки транзакционного сообщения служба Message Queuing передает сообщение в транзакционную очередь недоставленных сообщений на компьютере-источнике во всех отрицательных или сомнительных случаях.       Если хранение сообщений в очереди недоставленных сообщений, необходимо снять очереди периодически для удаления сообщений, которые больше не нужны. Сообщения, хранящиеся в очереди недоставленных сообщений, учитываются в размере квоты для компьютера, на котором находится очередь. Квота компьютера устанавливается администратором и определяет для объема, выделенного для хранения сообщений на данном компьютере, а не только в одной очереди.       Не создавайте журнал или очередь недоставленных сообщений. Они оба системных очередей, создается службой Message Queuing."
  example:
  - "The following code example gets and sets the value of a message's UseDeadLetterQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseDeadLetterQueue { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если результатом сбоя доставки сообщения должен быть копии сообщений, отправляемых в очередь недоставленных сообщений; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.UseDeadLetterQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства UseDeadLetterQueue."
  platform:
  - net462
- uid: System.Messaging.Message.UseEncryption
  id: UseEncryption
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseEncryption
  nameWithType: Message.UseEncryption
  fullName: System.Messaging.Message.UseEncryption
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает значение, указывающее, следует ли сообщение конфиденциальным."
  remarks: "Если сообщение является закрытым, его текст шифруется перед отправкой и расшифровывается при получении. Для отправки конфиденциальное сообщение, передающее приложение должно указывать, об использовании шифрования и при необходимости алгоритма шифрования.       При передаче конфиденциальных сообщений, приложения не должны выполнять шифрование сообщения. Служба Message Queuing может шифровать текст сообщения, когда приложение отправляет сообщения в рамках предприятия Microsoft Windows 2000, который имеет доступ к службе каталогов. При получении конфиденциальных сообщений, диспетчер принимающей очереди всегда расшифровывает текст сообщения."
  example:
  - "The following code example gets and sets the value of a message's UseEncryption property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseEncryption { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>требовать очереди сообщений для шифрования сообщения. в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.UseEncryption*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства UseEncryption."
  platform:
  - net462
- uid: System.Messaging.Message.UseJournalQueue
  id: UseJournalQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseJournalQueue
  nameWithType: Message.UseJournalQueue
  fullName: System.Messaging.Message.UseJournalQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает значение, указывающее, должна ли храниться копия сообщения в журнале компьютера на исходном компьютере."
  remarks: "UseJournalQueue и <xref:System.Messaging.Message.UseDeadLetterQueue%2A>Свойства указывают, как очереди сообщений отслеживает сообщения.</xref:System.Messaging.Message.UseDeadLetterQueue%2A> Если UseJournalQueue `true`, а затем его копия сохраняется в журнале исходного компьютера на каждом шаге передачи сообщения.       Отправленного сообщения копируется в очередь журнала, только если очередь назначения располагается на удаленном компьютере. Если файл находится на локальном компьютере, сообщение отправляется непосредственно в очередь; отсутствуют промежуточные шаги требующих ведения журнала.       Если хранение сообщений в очереди журнала, очистки очереди периодически для удаления сообщений, которые больше не нужны. Сообщения, хранящиеся в очереди журнала, входят в квоту для компьютера, на котором находится очередь. (Квота компьютера устанавливается администратором).       Не создавайте журнал или очередь недоставленных сообщений. Они оба системных очередей, создается службой Message Queuing."
  example:
  - "The following code example gets and sets the value of a message's UseJournalQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseJournalQueue { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы требуется сохранить копию сообщения в журнале компьютера-источника после сообщения успешной передачи (с исходного компьютера на следующий сервер); в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.UseJournalQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Чтобы не учитывать свойство UseJournalQueue фильтруется очереди сообщений."
  platform:
  - net462
- uid: System.Messaging.Message.UseTracing
  id: UseTracing
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseTracing
  nameWithType: Message.UseTracing
  fullName: System.Messaging.Message.UseTracing
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "Возвращает или задает значение, указывающее, следует ли отслеживать сообщение при его переходе к очереди назначения."
  remarks: "Свойство UseTracing Указывает необходимость отслеживать сообщение при его переходе к очереди назначения. Если `true`, в отчет (создается службой Message Queuing) отправляется в очередь отчетов при каждом проходе сообщения через сервер маршрутизации очереди сообщений. Очередь отчетов определяется службой Queue Manager источника. Очереди отчетов не ограничиваются отчетами, создаваемыми службой Message Queuing; создаваемые приложением сообщения могут отправляться также в очередь отчетов.       Использование трассировки включает настройку Active Directory и указании очереди отчета службой очередей сообщений. Администратор настраивает эти параметры."
  example:
  - "The following code example gets and sets the value of a message's UseTracing property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseTracing { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>При каждом промежуточном этапе прохождения сообщения в очередь назначения создает отчет, передаваемый в очередь отчетов в системе; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Messaging.Message.UseTracing*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Очередь сообщений отфильтрована без учета свойства UseTracing."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.Messaging.MessageQueueException
  parent: System.Messaging
  isExternal: false
  name: MessageQueueException
  nameWithType: MessageQueueException
  fullName: System.Messaging.MessageQueueException
- uid: System.Messaging.Message.#ctor
  parent: System.Messaging.Message
  isExternal: false
  name: Message()
  nameWithType: Message.Message()
  fullName: System.Messaging.Message.Message()
- uid: System.Messaging.Message.#ctor(System.Object)
  parent: System.Messaging.Message
  isExternal: false
  name: Message(Object)
  nameWithType: Message.Message(Object)
  fullName: System.Messaging.Message.Message(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)
  parent: System.Messaging.Message
  isExternal: false
  name: Message(Object,IMessageFormatter)
  nameWithType: Message.Message(Object,IMessageFormatter)
  fullName: System.Messaging.Message.Message(Object,IMessageFormatter)
- uid: System.Messaging.IMessageFormatter
  parent: System.Messaging
  isExternal: false
  name: IMessageFormatter
  nameWithType: IMessageFormatter
  fullName: System.Messaging.IMessageFormatter
- uid: System.Messaging.Message.AcknowledgeType
  parent: System.Messaging.Message
  isExternal: false
  name: AcknowledgeType
  nameWithType: Message.AcknowledgeType
  fullName: System.Messaging.Message.AcknowledgeType
- uid: System.Messaging.AcknowledgeTypes
  parent: System.Messaging
  isExternal: false
  name: AcknowledgeTypes
  nameWithType: AcknowledgeTypes
  fullName: System.Messaging.AcknowledgeTypes
- uid: System.Messaging.Message.Acknowledgment
  parent: System.Messaging.Message
  isExternal: false
  name: Acknowledgment
  nameWithType: Message.Acknowledgment
  fullName: System.Messaging.Message.Acknowledgment
- uid: System.Messaging.Acknowledgment
  parent: System.Messaging
  isExternal: false
  name: Acknowledgment
  nameWithType: Acknowledgment
  fullName: System.Messaging.Acknowledgment
- uid: System.Messaging.Message.AdministrationQueue
  parent: System.Messaging.Message
  isExternal: false
  name: AdministrationQueue
  nameWithType: Message.AdministrationQueue
  fullName: System.Messaging.Message.AdministrationQueue
- uid: System.Messaging.MessageQueue
  parent: System.Messaging
  isExternal: false
  name: MessageQueue
  nameWithType: MessageQueue
  fullName: System.Messaging.MessageQueue
- uid: System.Messaging.Message.AppSpecific
  parent: System.Messaging.Message
  isExternal: false
  name: AppSpecific
  nameWithType: Message.AppSpecific
  fullName: System.Messaging.Message.AppSpecific
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Messaging.Message.ArrivedTime
  parent: System.Messaging.Message
  isExternal: false
  name: ArrivedTime
  nameWithType: Message.ArrivedTime
  fullName: System.Messaging.Message.ArrivedTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Messaging.Message.AttachSenderId
  parent: System.Messaging.Message
  isExternal: false
  name: AttachSenderId
  nameWithType: Message.AttachSenderId
  fullName: System.Messaging.Message.AttachSenderId
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Messaging.Message.Authenticated
  parent: System.Messaging.Message
  isExternal: false
  name: Authenticated
  nameWithType: Message.Authenticated
  fullName: System.Messaging.Message.Authenticated
- uid: System.Messaging.Message.AuthenticationProviderName
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderName
  nameWithType: Message.AuthenticationProviderName
  fullName: System.Messaging.Message.AuthenticationProviderName
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Messaging.Message.AuthenticationProviderType
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderType
  nameWithType: Message.AuthenticationProviderType
  fullName: System.Messaging.Message.AuthenticationProviderType
- uid: System.Messaging.CryptographicProviderType
  parent: System.Messaging
  isExternal: false
  name: CryptographicProviderType
  nameWithType: CryptographicProviderType
  fullName: System.Messaging.CryptographicProviderType
- uid: System.Messaging.Message.Body
  parent: System.Messaging.Message
  isExternal: false
  name: Body
  nameWithType: Message.Body
  fullName: System.Messaging.Message.Body
- uid: System.Messaging.Message.BodyStream
  parent: System.Messaging.Message
  isExternal: false
  name: BodyStream
  nameWithType: Message.BodyStream
  fullName: System.Messaging.Message.BodyStream
- uid: System.IO.Stream
  parent: System.IO
  isExternal: true
  name: Stream
  nameWithType: Stream
  fullName: System.IO.Stream
- uid: System.Messaging.Message.BodyType
  parent: System.Messaging.Message
  isExternal: false
  name: BodyType
  nameWithType: Message.BodyType
  fullName: System.Messaging.Message.BodyType
- uid: System.Messaging.Message.ConnectorType
  parent: System.Messaging.Message
  isExternal: false
  name: ConnectorType
  nameWithType: Message.ConnectorType
  fullName: System.Messaging.Message.ConnectorType
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.Messaging.Message.CorrelationId
  parent: System.Messaging.Message
  isExternal: false
  name: CorrelationId
  nameWithType: Message.CorrelationId
  fullName: System.Messaging.Message.CorrelationId
- uid: System.Messaging.Message.DestinationQueue
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationQueue
  nameWithType: Message.DestinationQueue
  fullName: System.Messaging.Message.DestinationQueue
- uid: System.Messaging.Message.DestinationSymmetricKey
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationSymmetricKey
  nameWithType: Message.DestinationSymmetricKey
  fullName: System.Messaging.Message.DestinationSymmetricKey
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Messaging.Message.DigitalSignature
  parent: System.Messaging.Message
  isExternal: false
  name: DigitalSignature
  nameWithType: Message.DigitalSignature
  fullName: System.Messaging.Message.DigitalSignature
- uid: System.Messaging.Message.EncryptionAlgorithm
  parent: System.Messaging.Message
  isExternal: false
  name: EncryptionAlgorithm
  nameWithType: Message.EncryptionAlgorithm
  fullName: System.Messaging.Message.EncryptionAlgorithm
- uid: System.Messaging.EncryptionAlgorithm
  parent: System.Messaging
  isExternal: false
  name: EncryptionAlgorithm
  nameWithType: EncryptionAlgorithm
  fullName: System.Messaging.EncryptionAlgorithm
- uid: System.Messaging.Message.Extension
  parent: System.Messaging.Message
  isExternal: false
  name: Extension
  nameWithType: Message.Extension
  fullName: System.Messaging.Message.Extension
- uid: System.Messaging.Message.Formatter
  parent: System.Messaging.Message
  isExternal: false
  name: Formatter
  nameWithType: Message.Formatter
  fullName: System.Messaging.Message.Formatter
- uid: System.Messaging.Message.HashAlgorithm
  parent: System.Messaging.Message
  isExternal: false
  name: HashAlgorithm
  nameWithType: Message.HashAlgorithm
  fullName: System.Messaging.Message.HashAlgorithm
- uid: System.Messaging.HashAlgorithm
  parent: System.Messaging
  isExternal: false
  name: HashAlgorithm
  nameWithType: HashAlgorithm
  fullName: System.Messaging.HashAlgorithm
- uid: System.Messaging.Message.Id
  parent: System.Messaging.Message
  isExternal: false
  name: Id
  nameWithType: Message.Id
  fullName: System.Messaging.Message.Id
- uid: System.Messaging.Message.InfiniteTimeout
  parent: System.Messaging.Message
  isExternal: false
  name: InfiniteTimeout
  nameWithType: Message.InfiniteTimeout
  fullName: System.Messaging.Message.InfiniteTimeout
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Messaging.Message.IsFirstInTransaction
  parent: System.Messaging.Message
  isExternal: false
  name: IsFirstInTransaction
  nameWithType: Message.IsFirstInTransaction
  fullName: System.Messaging.Message.IsFirstInTransaction
- uid: System.Messaging.Message.IsLastInTransaction
  parent: System.Messaging.Message
  isExternal: false
  name: IsLastInTransaction
  nameWithType: Message.IsLastInTransaction
  fullName: System.Messaging.Message.IsLastInTransaction
- uid: System.Messaging.Message.Label
  parent: System.Messaging.Message
  isExternal: false
  name: Label
  nameWithType: Message.Label
  fullName: System.Messaging.Message.Label
- uid: System.Messaging.Message.LookupId
  parent: System.Messaging.Message
  isExternal: false
  name: LookupId
  nameWithType: Message.LookupId
  fullName: System.Messaging.Message.LookupId
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Messaging.Message.MessageType
  parent: System.Messaging.Message
  isExternal: false
  name: MessageType
  nameWithType: Message.MessageType
  fullName: System.Messaging.Message.MessageType
- uid: System.Messaging.MessageType
  parent: System.Messaging
  isExternal: false
  name: MessageType
  nameWithType: MessageType
  fullName: System.Messaging.MessageType
- uid: System.Messaging.Message.Priority
  parent: System.Messaging.Message
  isExternal: false
  name: Priority
  nameWithType: Message.Priority
  fullName: System.Messaging.Message.Priority
- uid: System.Messaging.MessagePriority
  parent: System.Messaging
  isExternal: false
  name: MessagePriority
  nameWithType: MessagePriority
  fullName: System.Messaging.MessagePriority
- uid: System.Messaging.Message.Recoverable
  parent: System.Messaging.Message
  isExternal: false
  name: Recoverable
  nameWithType: Message.Recoverable
  fullName: System.Messaging.Message.Recoverable
- uid: System.Messaging.Message.ResponseQueue
  parent: System.Messaging.Message
  isExternal: false
  name: ResponseQueue
  nameWithType: Message.ResponseQueue
  fullName: System.Messaging.Message.ResponseQueue
- uid: System.Messaging.Message.SecurityContext
  parent: System.Messaging.Message
  isExternal: false
  name: SecurityContext
  nameWithType: Message.SecurityContext
  fullName: System.Messaging.Message.SecurityContext
- uid: System.Messaging.SecurityContext
  parent: System.Messaging
  isExternal: false
  name: SecurityContext
  nameWithType: SecurityContext
  fullName: System.Messaging.SecurityContext
- uid: System.Messaging.Message.SenderCertificate
  parent: System.Messaging.Message
  isExternal: false
  name: SenderCertificate
  nameWithType: Message.SenderCertificate
  fullName: System.Messaging.Message.SenderCertificate
- uid: System.Messaging.Message.SenderId
  parent: System.Messaging.Message
  isExternal: false
  name: SenderId
  nameWithType: Message.SenderId
  fullName: System.Messaging.Message.SenderId
- uid: System.Messaging.Message.SenderVersion
  parent: System.Messaging.Message
  isExternal: false
  name: SenderVersion
  nameWithType: Message.SenderVersion
  fullName: System.Messaging.Message.SenderVersion
- uid: System.Messaging.Message.SentTime
  parent: System.Messaging.Message
  isExternal: false
  name: SentTime
  nameWithType: Message.SentTime
  fullName: System.Messaging.Message.SentTime
- uid: System.Messaging.Message.SourceMachine
  parent: System.Messaging.Message
  isExternal: false
  name: SourceMachine
  nameWithType: Message.SourceMachine
  fullName: System.Messaging.Message.SourceMachine
- uid: System.Messaging.Message.TimeToBeReceived
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToBeReceived
  nameWithType: Message.TimeToBeReceived
  fullName: System.Messaging.Message.TimeToBeReceived
- uid: System.Messaging.Message.TimeToReachQueue
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToReachQueue
  nameWithType: Message.TimeToReachQueue
  fullName: System.Messaging.Message.TimeToReachQueue
- uid: System.Messaging.Message.TransactionId
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionId
  nameWithType: Message.TransactionId
  fullName: System.Messaging.Message.TransactionId
- uid: System.Messaging.Message.TransactionStatusQueue
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionStatusQueue
  nameWithType: Message.TransactionStatusQueue
  fullName: System.Messaging.Message.TransactionStatusQueue
- uid: System.Messaging.Message.UseAuthentication
  parent: System.Messaging.Message
  isExternal: false
  name: UseAuthentication
  nameWithType: Message.UseAuthentication
  fullName: System.Messaging.Message.UseAuthentication
- uid: System.Messaging.Message.UseDeadLetterQueue
  parent: System.Messaging.Message
  isExternal: false
  name: UseDeadLetterQueue
  nameWithType: Message.UseDeadLetterQueue
  fullName: System.Messaging.Message.UseDeadLetterQueue
- uid: System.Messaging.Message.UseEncryption
  parent: System.Messaging.Message
  isExternal: false
  name: UseEncryption
  nameWithType: Message.UseEncryption
  fullName: System.Messaging.Message.UseEncryption
- uid: System.Messaging.Message.UseJournalQueue
  parent: System.Messaging.Message
  isExternal: false
  name: UseJournalQueue
  nameWithType: Message.UseJournalQueue
  fullName: System.Messaging.Message.UseJournalQueue
- uid: System.Messaging.Message.UseTracing
  parent: System.Messaging.Message
  isExternal: false
  name: UseTracing
  nameWithType: Message.UseTracing
  fullName: System.Messaging.Message.UseTracing
- uid: System.Messaging.Message.#ctor*
  parent: System.Messaging.Message
  isExternal: false
  name: Message
  nameWithType: Message.Message
- uid: System.Messaging.Message.AcknowledgeType*
  parent: System.Messaging.Message
  isExternal: false
  name: AcknowledgeType
  nameWithType: Message.AcknowledgeType
- uid: System.Messaging.Message.Acknowledgment*
  parent: System.Messaging.Message
  isExternal: false
  name: Acknowledgment
  nameWithType: Message.Acknowledgment
- uid: System.Messaging.Message.AdministrationQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: AdministrationQueue
  nameWithType: Message.AdministrationQueue
- uid: System.Messaging.Message.AppSpecific*
  parent: System.Messaging.Message
  isExternal: false
  name: AppSpecific
  nameWithType: Message.AppSpecific
- uid: System.Messaging.Message.ArrivedTime*
  parent: System.Messaging.Message
  isExternal: false
  name: ArrivedTime
  nameWithType: Message.ArrivedTime
- uid: System.Messaging.Message.AttachSenderId*
  parent: System.Messaging.Message
  isExternal: false
  name: AttachSenderId
  nameWithType: Message.AttachSenderId
- uid: System.Messaging.Message.Authenticated*
  parent: System.Messaging.Message
  isExternal: false
  name: Authenticated
  nameWithType: Message.Authenticated
- uid: System.Messaging.Message.AuthenticationProviderName*
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderName
  nameWithType: Message.AuthenticationProviderName
- uid: System.Messaging.Message.AuthenticationProviderType*
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderType
  nameWithType: Message.AuthenticationProviderType
- uid: System.Messaging.Message.Body*
  parent: System.Messaging.Message
  isExternal: false
  name: Body
  nameWithType: Message.Body
- uid: System.Messaging.Message.BodyStream*
  parent: System.Messaging.Message
  isExternal: false
  name: BodyStream
  nameWithType: Message.BodyStream
- uid: System.Messaging.Message.BodyType*
  parent: System.Messaging.Message
  isExternal: false
  name: BodyType
  nameWithType: Message.BodyType
- uid: System.Messaging.Message.ConnectorType*
  parent: System.Messaging.Message
  isExternal: false
  name: ConnectorType
  nameWithType: Message.ConnectorType
- uid: System.Messaging.Message.CorrelationId*
  parent: System.Messaging.Message
  isExternal: false
  name: CorrelationId
  nameWithType: Message.CorrelationId
- uid: System.Messaging.Message.DestinationQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationQueue
  nameWithType: Message.DestinationQueue
- uid: System.Messaging.Message.DestinationSymmetricKey*
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationSymmetricKey
  nameWithType: Message.DestinationSymmetricKey
- uid: System.Messaging.Message.DigitalSignature*
  parent: System.Messaging.Message
  isExternal: false
  name: DigitalSignature
  nameWithType: Message.DigitalSignature
- uid: System.Messaging.Message.EncryptionAlgorithm*
  parent: System.Messaging.Message
  isExternal: false
  name: EncryptionAlgorithm
  nameWithType: Message.EncryptionAlgorithm
- uid: System.Messaging.Message.Extension*
  parent: System.Messaging.Message
  isExternal: false
  name: Extension
  nameWithType: Message.Extension
- uid: System.Messaging.Message.Formatter*
  parent: System.Messaging.Message
  isExternal: false
  name: Formatter
  nameWithType: Message.Formatter
- uid: System.Messaging.Message.HashAlgorithm*
  parent: System.Messaging.Message
  isExternal: false
  name: HashAlgorithm
  nameWithType: Message.HashAlgorithm
- uid: System.Messaging.Message.Id*
  parent: System.Messaging.Message
  isExternal: false
  name: Id
  nameWithType: Message.Id
- uid: System.Messaging.Message.IsFirstInTransaction*
  parent: System.Messaging.Message
  isExternal: false
  name: IsFirstInTransaction
  nameWithType: Message.IsFirstInTransaction
- uid: System.Messaging.Message.IsLastInTransaction*
  parent: System.Messaging.Message
  isExternal: false
  name: IsLastInTransaction
  nameWithType: Message.IsLastInTransaction
- uid: System.Messaging.Message.Label*
  parent: System.Messaging.Message
  isExternal: false
  name: Label
  nameWithType: Message.Label
- uid: System.Messaging.Message.LookupId*
  parent: System.Messaging.Message
  isExternal: false
  name: LookupId
  nameWithType: Message.LookupId
- uid: System.Messaging.Message.MessageType*
  parent: System.Messaging.Message
  isExternal: false
  name: MessageType
  nameWithType: Message.MessageType
- uid: System.Messaging.Message.Priority*
  parent: System.Messaging.Message
  isExternal: false
  name: Priority
  nameWithType: Message.Priority
- uid: System.Messaging.Message.Recoverable*
  parent: System.Messaging.Message
  isExternal: false
  name: Recoverable
  nameWithType: Message.Recoverable
- uid: System.Messaging.Message.ResponseQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: ResponseQueue
  nameWithType: Message.ResponseQueue
- uid: System.Messaging.Message.SecurityContext*
  parent: System.Messaging.Message
  isExternal: false
  name: SecurityContext
  nameWithType: Message.SecurityContext
- uid: System.Messaging.Message.SenderCertificate*
  parent: System.Messaging.Message
  isExternal: false
  name: SenderCertificate
  nameWithType: Message.SenderCertificate
- uid: System.Messaging.Message.SenderId*
  parent: System.Messaging.Message
  isExternal: false
  name: SenderId
  nameWithType: Message.SenderId
- uid: System.Messaging.Message.SenderVersion*
  parent: System.Messaging.Message
  isExternal: false
  name: SenderVersion
  nameWithType: Message.SenderVersion
- uid: System.Messaging.Message.SentTime*
  parent: System.Messaging.Message
  isExternal: false
  name: SentTime
  nameWithType: Message.SentTime
- uid: System.Messaging.Message.SourceMachine*
  parent: System.Messaging.Message
  isExternal: false
  name: SourceMachine
  nameWithType: Message.SourceMachine
- uid: System.Messaging.Message.TimeToBeReceived*
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToBeReceived
  nameWithType: Message.TimeToBeReceived
- uid: System.Messaging.Message.TimeToReachQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToReachQueue
  nameWithType: Message.TimeToReachQueue
- uid: System.Messaging.Message.TransactionId*
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionId
  nameWithType: Message.TransactionId
- uid: System.Messaging.Message.TransactionStatusQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionStatusQueue
  nameWithType: Message.TransactionStatusQueue
- uid: System.Messaging.Message.UseAuthentication*
  parent: System.Messaging.Message
  isExternal: false
  name: UseAuthentication
  nameWithType: Message.UseAuthentication
- uid: System.Messaging.Message.UseDeadLetterQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: UseDeadLetterQueue
  nameWithType: Message.UseDeadLetterQueue
- uid: System.Messaging.Message.UseEncryption*
  parent: System.Messaging.Message
  isExternal: false
  name: UseEncryption
  nameWithType: Message.UseEncryption
- uid: System.Messaging.Message.UseJournalQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: UseJournalQueue
  nameWithType: Message.UseJournalQueue
- uid: System.Messaging.Message.UseTracing*
  parent: System.Messaging.Message
  isExternal: false
  name: UseTracing
  nameWithType: Message.UseTracing
