### YamlMime:ManagedReference
items:
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp
  id: FederatedMessageSecurityOverHttp
  children:
  - System.ServiceModel.FederatedMessageSecurityOverHttp.#ctor
  - System.ServiceModel.FederatedMessageSecurityOverHttp.AlgorithmSuite
  - System.ServiceModel.FederatedMessageSecurityOverHttp.ClaimTypeRequirements
  - System.ServiceModel.FederatedMessageSecurityOverHttp.EstablishSecurityContext
  - System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedKeyType
  - System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedTokenType
  - System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerAddress
  - System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerBinding
  - System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerMetadataAddress
  - System.ServiceModel.FederatedMessageSecurityOverHttp.NegotiateServiceCredential
  - System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeAlgorithmSuite
  - System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeClaimTypeRequirements
  - System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeEstablishSecurityContext
  - System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeIssuedKeyType
  - System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeNegotiateServiceCredential
  - System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeTokenRequestParameters
  - System.ServiceModel.FederatedMessageSecurityOverHttp.TokenRequestParameters
  langs:
  - csharp
  name: FederatedMessageSecurityOverHttp
  nameWithType: FederatedMessageSecurityOverHttp
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp
  type: Class
  summary: "Настраивает безопасность на уровне сообщений <xref uid=&quot;langword_csharp_WSFederationHttpBinding&quot; name=&quot;WSFederationHttpBinding&quot; href=&quot;&quot;> </xref> привязки."
  remarks: "Этот класс содержит свойства, которые обеспечивают управление различными аспектами конфигурации безопасности между клиентом и службой, включая сведения, касающиеся издателя, из которого служба ожидает получить федеративных учетных данных клиента."
  syntax:
    content: public sealed class FederatedMessageSecurityOverHttp
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.#ctor
  id: '#ctor'
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: FederatedMessageSecurityOverHttp()
  nameWithType: FederatedMessageSecurityOverHttp.FederatedMessageSecurityOverHttp()
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.FederatedMessageSecurityOverHttp()
  type: Constructor
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.ServiceModel.FederatedMessageSecurityOverHttp&quot;> </xref> класса."
  syntax:
    content: public FederatedMessageSecurityOverHttp ();
    parameters: []
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.AlgorithmSuite
  id: AlgorithmSuite
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: AlgorithmSuite
  nameWithType: FederatedMessageSecurityOverHttp.AlgorithmSuite
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.AlgorithmSuite
  type: Property
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Возвращает и задает набор алгоритмов, который указывает алгоритмы ключа и шифрования сообщений."
  remarks: "<xref:System.ServiceModel.Security.SecurityAlgorithmSuite>Возвращаемый объект содержит несколько свойств, которые определяют алгоритмы безопасности для использования при определенных условиях.</xref:System.ServiceModel.Security.SecurityAlgorithmSuite> Он также описывает различные функциональные возможности безопасности службы."
  example:
  - "The following code shows how to access this property from the binding, and set it.  \n  \n [!code-vb[WSFederationHttpSecurity#5](~/add/codesnippet/visualbasic/p-system.servicemodel.fe_1_1.vb)]\n [!code-cs[WSFederationHttpSecurity#5](~/add/codesnippet/csharp/p-system.servicemodel.fe_1_1.cs)]"
  syntax:
    content: public System.ServiceModel.Security.SecurityAlgorithmSuite AlgorithmSuite { get; set; }
    return:
      type: System.ServiceModel.Security.SecurityAlgorithmSuite
      description: "A <xref href=&quot;System.ServiceModel.Security.SecurityAlgorithmSuite&quot;></xref>. Значение по умолчанию — <xref:System.ServiceModel.Security.SecurityAlgorithmSuite.Basic256*>.</xref:System.ServiceModel.Security.SecurityAlgorithmSuite.Basic256*>"
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.AlgorithmSuite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Значение равно <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ClaimTypeRequirements
  id: ClaimTypeRequirements
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: ClaimTypeRequirements
  nameWithType: FederatedMessageSecurityOverHttp.ClaimTypeRequirements
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.ClaimTypeRequirements
  type: Property
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Возвращает коллекцию <xref href=&quot;System.ServiceModel.Security.Tokens.ClaimTypeRequirement&quot;> </xref> экземпляров для этой привязки."
  remarks: "Коллекция, возвращаемая этим свойством, используется службой для указания обязательных и необязательных утверждений, которые должны содержаться в выданном маркере, используемом клиентом для доступа к службе. Служба предоставляет обязательные типы утверждений в метаданных, если публикация WDSL включена, но WCF не требует, чтобы выданный маркер содержал заданные типы утверждений.  Службы, для которых необходимо принудительное обязательных типов утверждений следует сделать с помощью политики авторизации.       В федеративных клиентах эта коллекция содержит список обязательных и необязательных утверждений, который отправляется службе маркеров безопасности в запросе клиента для выданного маркера."
  example:
  - "The following code shows how to access this property from the binding, and set it.  \n  \n [!code-vb[WSFederationHttpSecurity#11](~/add/codesnippet/visualbasic/p-system.servicemodel.fe_5_1.vb)]\n [!code-cs[WSFederationHttpSecurity#11](~/add/codesnippet/csharp/p-system.servicemodel.fe_5_1.cs)]"
  syntax:
    content: public System.Collections.ObjectModel.Collection<System.ServiceModel.Security.Tokens.ClaimTypeRequirement> ClaimTypeRequirements { get; }
    return:
      type: System.Collections.ObjectModel.Collection{System.ServiceModel.Security.Tokens.ClaimTypeRequirement}
      description: "Объект &lt;xref:System.Collections.ObjectModel.Collection%601&gt; типа <xref href=&quot;System.ServiceModel.Security.Tokens.ClaimTypeRequirement&quot;> </xref>. Значение по умолчанию является пустой коллекцией."
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.ClaimTypeRequirements*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.EstablishSecurityContext
  id: EstablishSecurityContext
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: EstablishSecurityContext
  nameWithType: FederatedMessageSecurityOverHttp.EstablishSecurityContext
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.EstablishSecurityContext
  type: Property
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Возвращает или задает значение, требуется ли контекст безопасности был помещен на место."
  syntax:
    content: public bool EstablishSecurityContext { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если контекст безопасности требует размещения; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.EstablishSecurityContext*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedKeyType
  id: IssuedKeyType
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: IssuedKeyType
  nameWithType: FederatedMessageSecurityOverHttp.IssuedKeyType
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedKeyType
  type: Property
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Задает тип выдаваемого ключа."
  remarks: "Допустимые значения <xref:System.IdentityModel.Tokens.SecurityKeyType>— <xref:System.IdentityModel.Tokens.SecurityKeyType>и <xref:System.IdentityModel.Tokens.SecurityKeyType>.</xref:System.IdentityModel.Tokens.SecurityKeyType> </xref:System.IdentityModel.Tokens.SecurityKeyType> </xref:System.IdentityModel.Tokens.SecurityKeyType>"
  example:
  - "The following code shows how to access this property from the binding, and set it.  \n  \n [!code-vb[WSFederationHttpSecurity#7](~/add/codesnippet/visualbasic/p-system.servicemodel.fe_6_1.vb)]\n [!code-cs[WSFederationHttpSecurity#7](~/add/codesnippet/csharp/p-system.servicemodel.fe_6_1.cs)]"
  syntax:
    content: public System.IdentityModel.Tokens.SecurityKeyType IssuedKeyType { get; set; }
    return:
      type: System.IdentityModel.Tokens.SecurityKeyType
      description: "A <xref href=&quot;System.IdentityModel.Tokens.SecurityKeyType&quot;></xref>. Значение по умолчанию — <xref href=&quot;System.IdentityModel.Tokens.SecurityKeyType&quot;> </xref>."
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedKeyType*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Значение не является допустимым <xref href=&quot;System.IdentityModel.Tokens.SecurityKeyType&quot;> </xref>."
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedTokenType
  id: IssuedTokenType
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: IssuedTokenType
  nameWithType: FederatedMessageSecurityOverHttp.IssuedTokenType
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedTokenType
  type: Property
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Указывает тип маркера, который должен быть выдан службой маркеров безопасности."
  remarks: "Это свойство указывает тип маркера, который ожидает служба и элементов управления, которые SecurityTokenAuthenticator создается на стороне службы. На стороне клиента оно управляет типом, который отправляется службе маркеров безопасности в запросе клиента для выданного маркера.       IssuedTokenType обычно принимает форму URI."
  example:
  - "The following code shows how to access this property from the binding, and set it.  \n  \n [!code-vb[WSFederationHttpSecurity#4](~/add/codesnippet/visualbasic/p-system.servicemodel.fe_2_1.vb)]\n [!code-cs[WSFederationHttpSecurity#4](~/add/codesnippet/csharp/p-system.servicemodel.fe_2_1.cs)]"
  syntax:
    content: public string IssuedTokenType { get; set; }
    return:
      type: System.String
      description: "Тип выдаваемых маркеров. Значение по умолчанию — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>, которое вызывает WCF для запроса маркера безопасности SAML у службы STS."
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedTokenType*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerAddress
  id: IssuerAddress
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: IssuerAddress
  nameWithType: FederatedMessageSecurityOverHttp.IssuerAddress
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerAddress
  type: Property
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Возвращает или задает адрес конечной точки службы маркеров безопасности, выдающей учетные данные для службы."
  remarks: "Этот адрес используется в качестве конечной точки для службы маркеров безопасности, выдающей учетные данные для службы. Службы предоставляют адрес издателя в метаданных, если язык WSDL включен, но не использовать его. Клиенты используют адрес издателя для связи со службой маркеров безопасности. Если значение свойства IssuerAddress равно null клиенты могут откат к использованию службы маркеров безопасности, указанной с помощью свойств LocalIssuerAddress и LocalIssuerBinding в IssuedTokenClientCredential.       Установка этого значения в `null` или анонимный URI WS-AddressingIdentity на стороне клиента приводит CardSpace, если свойству ClientCredentials.SupportInteractive присвоено значение true при определенных обстоятельствах."
  example:
  - "The following code shows how to access this property from the binding, and set it.  \n  \n [!code-vb[WSFederationHttpSecurity#8](~/add/codesnippet/visualbasic/p-system.servicemodel.fe_3_1.vb)]\n [!code-cs[WSFederationHttpSecurity#8](~/add/codesnippet/csharp/p-system.servicemodel.fe_3_1.cs)]"
  syntax:
    content: public System.ServiceModel.EndpointAddress IssuerAddress { get; set; }
    return:
      type: System.ServiceModel.EndpointAddress
      description: "<xref:System.ServiceModel.EndpointAddress>Службы маркеров безопасности.</xref:System.ServiceModel.EndpointAddress>"
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerAddress*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerBinding
  id: IssuerBinding
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: IssuerBinding
  nameWithType: FederatedMessageSecurityOverHttp.IssuerBinding
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerBinding
  type: Property
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Возвращает или задает привязку, которая используется клиентом при взаимодействии со службой маркеров безопасности, адрес конечной точки равно <xref:System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerAddress*>.</xref:System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerAddress*>"
  remarks: "Это свойство используется для задания привязки, используемый клиентом между клиентом и службой маркеров безопасности при получении учетных данных для службы.       Обратите внимание, что это свойство необходимо заполнить на стороне службы, так как его может использовать только с помощью клиента."
  example:
  - "The following code shows how to access this property from the binding, and set it.  \n  \n [!code-vb[WSFederationHttpSecurity#9](~/add/codesnippet/visualbasic/p-system.servicemodel.fe_4_1.vb)]\n [!code-cs[WSFederationHttpSecurity#9](~/add/codesnippet/csharp/p-system.servicemodel.fe_4_1.cs)]"
  syntax:
    content: public System.ServiceModel.Channels.Binding IssuerBinding { get; set; }
    return:
      type: System.ServiceModel.Channels.Binding
      description: "<xref:System.ServiceModel.Channels.Binding>Для использования клиентом при взаимодействии со службой маркеров безопасности.</xref:System.ServiceModel.Channels.Binding>"
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerBinding*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerMetadataAddress
  id: IssuerMetadataAddress
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: IssuerMetadataAddress
  nameWithType: FederatedMessageSecurityOverHttp.IssuerMetadataAddress
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerMetadataAddress
  type: Property
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Возвращает или задает адрес конечной точки для взаимодействия со службой маркеров безопасности аппаратного."
  remarks: "Этот адрес используется в качестве конечной точки для службы маркеров безопасности, выдающей учетные данные для службы, использование аппаратного контроллера."
  example:
  - "The following code shows how to access this property from the binding, and set it.  \n  \n [!code-vb[WSFederationHttpSecurity#10](~/add/codesnippet/visualbasic/p-system.servicemodel.fe_0_1.vb)]\n [!code-cs[WSFederationHttpSecurity#10](~/add/codesnippet/csharp/p-system.servicemodel.fe_0_1.cs)]"
  syntax:
    content: public System.ServiceModel.EndpointAddress IssuerMetadataAddress { get; set; }
    return:
      type: System.ServiceModel.EndpointAddress
      description: "<xref:System.ServiceModel.Channels.Binding>Для использования при взаимодействии со службой маркеров безопасности аппаратного.</xref:System.ServiceModel.Channels.Binding>"
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerMetadataAddress*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.NegotiateServiceCredential
  id: NegotiateServiceCredential
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: NegotiateServiceCredential
  nameWithType: FederatedMessageSecurityOverHttp.NegotiateServiceCredential
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.NegotiateServiceCredential
  type: Property
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Указывает, выполняется ли согласование SSL на уровне сообщений для получения сертификата службы."
  remarks: "Это свойство указывает, является ли сертификат службы автоматически согласовывается между клиентом и службой. Если это свойство имеет `true`, такое согласование выполняется. Если это свойство имеет `false`, то перед взаимодействием со службой сертификата службы должно быть задано на клиенте.       Службы должны всегда указывать сертификат.       Если это свойство имеет значение true, сообщение согласование SSL на уровне для сертификата службы происходит перед отправкой запроса на выдачу маркера безопасности службе маркеров безопасности, указанной с помощью свойств IssuerAddress и IssuerBinding (или свойств LocalIssuerAddress и LocalIssuerBinding)."
  example:
  - "The following code shows how to access this property from the binding, and set it.  \n  \n [!code-vb[WSFederationHttpSecurity#6](~/add/codesnippet/visualbasic/a9c91759-1874-4a3e-b7d4-_1.vb)]\n [!code-cs[WSFederationHttpSecurity#6](~/add/codesnippet/csharp/a9c91759-1874-4a3e-b7d4-_1.cs)]"
  syntax:
    content: public bool NegotiateServiceCredential { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если сертификат службы согласован. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> при наличии внешнего сертификата службы. Значение по умолчанию — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.NegotiateServiceCredential*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeAlgorithmSuite
  id: ShouldSerializeAlgorithmSuite
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: ShouldSerializeAlgorithmSuite()
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeAlgorithmSuite()
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeAlgorithmSuite()
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Возвращает, нужно ли выполнять сериализацию набор алгоритмов, используемый для обеспечения безопасности сообщений на уровне SOAP."
  syntax:
    content: public bool ShouldSerializeAlgorithmSuite ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если должен быть сериализован набор алгоритмов. в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeAlgorithmSuite*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeClaimTypeRequirements
  id: ShouldSerializeClaimTypeRequirements
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: ShouldSerializeClaimTypeRequirements()
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeClaimTypeRequirements()
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeClaimTypeRequirements()
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Возвращает все существующие требования к типу утверждения могут быть сериализованы."
  syntax:
    content: public bool ShouldSerializeClaimTypeRequirements ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если существуют требования для сериализации; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeClaimTypeRequirements*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeEstablishSecurityContext
  id: ShouldSerializeEstablishSecurityContext
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: ShouldSerializeEstablishSecurityContext()
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeEstablishSecurityContext()
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeEstablishSecurityContext()
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Возвращает значение, указывающее, является ли контекст безопасности не используется по умолчанию и должно быть сериализовано."
  syntax:
    content: public bool ShouldSerializeEstablishSecurityContext ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если контекст должен быть сериализован. в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeEstablishSecurityContext*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeIssuedKeyType
  id: ShouldSerializeIssuedKeyType
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: ShouldSerializeIssuedKeyType()
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeIssuedKeyType()
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeIssuedKeyType()
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Возвращает значение, указывающее, является ли тип выданного ключа не по умолчанию и должно быть сериализовано."
  syntax:
    content: public bool ShouldSerializeIssuedKeyType ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если тип должен быть сериализован. в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeIssuedKeyType*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeNegotiateServiceCredential
  id: ShouldSerializeNegotiateServiceCredential
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: ShouldSerializeNegotiateServiceCredential()
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeNegotiateServiceCredential()
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeNegotiateServiceCredential()
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Возвращает значение, указывающее, является ли процесс согласования учетных данных службы не является процессом по умолчанию и должно быть сериализовано."
  syntax:
    content: public bool ShouldSerializeNegotiateServiceCredential ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если процесс должен быть сериализован. в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeNegotiateServiceCredential*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeTokenRequestParameters
  id: ShouldSerializeTokenRequestParameters
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: ShouldSerializeTokenRequestParameters()
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeTokenRequestParameters()
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeTokenRequestParameters()
  type: Method
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Возвращает указание на то, что все существующие параметры запроса маркера могут быть сериализованы."
  syntax:
    content: public bool ShouldSerializeTokenRequestParameters ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>При наличии параметров должно быть сериализовано; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeTokenRequestParameters*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.TokenRequestParameters
  id: TokenRequestParameters
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  langs:
  - csharp
  name: TokenRequestParameters
  nameWithType: FederatedMessageSecurityOverHttp.TokenRequestParameters
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.TokenRequestParameters
  type: Property
  assemblies:
  - System.ServiceModel
  namespace: System.ServiceModel
  summary: "Возвращает коллекцию элементов XML, отправляемые в тексте сообщения службе маркеров безопасности при запросе маркера."
  remarks: "Коллекция, возвращаемая этим свойством, используется для указания дополнительных XML-элементов, отправляемых в тексте сообщения службе маркеров безопасности при запросе маркера."
  syntax:
    content: public System.Collections.ObjectModel.Collection<System.Xml.XmlElement> TokenRequestParameters { get; }
    return:
      type: System.Collections.ObjectModel.Collection{System.Xml.XmlElement}
      description: "Объект &lt;xref:System.Collections.ObjectModel.Collection%601&gt; типа <xref href=&quot;System.Xml.XmlElement&quot;> </xref>."
  overload: System.ServiceModel.FederatedMessageSecurityOverHttp.TokenRequestParameters*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.#ctor
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: FederatedMessageSecurityOverHttp()
  nameWithType: FederatedMessageSecurityOverHttp.FederatedMessageSecurityOverHttp()
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.FederatedMessageSecurityOverHttp()
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.AlgorithmSuite
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: AlgorithmSuite
  nameWithType: FederatedMessageSecurityOverHttp.AlgorithmSuite
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.AlgorithmSuite
- uid: System.ServiceModel.Security.SecurityAlgorithmSuite
  parent: System.ServiceModel.Security
  isExternal: false
  name: SecurityAlgorithmSuite
  nameWithType: SecurityAlgorithmSuite
  fullName: System.ServiceModel.Security.SecurityAlgorithmSuite
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ClaimTypeRequirements
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: ClaimTypeRequirements
  nameWithType: FederatedMessageSecurityOverHttp.ClaimTypeRequirements
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.ClaimTypeRequirements
- uid: System.Collections.ObjectModel.Collection{System.ServiceModel.Security.Tokens.ClaimTypeRequirement}
  parent: System.Collections.ObjectModel
  isExternal: true
  name: Collection<ClaimTypeRequirement>
  nameWithType: Collection<ClaimTypeRequirement>
  fullName: System.Collections.ObjectModel.Collection<System.ServiceModel.Security.Tokens.ClaimTypeRequirement>
  spec.csharp:
  - uid: System.Collections.ObjectModel.Collection`1
    name: Collection
    nameWithType: Collection
    fullName: Collection<System.ServiceModel.Security.Tokens.ClaimTypeRequirement>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ServiceModel.Security.Tokens.ClaimTypeRequirement
    name: ClaimTypeRequirement
    nameWithType: ClaimTypeRequirement
    fullName: ClaimTypeRequirement
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.EstablishSecurityContext
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: EstablishSecurityContext
  nameWithType: FederatedMessageSecurityOverHttp.EstablishSecurityContext
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.EstablishSecurityContext
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedKeyType
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: IssuedKeyType
  nameWithType: FederatedMessageSecurityOverHttp.IssuedKeyType
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedKeyType
- uid: System.IdentityModel.Tokens.SecurityKeyType
  parent: System.IdentityModel.Tokens
  isExternal: false
  name: SecurityKeyType
  nameWithType: SecurityKeyType
  fullName: System.IdentityModel.Tokens.SecurityKeyType
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedTokenType
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: IssuedTokenType
  nameWithType: FederatedMessageSecurityOverHttp.IssuedTokenType
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedTokenType
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerAddress
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: IssuerAddress
  nameWithType: FederatedMessageSecurityOverHttp.IssuerAddress
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerAddress
- uid: System.ServiceModel.EndpointAddress
  parent: System.ServiceModel
  isExternal: true
  name: EndpointAddress
  nameWithType: EndpointAddress
  fullName: System.ServiceModel.EndpointAddress
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerBinding
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: IssuerBinding
  nameWithType: FederatedMessageSecurityOverHttp.IssuerBinding
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerBinding
- uid: System.ServiceModel.Channels.Binding
  parent: System.ServiceModel.Channels
  isExternal: true
  name: Binding
  nameWithType: Binding
  fullName: System.ServiceModel.Channels.Binding
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerMetadataAddress
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: IssuerMetadataAddress
  nameWithType: FederatedMessageSecurityOverHttp.IssuerMetadataAddress
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerMetadataAddress
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.NegotiateServiceCredential
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: NegotiateServiceCredential
  nameWithType: FederatedMessageSecurityOverHttp.NegotiateServiceCredential
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.NegotiateServiceCredential
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeAlgorithmSuite
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: ShouldSerializeAlgorithmSuite()
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeAlgorithmSuite()
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeAlgorithmSuite()
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeClaimTypeRequirements
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: ShouldSerializeClaimTypeRequirements()
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeClaimTypeRequirements()
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeClaimTypeRequirements()
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeEstablishSecurityContext
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: ShouldSerializeEstablishSecurityContext()
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeEstablishSecurityContext()
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeEstablishSecurityContext()
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeIssuedKeyType
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: ShouldSerializeIssuedKeyType()
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeIssuedKeyType()
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeIssuedKeyType()
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeNegotiateServiceCredential
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: ShouldSerializeNegotiateServiceCredential()
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeNegotiateServiceCredential()
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeNegotiateServiceCredential()
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeTokenRequestParameters
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: ShouldSerializeTokenRequestParameters()
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeTokenRequestParameters()
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeTokenRequestParameters()
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.TokenRequestParameters
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: TokenRequestParameters
  nameWithType: FederatedMessageSecurityOverHttp.TokenRequestParameters
  fullName: System.ServiceModel.FederatedMessageSecurityOverHttp.TokenRequestParameters
- uid: System.Collections.ObjectModel.Collection{System.Xml.XmlElement}
  parent: System.Collections.ObjectModel
  isExternal: true
  name: Collection<XmlElement>
  nameWithType: Collection<XmlElement>
  fullName: System.Collections.ObjectModel.Collection<System.Xml.XmlElement>
  spec.csharp:
  - uid: System.Collections.ObjectModel.Collection`1
    name: Collection
    nameWithType: Collection
    fullName: Collection<System.Xml.XmlElement>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Xml.XmlElement
    name: XmlElement
    nameWithType: XmlElement
    fullName: XmlElement
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.#ctor*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: FederatedMessageSecurityOverHttp
  nameWithType: FederatedMessageSecurityOverHttp.FederatedMessageSecurityOverHttp
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.AlgorithmSuite*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: AlgorithmSuite
  nameWithType: FederatedMessageSecurityOverHttp.AlgorithmSuite
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ClaimTypeRequirements*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: ClaimTypeRequirements
  nameWithType: FederatedMessageSecurityOverHttp.ClaimTypeRequirements
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.EstablishSecurityContext*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: EstablishSecurityContext
  nameWithType: FederatedMessageSecurityOverHttp.EstablishSecurityContext
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedKeyType*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: IssuedKeyType
  nameWithType: FederatedMessageSecurityOverHttp.IssuedKeyType
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuedTokenType*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: IssuedTokenType
  nameWithType: FederatedMessageSecurityOverHttp.IssuedTokenType
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerAddress*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: IssuerAddress
  nameWithType: FederatedMessageSecurityOverHttp.IssuerAddress
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerBinding*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: IssuerBinding
  nameWithType: FederatedMessageSecurityOverHttp.IssuerBinding
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.IssuerMetadataAddress*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: IssuerMetadataAddress
  nameWithType: FederatedMessageSecurityOverHttp.IssuerMetadataAddress
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.NegotiateServiceCredential*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: NegotiateServiceCredential
  nameWithType: FederatedMessageSecurityOverHttp.NegotiateServiceCredential
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeAlgorithmSuite*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: ShouldSerializeAlgorithmSuite
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeAlgorithmSuite
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeClaimTypeRequirements*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: ShouldSerializeClaimTypeRequirements
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeClaimTypeRequirements
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeEstablishSecurityContext*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: ShouldSerializeEstablishSecurityContext
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeEstablishSecurityContext
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeIssuedKeyType*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: ShouldSerializeIssuedKeyType
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeIssuedKeyType
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeNegotiateServiceCredential*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: ShouldSerializeNegotiateServiceCredential
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeNegotiateServiceCredential
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.ShouldSerializeTokenRequestParameters*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: ShouldSerializeTokenRequestParameters
  nameWithType: FederatedMessageSecurityOverHttp.ShouldSerializeTokenRequestParameters
- uid: System.ServiceModel.FederatedMessageSecurityOverHttp.TokenRequestParameters*
  parent: System.ServiceModel.FederatedMessageSecurityOverHttp
  isExternal: false
  name: TokenRequestParameters
  nameWithType: FederatedMessageSecurityOverHttp.TokenRequestParameters
