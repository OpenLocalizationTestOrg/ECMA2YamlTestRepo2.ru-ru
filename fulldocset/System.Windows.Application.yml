### YamlMime:ManagedReference
items:
- uid: System.Windows.Application
  id: Application
  children:
  - System.Windows.Application.#ctor
  - System.Windows.Application.Activated
  - System.Windows.Application.Current
  - System.Windows.Application.Deactivated
  - System.Windows.Application.DispatcherUnhandledException
  - System.Windows.Application.Exit
  - System.Windows.Application.FindResource(System.Object)
  - System.Windows.Application.FragmentNavigation
  - System.Windows.Application.GetContentStream(System.Uri)
  - System.Windows.Application.GetCookie(System.Uri)
  - System.Windows.Application.GetRemoteStream(System.Uri)
  - System.Windows.Application.GetResourceStream(System.Uri)
  - System.Windows.Application.LoadCompleted
  - System.Windows.Application.LoadComponent(System.Uri)
  - System.Windows.Application.LoadComponent(System.Object,System.Uri)
  - System.Windows.Application.MainWindow
  - System.Windows.Application.Navigated
  - System.Windows.Application.Navigating
  - System.Windows.Application.NavigationFailed
  - System.Windows.Application.NavigationProgress
  - System.Windows.Application.NavigationStopped
  - System.Windows.Application.OnActivated(System.EventArgs)
  - System.Windows.Application.OnDeactivated(System.EventArgs)
  - System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  - System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  - System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  - System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  - System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  - System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  - System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  - System.Windows.Application.Properties
  - System.Windows.Application.ResourceAssembly
  - System.Windows.Application.Resources
  - System.Windows.Application.Run
  - System.Windows.Application.Run(System.Windows.Window)
  - System.Windows.Application.SessionEnding
  - System.Windows.Application.SetCookie(System.Uri,System.String)
  - System.Windows.Application.Shutdown
  - System.Windows.Application.Shutdown(System.Int32)
  - System.Windows.Application.ShutdownMode
  - System.Windows.Application.Startup
  - System.Windows.Application.StartupUri
  - System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.Application.TryFindResource(System.Object)
  - System.Windows.Application.Windows
  langs:
  - csharp
  name: Application
  nameWithType: Application
  fullName: System.Windows.Application
  type: Class
  summary: "Инкапсулирует [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] приложения."
  remarks: "Приложения — это класс, который инкапсулирует [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] функции для конкретных приложений, включая следующие:- **существования приложения**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A>( <xref:System.Windows.Application.Deactivated>), <xref:System.Windows.Application.DispatcherUnhandledException>( <xref:System.Windows.Application.Exit>), <xref:System.Windows.Application.Run%2A>( <xref:System.Windows.Application.SessionEnding>), <xref:System.Windows.Application.Shutdown%2A>( <xref:System.Windows.Application.ShutdownMode%2A>), <xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.Application.SessionEnding> </xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application.Exit> </xref:System.Windows.Application.DispatcherUnhandledException> </xref:System.Windows.Application.Deactivated> </xref:System.Windows.Application.Current%2A> </xref:System.Windows.Application.Activated>      - **Окно области приложения, свойства и управление ресурсами**: <xref:System.Windows.Application.FindResource%2A>( <xref:System.Windows.Application.GetContentStream%2A>), <xref:System.Windows.Application.GetResourceStream%2A>( <xref:System.Windows.Application.LoadComponent%2A>), <xref:System.Windows.Application.MainWindow%2A>( <xref:System.Windows.Application.Properties%2A>), <xref:System.Windows.Application.Resources%2A>( <xref:System.Windows.Application.StartupUri%2A>), <xref:System.Windows.Application.Windows%2A>.</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Application.StartupUri%2A> </xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application.Properties%2A> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.LoadComponent%2A> </xref:System.Windows.Application.GetResourceStream%2A> </xref:System.Windows.Application.GetContentStream%2A> </xref:System.Windows.Application.FindResource%2A>      - **Параметр командной строки, а также выход код обработки**: <xref:System.Windows.Application.Startup?displayProperty=fullName>( <xref:System.Windows.Application.Exit?displayProperty=fullName>), <xref:System.Windows.Application.Shutdown%2A?displayProperty=fullName>.</xref:System.Windows.Application.Shutdown%2A?displayProperty=fullName> </xref:System.Windows.Application.Exit?displayProperty=fullName> </xref:System.Windows.Application.Startup?displayProperty=fullName>      -   **Navigation**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.</xref:System.Windows.Application.GetCookie%2A></xref:System.Windows.Application.SetCookie%2A></xref:System.Windows.Application.NavigationFailed></xref:System.Windows.Application.NavigationStopped></xref:System.Windows.Application.NavigationProgress></xref:System.Windows.Application.Navigating></xref:System.Windows.Application.Navigated></xref:System.Windows.Application.LoadCompleted></xref:System.Windows.Application.FragmentNavigation>       Приложение реализует единый шаблон для предоставления общего доступа к его окна, свойства и услуги объема ресурсов. Таким образом может быть создан только один экземпляр класса приложения на <xref:System.AppDomain>.</xref:System.AppDomain>       Можно реализовать с помощью разметки, разметки и кода или кода приложения. Если приложение реализовано с разметкой, ли разметку или разметку и код программной файла исправления должны быть настроены как [!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` элемента.      Настроек [!NOTE] настроек отдельного приложения, которые не требуется объект приложения; это можно реализовать настраиваемый `static` метод точки входа (`Main`), которая будет открывать окна без создания экземпляра приложения. Однако [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)] требуется объект приложения."
  example:
  - "The following example shows how a standard application is defined using only markup:  \n  \n [!code-xml[ApplicationSnippets#ApplicationMARKUP](~/add/codesnippet/xaml/ApplicationSnippets.CSharp/AppMarkup.xaml#applicationmarkup)]  \n  \n The following example shows how a standard application is defined using only code:  \n  \n [!code-cs[ApplicationSnippets#ApplicationCODE](~/add/codesnippet/csharp/ApplicationSnippets.CSharp/AppCode.cs#applicationcode)]\n [!code-vb[ApplicationSnippets#ApplicationCODE](~/add/codesnippet/visualbasic/applicationsnippets/appcode.vb#applicationcode)]  \n  \n The following example shows how a standard application is defined using a combination of markup and code-behind.  \n  \n [!code-xml[ApplicationSnippets#ApplicationXAML](~/add/codesnippet/xaml/ApplicationSnippets.CSharp/App.xaml#applicationxaml)]  \n  \n [!code-cs[ApplicationSnippets#ApplicationCODEBEHIND](~/add/codesnippet/csharp/ApplicationSnippets.CSharp/App.xaml.cs#applicationcodebehind)]\n [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/add/codesnippet/visualbasic/applicationsnippets/application.xaml.vb#applicationcodebehind)]"
  syntax:
    content: 'public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient'
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  implements:
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.Application.#ctor
  id: '#ctor'
  parent: System.Windows.Application
  langs:
  - csharp
  name: Application()
  nameWithType: Application.Application()
  fullName: System.Windows.Application.Application()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Windows.Application&quot;> </xref> класса."
  remarks: "Только один экземпляр <xref:System.Windows.Application>можно создать класс <xref:System.AppDomain>, чтобы обеспечить общий доступ к единому набору данных окна и свойств ресурсов области приложения.</xref:System.AppDomain> </xref:System.Windows.Application> Следовательно, конструктор по умолчанию для <xref:System.Windows.Application>класс определяет, находится ли экземпляр инициализируемого первый экземпляр в <xref:System.AppDomain>; Если нет, <xref:System.InvalidOperationException>возникает исключение.</xref:System.InvalidOperationException> </xref:System.AppDomain> </xref:System.Windows.Application>       <xref:System.Windows.Application>Для текущего <xref:System.AppDomain>предоставляется из статического <xref:System.Windows.Application.Current%2A>свойство.</xref:System.Windows.Application.Current%2A> </xref:System.AppDomain> </xref:System.Windows.Application>"
  syntax:
    content: public Application ();
    parameters: []
  overload: System.Windows.Application.#ctor*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Более одного экземпляра <xref href=&quot;System.Windows.Application&quot;> </xref> каждого создается класс <xref href=&quot;System.AppDomain&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Application.Activated
  id: Activated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Activated
  nameWithType: Application.Activated
  fullName: System.Windows.Application.Activated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит, когда приложение становится активным."
  remarks: "Объект [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] активируется приложение, которое содержит один или несколько открытых окон (становится активным) при одного из окон активации в первый раз с момента было запущено приложение, или когда одно из окон активизируется пока приложение не является активным: в частности, выполнения активации при:-приложение создает первое окно.      -Пользователь переключается в приложение с помощью клавиш ALT + TAB или с помощью диспетчера задач.      -Пользователь нажимает кнопку панели задач для одного из окон в приложении.       Приложения, которые необходимо обнаружить, когда они активации можно обрабатывать событие Activated.       После активации приложения он может деактивировать и повторно много раз за время своего существования. Если поведение или состояние приложения зависит от состояния его активации, обработки и Activated и <xref:System.Windows.Application.Deactivated>событий, чтобы определить какие активации состояния его in.</xref:System.Windows.Application.Deactivated>       Когда приложение становится активной, Activated не возникнет снова до деактивации приложения, вне зависимости от того, сколько windows в приложении активируются во время активного приложения.       Активировать не возникает для [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following example shows how to detect when a standalone application activates and deactivates.  \n  \n [!code-xml[ApplicationActivationSnippets#DetectActivationStateXAML](~/add/codesnippet/xaml/ApplicationActivationSnippets.CSharp/App.xaml#detectactivationstatexaml)]  \n  \n [!code-cs[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/csharp/ApplicationActivationSnippets.CSharp/App.xaml.cs#detectactivationstatecodebehind)]\n [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/visualbasic/applicationactivationsnippets/application.xaml.vb#detectactivationstatecodebehind)]"
  syntax:
    content: public event EventHandler Activated;
    return:
      type: System.EventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Current
  id: Current
  parent: System.Windows.Application
  langs:
  - csharp
  name: Current
  nameWithType: Application.Current
  fullName: System.Windows.Application.Current
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает <xref href=&quot;System.Windows.Application&quot;> </xref> для текущего <xref href=&quot;System.AppDomain&quot;> </xref>."
  remarks: "<xref:System.Windows.Application>— на-<xref:System.AppDomain> одноэлементный тип, который реализует для предоставления общего доступа <xref:System.Windows.Application>экземпляра для текущего <xref:System.AppDomain>.</xref:System.AppDomain> </xref:System.Windows.Application> статическое свойство Current</xref:System.AppDomain></xref:System.Windows.Application> Это гарантирует состояния управляется <xref:System.Windows.Application>, включая общие ресурсы и состояние, доступно из единого, общего расположения.</xref:System.Windows.Application>       Это свойство является поточно-ориентированным и доступно из любого потока."
  syntax:
    content: public static System.Windows.Application Current { get; }
    return:
      type: System.Windows.Application
      description: "<xref href=&quot;System.Windows.Application&quot;> </xref> Для текущего <xref href=&quot;System.AppDomain&quot;> </xref>."
  overload: System.Windows.Application.Current*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Deactivated
  id: Deactivated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Deactivated
  nameWithType: Application.Deactivated
  fullName: System.Windows.Application.Deactivated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит, когда приложение перестает быть активным."
  remarks: "Объект [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] приложение, которое содержит один или несколько открытых окон деактивирует (перестает быть активным) когда пользователь выполняет следующее:-переключается на другое приложение, с помощью клавиш ALT + TAB или с помощью диспетчера задач.      -Нажимает кнопку панели задач для окна в другое приложение.       Приложения, которые необходимо обнаружить деактивации можно обрабатывать событие деактивирован.       После активации приложения он может деактивировать и повторно много раз за время своего существования. Если поведение или состояние приложения зависит от состояния его активации, поскольку может обрабатывать оба деактивирован и <xref:System.Windows.Application.Activated>событий, чтобы определить, что состояние, его in.</xref:System.Windows.Application.Activated>       Деактивировать не возникает для [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following example shows how to detect when a standalone application deactivates and activates.  \n  \n [!code-xml[ApplicationActivationSnippets#DetectActivationStateXAML](~/add/codesnippet/xaml/ApplicationActivationSnippets.CSharp/App.xaml#detectactivationstatexaml)]  \n  \n [!code-cs[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/csharp/ApplicationActivationSnippets.CSharp/App.xaml.cs#detectactivationstatecodebehind)]\n [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/visualbasic/applicationactivationsnippets/application.xaml.vb#detectactivationstatecodebehind)]"
  syntax:
    content: public event EventHandler Deactivated;
    return:
      type: System.EventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.DispatcherUnhandledException
  id: DispatcherUnhandledException
  parent: System.Windows.Application
  langs:
  - csharp
  name: DispatcherUnhandledException
  nameWithType: Application.DispatcherUnhandledException
  fullName: System.Windows.Application.DispatcherUnhandledException
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит, когда исключение создаваемых приложением, но не обрабатываются."
  remarks: "По умолчанию [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] перехватывает необработанные исключения, сообщает пользователю об исключении из диалогового окна (из которого они могут сообщить об исключении) и автоматически завершает работу приложения.       Тем не менее если приложению требуется выполнять обработку на центральном расположении пользовательских необработанное исключение, должен обрабатывать DispatcherUnhandledException.       Вызванные DispatcherUnhandledException <xref:System.Windows.Application>для каждого исключения, которое не было обработано кодом, выполняемым в основном потоке пользовательского интерфейса.</xref:System.Windows.Application>       Если исключение не обрабатывается на либо фона [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] потоков (потока с собственным <xref:System.Windows.Threading.Dispatcher>) или фоновым рабочим потоком (поток без <xref:System.Windows.Threading.Dispatcher>), исключение не пересылаются на основной [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] потока.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> Следовательно DispatcherUnhandledException не возникает. В этих случаях необходимо написать код для выполнения следующих: 1.  Обработка исключений в фоновом потоке.      2.  Отправка данных исключений главный [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] потока.      3.  Заново создать их в основном [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] потока без обработки их, чтобы разрешить DispatcherUnhandledException вызываемого.       Дополнительные сведения см. в разделе [потоковая модель](~/add/includes/ajax-current-ext-md.md) Обзор.       Обработчик событий DispatcherUnhandledException передается <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs>аргумент, содержащий контекстные сведения об этом исключении, включая:-исключение (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).</xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A> </xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs>      - <xref:System.Windows.Threading.Dispatcher>Из которого она была создана (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>).</xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A> </xref:System.Windows.Threading.Dispatcher>       Эти сведения можно использовать, чтобы определить, является ли исключение невозможным. Исключение с возможностью восстановления может быть <xref:System.IO.FileNotFoundException>, например, может быть неустранимое исключение <xref:System.StackOverflowException>, например.</xref:System.StackOverflowException> </xref:System.IO.FileNotFoundException>       При обработке необработанного исключения из DispatcherUnhandledException, и не хотите [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] продолжить его обработки, необходимо задать <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A>Свойства `true`.</xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A>       В отличие от других событий, <xref:System.Windows.Application>вызывает DispatcherUnhandledException не имеет реализации сопоставления защищенный виртуальный (OnDispatcherUnhandledException).</xref:System.Windows.Application> Следовательно, классы, производные от <xref:System.Windows.Application>всегда необходимо зарегистрировать обработчик событий DispatcherUnhandledException для обработки необработанных исключений.</xref:System.Windows.Application>"
  example:
  - "The following example shows how to process unhandled exceptions by handling the DispatcherUnhandledException event.  \n  \n [!code-cs[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/add/codesnippet/csharp/ApplicationDispatcherUnhandledExceptionSnippets.CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]\n [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/add/codesnippet/visualbasic/applicationdispatcherunhandledexceptionsnippets/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  \n[!code-cs[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/add/codesnippet/csharp/ApplicationDispatcherUnhandledExceptionSnippets.CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]\n[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/add/codesnippet/visualbasic/applicationdispatcherunhandledexceptionsnippets/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Exit
  id: Exit
  parent: System.Windows.Application
  langs:
  - csharp
  name: Exit
  nameWithType: Application.Exit
  fullName: System.Windows.Application.Exit
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит непосредственно перед приложение завершает работу и не может быть отменено."
  remarks: "Приложение может завершить работу в любом из следующих причин: - <xref:System.Windows.Application.Shutdown%2A>метод <xref:System.Windows.Application>объекта вызывается, явно или по мнению <xref:System.Windows.Application.ShutdownMode%2A>свойство.</xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application> </xref:System.Windows.Application.Shutdown%2A>      -Пользователь завершает сеанс выходом или завершает работу.       Можно обнаружить, когда происходит завершение работы приложения путем обработки события выхода и выполнить дополнительную обработку при необходимости.       Также можно обрабатывать выход, чтобы просмотреть или изменить код завершения приложения, если не нужно вызывать <xref:System.Windows.Application.Shutdown%2A>явно.</xref:System.Windows.Application.Shutdown%2A> Код выхода, предоставляемый из <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>свойство <xref:System.Windows.ExitEventArgs>аргумента, переданного в обработчик событий выхода.</xref:System.Windows.ExitEventArgs> </xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> При остановке выполнения приложения, код завершения передается операционной системы для последующей обработки.       Если приложение обрабатывает <xref:System.Windows.Application.SessionEnding>событий и впоследствии отменяет его выход не возникает и приложение продолжает работу в соответствии с режимом завершения работы.</xref:System.Windows.Application.SessionEnding>       Код выхода, которые могут быть установлены из [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)], несмотря на то, что значение учитывается.       Для [!INCLUDE[TLA2#tla_xbap#plural](~/add/includes/tla2sharptla-xbapsharpplural-md.md)], выход возникает в следующих случаях: - [!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)] перехода на другую.      -В [!INCLUDE[TLA2#tla_ie7](~/add/includes/tla2sharptla-ie7-md.md)], когда вкладке, на котором размещается [!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)] закрыт.      -При закрытии браузера.       Во всех случаях значение <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>свойство игнорируется.</xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>"
  example:
  - "The following example demonstrates how to:  \n  \n-   Handle the Exit event.  \n  \n-   Inspect and update the <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> property of the <xref:System.Windows.ExitEventArgs>.  \n  \n-   Write an entry to an application log in isolated storage.  \n  \n-   Persist the application state to isolated storage.  \n  \n [!code-xml[ApplicationExitSnippets#HandleExitXAML](~/add/codesnippet/xaml/ApplicationExitSnippets.CSharp/App.xaml#handleexitxaml)]  \n  \n [!code-cs[ApplicationExitSnippets#HandleExitCODEBEHIND](~/add/codesnippet/csharp/ApplicationExitSnippets.CSharp/App.xaml.cs#handleexitcodebehind)]\n [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/add/codesnippet/visualbasic/applicationexitsnippets/application.xaml.vb#handleexitcodebehind)]"
  syntax:
    content: public event System.Windows.ExitEventHandler Exit;
    return:
      type: System.Windows.ExitEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.Application
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: Application.FindResource(Object)
  fullName: System.Windows.Application.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Выполняет поиск [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] ресурсов, таких как <xref href=&quot;System.Windows.Style&quot;> </xref> или <xref href=&quot;System.Windows.Media.Brush&quot;> </xref>с указанным ключом и вызывает исключение, если запрошенный ресурс не найден (см. [ресурсов XAML](~/add/includes/ajax-current-ext-md.md))."
  remarks: "FindResource сначала просматривает ресурсов области приложения для указанного ресурса. Ресурсы области приложения, управляются <xref:System.Windows.Application>и предоставляются из <xref:System.Windows.Application.Resources%2A>свойство.</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application> Если указанный ресурс не найден в наборе ресурсов области приложения, FindResource рядом выполняет системных ресурсов. Системные ресурсы являются ресурсы оболочки, определяемый пользователем и включать цвета, шрифты и настойки оболочки. Они предоставляются из <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, и <xref:System.Windows.SystemParameters>соответственно статических свойств.</xref:System.Windows.SystemParameters> </xref:System.Windows.SystemFonts> </xref:System.Windows.SystemColors> Чтобы использовать FindResource для их получения, эти типы также предоставляют ключевые свойства ресурсов, предназначенных для передачи FindResource; Например, <xref:System.Windows.SystemParameters.IconWidthKey%2A>.</xref:System.Windows.SystemParameters.IconWidthKey%2A>       Так как FindResource возвращает объект, необходимо привести возвращаемое значение к соответствующему типу при обнаружении ресурса.      Настроек [!IMPORTANT] настроек при вызове этого метода для ключа, который не удается найти, создается исключение. Если вы не хотите обрабатывать исключения, возникающие в результате вызова FindResource, <xref:System.Windows.Application.TryFindResource%2A>вместо него вызовите; <xref:System.Windows.Application.TryFindResource%2A>возвращает `null` ссылки, если запрошенный ресурс не найден, а не вызывает исключение.</xref:System.Windows.Application.TryFindResource%2A> </xref:System.Windows.Application.TryFindResource%2A>       Этот метод является поточно-ориентированным и может вызываться из любого потока."
  example:
  - "The following example shows how to use FindResource to find a resource, and to handle <xref:System.Windows.ResourceReferenceKeyNotFoundException> if the resource is not found.  \n  \n [!code-cs[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/add/codesnippet/csharp/ApplicationFindResourceSnippets/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]\n [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/add/codesnippet/visualbasic/applicationfindresourcesnippets/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "Имя ресурса для поиска."
    return:
      type: System.Object
      description: "Объект запрошенного ресурса. Если запрошенный ресурс не найден, <xref href=&quot;System.Windows.ResourceReferenceKeyNotFoundException&quot;> </xref> возникает исключение."
  overload: System.Windows.Application.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "Не удается найти ресурс."
  platform:
  - net462
- uid: System.Windows.Application.FragmentNavigation
  id: FragmentNavigation
  parent: System.Windows.Application
  langs:
  - csharp
  name: FragmentNavigation
  nameWithType: Application.FragmentNavigation
  fullName: System.Windows.Application.FragmentNavigation
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит, когда навигатор в приложении начинается переход к фрагменту содержимого навигации выполняется немедленно, если нужный фрагмент находится в текущем содержимом, или после источника [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] загрузки содержимого, если нужный фрагмент находится в другом содержимом."
  remarks: "Навигатор является либо <xref:System.Windows.Navigation.NavigationWindow>или <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       В разделе <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;
    return:
      type: System.Windows.Navigation.FragmentNavigationEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.GetContentStream(System.Uri)
  id: GetContentStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetContentStream(Uri)
  nameWithType: Application.GetContentStream(Uri)
  fullName: System.Windows.Application.GetContentStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает поток ресурса для файла данных содержания, расположенный по указанному индексу <xref:System.Uri>(см. [ресурса приложения WPF, содержимое и файлы данных](~/add/includes/ajax-current-ext-md.md)).</xref:System.Uri>"
  remarks: "Этот метод не является потокобезопасным."
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);
    parameters:
    - id: uriContent
      type: System.Uri
      description: "Относительные <xref:System.Uri>сопоставляемого свободных ресурсов.</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "Объект <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> , содержащий файл данных содержимого, расположенный по указанным <xref:System.Uri>.</xref:System.Uri> Если свободные ресурс не найден, возвращается значение null."
  overload: System.Windows.Application.GetContentStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref:System.Uri>, Передаваемое в GetContentStream имеет значение null.</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Uri>, Передаваемый GetContentStream является абсолютным <xref:System.Uri>.</xref:System.Uri> </xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.GetCookie(System.Uri)
  id: GetCookie(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetCookie(Uri)
  nameWithType: Application.GetCookie(Uri)
  fullName: System.Windows.Application.GetCookie(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Извлекает файл cookie для местоположении, заданном свойством <xref:System.Uri>.</xref:System.Uri>"
  remarks: "GetCookie извлекает файл cookie для указанного <xref:System.Uri>.</xref:System.Uri> Если не удается получить файл cookie, <xref:System.ComponentModel.Win32Exception>возникает исключение.</xref:System.ComponentModel.Win32Exception> Необходимо написать код для передачи строки cookie в список пар имя значение.       Обзор файлов cookie в [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)], в разделе [Общие сведения о навигации](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static string GetCookie (Uri uri);
    parameters:
    - id: uri
      type: System.Uri
      description: "<xref:System.Uri>, Задающий расположение, для которого был создан файл cookie.</xref:System.Uri>"
    return:
      type: System.String
      description: "Объект <xref:System.String>значение, если существует файл cookie; в противном случае <xref href=&quot;System.ComponentModel.Win32Exception&quot;> </xref> возникает исключение.</xref:System.String>"
  overload: System.Windows.Application.GetCookie*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Объект [!INCLUDE[TLA#tla_win32](~/add/includes/tlasharptla-win32-md.md)] ошибка возникла в <xref uid=&quot;langword_csharp_InternetGetCookie&quot; name=&quot;InternetGetCookie&quot; href=&quot;&quot;> </xref> (называемой по GetCookie) Если проблема возникает при попытке получения указанного файла cookie."
  platform:
  - net462
- uid: System.Windows.Application.GetRemoteStream(System.Uri)
  id: GetRemoteStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetRemoteStream(Uri)
  nameWithType: Application.GetRemoteStream(Uri)
  fullName: System.Windows.Application.GetRemoteStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает поток ресурса для файла данных исходного сайта, расположенный по указанному индексу <xref:System.Uri>(см. [ресурса приложения WPF, содержимое и файлы данных](~/add/includes/ajax-current-ext-md.md)).</xref:System.Uri>"
  remarks: "Этот метод не является потокобезопасным."
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);
    parameters:
    - id: uriRemote
      type: System.Uri
      description: "<xref:System.Uri>Сопоставляемого свободных ресурсов на исходном узле.</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "Объект <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> , содержащий поток ресурса для файла данных исходного сайта, расположенный по указанным <xref:System.Uri>.</xref:System.Uri> Если свободные ресурс не найден, <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> возвращается."
  overload: System.Windows.Application.GetRemoteStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref:System.Uri>, Передаваемое в GetRemoteStream имеет значение null.</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Uri>, Передаваемое в GetRemoteStream либо не относительным или абсолютным, а не в `pack://siteoforigin:,,,/` формы.</xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.GetResourceStream(System.Uri)
  id: GetResourceStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetResourceStream(Uri)
  nameWithType: Application.GetResourceStream(Uri)
  fullName: System.Windows.Application.GetResourceStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает поток ресурса для файла данных ресурса, расположенный по указанному индексу <xref:System.Uri>(см. [ресурса приложения WPF, содержимое и файлы данных](~/add/includes/ajax-current-ext-md.md)).</xref:System.Uri>"
  remarks: "Этот метод не является потокобезопасным."
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);
    parameters:
    - id: uriResource
      type: System.Uri
      description: "<xref:System.Uri>Сопоставляемого внедренного ресурса.</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "Объект <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> , содержащий поток ресурса для файла данных ресурса, расположенный по указанным <xref:System.Uri>.</xref:System.Uri>"
  overload: System.Windows.Application.GetResourceStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref:System.Uri>, Передаваемое в GetResourceStream имеет значение null.</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Uri>, Передаваемое в GetResourceStream либо не относительным или абсолютным, а не в `pack://application:,,,/` формы.</xref:System.Uri>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<xref:System.Uri>, Передаваемая атрибуту не удается найти GetResourceStream.</xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.LoadCompleted
  id: LoadCompleted
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadCompleted
  nameWithType: Application.LoadCompleted
  fullName: System.Windows.Application.LoadCompleted
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит, когда содержимое, переданное в навигаторе приложения было загружено, синтаксический анализ и обрабатывается."
  remarks: "Навигатор является либо <xref:System.Windows.Navigation.NavigationWindow>или <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       В разделе <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=fullName>      Настроек [!NOTE] настроек прослушивать события на навигацию содержимого, такие как <xref:System.Windows.FrameworkElement.Loaded>события <xref:System.Windows.Controls.Page>перед обращением к свойства содержимого навигацию.</xref:System.Windows.Controls.Page> </xref:System.Windows.FrameworkElement.Loaded>"
  syntax:
    content: public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;
    return:
      type: System.Windows.Navigation.LoadCompletedEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.LoadComponent(System.Uri)
  id: LoadComponent(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadComponent(Uri)
  nameWithType: Application.LoadComponent(Uri)
  fullName: System.Windows.Application.LoadComponent(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Загружает [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] файла, расположенного по указанному индексу [!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)]и преобразует его в экземпляр объекта, который задается параметром корневой элемент [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] файла."
  remarks: "Необходимо явным образом преобразовать возвращаемое значение в совпадает с типом корневого элемента [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] файла.       [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] Файл может быть файлом кода приложения (настроен в качестве [!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)] элемент страницы) или файлом данных приложения (файл ресурсов, файл содержимого или узла исходного файла; в разделе [ресурса приложения WPF, содержимое и файлы данных](~/add/includes/ajax-current-ext-md.md)).      Настроек [!NOTE] настроек этот метод не является потокобезопасным."
  syntax:
    content: public static object LoadComponent (Uri resourceLocator);
    parameters:
    - id: resourceLocator
      type: System.Uri
      description: "Объект <xref:System.Uri>, сопоставляемый относительный [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] файл.</xref:System.Uri>"
    return:
      type: System.Object
      description: "Экземпляр корневого элемента, заданного с помощью загруженного файла XAML."
  overload: System.Windows.Application.LoadComponent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceLocator</code>имеет значение null."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>resourceLocator</code> is an absolute [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)]."
  - type: System.Exception
    commentId: T:System.Exception
    description: "Файл не [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] файла."
  platform:
  - net462
- uid: System.Windows.Application.LoadComponent(System.Object,System.Uri)
  id: LoadComponent(System.Object,System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadComponent(Object,Uri)
  nameWithType: Application.LoadComponent(Object,Uri)
  fullName: System.Windows.Application.LoadComponent(Object,Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Загружает [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] файла, расположенного по указанному индексу [!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)] и преобразует его в экземпляр объекта, который задается параметром корневой элемент [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] файла."
  remarks: "[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] Файл может быть файлом кода приложения (настроен в качестве [!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)] элемент страницы) или файлом данных приложения (файл ресурсов, файл содержимого или узла исходного файла; в разделе [ресурса приложения WPF, содержимое и файлы данных](~/add/includes/ajax-current-ext-md.md)).      Настроек [!NOTE] настроек этот метод не является потокобезопасным."
  syntax:
    content: public static void LoadComponent (object component, Uri resourceLocator);
    parameters:
    - id: component
      type: System.Object
      description: "Объект того же типа как корневой элемент [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] файла."
    - id: resourceLocator
      type: System.Uri
      description: "Объект <xref:System.Uri>, сопоставляемый относительный [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] файл.</xref:System.Uri>"
  overload: System.Windows.Application.LoadComponent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceLocator</code>имеет значение null."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>resourceLocator</code> is an absolute [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)]."
  - type: System.Exception
    commentId: T:System.Exception
    description: "<code>component</code>имеет тип, не совпадает с корневым элементом [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] файла."
  platform:
  - net462
- uid: System.Windows.Application.MainWindow
  id: MainWindow
  parent: System.Windows.Application
  langs:
  - csharp
  name: MainWindow
  nameWithType: Application.MainWindow
  fullName: System.Windows.Application.MainWindow
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает главное окно приложения."
  remarks: "MainWindow автоматически устанавливается со ссылкой на первый <xref:System.Windows.Window>объект для создания экземпляра в списке <xref:System.AppDomain>.</xref:System.AppDomain> </xref:System.Windows.Window>       Можно указать различные главного окна, задав MainWindow назначения другой <xref:System.Windows.Application.Windows%2A>объекта свойству MainWindow.</xref:System.Windows.Application.Windows%2A>       Если <xref:System.Windows.Application.ShutdownMode%2A>свойство <xref:System.Windows.Application>имеет значение <xref:System.Windows.ShutdownMode>, закрытием главного окна вызывает завершение работы приложения.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application> </xref:System.Windows.Application.ShutdownMode%2A>       Можно задать свойство MainWindow из [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)], если главное окно приложения не является окном, полученным путем установки <xref:System.Windows.Application.StartupUri%2A>Свойства [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)].</xref:System.Windows.Application.StartupUri%2A> Два ограничения [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)] , подход:-можно указать либо [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]-только <xref:System.Windows.Window>или [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]-только <xref:System.Windows.Navigation.NavigationWindow>как главного окна.</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Window>      -Необходимо задать <xref:System.Windows.UIElement.Visibility%2A>указать свойство окна, в противном случае оно не будет отображаться.</xref:System.Windows.UIElement.Visibility%2A>       Ссылка на первый <xref:System.Windows.Window>объекта также добавляется в качестве первого элемента, который <xref:System.Windows.Application.Windows%2A>коллекции.</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Window> Если MainWindow впоследствии устанавливается со ссылкой на другой <xref:System.Windows.Window>, изменится расположение элемента со ссылкой на главное окно при порядок элементов в <xref:System.Windows.Application.Windows%2A>остается прежним.</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Window> Следовательно всегда используют MainWindow ссылалась на главное окно, а не к первому элементу в <xref:System.Windows.Application.Windows%2A>.</xref:System.Windows.Application.Windows%2A>      Настроек [!NOTE] настроек Если главное окно <xref:System.Windows.Navigation.NavigationWindow>, и требуется отдельный доступ к <xref:System.Windows.Navigation.NavigationWindow>членам, необходимо будет выполнить приведение значения MainWindow <xref:System.Windows.Navigation.NavigationWindow>.</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.NavigationWindow>   >> Это свойство доступно только из потока, который создал <xref:System.Windows.Application>объекта.</xref:System.Windows.Application>"
  example:
  - "The following example shows how to find the main application window.  \n  \n [!code-cs[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/add/codesnippet/csharp/ApplicationMainWindowSnippets.CSharp/App.xaml.cs#getapplicationmainwindowcode)]\n [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/add/codesnippet/visualbasic/applicationmainwindowsnippets/application.xaml.vb#getapplicationmainwindowcode)]  \n  \n The following example shows how to set MainWindow using [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)].  \n  \n [!code-xml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/add/codesnippet/xaml/ApplicationMainWindowSnippets.XAML/App.xaml#setapplicationmainwindowxaml)]  \n  \n The following example shows how to instantiate the MainWindow in code during application startup.  \n  \n [!code-cs[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/add/codesnippet/csharp/HOWTOWindowManagementSnippets/App.xaml.cs#firstwindowusingcodecodebehind)]\n [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/add/codesnippet/visualbasic/howtowindowmanagementsnippets/application.xaml.vb#firstwindowusingcodecodebehind)]"
  syntax:
    content: public System.Windows.Window MainWindow { get; set; }
    return:
      type: System.Windows.Window
      description: "Объект <xref href=&quot;System.Windows.Window&quot;> </xref> , назначенный в качестве главного окна приложения."
  overload: System.Windows.Application.MainWindow*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "MainWindow устанавливается из приложения, размещенные в браузере, например [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]."
  platform:
  - net462
- uid: System.Windows.Application.Navigated
  id: Navigated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Navigated
  nameWithType: Application.Navigated
  fullName: System.Windows.Application.Navigated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит, когда содержимое, которое выполняется переход в навигаторе в приложении был найден, несмотря на то, что он не завершил загрузку."
  remarks: "Навигатор является либо <xref:System.Windows.Navigation.NavigationWindow>или <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       В разделе <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigatedEventHandler Navigated;
    return:
      type: System.Windows.Navigation.NavigatedEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Navigating
  id: Navigating
  parent: System.Windows.Application
  langs:
  - csharp
  name: Navigating
  nameWithType: Application.Navigating
  fullName: System.Windows.Application.Navigating
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит при запросе нового перехода в навигаторе в приложении."
  remarks: "Навигатор является либо <xref:System.Windows.Navigation.NavigationWindow>или <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       В разделе <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;
    return:
      type: System.Windows.Navigation.NavigatingCancelEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationFailed
  id: NavigationFailed
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationFailed
  nameWithType: Application.NavigationFailed
  fullName: System.Windows.Application.NavigationFailed
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит при возникновении ошибки во время навигатор в приложении выполняется переход к запрошенному содержимому."
  remarks: "Навигатор является либо <xref:System.Windows.Navigation.NavigationWindow>или <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       В разделе <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;
    return:
      type: System.Windows.Navigation.NavigationFailedEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationProgress
  id: NavigationProgress
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationProgress
  nameWithType: Application.NavigationProgress
  fullName: System.Windows.Application.NavigationProgress
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит периодически во время загрузки, который управляется навигатор в приложении для предоставления сведений о ходе выполнения перехода."
  remarks: "Навигатор является либо <xref:System.Windows.Navigation.NavigationWindow>или <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       В разделе <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;
    return:
      type: System.Windows.Navigation.NavigationProgressEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationStopped
  id: NavigationStopped
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationStopped
  nameWithType: Application.NavigationStopped
  fullName: System.Windows.Application.NavigationStopped
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит, когда <xref uid=&quot;langword_csharp_StopLoading&quot; name=&quot;StopLoading&quot; href=&quot;&quot;> </xref> вызывается метод навигатор в приложении или при запросе нового перехода в навигаторе во время выполнения текущего перехода."
  remarks: "Навигатор является либо <xref:System.Windows.Navigation.NavigationWindow>или <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       В разделе <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;
    return:
      type: System.Windows.Navigation.NavigationStoppedEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnActivated(System.EventArgs)
  id: OnActivated(System.EventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnActivated(EventArgs)
  nameWithType: Application.OnActivated(EventArgs)
  fullName: System.Windows.Application.OnActivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Application.Activated&quot;> </xref> событий."
  remarks: "Вызывает OnActivated <xref:System.Windows.Application.Activated>событий.</xref:System.Windows.Application.Activated>       Тип, производный от <xref:System.Windows.Application>могут переопределять OnActivated.</xref:System.Windows.Application> Переопределенный метод должен вызвать метод OnActivated в базовом классе, если <xref:System.Windows.Application.Activated>должен вызываться.</xref:System.Windows.Application.Activated>"
  syntax:
    content: protected virtual void OnActivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>, Содержащий данные события.</xref:System.EventArgs>"
  overload: System.Windows.Application.OnActivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnDeactivated(System.EventArgs)
  id: OnDeactivated(System.EventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnDeactivated(EventArgs)
  nameWithType: Application.OnDeactivated(EventArgs)
  fullName: System.Windows.Application.OnDeactivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Application.Deactivated&quot;> </xref> событий."
  remarks: "Вызывает OnDeactivated <xref:System.Windows.Application.Deactivated>событий.</xref:System.Windows.Application.Deactivated>       Тип, производный от <xref:System.Windows.Application>могут переопределять OnDeactivated.</xref:System.Windows.Application> Переопределенный метод должен вызвать метод OnDeactivated в базовом классе, если <xref:System.Windows.Application.Deactivated>должен вызываться.</xref:System.Windows.Application.Deactivated>"
  syntax:
    content: protected virtual void OnDeactivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>, Содержащий данные события.</xref:System.EventArgs>"
  overload: System.Windows.Application.OnDeactivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  id: OnExit(System.Windows.ExitEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnExit(ExitEventArgs)
  nameWithType: Application.OnExit(ExitEventArgs)
  fullName: System.Windows.Application.OnExit(ExitEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Application.Exit&quot;> </xref> событий."
  remarks: "Вызывает OnExit <xref:System.Windows.Application.Exit>событий.</xref:System.Windows.Application.Exit>       Тип, производный от <xref:System.Windows.Application>может переопределять метод OnExit.</xref:System.Windows.Application> Переопределенный метод должен вызвать метод OnExit в базовом классе, если <xref:System.Windows.Application.Exit>должен вызываться.</xref:System.Windows.Application.Exit>"
  syntax:
    content: protected virtual void OnExit (System.Windows.ExitEventArgs e);
    parameters:
    - id: e
      type: System.Windows.ExitEventArgs
      description: "<xref href=&quot;System.Windows.ExitEventArgs&quot;> </xref> , Содержащий данные события."
  overload: System.Windows.Application.OnExit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  id: OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnFragmentNavigation(FragmentNavigationEventArgs)
  nameWithType: Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  fullName: System.Windows.Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Application.FragmentNavigation&quot;> </xref> событий."
  remarks: "Вызывает OnFragmentNavigation <xref:System.Windows.Application.FragmentNavigation>событий.</xref:System.Windows.Application.FragmentNavigation>       Тип, производный от <xref:System.Windows.Application>могут переопределять OnFragmentNavigation.</xref:System.Windows.Application> Переопределенный метод должен вызвать метод OnFragmentNavigation в базовом классе, если <xref:System.Windows.Application.FragmentNavigation>должен вызываться.</xref:System.Windows.Application.FragmentNavigation>"
  syntax:
    content: protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.FragmentNavigationEventArgs
      description: "Объект <xref href=&quot;System.Windows.Navigation.FragmentNavigationEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Windows.Application.OnFragmentNavigation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  id: OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnLoadCompleted(NavigationEventArgs)
  nameWithType: Application.OnLoadCompleted(NavigationEventArgs)
  fullName: System.Windows.Application.OnLoadCompleted(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Application.LoadCompleted&quot;> </xref> событий."
  remarks: "Вызывает OnLoadCompleted <xref:System.Windows.Application.LoadCompleted>событий.</xref:System.Windows.Application.LoadCompleted>       Тип, производный от <xref:System.Windows.Application>могут переопределять OnLoadCompleted.</xref:System.Windows.Application> Переопределенный метод должен вызвать метод OnLoadCompleted в базовом классе, если <xref:System.Windows.Application.LoadCompleted>должен вызываться.</xref:System.Windows.Application.LoadCompleted>"
  syntax:
    content: protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "Объект <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Windows.Application.OnLoadCompleted*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  id: OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigated(NavigationEventArgs)
  nameWithType: Application.OnNavigated(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigated(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Application.Navigated&quot;> </xref> событий."
  remarks: "Вызывает OnNavigated <xref:System.Windows.Application.Navigated>событий.</xref:System.Windows.Application.Navigated>       Тип, производный от <xref:System.Windows.Application>могут переопределять OnNavigated.</xref:System.Windows.Application> Переопределенный метод должен вызвать метод OnNavigated в базовом классе, если <xref:System.Windows.Application.Navigated>должен вызываться.</xref:System.Windows.Application.Navigated>"
  syntax:
    content: protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "Объект <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Windows.Application.OnNavigated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  id: OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigating(NavigatingCancelEventArgs)
  nameWithType: Application.OnNavigating(NavigatingCancelEventArgs)
  fullName: System.Windows.Application.OnNavigating(NavigatingCancelEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Application.Navigating&quot;> </xref> событий."
  remarks: "Вызывает OnNavigating <xref:System.Windows.Application.Navigating>событий.</xref:System.Windows.Application.Navigating>       Тип, производный от <xref:System.Windows.Application>могут переопределять OnNavigating.</xref:System.Windows.Application> Переопределенный метод должен вызвать метод OnNavigating в базовом классе, если <xref:System.Windows.Application.Navigating>должен вызываться.</xref:System.Windows.Application.Navigating>"
  syntax:
    content: protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigatingCancelEventArgs
      description: "Объект <xref href=&quot;System.Windows.Navigation.NavigatingCancelEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Windows.Application.OnNavigating*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  id: OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationFailed(NavigationFailedEventArgs)
  nameWithType: Application.OnNavigationFailed(NavigationFailedEventArgs)
  fullName: System.Windows.Application.OnNavigationFailed(NavigationFailedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Application.NavigationFailed&quot;> </xref> событий."
  remarks: "Вызывает OnNavigationFailed <xref:System.Windows.Application.NavigationFailed>событий.</xref:System.Windows.Application.NavigationFailed>       Тип, производный от <xref:System.Windows.Application>могут переопределять OnNavigationFailed.</xref:System.Windows.Application> Переопределенный метод должен вызвать метод OnNavigationFailed в базовом классе, если <xref:System.Windows.Application.NavigationFailed>должен вызываться.</xref:System.Windows.Application.NavigationFailed>"
  example:
  - "<xref:System.Windows.Application.OnFragmentNavigation%2A>  \n  \n <xref:System.Windows.Application.OnLoadCompleted%2A>  \n  \n <xref:System.Windows.Application.OnNavigating%2A>  \n  \n <xref:System.Windows.Application.OnNavigated%2A>  \n  \n <xref:System.Windows.Application.OnNavigationProgress%2A>  \n  \n <xref:System.Windows.Application.OnNavigationStopped%2A>"
  syntax:
    content: protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationFailedEventArgs
      description: "Объект <xref href=&quot;System.Windows.Navigation.NavigationFailedEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Windows.Application.OnNavigationFailed*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  id: OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationProgress(NavigationProgressEventArgs)
  nameWithType: Application.OnNavigationProgress(NavigationProgressEventArgs)
  fullName: System.Windows.Application.OnNavigationProgress(NavigationProgressEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Application.NavigationProgress&quot;> </xref> событий."
  remarks: "Вызывает OnNavigationProgress <xref:System.Windows.Application.NavigationProgress>событий.</xref:System.Windows.Application.NavigationProgress>       Тип, производный от <xref:System.Windows.Application>могут переопределять OnNavigationProgress.</xref:System.Windows.Application> Переопределенный метод должен явным образом вызвать OnNavigationProgress в базовом классе Если <xref:System.Windows.Application.NavigationProgress>должен вызываться.</xref:System.Windows.Application.NavigationProgress>"
  syntax:
    content: protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationProgressEventArgs
      description: "Объект <xref href=&quot;System.Windows.Navigation.NavigationProgressEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Windows.Application.OnNavigationProgress*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  id: OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationStopped(NavigationEventArgs)
  nameWithType: Application.OnNavigationStopped(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigationStopped(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Application.NavigationStopped&quot;> </xref> событий."
  remarks: "Вызывает OnNavigationStopped <xref:System.Windows.Application.NavigationStopped>событий.</xref:System.Windows.Application.NavigationStopped>       Тип, производный от <xref:System.Windows.Application>могут переопределять OnNavigationStopped.</xref:System.Windows.Application> Переопределенный метод должен вызвать метод OnNavigationStopped в базовом классе, если <xref:System.Windows.Application.NavigationStopped>должен вызываться.</xref:System.Windows.Application.NavigationStopped>"
  syntax:
    content: protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "Объект <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Windows.Application.OnNavigationStopped*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  id: OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnSessionEnding(SessionEndingCancelEventArgs)
  nameWithType: Application.OnSessionEnding(SessionEndingCancelEventArgs)
  fullName: System.Windows.Application.OnSessionEnding(SessionEndingCancelEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Application.SessionEnding&quot;> </xref> событий."
  remarks: "Вызывает OnSessionEnding <xref:System.Windows.Application.SessionEnding>событий.</xref:System.Windows.Application.SessionEnding>       Тип, производный от <xref:System.Windows.Application>могут переопределять OnSessionEnding.</xref:System.Windows.Application> Переопределенный метод должен вызвать метод OnSessionEnding в базовом классе, если <xref:System.Windows.Application.SessionEnding>должен вызываться.</xref:System.Windows.Application.SessionEnding>"
  syntax:
    content: protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.SessionEndingCancelEventArgs
      description: "Объект <xref href=&quot;System.Windows.SessionEndingCancelEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Windows.Application.OnSessionEnding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  id: OnStartup(System.Windows.StartupEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnStartup(StartupEventArgs)
  nameWithType: Application.OnStartup(StartupEventArgs)
  fullName: System.Windows.Application.OnStartup(StartupEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Application.Startup&quot;> </xref> событий."
  remarks: "Вызывает OnStartup <xref:System.Windows.Application.Startup>событий.</xref:System.Windows.Application.Startup>       Тип, производный от <xref:System.Windows.Application>могут переопределять OnStartup.</xref:System.Windows.Application> Переопределенный метод должен вызвать метод OnStartup в базовом классе, если <xref:System.Windows.Application.Startup>событие должно вызываться.</xref:System.Windows.Application.Startup>"
  syntax:
    content: protected virtual void OnStartup (System.Windows.StartupEventArgs e);
    parameters:
    - id: e
      type: System.Windows.StartupEventArgs
      description: "Объект <xref href=&quot;System.Windows.StartupEventArgs&quot;> </xref> , содержащий данные события."
  overload: System.Windows.Application.OnStartup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Properties
  id: Properties
  parent: System.Windows.Application
  langs:
  - csharp
  name: Properties
  nameWithType: Application.Properties
  fullName: System.Windows.Application.Properties
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает коллекцию свойств области приложения."
  remarks: "<xref:System.Windows.Application>предоставляет словарь через свойства, которые можно использовать для хранения свойств области приложения.</xref:System.Windows.Application> Это позволяет совместно использовать состояние всем кодом в <xref:System.AppDomain>образом потокобезопасна, без необходимости написания собственного кода состояния.</xref:System.AppDomain>       Свойства, которые хранятся в свойствах необходимо преобразовать в соответствующий возвращаемый тип.       Свойство TheProperties является поточно-ориентированным и доступно из любого потока."
  example:
  - "The following example shows how create and use an application-scope property using Properties.  \n  \n [!code-xml[ApplicationPropertiesSnippets#HandleStartupXAML](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/App.xaml#handlestartupxaml)]  \n  \n [!code-cs[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/csharp/ApplicationPropertiesSnippets.CSharp/App.xaml.cs#handlestartupcodebehind)]\n [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/visualbasic/applicationpropertiessnippets/application.xaml.vb#handlestartupcodebehind)]  \n  \n [!code-xml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  \n[!code-xml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  \n  \n [!code-cs[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/add/codesnippet/csharp/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]\n [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/add/codesnippet/visualbasic/applicationpropertiessnippets/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]"
  syntax:
    content: public System.Collections.IDictionary Properties { get; }
    return:
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>, Содержащий свойства области приложения.</xref:System.Collections.IDictionary>"
  overload: System.Windows.Application.Properties*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.ResourceAssembly
  id: ResourceAssembly
  parent: System.Windows.Application
  langs:
  - csharp
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
  fullName: System.Windows.Application.ResourceAssembly
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает <xref:System.Reflection.Assembly>, предоставляющий пакете [!INCLUDE[TLA#tla_uri#plural](~/add/includes/tlasharptla-urisharpplural-md.md)] для ресурсов в [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] приложения.</xref:System.Reflection.Assembly>"
  remarks: "По умолчанию [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] ресурсы разрешаются во время выполнения по отношению к сборке записей, который определяется значение, возвращенное <xref:System.Reflection.Assembly.GetEntryAssembly%2A>метод.</xref:System.Reflection.Assembly.GetEntryAssembly%2A>       Первичная сборка — сборка, которая возвращается методом <xref:System.Reflection.Assembly.GetEntryAssembly%2A>и могут быть следующие:-исполняемой сборки в домен приложения по умолчанию.</xref:System.Reflection.Assembly.GetEntryAssembly%2A>      — Первая сборка для выполнения путем вызова <xref:System.AppDomain.ExecuteAssembly%2A>.</xref:System.AppDomain.ExecuteAssembly%2A>       В следующих случаях, однако [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] сборку не удается получить ссылку на сборку запись: - узлы (собственной) приложения неуправляемого [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] сборки.      -Узлы управляемого приложения [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] сборки, загрузив его в новый домен приложения с помощью метода, отличного от <xref:System.AppDomain.ExecuteAssembly%2A>.</xref:System.AppDomain.ExecuteAssembly%2A>       В обоих этих случаях <xref:System.Reflection.Assembly.GetEntryAssembly%2A>возвращает `null`и [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] ресурсы сборки не может быть разрешена.</xref:System.Reflection.Assembly.GetEntryAssembly%2A> В этих случаях атрибута ResourceAssembly можно задать, только один раз со ссылкой на сборку, которая должна использоваться для разрешения ресурсов.       Атрибута ResourceAssembly можно задать только один раз, поскольку маловероятно, что сборка ресурсов изменится после [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] сборка загружается.      Настроек [!NOTE] настроек атрибута ResourceAssembly не может быть задан, когда [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] сборки может обнаруживать сборке записей — то есть, когда <xref:System.Reflection.Assembly.GetEntryAssembly%2A>возвращает ссылку на сборку, вместо `null`.</xref:System.Reflection.Assembly.GetEntryAssembly%2A>       Это свойство является поточно-ориентированным и доступно из любого потока.       Атрибута ResourceAssembly впервые появился в платформе .NET Framework версии 3.5.  Дополнительные сведения см. в разделе [версии и зависимости](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Reflection.Assembly ResourceAssembly { get; set; }
    return:
      type: System.Reflection.Assembly
      description: "Ссылку на <xref:System.Reflection.Assembly>, предоставляющий пакете [!INCLUDE[TLA#tla_uri#plural](~/add/includes/tlasharptla-urisharpplural-md.md)] для ресурсов в [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] приложения.</xref:System.Reflection.Assembly>"
  overload: System.Windows.Application.ResourceAssembly*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Объект [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] приложение имеет запись сборки или атрибута ResourceAssembly уже задано."
  platform:
  - net462
- uid: System.Windows.Application.Resources
  id: Resources
  parent: System.Windows.Application
  langs:
  - csharp
  name: Resources
  nameWithType: Application.Resources
  fullName: System.Windows.Application.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает коллекцию ресурсов области приложения, таких как стили и кисти."
  remarks: "Свойства ресурсов можно использовать совместное использование ресурсов в windows и элементы приложения. Кроме того, ресурсы свойство включено в путь для поиска ресурсов, обхода в следующем порядке: 1.  Элементы 2.  Windows 3.  Ресурсы 4.  Система в результате [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] элементы можно привязать к ресурсам области приложения. Кроме того, если изменения ресурсов, ресурсов система гарантирует элемента свойств, связанных с этими ресурсами автоматически обновляются для отражения изменений.       Ресурсы области приложения предоставляют простой способ поддержки единой темы всего приложения. Можно легко создать тему в [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] с помощью `Application.Resources` тег. Тем не менее, если приложение поддерживает несколько тем, которые могут содержать большое количество элементов темы, может быть проще управлять ими с помощью одного <xref:System.Windows.ResourceDictionary>экземпляра для каждой темы.</xref:System.Windows.ResourceDictionary> Таким образом могут применяться новую тему, присвоив свойству ресурсы на соответствующие <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>       Существуют два аспекта, чтобы сделать при использовании ресурсов. Во-первых, словарь *ключ* является объектом, поэтому вам необходимо использовать один и тот же экземпляр объекта при установке и получении значения свойства (Обратите внимание, что ключ является с учетом регистра, при использовании строки). Во-вторых, словарь *значение* является объектом, поэтому вам необходимо будет преобразовать значение в требуемый тип при получении значения свойства.       Ресурсы является поточно-ориентированным и доступно из любого потока."
  example:
  - "This example illustrates how to use [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] together with application-scope resources to create a consistent visual appearance.  \n  \n [!code-xml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/App.xaml#resourcespropertyxaml)]  \n  \n [!code-xml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/MainWindow.xaml#windowbackgroundpropertyxaml1)]  \n[!code-xml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/MainWindow.xaml#windowbackgroundpropertyxaml2)]  \n  \n The following example shows how to set an application resource in code and XAML.  \n  \n [!code-vb[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/add/codesnippet/visualbasic/howtoapplicationmodelsnippets/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]\n [!code-cs[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/add/codesnippet/csharp/HOWTOApplicationModelSnippets/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]  \n  \n [!code-xml[HOWTOApplicationModelSnippets#SetApplicationScopeResourceXAML](~/add/codesnippet/xaml/HOWTOApplicationModelSnippets/App.xaml#setapplicationscoperesourcexaml)]  \n  \n The following example shows how to get an application resource in code.  \n  \n [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/add/codesnippet/visualbasic/howtoapplicationmodelsnippets/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]\n [!code-cs[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/add/codesnippet/csharp/HOWTOApplicationModelSnippets/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "Объект <xref href=&quot;System.Windows.ResourceDictionary&quot;> </xref> , содержащий ноль или более ресурсов области приложения."
  overload: System.Windows.Application.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Run
  id: Run
  parent: System.Windows.Application
  langs:
  - csharp
  name: Run()
  nameWithType: Application.Run()
  fullName: System.Windows.Application.Run()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Запускает [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] приложения."
  remarks: "<xref:System.Windows.Application.Run%2A>вызывается для запуска [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] приложения.</xref:System.Windows.Application.Run%2A> При определении вашей <xref:System.Windows.Application>с помощью разметку или разметку и код программной части, <xref:System.Windows.Application.Run%2A>вызывается неявно.</xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application> Тем не менее если определить <xref:System.Windows.Application>с помощью кода, необходимо явным образом вызвать <xref:System.Windows.Application.Run%2A>.</xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application> вашей       При <xref:System.Windows.Application.Run%2A>вызове <xref:System.Windows.Application>присоединяет новый <xref:System.Windows.Threading.Dispatcher>экземпляр [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] потока.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Application> </xref:System.Windows.Application.Run%2A> Далее, <xref:System.Windows.Threading.Dispatcher>объекта <xref:System.Windows.Threading.Dispatcher.Run%2A>вызывается метод, который запускает цикл обработки сообщений для обработки сообщений windows.</xref:System.Windows.Threading.Dispatcher.Run%2A> </xref:System.Windows.Threading.Dispatcher> Наконец <xref:System.Windows.Threading.Dispatcher>вызывает <xref:System.Windows.Application>объекта <xref:System.Windows.Application.OnStartup%2A>метод для вызова <xref:System.Windows.Application.Startup>событий.</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.OnStartup%2A> </xref:System.Windows.Application> </xref:System.Windows.Threading.Dispatcher> В результате установления модель выполнения приложения путем обработки <xref:System.Windows.Application.Startup>, тогда приложение считается работать.</xref:System.Windows.Application.Startup>       Приложение останавливается при <xref:System.Windows.Application.Shutdown%2A>вызове; значение <xref:System.Windows.Application.ShutdownMode%2A>свойство определяет, когда <xref:System.Windows.Application.Shutdown%2A>вызывается и это происходит автоматически, или необходимо явным образом вызвать его.</xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application.Shutdown%2A>       <xref:System.Windows.Application.Run%2A>может вызываться только из потока, который создает <xref:System.Windows.Application>объекта.</xref:System.Windows.Application></xref:System.Windows.Application.Run%2A> Кроме того <xref:System.Windows.Application.Run%2A>нельзя вызвать из [!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)].</xref:System.Windows.Application.Run%2A>"
  example:
  - "The following example shows an application that uses a custom <xref:System.Windows.Application> and must therefore explicitly call <xref:System.Windows.Application.Run%2A>.  \n  \n [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/add/codesnippet/visualbasic/applicationrunsnippets/app.vb#customentrypointandruncode)]\n [!code-cs[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/add/codesnippet/csharp/ApplicationRunSnippets.CSharp/App.cs#customentrypointandruncode)]"
  syntax:
    content: public int Run ();
    parameters: []
    return:
      type: System.Int32
      description: "<xref:System.Int32>Приложения код выхода, возвращаемый операционной системе при завершении работы приложения.</xref:System.Int32> По умолчанию значение кода выхода — 0."
  overload: System.Windows.Application.Run*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Запуск вызывается из приложения, размещаемые в браузере (например, [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)])."
  platform:
  - net462
- uid: System.Windows.Application.Run(System.Windows.Window)
  id: Run(System.Windows.Window)
  parent: System.Windows.Application
  langs:
  - csharp
  name: Run(Window)
  nameWithType: Application.Run(Window)
  fullName: System.Windows.Application.Run(Window)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Запускает [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] приложения и открывает указанное окно."
  remarks: "Эта перегрузка расширяет <xref:System.Windows.Application.Run%2A>метод для открытия указанного окна после запуска приложения.</xref:System.Windows.Application.Run%2A>       Если задать код <xref:System.Windows.Application>, открывается окно при запуске, явным образом вызвать выполнения.</xref:System.Windows.Application>       Если вы создаете вашей <xref:System.Windows.Application>с использованием разметки, разметки и кода, можно автоматически открыть окно при использовании одной из следующих способов: - декларативно, задав <xref:System.Windows.Application.StartupUri%2A>.</xref:System.Windows.Application.StartupUri%2A> </xref:System.Windows.Application>      — Программными средствами обрабатывая <xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup>"
  example:
  - "The following example shows an application with a manually-created static entry point method that instantiates <xref:System.Windows.Application>, before calling <xref:System.Windows.Application.Run%2A>.  \n  \n [!code-cs[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/add/codesnippet/csharp/ApplicationRunOL1Snippets.CSharp/App.cs#customentrypointandrunol1code)]\n [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/add/codesnippet/visualbasic/applicationrunol1snippets/app.vb#customentrypointandrunol1code)]"
  syntax:
    content: public int Run (System.Windows.Window window);
    parameters:
    - id: window
      type: System.Windows.Window
      description: "Объект <xref href=&quot;System.Windows.Window&quot;> </xref> , открывается автоматически при запуске приложения."
    return:
      type: System.Int32
      description: "<xref:System.Int32>Приложения код выхода, возвращаемый операционной системе при завершении работы приложения.</xref:System.Int32> По умолчанию значение кода выхода — 0."
  overload: System.Windows.Application.Run*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Windows.Application.Run*>вызывается из приложения, размещаемые в браузере (например, [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]).</xref:System.Windows.Application.Run*>"
  platform:
  - net462
- uid: System.Windows.Application.SessionEnding
  id: SessionEnding
  parent: System.Windows.Application
  langs:
  - csharp
  name: SessionEnding
  nameWithType: Application.SessionEnding
  fullName: System.Windows.Application.SessionEnding
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит, когда пользователь завершает [!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)] сеанс выходом или завершение работы операционной системы."
  remarks: "По умолчанию приложение завершает работу при [!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)] завершается сеанс, в которых происходит, когда пользователь выходит из системы или завершает работу. В этом случае [!INCLUDE[TLA2#tla_mswin](~/add/includes/tla2sharptla-mswin-md.md)] запрашивает у всех действующих приложений на завершение работы. Однако это возможно, приложение может быть не готовы к завершению работы, это происходит. Например приложение может иметь данные, находится в несогласованном состоянии, или в середине длительной операции. В таких ситуациях он может возникнуть необходимость предотвратить завершение сеанса и может быть предпочтительнее разрешить пользователям возможность решить, следует ли позволить завершить текущий сеанс.       Можно обнаружить при завершении сеанса путем обработки события SessionEnding. Если приложению требуется предотвратить завершение, сеанс <xref:System.Windows.SessionEndingCancelEventArgs>предоставляет аргумента, переданного в обработчик событий <xref:System.ComponentModel.CancelEventArgs.Cancel%2A>, задаваемый для `true` (значение по умолчанию — `false`).</xref:System.ComponentModel.CancelEventArgs.Cancel%2A> </xref:System.Windows.SessionEndingCancelEventArgs>       Если SessionEnding не обрабатывается или обрабатывается без выполняется Отмена <xref:System.Windows.Application.Shutdown%2A>вызывается и <xref:System.Windows.Application.Exit>события.</xref:System.Windows.Application.Exit> </xref:System.Windows.Application.Shutdown%2A>       Чтобы получить дополнительные сведения о том, почему сеанс завершается, приложение может проверять <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, которое является одним из <xref:System.Windows.ReasonSessionEnding>значения (<xref:System.Windows.ReasonSessionEnding> и <xref:System.Windows.ReasonSessionEnding>).</xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>       Консольные приложения не вызывает SessionEnding.       SessionEnding возникает только в том потоке, который создает <xref:System.Windows.Application>объекта.</xref:System.Windows.Application>       SessionEnding не вызывается для [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]."
  example:
  - "The following example demonstrates how to handle the SessionEnding event and allow the user to cancel it.  \n  \n [!code-xml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/add/codesnippet/xaml/ApplicationSessionEndingSnippets.CSharp/App.xaml#handlingsessionendingxaml)]  \n  \n [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/add/codesnippet/visualbasic/applicationsessionendingsnippets/application.xaml.vb#handlingsessionendingcodebehind)]\n [!code-cs[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/add/codesnippet/csharp/ApplicationSessionEndingSnippets.CSharp/App.xaml.cs#handlingsessionendingcodebehind)]"
  syntax:
    content: public event System.Windows.SessionEndingCancelEventHandler SessionEnding;
    return:
      type: System.Windows.SessionEndingCancelEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.SetCookie(System.Uri,System.String)
  id: SetCookie(System.Uri,System.String)
  parent: System.Windows.Application
  langs:
  - csharp
  name: SetCookie(Uri,String)
  nameWithType: Application.SetCookie(Uri,String)
  fullName: System.Windows.Application.SetCookie(Uri,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Создает файл cookie для местоположении, заданном свойством <xref:System.Uri>.</xref:System.Uri>"
  remarks: "Файл cookie представляет собой произвольной данных, которые могут быть сохранены на приложения на клиентском компьютере во время сеанса приложения (cookie сеанса) или между сеансами приложения (постоянные файлы cookie). Оба типа файлов cookie, можно создать путем вызова SetCookie.       Данные cookie обычно принимает форму пары &quot;имя значение&quot; в следующем формате: `Name=Value` SetCookie, передать строку этого формата вместе с <xref:System.Uri>расположения, для которого следует задать куки-файл (как правило, домен приложения).</xref:System.Uri>       Является ли файл cookie файла cookie сеанса или постоянный файл cookie зависит от того, включает ли строка файла cookie, передаваемый SetCookie дату окончания действия. Строка для файла cookie сеанса не включает дату окончания действия. Выполняет строку для постоянный файл cookie и должен быть в следующем формате: `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT` сохраняемые файлы Cookie хранятся в текущем [!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)] папке временных файлов Интернета для установки до истечения срока их действия, в этом случае они будут удалены. Можно удалить постоянный файл cookie из приложения, задав даты его истечения срока действия в значение даты и времени в прошлом.       Обзор файлов cookie в [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)], в разделе [Общие сведения о навигации](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static void SetCookie (Uri uri, string value);
    parameters:
    - id: uri
      type: System.Uri
      description: "<xref:System.Uri>, Задающий расположение, для которого должен быть создан файл cookie.</xref:System.Uri>"
    - id: value
      type: System.String
      description: "<xref:System.String>, Содержащий данные файла cookie.</xref:System.String>"
  overload: System.Windows.Application.SetCookie*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Объект [!INCLUDE[TLA#tla_win32](~/add/includes/tlasharptla-win32-md.md)] ошибка возникла в <xref uid=&quot;langword_csharp_InternetSetCookie&quot; name=&quot;InternetSetCookie&quot; href=&quot;&quot;> </xref> (называемой по SetCookie) Если проблема возникает при попытке создания указанного файла cookie."
  platform:
  - net462
- uid: System.Windows.Application.Shutdown
  id: Shutdown
  parent: System.Windows.Application
  langs:
  - csharp
  name: Shutdown()
  nameWithType: Application.Shutdown()
  fullName: System.Windows.Application.Shutdown()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Завершает работу приложения."
  remarks: "При вызове завершения работы приложения прекращается. Можно обработать <xref:System.Windows.Application.Exit>событий для определения, когда приложение должно завершить свою работу, чтобы выполнить соответствующую обработку.</xref:System.Windows.Application.Exit>       Завершение работы неявно вызывается [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] в следующих ситуациях: — Если <xref:System.Windows.Application.ShutdownMode%2A>задано значение <xref:System.Windows.ShutdownMode>.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      -Если <xref:System.Windows.Application.ShutdownMode%2A>задано значение <xref:System.Windows.ShutdownMode>.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      — Когда пользователь завершает сеанс и <xref:System.Windows.Application.SessionEnding>событие обрабатывается, либо обрабатываются без отмены.</xref:System.Windows.Application.SessionEnding>       Явный вызов завершения работы вызывает приложение для завершения работы, независимо от <xref:System.Windows.Application.ShutdownMode%2A>параметр.</xref:System.Windows.Application.ShutdownMode%2A> Однако если <xref:System.Windows.Application.ShutdownMode%2A>имеет значение <xref:System.Windows.ShutdownMode>, необходимо вызвать завершение работы приложения.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      Настроек [!IMPORTANT] настроек вызывается при завершении работы, приложение будет завершена, вне зависимости от того, следует ли <xref:System.Windows.Window.Closing>событие всех открытых окон отменяется.</xref:System.Windows.Window.Closing>       Этот метод может вызываться только из потока, который создал <xref:System.Windows.Application>объекта.</xref:System.Windows.Application>"
  syntax:
    content: public void Shutdown ();
    parameters: []
  overload: System.Windows.Application.Shutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Shutdown(System.Int32)
  id: Shutdown(System.Int32)
  parent: System.Windows.Application
  langs:
  - csharp
  name: Shutdown(Int32)
  nameWithType: Application.Shutdown(Int32)
  fullName: System.Windows.Application.Shutdown(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Завершает работу приложения и передает указанный код выхода операционной системе."
  remarks: "Можно обработать <xref:System.Windows.Application.Exit>событие, чтобы вернуть код завершения.</xref:System.Windows.Application.Exit> Тем не менее если явным образом вызвать <xref:System.Windows.Application.Shutdown%2A>, и обрабатывать <xref:System.Windows.Application.Exit>только чтобы задать код выхода, могут вызвать завершение работы вместо.</xref:System.Windows.Application.Exit> </xref:System.Windows.Application.Shutdown%2A>       Этот метод может вызываться только из потока, который создал <xref:System.Windows.Application>объекта.</xref:System.Windows.Application>"
  syntax:
    content: public void Shutdown (int exitCode);
    parameters:
    - id: exitCode
      type: System.Int32
      description: "Целочисленный код завершения для приложения. Код выхода по умолчанию — 0."
  overload: System.Windows.Application.Shutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.ShutdownMode
  id: ShutdownMode
  parent: System.Windows.Application
  langs:
  - csharp
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
  fullName: System.Windows.Application.ShutdownMode
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает условие, вызывающее <xref:System.Windows.Application.Shutdown*>вызываемого метода.</xref:System.Windows.Application.Shutdown*>"
  remarks: "Приложения перестают работать только если <xref:System.Windows.Application.Shutdown%2A>вызывается метод приложения.</xref:System.Windows.Application.Shutdown%2A> Завершение работы может произойти явно или неявно, как указано в значении свойства ShutdownMode.       Если значение ShutdownMode <xref:System.Windows.ShutdownMode>, [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] неявно вызывает <xref:System.Windows.Application.Shutdown%2A>при закрытии последнего окна в приложении, даже если любой версии windows в данный момент созданы устанавливаются в качестве главного окна (см. <xref:System.Windows.Application.MainWindow%2A>).</xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode>       ShutdownMode из <xref:System.Windows.ShutdownMode>вызывает [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]неявно вызывается <xref:System.Windows.Application.Shutdown%2A>при <xref:System.Windows.Application.MainWindow%2A>Закрыто, даже если в настоящее время открыты другие окна.</xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode>       Время существования некоторых приложений может не зависеть при главного окна или последнее окно закрывается или могут не зависеть от windows на всех. В этих сценариях необходимо задать свойство ShutdownMode <xref:System.Windows.ShutdownMode>, которая требует явного <xref:System.Windows.Application.Shutdown%2A>вызова метода, чтобы остановить приложение.</xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode> В противном случае выполнение приложения продолжается в фоновом режиме.       ShutdownMode можно настроить декларативно [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] или программным образом из кода.       Это свойство доступно только из потока, который создал <xref:System.Windows.Application>объекта.</xref:System.Windows.Application>"
  example:
  - "The following example shows how to configure ShutdownMode to specify that an application must be closed explicitly.  \n  \n [!code-xml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/add/codesnippet/xaml/ApplicationShutdownModeSnippets.XAML/App.xaml#setshutdownmodexaml)]"
  syntax:
    content: public System.Windows.ShutdownMode ShutdownMode { get; set; }
    return:
      type: System.Windows.ShutdownMode
      description: "Объект <xref href=&quot;System.Windows.ShutdownMode&quot;> </xref> значение перечисления. Значение по умолчанию — <xref href=&quot;System.Windows.ShutdownMode&quot;> </xref>."
  overload: System.Windows.Application.ShutdownMode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Startup
  id: Startup
  parent: System.Windows.Application
  langs:
  - csharp
  name: Startup
  nameWithType: Application.Startup
  fullName: System.Windows.Application.Startup
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит при <xref:System.Windows.Application.Run*>метод <xref href=&quot;System.Windows.Application&quot;> </xref> объект называется.</xref:System.Windows.Application.Run*>"
  remarks: "Типичный [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] приложение может выполнять разнообразные задачи инициализации, при запуске, включая:-обработка аргументов командной строки.      -Открытие главного окна.      -Инициализация ресурсов области приложения.      -Инициализация свойств области приложения.       Можно задать декларативно главное окно и ресурсов области приложения с помощью [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] (<xref:System.Windows.Application.StartupUri%2A> и <xref:System.Windows.Application.Resources%2A>соответственно).</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application.StartupUri%2A> Иногда тем не менее, ресурсы или главное окно приложения можно определить только программными средствами во время выполнения. Кроме того свойства области приложения и параметры командной строки может использоваться только программно. Программный инициализации выполняются путем обработки событий запуска, включая следующие: - получения и обработки параметров командной строки, которые доступны из <xref:System.Windows.StartupEventArgs.Args%2A>свойство <xref:System.Windows.StartupEventArgs>класс, который передается в обработчик события Startup.</xref:System.Windows.StartupEventArgs> </xref:System.Windows.StartupEventArgs.Args%2A>      -Инициализация ресурсов области приложения с помощью <xref:System.Windows.Application.Resources%2A>свойство.</xref:System.Windows.Application.Resources%2A>      -Инициализация свойств области приложения с помощью <xref:System.Windows.Application.Properties%2A>свойство.</xref:System.Windows.Application.Properties%2A>      -Создание экземпляра и окнами, один (или более).      Настроек [!NOTE] настроек параметров командной строки также может быть получено путем вызова статического <xref:System.Environment.GetCommandLineArgs%2A>метод <xref:System.Environment>объекта.</xref:System.Environment> </xref:System.Environment.GetCommandLineArgs%2A> Тем не менее <xref:System.Environment.GetCommandLineArgs%2A>требует полного доверия для выполнения.</xref:System.Environment.GetCommandLineArgs%2A>       Если задать <xref:System.Windows.Application.StartupUri%2A>с помощью [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)], главное окно, которое создается недоступен либо из <xref:System.Windows.Application.MainWindow%2A>свойство или <xref:System.Windows.Application.Windows%2A>свойство <xref:System.Windows.Application>объекта до, после обработки события при запуске.</xref:System.Windows.Application> </xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.StartupUri%2A> Если вам нужен доступ к главного окна во время запуска, необходимо вручную создать новый объект окна из обработчика событий при запуске.      Настроек [!NOTE] настроек Если приложение использует <xref:System.Net.AuthenticationManager.CredentialPolicy%2A>Задание политики учетных данных, необходимо задать <xref:System.Net.AuthenticationManager.CredentialPolicy%2A>после запуска вызванное; в противном случае — [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] задает для внутренней политики по умолчанию непосредственно после возникновения события запуска.</xref:System.Net.AuthenticationManager.CredentialPolicy%2A> </xref:System.Net.AuthenticationManager.CredentialPolicy%2A>       Аргументы командной строки, которые передаются в обработчик события Startup не совпадает с [!INCLUDE[TLA#tla_url](~/add/includes/tlasharptla-url-md.md)] параметры строки, которые передаются запроса [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]."
  example:
  - "The following example shows how to acquire and process command-line options from a standalone application. If the **/StartMinimized** command-line parameter was provided, the application opens the main window in a minimized state.  \n  \n [!code-xml[ApplicationStartupSnippets#HandleStartupXAML](~/add/codesnippet/xaml/ApplicationStartupSnippets.CSharp/App.xaml#handlestartupxaml)]  \n  \n [!code-cs[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/csharp/ApplicationStartupSnippets.CSharp/App.xaml.cs#handlestartupcodebehind)]\n [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/visualbasic/applicationstartupsnippets/application.xaml.vb#handlestartupcodebehind)]  \n  \n [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)] cannot retrieve and process command-line arguments because they are launched with [!INCLUDE[TLA#tla_clickonce](~/add/includes/tlasharptla-clickonce-md.md)] deployment (see [Deploying a WPF Application (WPF)](~/add/includes/ajax-current-ext-md.md)). However, they can retrieve and process query string parameters from the URLs that are used to launch them."
  syntax:
    content: public event System.Windows.StartupEventHandler Startup;
    return:
      type: System.Windows.StartupEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.StartupUri
  id: StartupUri
  parent: System.Windows.Application
  langs:
  - csharp
  name: StartupUri
  nameWithType: Application.StartupUri
  fullName: System.Windows.Application.StartupUri
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] , автоматически отображаются при запуске приложения."
  remarks: "Можно использовать для автоматической загрузки StartupUri [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] ресурсов при запуске приложения.       В следующей таблице показаны типы [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] ресурсы, которые могут быть загружены, их открытии в тип окна и тип приложения, эти ресурсы можно задать в качестве StartupUri.      | Тип | Окно | Тип приложения |   |----------|------------|----------------------|   | <xref:System.Windows.Window>| <xref:System.Windows.Window>| Только автономное |   | <xref:System.Windows.Navigation.NavigationWindow>| <xref:System.Windows.Navigation.NavigationWindow>| Только автономное |   | <xref:System.Windows.Controls.Page>| <xref:System.Windows.Navigation.NavigationWindow>| Автономный или Браузерные |   | <xref:System.Windows.Controls.UserControl>| <xref:System.Windows.Navigation.NavigationWindow>| Автономный или Браузерные |   | <xref:System.Windows.Documents.FlowDocument>| <xref:System.Windows.Navigation.NavigationWindow>| Автономный или Браузерные |   | <xref:System.Windows.Navigation.PageFunction%601>| <xref:System.Windows.Navigation.NavigationWindow>| Автономный или Браузерные |       Как правило, задается свойство StartupUri декларативно в [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)].</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.PageFunction%601> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Documents.FlowDocument> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Controls.UserControl> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Controls.Page> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Window> </xref:System.Windows.Window> Тем не менее, StartupUri можно задать программно, например, в <xref:System.Windows.Application.Startup>обработчик событий, что полезно, если для приложения, можно загружать только необходимые [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] ресурсы во время выполнения.</xref:System.Windows.Application.Startup> Например, приложение может ожидать до времени выполнения для загрузки ресурсов, если имя [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] ресурсов хранится в файле конфигурации.       Значения, определяющего StartupUri декларативно или программно, соответствующий [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] ресурсов загружается только после <xref:System.Windows.Application.Startup>событие обрабатывается.</xref:System.Windows.Application.Startup> Следовательно будут недоступны в появившемся окне либо из <xref:System.Windows.Application.Windows%2A>свойства или <xref:System.Windows.Application.MainWindow%2A>свойств при обработке <xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Windows%2A>"
  syntax:
    content: public Uri StartupUri { get; set; }
    return:
      type: System.Uri
      description: "Объект <xref:System.Uri>, обозначающий [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] , автоматически открывается при запуске приложения.</xref:System.Uri>"
  overload: System.Windows.Application.StartupUri*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "StartupUri присваивается значение null."
  platform:
  - net462
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.Application
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Запрашивает, доступен ли заданное внешнее свойство в текущей области."
  remarks: "Этот член представляет явную реализацию члена интерфейса. Он может использоваться только если <xref:System.Windows.Application>экземпляр приводится к <xref:System.Windows.Markup.IQueryAmbient>интерфейс.</xref:System.Windows.Markup.IQueryAmbient> </xref:System.Windows.Application>"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "Имя запрошенного свойства окружения."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если запрошенное внешнее свойство доступно; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.Application
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: Application.TryFindResource(Object)
  fullName: System.Windows.Application.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Выполняет поиск указанного ресурса."
  remarks: "TryFindResource сначала просматривает ресурсов области приложения для указанного ресурса. Ресурсы области приложения, управляются <xref:System.Windows.Application>и предоставляются из <xref:System.Windows.Application.Resources%2A>свойство.</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application> Если указанный ресурс не найден в наборе ресурсов области приложения, TryFindResource Далее выполняет системных ресурсов. Системные ресурсы являются ресурсы оболочки, определяемый пользователем и включать цвета, шрифты и настойки оболочки. Они предоставляются из <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, и <xref:System.Windows.SystemParameters>соответственно статических свойств.</xref:System.Windows.SystemParameters> </xref:System.Windows.SystemFonts> </xref:System.Windows.SystemColors> Чтобы использовать TryFindResource для их получения, эти типы также предоставляют ключевые свойства ресурсов, предназначенных для передачи TryFindResource; Например, <xref:System.Windows.SystemParameters.IconWidthKey%2A>.</xref:System.Windows.SystemParameters.IconWidthKey%2A>       Так как TryFindResource возвращает объект, необходимо привести возвращаемое значение к соответствующему типу при обнаружении ресурса.       Этот метод является поточно-ориентированным и может вызываться из любого потока."
  example:
  - "The following example shows how to use TryFindResource to acquire a resource.  \n  \n [!code-xml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/add/codesnippet/xaml/ApplicationTryFindResourceSnippets/App.xaml#applicationcalltryfindresourcexaml)]  \n  \n [!code-cs[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/add/codesnippet/csharp/ApplicationTryFindResourceSnippets/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]\n [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/add/codesnippet/visualbasic/applicationtryfindresourcesnippets/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  \n[!code-cs[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/add/codesnippet/csharp/ApplicationTryFindResourceSnippets/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]\n[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/add/codesnippet/visualbasic/applicationtryfindresourcesnippets/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "Имя ресурса для поиска."
    return:
      type: System.Object
      description: "Объект запрошенного ресурса. Если запрошенный ресурс не найден, возвращается пустая ссылка."
  overload: System.Windows.Application.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Windows
  id: Windows
  parent: System.Windows.Application
  langs:
  - csharp
  name: Windows
  nameWithType: Application.Windows
  fullName: System.Windows.Application.Windows
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает созданные окна приложения."
  remarks: "Объект <xref:System.Windows.Window>автоматически добавляется ссылка Windows сразу после создания экземпляра окна на [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] потока; windows, созданных рабочих потоков не добавляются.</xref:System.Windows.Window> Объект <xref:System.Windows.Window>ссылка автоматически удаляется после его <xref:System.Windows.Window.Closing>событие было обработано и перед его <xref:System.Windows.Window.Closed>события.</xref:System.Windows.Window.Closed> </xref:System.Windows.Window.Closing> </xref:System.Windows.Window>       По умолчанию первый элемент, добавляемый свойство Windows становится <xref:System.Windows.Application.MainWindow%2A>.</xref:System.Windows.Application.MainWindow%2A>       Это свойство доступно только из потока, который создал <xref:System.Windows.Application>объекта.</xref:System.Windows.Application>"
  example:
  - "The following example demonstrates how to enumerate the Windows property to build a top-level Windows menu, which is common to [!INCLUDE[TLA#tla_mdi](~/add/includes/tlasharptla-mdi-md.md)] applications like [!INCLUDE[TLA#tla_xl](~/add/includes/tlasharptla-xl-md.md)], or multiple-instance Single Document Interface (SDI) applications like [!INCLUDE[TLA#tla_word](~/add/includes/tlasharptla-word-md.md)].  \n  \n [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/add/codesnippet/visualbasic/applicationwindowssnippets/windowmenuitem.vb#windowmenuitemcode)]\n [!code-cs[ApplicationWindowsSnippets#WindowMenuItemCODE](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/WindowMenuItem.cs#windowmenuitemcode)]  \n  \n [!code-xml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/add/codesnippet/xaml/ApplicationWindowsSnippets.CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  \n  \n [!code-cs[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]\n [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/add/codesnippet/visualbasic/applicationwindowssnippets/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  \n[!code-cs[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]\n[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/add/codesnippet/visualbasic/applicationwindowssnippets/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]"
  syntax:
    content: public System.Windows.WindowCollection Windows { get; }
    return:
      type: System.Windows.WindowCollection
      description: "Объект <xref href=&quot;System.Windows.WindowCollection&quot;> </xref> , содержащий ссылки на все окно объекты в текущем <xref href=&quot;System.AppDomain&quot;> </xref>."
  overload: System.Windows.Application.Windows*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Threading.DispatcherObject
  isExternal: false
  name: System.Windows.Threading.DispatcherObject
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.Windows.Application.#ctor
  parent: System.Windows.Application
  isExternal: false
  name: Application()
  nameWithType: Application.Application()
  fullName: System.Windows.Application.Application()
- uid: System.Windows.Application.Activated
  parent: System.Windows.Application
  isExternal: false
  name: Activated
  nameWithType: Application.Activated
  fullName: System.Windows.Application.Activated
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.Application.Current
  parent: System.Windows.Application
  isExternal: false
  name: Current
  nameWithType: Application.Current
  fullName: System.Windows.Application.Current
- uid: System.Windows.Application
  parent: System.Windows
  isExternal: false
  name: Application
  nameWithType: Application
  fullName: System.Windows.Application
- uid: System.Windows.Application.Deactivated
  parent: System.Windows.Application
  isExternal: false
  name: Deactivated
  nameWithType: Application.Deactivated
  fullName: System.Windows.Application.Deactivated
- uid: System.Windows.Application.DispatcherUnhandledException
  parent: System.Windows.Application
  isExternal: false
  name: DispatcherUnhandledException
  nameWithType: Application.DispatcherUnhandledException
  fullName: System.Windows.Application.DispatcherUnhandledException
- uid: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionEventHandler
  nameWithType: DispatcherUnhandledExceptionEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
- uid: System.Windows.Application.Exit
  parent: System.Windows.Application
  isExternal: false
  name: Exit
  nameWithType: Application.Exit
  fullName: System.Windows.Application.Exit
- uid: System.Windows.ExitEventHandler
  parent: System.Windows
  isExternal: false
  name: ExitEventHandler
  nameWithType: ExitEventHandler
  fullName: System.Windows.ExitEventHandler
- uid: System.Windows.Application.FindResource(System.Object)
  parent: System.Windows.Application
  isExternal: false
  name: FindResource(Object)
  nameWithType: Application.FindResource(Object)
  fullName: System.Windows.Application.FindResource(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.Application.FragmentNavigation
  parent: System.Windows.Application
  isExternal: false
  name: FragmentNavigation
  nameWithType: Application.FragmentNavigation
  fullName: System.Windows.Application.FragmentNavigation
- uid: System.Windows.Navigation.FragmentNavigationEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: FragmentNavigationEventHandler
  nameWithType: FragmentNavigationEventHandler
  fullName: System.Windows.Navigation.FragmentNavigationEventHandler
- uid: System.Windows.Application.GetContentStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetContentStream(Uri)
  nameWithType: Application.GetContentStream(Uri)
  fullName: System.Windows.Application.GetContentStream(Uri)
- uid: System.Windows.Resources.StreamResourceInfo
  parent: System.Windows.Resources
  isExternal: false
  name: StreamResourceInfo
  nameWithType: StreamResourceInfo
  fullName: System.Windows.Resources.StreamResourceInfo
- uid: System.Uri
  parent: System
  isExternal: true
  name: Uri
  nameWithType: Uri
  fullName: System.Uri
- uid: System.Windows.Application.GetCookie(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetCookie(Uri)
  nameWithType: Application.GetCookie(Uri)
  fullName: System.Windows.Application.GetCookie(Uri)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Application.GetRemoteStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetRemoteStream(Uri)
  nameWithType: Application.GetRemoteStream(Uri)
  fullName: System.Windows.Application.GetRemoteStream(Uri)
- uid: System.Windows.Application.GetResourceStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetResourceStream(Uri)
  nameWithType: Application.GetResourceStream(Uri)
  fullName: System.Windows.Application.GetResourceStream(Uri)
- uid: System.Windows.Application.LoadCompleted
  parent: System.Windows.Application
  isExternal: false
  name: LoadCompleted
  nameWithType: Application.LoadCompleted
  fullName: System.Windows.Application.LoadCompleted
- uid: System.Windows.Navigation.LoadCompletedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: LoadCompletedEventHandler
  nameWithType: LoadCompletedEventHandler
  fullName: System.Windows.Navigation.LoadCompletedEventHandler
- uid: System.Windows.Application.LoadComponent(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent(Uri)
  nameWithType: Application.LoadComponent(Uri)
  fullName: System.Windows.Application.LoadComponent(Uri)
- uid: System.Windows.Application.LoadComponent(System.Object,System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent(Object,Uri)
  nameWithType: Application.LoadComponent(Object,Uri)
  fullName: System.Windows.Application.LoadComponent(Object,Uri)
- uid: System.Windows.Application.MainWindow
  parent: System.Windows.Application
  isExternal: false
  name: MainWindow
  nameWithType: Application.MainWindow
  fullName: System.Windows.Application.MainWindow
- uid: System.Windows.Window
  parent: System.Windows
  isExternal: false
  name: Window
  nameWithType: Window
  fullName: System.Windows.Window
- uid: System.Windows.Application.Navigated
  parent: System.Windows.Application
  isExternal: false
  name: Navigated
  nameWithType: Application.Navigated
  fullName: System.Windows.Application.Navigated
- uid: System.Windows.Navigation.NavigatedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatedEventHandler
  nameWithType: NavigatedEventHandler
  fullName: System.Windows.Navigation.NavigatedEventHandler
- uid: System.Windows.Application.Navigating
  parent: System.Windows.Application
  isExternal: false
  name: Navigating
  nameWithType: Application.Navigating
  fullName: System.Windows.Application.Navigating
- uid: System.Windows.Navigation.NavigatingCancelEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatingCancelEventHandler
  nameWithType: NavigatingCancelEventHandler
  fullName: System.Windows.Navigation.NavigatingCancelEventHandler
- uid: System.Windows.Application.NavigationFailed
  parent: System.Windows.Application
  isExternal: false
  name: NavigationFailed
  nameWithType: Application.NavigationFailed
  fullName: System.Windows.Application.NavigationFailed
- uid: System.Windows.Navigation.NavigationFailedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationFailedEventHandler
  nameWithType: NavigationFailedEventHandler
  fullName: System.Windows.Navigation.NavigationFailedEventHandler
- uid: System.Windows.Application.NavigationProgress
  parent: System.Windows.Application
  isExternal: false
  name: NavigationProgress
  nameWithType: Application.NavigationProgress
  fullName: System.Windows.Application.NavigationProgress
- uid: System.Windows.Navigation.NavigationProgressEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationProgressEventHandler
  nameWithType: NavigationProgressEventHandler
  fullName: System.Windows.Navigation.NavigationProgressEventHandler
- uid: System.Windows.Application.NavigationStopped
  parent: System.Windows.Application
  isExternal: false
  name: NavigationStopped
  nameWithType: Application.NavigationStopped
  fullName: System.Windows.Application.NavigationStopped
- uid: System.Windows.Navigation.NavigationStoppedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationStoppedEventHandler
  nameWithType: NavigationStoppedEventHandler
  fullName: System.Windows.Navigation.NavigationStoppedEventHandler
- uid: System.Windows.Application.OnActivated(System.EventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnActivated(EventArgs)
  nameWithType: Application.OnActivated(EventArgs)
  fullName: System.Windows.Application.OnActivated(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.Application.OnDeactivated(System.EventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnDeactivated(EventArgs)
  nameWithType: Application.OnDeactivated(EventArgs)
  fullName: System.Windows.Application.OnDeactivated(EventArgs)
- uid: System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnExit(ExitEventArgs)
  nameWithType: Application.OnExit(ExitEventArgs)
  fullName: System.Windows.Application.OnExit(ExitEventArgs)
- uid: System.Windows.ExitEventArgs
  parent: System.Windows
  isExternal: false
  name: ExitEventArgs
  nameWithType: ExitEventArgs
  fullName: System.Windows.ExitEventArgs
- uid: System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnFragmentNavigation(FragmentNavigationEventArgs)
  nameWithType: Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  fullName: System.Windows.Application.OnFragmentNavigation(FragmentNavigationEventArgs)
- uid: System.Windows.Navigation.FragmentNavigationEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: FragmentNavigationEventArgs
  nameWithType: FragmentNavigationEventArgs
  fullName: System.Windows.Navigation.FragmentNavigationEventArgs
- uid: System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnLoadCompleted(NavigationEventArgs)
  nameWithType: Application.OnLoadCompleted(NavigationEventArgs)
  fullName: System.Windows.Application.OnLoadCompleted(NavigationEventArgs)
- uid: System.Windows.Navigation.NavigationEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationEventArgs
  nameWithType: NavigationEventArgs
  fullName: System.Windows.Navigation.NavigationEventArgs
- uid: System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigated(NavigationEventArgs)
  nameWithType: Application.OnNavigated(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigated(NavigationEventArgs)
- uid: System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigating(NavigatingCancelEventArgs)
  nameWithType: Application.OnNavigating(NavigatingCancelEventArgs)
  fullName: System.Windows.Application.OnNavigating(NavigatingCancelEventArgs)
- uid: System.Windows.Navigation.NavigatingCancelEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatingCancelEventArgs
  nameWithType: NavigatingCancelEventArgs
  fullName: System.Windows.Navigation.NavigatingCancelEventArgs
- uid: System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationFailed(NavigationFailedEventArgs)
  nameWithType: Application.OnNavigationFailed(NavigationFailedEventArgs)
  fullName: System.Windows.Application.OnNavigationFailed(NavigationFailedEventArgs)
- uid: System.Windows.Navigation.NavigationFailedEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationFailedEventArgs
  nameWithType: NavigationFailedEventArgs
  fullName: System.Windows.Navigation.NavigationFailedEventArgs
- uid: System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationProgress(NavigationProgressEventArgs)
  nameWithType: Application.OnNavigationProgress(NavigationProgressEventArgs)
  fullName: System.Windows.Application.OnNavigationProgress(NavigationProgressEventArgs)
- uid: System.Windows.Navigation.NavigationProgressEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationProgressEventArgs
  nameWithType: NavigationProgressEventArgs
  fullName: System.Windows.Navigation.NavigationProgressEventArgs
- uid: System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationStopped(NavigationEventArgs)
  nameWithType: Application.OnNavigationStopped(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigationStopped(NavigationEventArgs)
- uid: System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnSessionEnding(SessionEndingCancelEventArgs)
  nameWithType: Application.OnSessionEnding(SessionEndingCancelEventArgs)
  fullName: System.Windows.Application.OnSessionEnding(SessionEndingCancelEventArgs)
- uid: System.Windows.SessionEndingCancelEventArgs
  parent: System.Windows
  isExternal: false
  name: SessionEndingCancelEventArgs
  nameWithType: SessionEndingCancelEventArgs
  fullName: System.Windows.SessionEndingCancelEventArgs
- uid: System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnStartup(StartupEventArgs)
  nameWithType: Application.OnStartup(StartupEventArgs)
  fullName: System.Windows.Application.OnStartup(StartupEventArgs)
- uid: System.Windows.StartupEventArgs
  parent: System.Windows
  isExternal: false
  name: StartupEventArgs
  nameWithType: StartupEventArgs
  fullName: System.Windows.StartupEventArgs
- uid: System.Windows.Application.Properties
  parent: System.Windows.Application
  isExternal: false
  name: Properties
  nameWithType: Application.Properties
  fullName: System.Windows.Application.Properties
- uid: System.Collections.IDictionary
  parent: System.Collections
  isExternal: true
  name: IDictionary
  nameWithType: IDictionary
  fullName: System.Collections.IDictionary
- uid: System.Windows.Application.ResourceAssembly
  parent: System.Windows.Application
  isExternal: false
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
  fullName: System.Windows.Application.ResourceAssembly
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.Windows.Application.Resources
  parent: System.Windows.Application
  isExternal: false
  name: Resources
  nameWithType: Application.Resources
  fullName: System.Windows.Application.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.Application.Run
  parent: System.Windows.Application
  isExternal: false
  name: Run()
  nameWithType: Application.Run()
  fullName: System.Windows.Application.Run()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Application.Run(System.Windows.Window)
  parent: System.Windows.Application
  isExternal: false
  name: Run(Window)
  nameWithType: Application.Run(Window)
  fullName: System.Windows.Application.Run(Window)
- uid: System.Windows.Application.SessionEnding
  parent: System.Windows.Application
  isExternal: false
  name: SessionEnding
  nameWithType: Application.SessionEnding
  fullName: System.Windows.Application.SessionEnding
- uid: System.Windows.SessionEndingCancelEventHandler
  parent: System.Windows
  isExternal: false
  name: SessionEndingCancelEventHandler
  nameWithType: SessionEndingCancelEventHandler
  fullName: System.Windows.SessionEndingCancelEventHandler
- uid: System.Windows.Application.SetCookie(System.Uri,System.String)
  parent: System.Windows.Application
  isExternal: false
  name: SetCookie(Uri,String)
  nameWithType: Application.SetCookie(Uri,String)
  fullName: System.Windows.Application.SetCookie(Uri,String)
- uid: System.Windows.Application.Shutdown
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown()
  nameWithType: Application.Shutdown()
  fullName: System.Windows.Application.Shutdown()
- uid: System.Windows.Application.Shutdown(System.Int32)
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown(Int32)
  nameWithType: Application.Shutdown(Int32)
  fullName: System.Windows.Application.Shutdown(Int32)
- uid: System.Windows.Application.ShutdownMode
  parent: System.Windows.Application
  isExternal: false
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
  fullName: System.Windows.Application.ShutdownMode
- uid: System.Windows.ShutdownMode
  parent: System.Windows
  isExternal: false
  name: ShutdownMode
  nameWithType: ShutdownMode
  fullName: System.Windows.ShutdownMode
- uid: System.Windows.Application.Startup
  parent: System.Windows.Application
  isExternal: false
  name: Startup
  nameWithType: Application.Startup
  fullName: System.Windows.Application.Startup
- uid: System.Windows.StartupEventHandler
  parent: System.Windows
  isExternal: false
  name: StartupEventHandler
  nameWithType: StartupEventHandler
  fullName: System.Windows.StartupEventHandler
- uid: System.Windows.Application.StartupUri
  parent: System.Windows.Application
  isExternal: false
  name: StartupUri
  nameWithType: Application.StartupUri
  fullName: System.Windows.Application.StartupUri
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.Application
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Application.TryFindResource(System.Object)
  parent: System.Windows.Application
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: Application.TryFindResource(Object)
  fullName: System.Windows.Application.TryFindResource(Object)
- uid: System.Windows.Application.Windows
  parent: System.Windows.Application
  isExternal: false
  name: Windows
  nameWithType: Application.Windows
  fullName: System.Windows.Application.Windows
- uid: System.Windows.WindowCollection
  parent: System.Windows
  isExternal: false
  name: WindowCollection
  nameWithType: WindowCollection
  fullName: System.Windows.WindowCollection
- uid: System.Windows.Application.#ctor*
  parent: System.Windows.Application
  isExternal: false
  name: Application
  nameWithType: Application.Application
- uid: System.Windows.Application.Current*
  parent: System.Windows.Application
  isExternal: false
  name: Current
  nameWithType: Application.Current
- uid: System.Windows.Application.FindResource*
  parent: System.Windows.Application
  isExternal: false
  name: FindResource
  nameWithType: Application.FindResource
- uid: System.Windows.Application.GetContentStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetContentStream
  nameWithType: Application.GetContentStream
- uid: System.Windows.Application.GetCookie*
  parent: System.Windows.Application
  isExternal: false
  name: GetCookie
  nameWithType: Application.GetCookie
- uid: System.Windows.Application.GetRemoteStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetRemoteStream
  nameWithType: Application.GetRemoteStream
- uid: System.Windows.Application.GetResourceStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetResourceStream
  nameWithType: Application.GetResourceStream
- uid: System.Windows.Application.LoadComponent*
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent
  nameWithType: Application.LoadComponent
- uid: System.Windows.Application.MainWindow*
  parent: System.Windows.Application
  isExternal: false
  name: MainWindow
  nameWithType: Application.MainWindow
- uid: System.Windows.Application.OnActivated*
  parent: System.Windows.Application
  isExternal: false
  name: OnActivated
  nameWithType: Application.OnActivated
- uid: System.Windows.Application.OnDeactivated*
  parent: System.Windows.Application
  isExternal: false
  name: OnDeactivated
  nameWithType: Application.OnDeactivated
- uid: System.Windows.Application.OnExit*
  parent: System.Windows.Application
  isExternal: false
  name: OnExit
  nameWithType: Application.OnExit
- uid: System.Windows.Application.OnFragmentNavigation*
  parent: System.Windows.Application
  isExternal: false
  name: OnFragmentNavigation
  nameWithType: Application.OnFragmentNavigation
- uid: System.Windows.Application.OnLoadCompleted*
  parent: System.Windows.Application
  isExternal: false
  name: OnLoadCompleted
  nameWithType: Application.OnLoadCompleted
- uid: System.Windows.Application.OnNavigated*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigated
  nameWithType: Application.OnNavigated
- uid: System.Windows.Application.OnNavigating*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigating
  nameWithType: Application.OnNavigating
- uid: System.Windows.Application.OnNavigationFailed*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationFailed
  nameWithType: Application.OnNavigationFailed
- uid: System.Windows.Application.OnNavigationProgress*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationProgress
  nameWithType: Application.OnNavigationProgress
- uid: System.Windows.Application.OnNavigationStopped*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationStopped
  nameWithType: Application.OnNavigationStopped
- uid: System.Windows.Application.OnSessionEnding*
  parent: System.Windows.Application
  isExternal: false
  name: OnSessionEnding
  nameWithType: Application.OnSessionEnding
- uid: System.Windows.Application.OnStartup*
  parent: System.Windows.Application
  isExternal: false
  name: OnStartup
  nameWithType: Application.OnStartup
- uid: System.Windows.Application.Properties*
  parent: System.Windows.Application
  isExternal: false
  name: Properties
  nameWithType: Application.Properties
- uid: System.Windows.Application.ResourceAssembly*
  parent: System.Windows.Application
  isExternal: false
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
- uid: System.Windows.Application.Resources*
  parent: System.Windows.Application
  isExternal: false
  name: Resources
  nameWithType: Application.Resources
- uid: System.Windows.Application.Run*
  parent: System.Windows.Application
  isExternal: false
  name: Run
  nameWithType: Application.Run
- uid: System.Windows.Application.SetCookie*
  parent: System.Windows.Application
  isExternal: false
  name: SetCookie
  nameWithType: Application.SetCookie
- uid: System.Windows.Application.Shutdown*
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown
  nameWithType: Application.Shutdown
- uid: System.Windows.Application.ShutdownMode*
  parent: System.Windows.Application
  isExternal: false
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
- uid: System.Windows.Application.StartupUri*
  parent: System.Windows.Application
  isExternal: false
  name: StartupUri
  nameWithType: Application.StartupUri
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.Application
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.Application.TryFindResource*
  parent: System.Windows.Application
  isExternal: false
  name: TryFindResource
  nameWithType: Application.TryFindResource
- uid: System.Windows.Application.Windows*
  parent: System.Windows.Application
  isExternal: false
  name: Windows
  nameWithType: Application.Windows
