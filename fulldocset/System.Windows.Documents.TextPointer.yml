### YamlMime:ManagedReference
items:
- uid: System.Windows.Documents.TextPointer
  id: TextPointer
  children:
  - System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)
  - System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)
  - System.Windows.Documents.TextPointer.DocumentEnd
  - System.Windows.Documents.TextPointer.DocumentStart
  - System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)
  - System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)
  - System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)
  - System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)
  - System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)
  - System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.HasValidLayout
  - System.Windows.Documents.TextPointer.InsertLineBreak
  - System.Windows.Documents.TextPointer.InsertParagraphBreak
  - System.Windows.Documents.TextPointer.InsertTextInRun(System.String)
  - System.Windows.Documents.TextPointer.IsAtInsertionPosition
  - System.Windows.Documents.TextPointer.IsAtLineStartPosition
  - System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)
  - System.Windows.Documents.TextPointer.LogicalDirection
  - System.Windows.Documents.TextPointer.Paragraph
  - System.Windows.Documents.TextPointer.Parent
  - System.Windows.Documents.TextPointer.ToString
  langs:
  - csharp
  name: TextPointer
  nameWithType: TextPointer
  fullName: System.Windows.Documents.TextPointer
  type: Class
  summary: "Представляет позицию в <xref href=&quot;System.Windows.Documents.FlowDocument&quot;> </xref> или <xref href=&quot;System.Windows.Controls.TextBlock&quot;> </xref>."
  remarks: "Класс TextPointer представляет следующая терминология: - Поместите -. по своей природе, TextPointer всегда указывает на *позиции* в содержимом.  Подобные положения находятся либо между символами в содержимом или потока содержимого тегами элемента, определение структуры для содержимого.      -Текущее положение — поскольку TextPointer всегда указывает на позицию, а поскольку многие операции, которые могут быть выполнены с помощью TextPointer, относительно положения, в настоящее время, на который указывает TextPointer, смысл просто найти позиции, указываемой параметром TextPointer как *текущей позиции*.      -Позиция вставки - *позицию вставки* — положение, где может быть добавлено новое содержимое без нарушения любой семантических правил для соответствующего содержимого.  На практике положение вставки в любом месте — в содержимом положение курсора.  Примером является допустимой позицией TextPointer, не положение вставки — это позиция между две смежные <xref:System.Windows.Documents.Paragraph>теги (то есть, между закрывающего тега элемента выше и открывающий тег следующего абзаца).</xref:System.Windows.Documents.Paragraph>      -Символ — в целях TextPointer операции, включающие символы, следующие считается *символ*: - открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement>элемента.</xref:System.Windows.Documents.TextElement>          - <xref:System.Windows.UIElement>Элемент, содержащийся в <xref:System.Windows.Documents.InlineUIContainer>или <xref:System.Windows.Documents.BlockUIContainer>.</xref:System.Windows.Documents.BlockUIContainer> </xref:System.Windows.Documents.InlineUIContainer> </xref:System.Windows.UIElement>  Примечание такое <xref:System.Windows.UIElement>всегда считается ровно один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement>, не рассматриваются как символы.</xref:System.Windows.UIElement> </xref:System.Windows.UIElement>          -Каждое 16-разрядное [!INCLUDE[TLA#tla_unicode](~/add/includes/ajax-current-ext-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run>элемент.</xref:System.Windows.Documents.Run>      -Текстовый контейнер - A *контейнера текста* элемент, который образует конечную границу для имеющегося содержимого потока; в позиции, указанной TextPointer всегда находится в текстовом контейнере.  В настоящее время текстовый контейнер должен быть либо <xref:System.Windows.Documents.FlowDocument>или <xref:System.Windows.Controls.TextBlock>.</xref:System.Windows.Controls.TextBlock> </xref:System.Windows.Documents.FlowDocument>  Вообще говоря операции с экземплярами TextPointer в другой текстовой контейнеры не поддерживаются.      -Документа - содержимое в текстовом контейнере, называют *документа*, как в <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A>метод и <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>и <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>Свойства.</xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> </xref:System.Windows.Documents.TextPointer.DocumentStart%2A> </xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A>       Класс TextPointer предназначен для упрощения обхода и обработки содержимого, представленного [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] элементы потока содержимого; как правило, такие элементы, производные от <xref:System.Windows.Documents.TextElement>.</xref:System.Windows.Documents.TextElement>  Некоторые операции, которые TextPointer облегчает включают следующее:-выполняют порядковое сравнение текущего положения со вторым заданным положением.  В разделе <xref:System.Windows.Documents.TextPointer.CompareTo%2A>метод.</xref:System.Windows.Documents.TextPointer.CompareTo%2A>      -Определите тип содержимого, рядом с текущей позиции в указанном направлении.  В разделе <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A>метод и <xref:System.Windows.Documents.TextPointerContext>перечисления.</xref:System.Windows.Documents.TextPointerContext> </xref:System.Windows.Documents.TextPointer.GetPointerContext%2A>      -Get <xref:System.Windows.Documents.TextElement>, областей или рядом с текущей позиции.</xref:System.Windows.Documents.TextElement>  В разделе <xref:System.Windows.Documents.Paragraph>и <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A>метод.</xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> </xref:System.Windows.Documents.Paragraph>      -Получение контейнера текста, определяющего область текущего документа.  В разделе <xref:System.Windows.Documents.TextPointer.Parent%2A>свойство.</xref:System.Windows.Documents.TextPointer.Parent%2A>      -Получение указанное число символов, перед или после текущего положения.  В разделе <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A>метод.</xref:System.Windows.Documents.TextPointer.GetTextInRun%2A>      -Вставьте строку символов в текущей позиции.  В разделе <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A>метод.</xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A>      — Поиск границ строки в содержимом.  В разделе <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A>метод и <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A>свойство.</xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> </xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A>      -Преобразование между TextPointer позиций и смещения символ в содержимое.  В разделе <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A>и <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>методы.</xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> </xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A>      -Проверка visual нажатия путем преобразования между позиции TextPointer и <xref:System.Windows.Point>представляющий относительных координат.</xref:System.Windows.Point>      — Поиск ближайшего положения вставки или проверить, является ли текущая позиция вставки.  В разделе <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A>и <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>методов и <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A>свойство.</xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> </xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> </xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A>       Положение и <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A>обозначается объект TextPointer являются неизменяемыми.</xref:System.Windows.Documents.TextPointer.LogicalDirection%2A>  Если изменить содержимое или изменении позиции, указываемой параметром TextPointer не изменяется относительно окружающего текста; Вместо этого смещение, с самого начала содержимого соответствующим образом корректируется для отражения новое относительное положение в содержимом.  Например TextPointer, который указывает на позицию в начале данного абзаца продолжает указывать на начало данного абзаца, даже в том случае, когда содержимое является вставляются или удаляются до или после абзаца.       Класс TextPointer не предоставляет каких-либо открытых конструкторов.  Экземпляр TextPointer создается с помощью свойств или методов других объектов (включая другие объекты TextPointer). Ниже приведены некоторые примеры методов и свойств, создания и возврата TextPointer.  Этот список не является исчерпывающим: — <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A>до <xref:System.Windows.Documents.TextRange.End%2A>.</xref:System.Windows.Documents.TextRange.End%2A> </xref:System.Windows.Documents.TextRange.Start%2A> </xref:System.Windows.Documents.TextRange>      -   From a <xref:System.Windows.Documents.TextElement>:  <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, and <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.</xref:System.Windows.Documents.TextElement.ElementEnd%2A></xref:System.Windows.Documents.TextElement.ElementStart%2A></xref:System.Windows.Documents.TextElement.ContentEnd%2A></xref:System.Windows.Documents.TextElement.ContentStart%2A></xref:System.Windows.Documents.TextElement>      -Из <xref:System.Windows.Controls.TextBlock>(контейнера текста): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>и <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>.</xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A> </xref:System.Windows.Controls.TextBlock.ContentEnd%2A> </xref:System.Windows.Controls.TextBlock.ContentStart%2A> </xref:System.Windows.Controls.TextBlock>      -Из <xref:System.Windows.Documents.FlowDocument>(контейнера текста): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, и <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>— из существующих TextPointer: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>и <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>.</xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> </xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> </xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> </xref:System.Windows.Documents.TextPointer.DocumentStart%2A> </xref:System.Windows.Documents.FlowDocument.ContentEnd%2A> </xref:System.Windows.Documents.FlowDocument.ContentStart%2A> </xref:System.Windows.Documents.FlowDocument>"
  example:
  - "The following example demonstrates how to use a TextPointer to find a position just inside of the first <xref:System.Windows.Documents.Run> element in a specified text container.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_TextPointer1](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_textpointer1)]\n [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_textpointer1)]  \n  \n The following example implements a simplistic find algorithm using TextPointer facilities.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_TextPointer2](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_textpointer2)]\n [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_textpointer2)]"
  syntax:
    content: 'public class TextPointer : System.Windows.Documents.ContentPosition'
  inheritance:
  - System.Object
  - System.Windows.Documents.ContentPosition
  implements: []
  inheritedMembers:
  - System.Windows.Documents.ContentPosition.Missing
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)
  id: CompareTo(System.Windows.Documents.TextPointer)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: CompareTo(TextPointer)
  nameWithType: TextPointer.CompareTo(TextPointer)
  fullName: System.Windows.Documents.TextPointer.CompareTo(TextPointer)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Выполняет порядковое сравнение между позициями, заданному текущим <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> с указанием секунды <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>."
  remarks: "Значение –&1; указывает, что должность, указанную в текущем <xref:System.Windows.Documents.TextPointer>предшествует позиции, указанной параметром `position`.</xref:System.Windows.Documents.TextPointer>  Значение 0 указывает, что указанные положения равны.  Значение положительное +&1; указывает на должность, указанную в текущем <xref:System.Windows.Documents.TextPointer>соответствует позиции, указанной параметром `position`.</xref:System.Windows.Documents.TextPointer>"
  example:
  - "The following example demonstrates a use for this method.  In the example, the CompareTo method is used in conjunction with the <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> method to test whether a specified <xref:System.Windows.Documents.TextElement> is empty.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_getinsertionposition)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_getinsertionposition)]"
  syntax:
    content: public int CompareTo (System.Windows.Documents.TextPointer position);
    parameters:
    - id: position
      type: System.Windows.Documents.TextPointer
      description: "Объект <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> , указывающий позицию для сравнения с текущей позиции."
    return:
      type: System.Int32
      description: "– 1, если текущий <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> предшествует <code> position </code>; 0 Если расположения совпадают; Если + 1 текущего <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> соответствует <code> position </code>."
  overload: System.Windows.Documents.TextPointer.CompareTo*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>position</code>Указывает позицию вне контейнера текста, связанного с текущей позиции."
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)
  id: DeleteTextInRun(System.Int32)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: DeleteTextInRun(Int32)
  nameWithType: TextPointer.DeleteTextInRun(Int32)
  fullName: System.Windows.Documents.TextPointer.DeleteTextInRun(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Удаляет указанное количество символов из позиции, указываемой текущим <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>."
  remarks: "Укажите положительное значение, чтобы удалить символы, соответствующие текущей позиции (как в <xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName>); укажите отрицательное значение, чтобы удалить символы, предшествующие текущему положению (как в <xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName>).</xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName> </xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName>       Число фактически удаленных символов может быть меньше, чем число, заданное `count`.  Это происходит в случаях, где `count` указывает больше символов, чем существует для удаления."
  syntax:
    content: public int DeleteTextInRun (int count);
    parameters:
    - id: count
      type: System.Int32
      description: "Число удаляемых символов, начиная с текущей позиции. Укажите положительное значение, чтобы удалить символы, следующие за текущим положением; Укажите отрицательное значение, чтобы удалить символы, предшествующие текущей позиции."
    return:
      type: System.Int32
      description: "Число фактически удаленных символов."
  overload: System.Windows.Documents.TextPointer.DeleteTextInRun*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Метод вызывается в позиции, где текст не допускается."
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.DocumentEnd
  id: DocumentEnd
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: DocumentEnd
  nameWithType: TextPointer.DocumentEnd
  fullName: System.Windows.Documents.TextPointer.DocumentEnd
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> в конце содержимого в текстовом контейнере, связанный с текущей позиции."
  remarks: "<xref:System.Windows.Documents.TextPointer.Parent%2A>Для возвращенного <xref:System.Windows.Documents.TextPointer>всегда представляет собой контейнер текста (<xref:System.Windows.Controls.TextBlock> или <xref:System.Windows.Documents.FlowDocument>), а не <xref:System.Windows.Documents.TextElement>.</xref:System.Windows.Documents.TextElement> </xref:System.Windows.Documents.FlowDocument> </xref:System.Windows.Controls.TextBlock> </xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointer.Parent%2A>"
  syntax:
    content: public System.Windows.Documents.TextPointer DocumentEnd { get; }
    return:
      type: System.Windows.Documents.TextPointer
      description: "Объект <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> в конце содержимого в текстовом контейнере, связанный с текущей позиции."
  overload: System.Windows.Documents.TextPointer.DocumentEnd*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.DocumentStart
  id: DocumentStart
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: DocumentStart
  nameWithType: TextPointer.DocumentStart
  fullName: System.Windows.Documents.TextPointer.DocumentStart
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> в начале содержимого в текстовом контейнере, связанный с текущей позиции."
  remarks: "Используйте положения, возвращаемого этим свойством, в качестве базового положения, из которого необходимо применить смещения в другое место.  <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A>И <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>методы предоставляют способ преобразования между положениями и позиции смещения.</xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> </xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A>       <xref:System.Windows.Documents.TextPointer.Parent%2A>Для возвращенного <xref:System.Windows.Documents.TextPointer>всегда представляет собой контейнер текста (<xref:System.Windows.Controls.TextBlock> или <xref:System.Windows.Documents.FlowDocument>), а не <xref:System.Windows.Documents.TextElement>.</xref:System.Windows.Documents.TextElement> </xref:System.Windows.Documents.FlowDocument> </xref:System.Windows.Controls.TextBlock> </xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointer.Parent%2A>"
  syntax:
    content: public System.Windows.Documents.TextPointer DocumentStart { get; }
    return:
      type: System.Windows.Documents.TextPointer
      description: "Объект <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> в начале содержимого в текстовом контейнере, связанный с текущей позиции."
  overload: System.Windows.Documents.TextPointer.DocumentStart*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)
  id: GetAdjacentElement(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetAdjacentElement(LogicalDirection)
  nameWithType: TextPointer.GetAdjacentElement(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetAdjacentElement(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает элемент, если таковые имеются, границы текущего <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> в указанном логическом направлении."
  remarks: "Как правило, возвращаемый элемент является <xref:System.Windows.Documents.TextElement>.</xref:System.Windows.Documents.TextElement>  Объект <xref:System.Windows.UIElement>могут быть возвращены при <xref:System.Windows.Documents.TextPointer>указывает на позицию внутри <xref:System.Windows.Documents.BlockUIContainer>элемент или <xref:System.Windows.Documents.InlineUIContainer>элемент.</xref:System.Windows.Documents.InlineUIContainer> </xref:System.Windows.Documents.BlockUIContainer> </xref:System.Windows.Documents.TextPointer> </xref:System.Windows.UIElement>"
  syntax:
    content: public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "Один из <xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref> значений, указывающее логическое направление, в которых нужно искать соседними элементами."
    return:
      type: System.Windows.DependencyObject
      description: "Смежные элемента в указанном <code> direction </code>, или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если соседних элемента не существует."
  overload: System.Windows.Documents.TextPointer.GetAdjacentElement*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)
  id: GetCharacterRect(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetCharacterRect(LogicalDirection)
  nameWithType: TextPointer.GetCharacterRect(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetCharacterRect(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает ограничивающий прямоугольник (<xref href=&quot;System.Windows.Rect&quot;></xref>) для содержимого, границ текущего <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> в указанном логическом направлении."
  remarks: "<xref:System.Windows.Documents.TextElement>границы не учитываются содержимого в целях этого метода.</xref:System.Windows.Documents.TextElement>  Если <xref:System.Windows.Documents.TextPointer>располагается перед <xref:System.Windows.Documents.TextElement>границей, возвращаемое значение является ограничивающего прямоугольника для следующей отличных<xref:System.Windows.Documents.TextElement> содержимого в указанном направлении.</xref:System.Windows.Documents.TextElement> </xref:System.Windows.Documents.TextElement> </xref:System.Windows.Documents.TextPointer>  Если в указанном направлении нулевой ширины не имеет содержимого <xref:System.Windows.Rect>возвращается с высотой, совпадающей с высотой все предшествующие содержимого.</xref:System.Windows.Rect>       Операцию, выполняемую с помощью данного метода зависит от допустимого макета.  При необходимости этот метод пытается автоматически восстановить допустимый макет перед продолжением операции.  Повторное создание макета может быть довольно дорогой операции.  Используйте <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A>свойство для проверки допустимого макета перед выполнением операций, которые могут заново создать макет.</xref:System.Windows.Documents.TextPointer.HasValidLayout%2A>  Дополнительные сведения см. в разделе [макета](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "Один из <xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref> значений, указывающее логическое направление, в котором для поиска содержимого, ограничивающего прямоугольника."
    return:
      type: System.Windows.Rect
      description: "Ограничивающий прямоугольник для содержимого, границ текущего <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> в указанном направлении или &lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt; Если текущая позиция, сведения о макете допустимым недоступен."
  overload: System.Windows.Documents.TextPointer.GetCharacterRect*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)
  id: GetInsertionPosition(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetInsertionPosition(LogicalDirection)
  nameWithType: TextPointer.GetInsertionPosition(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetInsertionPosition(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> ближайший позицию вставки в указанное логическое направление."
  remarks: "Положение вставки — положение, где может быть добавлено новое содержимое без нарушения любой семантических правил для соответствующего содержимого.  На практике положение вставки в любом месте — в содержимом положение курсора.  Примером является допустимым <xref:System.Windows.Documents.TextPointer>, не положение вставки — положение между двумя смежные <xref:System.Windows.Documents.Paragraph>теги (т. е между закрывающего тега элемента выше и открывающий тег следующего абзаца).</xref:System.Windows.Documents.Paragraph> </xref:System.Windows.Documents.TextPointer>       Если <xref:System.Windows.Documents.TextPointer>уже указывает на допустимое положение вставки, однако закрывающий тег для непустой последовательности форматирования непосредственно следует за эту должность в заданном направлении, то <xref:System.Windows.Documents.TextPointer>возвращает этот метод корректируется для определения положения вставки сразу после закрытия последовательности форматирования.</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointer>    Например, рассмотрим последовательность разметки `<Bold>``a``</Bold>``b`.  Обратите внимание, что два положения вставки между буквами `a` и `b`— одна, которая предшествует закрывающий `Bold` тег и один непосредственно после закрывающего `Bold` тег.  GetInsertionPosition при вызове на <xref:System.Windows.Documents.TextPointer>на позицию сразу после буквы `a` и до закрытия `Bold` тега и с `direction` из <xref:System.Windows.Documents.LogicalDirection>, возвращенный <xref:System.Windows.Documents.TextPointer>корректируется на позицию непосредственно перед буквой `b`, после закрывающего `Bold` тег.</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.LogicalDirection> </xref:System.Windows.Documents.TextPointer>  Аналогичные корректировки выполняются для открывающих тегов форматирования при работе в обратном направлении логических.  Этот метод предназначен для предоставления средств устранения неоднозначности между позициями вставки в подобных случаев.       Этот метод можно использовать также для избирательно точек вставки, если участвует последовательность структурных тегов. Например, если на положение между закрытия и открытия тегов абзаца, направление параметра может использоваться выберите ближайший курсор в начало следующего абзаца (путем указания <xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName>) или в конце выше (путем указания <xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName>).</xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName> </xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName>       Если курсор уже находится в позиции курсора, и нет смежные форматирования тегов в указанном `direction`, возвращаемое <xref:System.Windows.Documents.TextPointer>ссылается на той же позиции, что и вызов метода <xref:System.Windows.Documents.TextPointer>.</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointer>       Возможно, нет допустимое положение вставки существует относительно позиции, на который указывает <xref:System.Windows.Documents.TextPointer>.</xref:System.Windows.Documents.TextPointer>  Это может произойти, если ссылочное содержимое является структурно незавершенным, как пустой таблицы или списка.  В таком случае этот метод возвращает <xref:System.Windows.Documents.TextPointer>в той же позиции, что <xref:System.Windows.Documents.TextPointer>из которого этот метод был вызван.</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointer>  Этот метод всегда возвращает допустимый <xref:System.Windows.Documents.TextPointer>.</xref:System.Windows.Documents.TextPointer>"
  example:
  - "This example shows how to use the GetInsertionPosition method to check whether a specified <xref:System.Windows.Documents.TextElement> is empty of printable content.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_getinsertionposition)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_getinsertionposition)]"
  syntax:
    content: public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "Один из <xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref> значений, указывающее логическое направление, в которых нужно искать ближайший позицию вставки."
    return:
      type: System.Windows.Documents.TextPointer
      description: "Объект <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> ближайший позицию вставки в указанном направлении."
  overload: System.Windows.Documents.TextPointer.GetInsertionPosition*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)
  id: GetLineStartPosition(System.Int32)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetLineStartPosition(Int32)
  nameWithType: TextPointer.GetLineStartPosition(Int32)
  fullName: System.Windows.Documents.TextPointer.GetLineStartPosition(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> в начало строки, в которой указан относительно текущего <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>."
  remarks: "Если <xref:System.Windows.Documents.TextPointer>указывает неоднозначную позицию, например, между двумя строками строки в направлении, указанным <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A>выбран в качестве относительного начальную строку.</xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> </xref:System.Windows.Documents.TextPointer>       Операцию, выполняемую с помощью данного метода зависит от допустимого макета.  При необходимости этот метод пытается автоматически восстановить допустимый макет перед продолжением операции.  Повторное создание макета может быть довольно дорогой операции.  Используйте <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A>для проверки допустимого макета перед выполнением операций, которые могут заново создать макет.</xref:System.Windows.Documents.TextPointer.HasValidLayout%2A>  Дополнительные сведения см. в разделе [макета](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.Documents.TextPointer GetLineStartPosition (int count);
    parameters:
    - id: count
      type: System.Int32
      description: "Число маркеров начала строки нужно пропустить при определении строки, для которой возвращается начальное положение. Отрицательные значения указывают предшествующие строки, 0 задает текущую строку и положительные значения задают следующие строки."
    return:
      type: System.Windows.Documents.TextPointer
      description: "Объект <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> указывает на начало указанной строки (с <xref:System.Windows.Documents.TextPointer.LogicalDirection*>значение <xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref>), или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если указанная строка находится за пределами диапазона или в противном случае не удается найти.</xref:System.Windows.Documents.TextPointer.LogicalDirection*>"
  overload: System.Windows.Documents.TextPointer.GetLineStartPosition*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)
  id: GetLineStartPosition(System.Int32,System.Int32@)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetLineStartPosition(Int32,Int32)
  nameWithType: TextPointer.GetLineStartPosition(Int32,Int32)
  fullName: System.Windows.Documents.TextPointer.GetLineStartPosition(Int32,Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> в начало строки, в которой указан относительно текущего <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>и сообщает о том, сколько строк были пропущены."
  remarks: "Если <xref:System.Windows.Documents.TextPointer>указывает неоднозначную позицию, например, между двумя строками строки в направлении, указанным <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A>выбрано свойство как относительный начальную строку.</xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> </xref:System.Windows.Documents.TextPointer>"
  syntax:
    content: public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);
    parameters:
    - id: count
      type: System.Int32
      description: "Число маркеров начала строки нужно пропустить при определении строки, для которой возвращается начальное положение. Отрицательные значения указывают предшествующие строки, 0 задает текущую строку и положительные значения задают следующие строки."
    - id: actualCount
      type: System.Int32
      description: "При возврате из этого метода содержит фактическое число маркеров начала строки, которые были пропущены при определении строки, для которой возвращается начальное положение.  Это значение может быть меньше, чем `count` Если начало или конец содержимого обнаружен до, пропуская указанное число строк. Этот параметр передается неинициализированным."
    return:
      type: System.Windows.Documents.TextPointer
      description: "Объект <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> указывает на начало указанной строки (с <xref:System.Windows.Documents.TextPointer.LogicalDirection*>значение <xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref>), или до начала строки, ближайшей к заданной строке, если указанная строка выходит за пределы диапазона.</xref:System.Windows.Documents.TextPointer.LogicalDirection*>"
  overload: System.Windows.Documents.TextPointer.GetLineStartPosition*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)
  id: GetNextContextPosition(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetNextContextPosition(LogicalDirection)
  nameWithType: TextPointer.GetNextContextPosition(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetNextContextPosition(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает указатель на следующий символ в указанном логическом направлении."
  remarks: "Одно из следующих рассматривается как символ: - открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement>элемента.</xref:System.Windows.Documents.TextElement>      - <xref:System.Windows.UIElement>Элемент, содержащийся в <xref:System.Windows.Documents.InlineUIContainer>или <xref:System.Windows.Documents.BlockUIContainer>.</xref:System.Windows.Documents.BlockUIContainer> </xref:System.Windows.Documents.InlineUIContainer> </xref:System.Windows.UIElement>  Примечание такое <xref:System.Windows.UIElement>всегда считается ровно один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement>, не рассматриваются как символы.</xref:System.Windows.UIElement> </xref:System.Windows.UIElement>      -Это 16-разрядная [!INCLUDE[TLA#tla_unicode](~/add/includes/ajax-current-ext-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run>элемент.</xref:System.Windows.Documents.Run>       Если следующий символ отнесен <xref:System.Windows.Documents.TextPointerContext>, <xref:System.Windows.Documents.TextPointerContext>, или <xref:System.Windows.Documents.TextPointerContext>(с <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A>метод), то <xref:System.Windows.Documents.TextPointer>возвращает этот метод перемещается вперед ровно один символ из текущей позиции.</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> </xref:System.Windows.Documents.TextPointerContext> </xref:System.Windows.Documents.TextPointerContext> </xref:System.Windows.Documents.TextPointerContext>       Если следующий символ к категории <xref:System.Windows.Documents.TextPointerContext>, то <xref:System.Windows.Documents.TextPointer>возвращает этот метод продвигается за текст к следующему символу нетекстовых (то есть следующей позиции <xref:System.Windows.Documents.TextPointerContext>не <xref:System.Windows.Documents.TextPointerContext>).</xref:System.Windows.Documents.TextPointerContext> </xref:System.Windows.Documents.TextPointerContext> </xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointerContext>  Символ точное число пересекаемых можно вычислить заранее путем вызова <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A>метод.</xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A>"
  example:
  - "The following example demonstrates a use for this method.  The example uses the GetNextContextPosition method in conjunction with the <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> method to traverse and extract the symbols in a specified <xref:System.Windows.Documents.TextElement>.  \n  \n While the example can be used to extract a [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] structure for the contents of a given <xref:System.Windows.Documents.TextElement>, it is intended for illustrative purposes only, and should not be used in production code.  See the <xref:System.Xml> namespace for a rich set of types designed for working with and processing XML.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_getnextcontextposition)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_getnextcontextposition)]"
  syntax:
    content: public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "Один из <xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref> значений, указывающее логическое направление, в которых необходимо искать следующий символ."
    return:
      type: System.Windows.Documents.TextPointer
      description: "Объект <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> к следующему символу в запрошенное направление или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> если текущего <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> границы начало или конец содержимого."
  overload: System.Windows.Documents.TextPointer.GetNextContextPosition*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)
  id: GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetNextInsertionPosition(LogicalDirection)
  nameWithType: TextPointer.GetNextInsertionPosition(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetNextInsertionPosition(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> следующую позицию вставки в указанном логическом направлении."
  remarks: "*Позицию вставки* — положение, где может быть добавлено новое содержимое без нарушения любой семантических правил для соответствующего содержимого.  На практике положение вставки в любом месте — в содержимом положение курсора.  Примером является допустимым <xref:System.Windows.Documents.TextPointer>, не положение вставки — положение между двумя смежные <xref:System.Windows.Documents.Paragraph>теги (т. е между закрывающего тега элемента выше и открывающий тег следующего абзаца).</xref:System.Windows.Documents.Paragraph> </xref:System.Windows.Documents.TextPointer>"
  example:
  - "The following example demonstrates a use for this method. The example uses the GetNextInsertionPosition method to traverse content element boundaries in order to count the number of <xref:System.Windows.Documents.Paragraph> elements present between two specified <xref:System.Windows.Documents.TextPointer> instances.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_getnextinsertionposition)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_getnextinsertionposition)]"
  syntax:
    content: public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "Один из <xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref> значений, указывающее логическое направление, в которой нужно выполнить поиск следующей позиции вставки."
    return:
      type: System.Windows.Documents.TextPointer
      description: "Объект <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> , определяющее запрошенное направление, в следующую позицию вставки или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если могут находиться не далее позицию вставки."
  overload: System.Windows.Documents.TextPointer.GetNextInsertionPosition*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)
  id: GetOffsetToPosition(System.Windows.Documents.TextPointer)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetOffsetToPosition(TextPointer)
  nameWithType: TextPointer.GetOffsetToPosition(TextPointer)
  fullName: System.Windows.Documents.TextPointer.GetOffsetToPosition(TextPointer)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает число символов в диапазоне от текущего <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> с указанием секунды <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>."
  remarks: "Одно из следующих рассматривается как символ: - открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement>элемента.</xref:System.Windows.Documents.TextElement>      - <xref:System.Windows.UIElement>Элемент, содержащийся в <xref:System.Windows.Documents.InlineUIContainer>или <xref:System.Windows.Documents.BlockUIContainer>.</xref:System.Windows.Documents.BlockUIContainer> </xref:System.Windows.Documents.InlineUIContainer> </xref:System.Windows.UIElement>  Примечание такое <xref:System.Windows.UIElement>всегда считается ровно один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement>, не рассматриваются как символы.</xref:System.Windows.UIElement> </xref:System.Windows.UIElement>      -Это 16-разрядная [!INCLUDE[TLA#tla_unicode](~/add/includes/ajax-current-ext-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run>элемент.</xref:System.Windows.Documents.Run>"
  example:
  - "The following example demonstrates a use for this method. The example uses the GetOffsetToPosition method to find the offsets for two <xref:System.Windows.Documents.TextPointer> instances, and then uses this information to save and restore the selection in a <xref:System.Windows.Controls.RichTextBox>.  The example assumes that the contents of the <xref:System.Windows.Controls.RichTextBox> have not changed between a selection save and a selection restore.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_getoffsettoposition)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_getoffsettoposition)]"
  syntax:
    content: public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);
    parameters:
    - id: position
      type: System.Windows.Documents.TextPointer
      description: "Объект <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> , указывающий позицию для поиска расстояние (в символах)."
    return:
      type: System.Int32
      description: "Относительное количество символов между текущим <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> и <code> position </code>.  Отрицательное значение указывает, что текущий <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> соответствует позиции, указанной параметром <code> position </code>, 0 означает, что должностей равны, и положительное значение указывает, что текущий <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> предшествует позиции, указанной параметром <code> position </code>."
  overload: System.Windows.Documents.TextPointer.GetOffsetToPosition*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>position</code>Указывает позицию вне контейнера текста, связанного с текущей позиции."
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)
  id: GetPointerContext(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetPointerContext(LogicalDirection)
  nameWithType: TextPointer.GetPointerContext(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetPointerContext(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает индикатор категории для содержимого, рядом с текущим <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> в указанном логическом направлении."
  remarks: ''
  example:
  - "The following example demonstrates a use for this method. The example uses the GetPointerContext method to implement an algorithm for calculating the balance of opening and closing element tags between two specified <xref:System.Windows.Documents.TextPointer> positions.  Each opening element tag is counted as +1, and each closing element tag is counted as –1.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_getoffsettoposition2)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_getoffsettoposition2)]"
  syntax:
    content: public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "Один из <xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref> значений, указывающее логическое направление, в котором для определения категории для смежных содержимого."
    return:
      type: System.Windows.Documents.TextPointerContext
      description: "Один из <xref href=&quot;System.Windows.Documents.TextPointerContext&quot;> </xref> значений, указывающее категория смежные содержимое в указанном направлении логических."
  overload: System.Windows.Documents.TextPointer.GetPointerContext*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)
  id: GetPositionAtOffset(System.Int32)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetPositionAtOffset(Int32)
  nameWithType: TextPointer.GetPositionAtOffset(Int32)
  fullName: System.Windows.Documents.TextPointer.GetPositionAtOffset(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> позиции с указанным смещением в символов с начала текущего <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>."
  remarks: "Одно из следующих рассматривается как символ: - открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement>элемента.</xref:System.Windows.Documents.TextElement>      - <xref:System.Windows.UIElement>Элемент, содержащийся в <xref:System.Windows.Documents.InlineUIContainer>или <xref:System.Windows.Documents.BlockUIContainer>.</xref:System.Windows.Documents.BlockUIContainer> </xref:System.Windows.Documents.InlineUIContainer> </xref:System.Windows.UIElement>  Примечание такое <xref:System.Windows.UIElement>всегда считается ровно один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement>, не рассматриваются как символы.</xref:System.Windows.UIElement> </xref:System.Windows.UIElement>      -Это 16-разрядная [!INCLUDE[TLA#tla_unicode](~/add/includes/ajax-current-ext-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run>элемент.</xref:System.Windows.Documents.Run>"
  example:
  - "The following example demonstrates a use for this method. The example uses the GetPositionAtOffset method to implement a pair of methods, one to calculate the offset to a specified position relative to any hosting paragraph, and the other to return a <xref:System.Windows.Documents.TextPointer> to a specified offset in a specified paragraph.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_getpositionatoffset)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_getpositionatoffset)]"
  syntax:
    content: public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);
    parameters:
    - id: offset
      type: System.Int32
      description: "Смещение, в символы, для которого нужно вычислить и возвращал значение позиции.  Если отрицательное смещение, позиция вычисляется в логическое направление, указанный пользователем противоположного <xref:System.Windows.Documents.TextPointer.LogicalDirection*>свойство.</xref:System.Windows.Documents.TextPointer.LogicalDirection*>"
    return:
      type: System.Windows.Documents.TextPointer
      description: "Объект <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> позиции с указанным смещением, или<xref uid=&quot;langword_csharp_ null &quot; name=&quot; null &quot; href=&quot;&quot;></xref>Если нет соответствующей позиции может быть найден."
  overload: System.Windows.Documents.TextPointer.GetPositionAtOffset*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)
  id: GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetPositionAtOffset(Int32,LogicalDirection)
  nameWithType: TextPointer.GetPositionAtOffset(Int32,LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetPositionAtOffset(Int32,LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> позиции с указанным смещением в символов с начала текущего <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> и в указанном направлении."
  remarks: "Одно из следующих рассматривается как символ: - открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement>элемента.</xref:System.Windows.Documents.TextElement>      - <xref:System.Windows.UIElement>Элемент, содержащийся в <xref:System.Windows.Documents.InlineUIContainer>или <xref:System.Windows.Documents.BlockUIContainer>.</xref:System.Windows.Documents.BlockUIContainer> </xref:System.Windows.Documents.InlineUIContainer> </xref:System.Windows.UIElement>  Примечание такое <xref:System.Windows.UIElement>всегда считается ровно один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement>, не рассматриваются как символы.</xref:System.Windows.UIElement> </xref:System.Windows.UIElement>      -Это 16-разрядная [!INCLUDE[TLA#tla_unicode](~/add/includes/ajax-current-ext-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run>элемент.</xref:System.Windows.Documents.Run>"
  syntax:
    content: public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: offset
      type: System.Int32
      description: "Смещение, в символы, для которого нужно вычислить и возвращал значение позиции.  Если смещение является отрицательной, возвращаемый <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> перед текущим <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>; в противном случае следует."
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "Один из <xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref> значений, определяющее направление логический возвращаемый <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>."
    return:
      type: System.Windows.Documents.TextPointer
      description: "Объект <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> позиции с указанным смещением, или<xref uid=&quot;langword_csharp_ null &quot; name=&quot; null &quot; href=&quot;&quot;></xref>Если смещение превышает длину содержимого."
  overload: System.Windows.Documents.TextPointer.GetPositionAtOffset*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)
  id: GetTextInRun(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetTextInRun(LogicalDirection)
  nameWithType: TextPointer.GetTextInRun(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetTextInRun(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает строку, содержащую текстом, смежным с текущим <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> в указанном логическом направлении."
  remarks: "Этот метод возвращает только непрерывные текстовые выполнения.  Ничего не возвращается, если любой символ типа не <xref:System.Windows.Documents.TextPointerContext>рядом с текущим <xref:System.Windows.Documents.TextPointer>в указанном направлении.</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointerContext>  Аналогичным образом возвращается только до следующего нетекстового символа."
  example:
  - "The following example demonstrates a use for this method. The example uses the GetTextInRun method to implement a simple text extractor.  The method returns a string concatenation of all text between two specified <xref:System.Windows.Documents.TextPointer> instances.  \n  \n While the example can be used to extract any text between two <xref:System.Windows.Documents.TextPointer> instances, it is intended for illustrative purposes only, and should not be used in production code.  Use the <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=fullName> property instead.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetTextInRun](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_gettextinrun)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_gettextinrun)]"
  syntax:
    content: public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "Один из <xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref> значений, указывающее логическое направление, в котором для поиска и возврата любым смежным текстом."
    return:
      type: System.String
      description: "Строка, содержащая любым смежным текстом в указанном направлении логического или &lt;xref:System.String?displayProperty=fullName&gt; Если смежные текст не может быть найден."
  overload: System.Windows.Documents.TextPointer.GetTextInRun*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)
  id: GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetTextInRun(LogicalDirection,Char[],Int32,Int32)
  nameWithType: TextPointer.GetTextInRun(LogicalDirection,Char[],Int32,Int32)
  fullName: System.Windows.Documents.TextPointer.GetTextInRun(LogicalDirection,Char[],Int32,Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Копирует указанное максимальное количество символов из любым смежным текстом в указанном направлении в массив символов, предоставленный вызывающим."
  remarks: "Этот метод возвращает только непрерывные текстовые выполнения.  Ничего не возвращается, если любой символ типа не <xref:System.Windows.Documents.TextPointerContext>рядом с текущим <xref:System.Windows.Documents.TextPointer>в указанном направлении.</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointerContext>  Аналогичным образом возвращается только до следующего нетекстового символа."
  syntax:
    content: public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "Один из <xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref> значений, указывающее логическое направление, в котором для поиска и скопируйте любым смежным текстом."
    - id: textBuffer
      type: System.Char[]
      description: "Буфер, в который копируется текст."
    - id: startIndex
      type: System.Int32
      description: "Индекс в `textBuffer` с которого начинается запись копируются текста."
    - id: count
      type: System.Int32
      description: "Максимальное число символов для копирования."
    return:
      type: System.Int32
      description: "Число символов, фактически скопированы в <code> textBuffer </code>."
  overload: System.Windows.Documents.TextPointer.GetTextInRun*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>startIndex</code>меньше 0 или больше, чем <xref:System.Array.Length*> свойство <code>textBuffer</code>.       - или - <code>count</code> меньше 0 или больше, чем оставшегося свободного места в <code>textBuffer</code> (<code>textBuffer</code>.<xref:System.Array.Length*> минус <code>startIndex</code>)."
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)
  id: GetTextRunLength(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetTextRunLength(LogicalDirection)
  nameWithType: TextPointer.GetTextRunLength(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetTextRunLength(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает количество символов Юникода между текущим <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> и далее нетекстового символа в указанном логическом направлении."
  remarks: "Одно из следующих рассматривается как символ: - открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement>элемента.</xref:System.Windows.Documents.TextElement>      - <xref:System.Windows.UIElement>Элемент, содержащийся в <xref:System.Windows.Documents.InlineUIContainer>или <xref:System.Windows.Documents.BlockUIContainer>.</xref:System.Windows.Documents.BlockUIContainer> </xref:System.Windows.Documents.InlineUIContainer> </xref:System.Windows.UIElement>  Примечание такое <xref:System.Windows.UIElement>всегда считается ровно один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement>, не рассматриваются как символы.</xref:System.Windows.UIElement> </xref:System.Windows.UIElement>      -Это 16-разрядная [!INCLUDE[TLA#tla_unicode](~/add/includes/ajax-current-ext-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run>элемент.</xref:System.Windows.Documents.Run>"
  syntax:
    content: public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "Один из <xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref> значений, указывающее логическое направление, в котором для определения числа символов."
    return:
      type: System.Int32
      description: "Число символов Юникода между текущим <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> и далее нетекстового символа.  Это число может быть равен 0, если нет смежные текста."
  overload: System.Windows.Documents.TextPointer.GetTextRunLength*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.HasValidLayout
  id: HasValidLayout
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: HasValidLayout
  nameWithType: TextPointer.HasValidLayout
  fullName: System.Windows.Documents.TextPointer.HasValidLayout
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Получает значение, указывающее, имеет ли контейнера текста, связанный с текущей позицией допустимого макета (последние)."
  remarks: "При необходимости, операций, зависящих от допустимого макета (такие как <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A>метода <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A>метод, и <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A>свойство) попытка автоматически создать заново допустимый макет перед продолжением операции.</xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> </xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> </xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A>  Повторное создание макета может быть довольно дорогой операции.  Используйте это свойство для проверки допустимого макета перед выполнением операций, которые могут заново создать макет.  Дополнительные сведения см. в разделе [макета](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public bool HasValidLayout { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если макет текущим и допустимым; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.TextPointer.HasValidLayout*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.InsertLineBreak
  id: InsertLineBreak
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: InsertLineBreak()
  nameWithType: TextPointer.InsertLineBreak()
  fullName: System.Windows.Documents.TextPointer.InsertLineBreak()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Вставляет символ новой строки в текущей позиции."
  syntax:
    content: public System.Windows.Documents.TextPointer InsertLineBreak ();
    parameters: []
    return:
      type: System.Windows.Documents.TextPointer
      description: "Объект <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> устанавливается сразу же после <xref href=&quot;System.Windows.Documents.LineBreak&quot;> </xref> элемента вставляемых этим методом."
  overload: System.Windows.Documents.TextPointer.InsertLineBreak*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.InsertParagraphBreak
  id: InsertParagraphBreak
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: InsertParagraphBreak()
  nameWithType: TextPointer.InsertParagraphBreak()
  fullName: System.Windows.Documents.TextPointer.InsertParagraphBreak()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Вставляет разрыв абзаца в текущей позиции."
  remarks: "Если этот метод вызывается в том случае, если текущее положение находится внутри существующего <xref:System.Windows.Documents.Paragraph>элемент, существующий абзац и любое содержимое, он содержит разбиваются на два абзаца в текущем положении.</xref:System.Windows.Documents.Paragraph>  Если этот метод вызывается, когда текущее положение находится за рамками существующего абзаца, вставляется новый, пустой абзац.  Если этот метод вызывается в позиции непригодным для разделения или вставки абзаца (например, в том случае, если текущее положение находится внутри <xref:System.Windows.Documents.Hyperlink>элемент), создается исключение.</xref:System.Windows.Documents.Hyperlink>"
  syntax:
    content: public System.Windows.Documents.TextPointer InsertParagraphBreak ();
    parameters: []
    return:
      type: System.Windows.Documents.TextPointer
      description: "Объект <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> на начало (<xref:System.Windows.Documents.TextElement.ContentStart*>) для нового абзаца.</xref:System.Windows.Documents.TextElement.ContentStart*>"
  overload: System.Windows.Documents.TextPointer.InsertParagraphBreak*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Этот метод вызывается на позиции, которая не может быть разделен, чтобы вместить новый абзац, например, в области <xref href=&quot;System.Windows.Documents.Hyperlink&quot;> </xref> или <xref href=&quot;System.Windows.Documents.InlineUIContainer&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.InsertTextInRun(System.String)
  id: InsertTextInRun(System.String)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: InsertTextInRun(String)
  nameWithType: TextPointer.InsertTextInRun(String)
  fullName: System.Windows.Documents.TextPointer.InsertTextInRun(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Вставляет указанный текст в текст <xref href=&quot;System.Windows.Documents.Run&quot;> </xref> в текущей позиции."
  remarks: "Если <xref:System.Windows.Documents.TextPointer>не ограничивается <xref:System.Windows.Documents.Run>элемент, <xref:System.Windows.Documents.Run>вставляется вместе с `textData`.</xref:System.Windows.Documents.Run> </xref:System.Windows.Documents.Run> </xref:System.Windows.Documents.TextPointer>"
  syntax:
    content: public void InsertTextInRun (string textData);
    parameters:
    - id: textData
      type: System.String
      description: "Вставляемый текст."
  overload: System.Windows.Documents.TextPointer.InsertTextInRun*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Текущая позиция не находится в <xref href=&quot;System.Windows.Documents.Run&quot;> </xref> элемента."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>textData</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.IsAtInsertionPosition
  id: IsAtInsertionPosition
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: IsAtInsertionPosition
  nameWithType: TextPointer.IsAtInsertionPosition
  fullName: System.Windows.Documents.TextPointer.IsAtInsertionPosition
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Получает значение, указывающее, является ли текущее положение положением вставки."
  remarks: "Положение вставки — положение, где может быть добавлено новое содержимое без нарушения любой семантических правил для соответствующего содержимого.  На практике положение вставки в любом месте — в содержимом положение курсора.  Примером является допустимым <xref:System.Windows.Documents.TextPointer>, не положение вставки — положение между двумя смежные <xref:System.Windows.Documents.Paragraph>теги (т. е между закрывающего тега элемента выше и открывающий тег следующего абзаца).</xref:System.Windows.Documents.Paragraph> </xref:System.Windows.Documents.TextPointer>"
  syntax:
    content: public bool IsAtInsertionPosition { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если текущее положение находится в позицию вставки; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.TextPointer.IsAtInsertionPosition*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.IsAtLineStartPosition
  id: IsAtLineStartPosition
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: IsAtLineStartPosition
  nameWithType: TextPointer.IsAtLineStartPosition
  fullName: System.Windows.Documents.TextPointer.IsAtLineStartPosition
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Получает значение, указывающее, является ли текущая позиция в начале строки."
  remarks: "Если <xref:System.Windows.Documents.TextPointer>указывает неоднозначную позицию, например, между двумя строками строки в направлении, указанным <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A>выбрано свойство как относительный начальную строку.</xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> </xref:System.Windows.Documents.TextPointer>       Операция, выполняемая это свойство зависит от допустимого макета.  При необходимости этот метод пытается автоматически восстановить допустимый макет перед продолжением операции.  Повторное создание макета может быть довольно дорогой операции.  Используйте <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A>свойство для проверки допустимого макета перед выполнением операций, которые могут заново создать макет.</xref:System.Windows.Documents.TextPointer.HasValidLayout%2A>  Дополнительные сведения см. в разделе [макета](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public bool IsAtLineStartPosition { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если текущее положение находится в начале строки; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.TextPointer.IsAtLineStartPosition*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)
  id: IsInSameDocument(System.Windows.Documents.TextPointer)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: IsInSameDocument(TextPointer)
  nameWithType: TextPointer.IsInSameDocument(TextPointer)
  fullName: System.Windows.Documents.TextPointer.IsInSameDocument(TextPointer)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Указывает, является ли заданная позиция в том же текстовом контейнере, что и текущее положение."
  remarks: "Большинство операций, которые включают несколько <xref:System.Windows.Documents.TextPointer>экземпляров допустимы только в случае, если данные экземпляры указывают положения, которые находятся в одной и той же области действия контейнера текста.</xref:System.Windows.Documents.TextPointer>  Например <xref:System.Windows.Documents.TextPointer.CompareTo%2A>и <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A>методов не может использоваться с <xref:System.Windows.Documents.TextPointer>позицию за пределами текстового контейнера, связанного с текущим положением.</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> </xref:System.Windows.Documents.TextPointer.CompareTo%2A>  Используйте этот метод, чтобы убедиться, что указанный <xref:System.Windows.Documents.TextPointer>совместима с текущей позиции для таких операций.</xref:System.Windows.Documents.TextPointer>"
  example:
  - "The following example demonstrates a use for this method.  The example uses the IsInSameDocument method to check whether a specified <xref:System.Windows.Documents.TextPointer> is positioned between two other specified <xref:System.Windows.Documents.TextPointer> instances in a situation when there is no guarantee that all three positions belong to the same text container.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_isinsamedocument)]\n [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_isinsamedocument)]"
  syntax:
    content: public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);
    parameters:
    - id: textPosition
      type: System.Windows.Documents.TextPointer
      description: "Объект <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> , указывающий позицию для сравнения с текущей позиции."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <code> textPosition </code> указывает на позицию, который находится в том же текстовом контейнере, что и текущее положение; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Documents.TextPointer.IsInSameDocument*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>textPosition</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.LogicalDirection
  id: LogicalDirection
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: LogicalDirection
  nameWithType: TextPointer.LogicalDirection
  fullName: System.Windows.Documents.TextPointer.LogicalDirection
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Возвращает логическое направление, связанный с текущим положением, которое используется для устранения неоднозначности содержимого, связанного с текущей позиции."
  remarks: "В качестве примера использования этого свойства <xref:System.Windows.Documents.LogicalDirection>из <xref:System.Windows.Documents.TextPointer>возвращается путем нажатия метод дает попадания в точку между двумя символов текста.</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.LogicalDirection> Логическое направление указывает, какой из двух символов был нажат — влево или вправо."
  syntax:
    content: public System.Windows.Documents.LogicalDirection LogicalDirection { get; }
    return:
      type: System.Windows.Documents.LogicalDirection
      description: "<xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref> Значение, связанное с текущей позиции."
  overload: System.Windows.Documents.TextPointer.LogicalDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.Paragraph
  id: Paragraph
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: Paragraph
  nameWithType: TextPointer.Paragraph
  fullName: System.Windows.Documents.TextPointer.Paragraph
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "При наличии получает абзаца, определяющий текущую позицию."
  syntax:
    content: public System.Windows.Documents.Paragraph Paragraph { get; }
    return:
      type: System.Windows.Documents.Paragraph
      description: "<xref href=&quot;System.Windows.Documents.Paragraph&quot;> </xref> , Области текущей позиции или<xref uid=&quot;langword_csharp_ null &quot; name=&quot; null &quot; href=&quot;&quot;></xref>Если такие абзац не существует."
  overload: System.Windows.Documents.TextPointer.Paragraph*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.Parent
  id: Parent
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: Parent
  nameWithType: TextPointer.Parent
  fullName: System.Windows.Documents.TextPointer.Parent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Получает логический родительский элемент, определяющий текущую позицию."
  syntax:
    content: public System.Windows.DependencyObject Parent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "Логический родительский объект, определяющий текущую позицию."
  overload: System.Windows.Documents.TextPointer.Parent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.ToString
  id: ToString
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: ToString()
  nameWithType: TextPointer.ToString()
  fullName: System.Windows.Documents.TextPointer.ToString()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "Этот тип или член поддерживает [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] инфраструктуру и не предназначен для использования непосредственно из программного кода."
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "Строка, представляющая объект."
  overload: System.Windows.Documents.TextPointer.ToString*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Documents.ContentPosition
  isExternal: false
  name: System.Windows.Documents.ContentPosition
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: CompareTo(TextPointer)
  nameWithType: TextPointer.CompareTo(TextPointer)
  fullName: System.Windows.Documents.TextPointer.CompareTo(TextPointer)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Documents.TextPointer
  parent: System.Windows.Documents
  isExternal: false
  name: TextPointer
  nameWithType: TextPointer
  fullName: System.Windows.Documents.TextPointer
- uid: System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: DeleteTextInRun(Int32)
  nameWithType: TextPointer.DeleteTextInRun(Int32)
  fullName: System.Windows.Documents.TextPointer.DeleteTextInRun(Int32)
- uid: System.Windows.Documents.TextPointer.DocumentEnd
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: DocumentEnd
  nameWithType: TextPointer.DocumentEnd
  fullName: System.Windows.Documents.TextPointer.DocumentEnd
- uid: System.Windows.Documents.TextPointer.DocumentStart
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: DocumentStart
  nameWithType: TextPointer.DocumentStart
  fullName: System.Windows.Documents.TextPointer.DocumentStart
- uid: System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetAdjacentElement(LogicalDirection)
  nameWithType: TextPointer.GetAdjacentElement(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetAdjacentElement(LogicalDirection)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.Documents.LogicalDirection
  parent: System.Windows.Documents
  isExternal: false
  name: LogicalDirection
  nameWithType: LogicalDirection
  fullName: System.Windows.Documents.LogicalDirection
- uid: System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetCharacterRect(LogicalDirection)
  nameWithType: TextPointer.GetCharacterRect(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetCharacterRect(LogicalDirection)
- uid: System.Windows.Rect
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
- uid: System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetInsertionPosition(LogicalDirection)
  nameWithType: TextPointer.GetInsertionPosition(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetInsertionPosition(LogicalDirection)
- uid: System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetLineStartPosition(Int32)
  nameWithType: TextPointer.GetLineStartPosition(Int32)
  fullName: System.Windows.Documents.TextPointer.GetLineStartPosition(Int32)
- uid: System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetLineStartPosition(Int32,Int32)
  nameWithType: TextPointer.GetLineStartPosition(Int32,Int32)
  fullName: System.Windows.Documents.TextPointer.GetLineStartPosition(Int32,Int32)
- uid: System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetNextContextPosition(LogicalDirection)
  nameWithType: TextPointer.GetNextContextPosition(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetNextContextPosition(LogicalDirection)
- uid: System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetNextInsertionPosition(LogicalDirection)
  nameWithType: TextPointer.GetNextInsertionPosition(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetNextInsertionPosition(LogicalDirection)
- uid: System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetOffsetToPosition(TextPointer)
  nameWithType: TextPointer.GetOffsetToPosition(TextPointer)
  fullName: System.Windows.Documents.TextPointer.GetOffsetToPosition(TextPointer)
- uid: System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetPointerContext(LogicalDirection)
  nameWithType: TextPointer.GetPointerContext(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetPointerContext(LogicalDirection)
- uid: System.Windows.Documents.TextPointerContext
  parent: System.Windows.Documents
  isExternal: false
  name: TextPointerContext
  nameWithType: TextPointerContext
  fullName: System.Windows.Documents.TextPointerContext
- uid: System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetPositionAtOffset(Int32)
  nameWithType: TextPointer.GetPositionAtOffset(Int32)
  fullName: System.Windows.Documents.TextPointer.GetPositionAtOffset(Int32)
- uid: System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetPositionAtOffset(Int32,LogicalDirection)
  nameWithType: TextPointer.GetPositionAtOffset(Int32,LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetPositionAtOffset(Int32,LogicalDirection)
- uid: System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetTextInRun(LogicalDirection)
  nameWithType: TextPointer.GetTextInRun(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetTextInRun(LogicalDirection)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetTextInRun(LogicalDirection,Char[],Int32,Int32)
  nameWithType: TextPointer.GetTextInRun(LogicalDirection,Char[],Int32,Int32)
  fullName: System.Windows.Documents.TextPointer.GetTextInRun(LogicalDirection,Char[],Int32,Int32)
- uid: System.Char[]
  parent: System
  isExternal: true
  name: Char
  nameWithType: Char
  fullName: System.Char[]
  spec.csharp:
  - uid: System.Char
    name: Char
    nameWithType: Char
    fullName: Char[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetTextRunLength(LogicalDirection)
  nameWithType: TextPointer.GetTextRunLength(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetTextRunLength(LogicalDirection)
- uid: System.Windows.Documents.TextPointer.HasValidLayout
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: HasValidLayout
  nameWithType: TextPointer.HasValidLayout
  fullName: System.Windows.Documents.TextPointer.HasValidLayout
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Documents.TextPointer.InsertLineBreak
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: InsertLineBreak()
  nameWithType: TextPointer.InsertLineBreak()
  fullName: System.Windows.Documents.TextPointer.InsertLineBreak()
- uid: System.Windows.Documents.TextPointer.InsertParagraphBreak
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: InsertParagraphBreak()
  nameWithType: TextPointer.InsertParagraphBreak()
  fullName: System.Windows.Documents.TextPointer.InsertParagraphBreak()
- uid: System.Windows.Documents.TextPointer.InsertTextInRun(System.String)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: InsertTextInRun(String)
  nameWithType: TextPointer.InsertTextInRun(String)
  fullName: System.Windows.Documents.TextPointer.InsertTextInRun(String)
- uid: System.Windows.Documents.TextPointer.IsAtInsertionPosition
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: IsAtInsertionPosition
  nameWithType: TextPointer.IsAtInsertionPosition
  fullName: System.Windows.Documents.TextPointer.IsAtInsertionPosition
- uid: System.Windows.Documents.TextPointer.IsAtLineStartPosition
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: IsAtLineStartPosition
  nameWithType: TextPointer.IsAtLineStartPosition
  fullName: System.Windows.Documents.TextPointer.IsAtLineStartPosition
- uid: System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: IsInSameDocument(TextPointer)
  nameWithType: TextPointer.IsInSameDocument(TextPointer)
  fullName: System.Windows.Documents.TextPointer.IsInSameDocument(TextPointer)
- uid: System.Windows.Documents.TextPointer.LogicalDirection
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: LogicalDirection
  nameWithType: TextPointer.LogicalDirection
  fullName: System.Windows.Documents.TextPointer.LogicalDirection
- uid: System.Windows.Documents.TextPointer.Paragraph
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: Paragraph
  nameWithType: TextPointer.Paragraph
  fullName: System.Windows.Documents.TextPointer.Paragraph
- uid: System.Windows.Documents.Paragraph
  parent: System.Windows.Documents
  isExternal: false
  name: Paragraph
  nameWithType: Paragraph
  fullName: System.Windows.Documents.Paragraph
- uid: System.Windows.Documents.TextPointer.Parent
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: Parent
  nameWithType: TextPointer.Parent
  fullName: System.Windows.Documents.TextPointer.Parent
- uid: System.Windows.Documents.TextPointer.ToString
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: ToString()
  nameWithType: TextPointer.ToString()
  fullName: System.Windows.Documents.TextPointer.ToString()
- uid: System.Windows.Documents.TextPointer.CompareTo*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: CompareTo
  nameWithType: TextPointer.CompareTo
- uid: System.Windows.Documents.TextPointer.DeleteTextInRun*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: DeleteTextInRun
  nameWithType: TextPointer.DeleteTextInRun
- uid: System.Windows.Documents.TextPointer.DocumentEnd*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: DocumentEnd
  nameWithType: TextPointer.DocumentEnd
- uid: System.Windows.Documents.TextPointer.DocumentStart*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: DocumentStart
  nameWithType: TextPointer.DocumentStart
- uid: System.Windows.Documents.TextPointer.GetAdjacentElement*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetAdjacentElement
  nameWithType: TextPointer.GetAdjacentElement
- uid: System.Windows.Documents.TextPointer.GetCharacterRect*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetCharacterRect
  nameWithType: TextPointer.GetCharacterRect
- uid: System.Windows.Documents.TextPointer.GetInsertionPosition*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetInsertionPosition
  nameWithType: TextPointer.GetInsertionPosition
- uid: System.Windows.Documents.TextPointer.GetLineStartPosition*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetLineStartPosition
  nameWithType: TextPointer.GetLineStartPosition
- uid: System.Windows.Documents.TextPointer.GetNextContextPosition*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetNextContextPosition
  nameWithType: TextPointer.GetNextContextPosition
- uid: System.Windows.Documents.TextPointer.GetNextInsertionPosition*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetNextInsertionPosition
  nameWithType: TextPointer.GetNextInsertionPosition
- uid: System.Windows.Documents.TextPointer.GetOffsetToPosition*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetOffsetToPosition
  nameWithType: TextPointer.GetOffsetToPosition
- uid: System.Windows.Documents.TextPointer.GetPointerContext*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetPointerContext
  nameWithType: TextPointer.GetPointerContext
- uid: System.Windows.Documents.TextPointer.GetPositionAtOffset*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetPositionAtOffset
  nameWithType: TextPointer.GetPositionAtOffset
- uid: System.Windows.Documents.TextPointer.GetTextInRun*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetTextInRun
  nameWithType: TextPointer.GetTextInRun
- uid: System.Windows.Documents.TextPointer.GetTextRunLength*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetTextRunLength
  nameWithType: TextPointer.GetTextRunLength
- uid: System.Windows.Documents.TextPointer.HasValidLayout*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: HasValidLayout
  nameWithType: TextPointer.HasValidLayout
- uid: System.Windows.Documents.TextPointer.InsertLineBreak*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: InsertLineBreak
  nameWithType: TextPointer.InsertLineBreak
- uid: System.Windows.Documents.TextPointer.InsertParagraphBreak*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: InsertParagraphBreak
  nameWithType: TextPointer.InsertParagraphBreak
- uid: System.Windows.Documents.TextPointer.InsertTextInRun*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: InsertTextInRun
  nameWithType: TextPointer.InsertTextInRun
- uid: System.Windows.Documents.TextPointer.IsAtInsertionPosition*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: IsAtInsertionPosition
  nameWithType: TextPointer.IsAtInsertionPosition
- uid: System.Windows.Documents.TextPointer.IsAtLineStartPosition*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: IsAtLineStartPosition
  nameWithType: TextPointer.IsAtLineStartPosition
- uid: System.Windows.Documents.TextPointer.IsInSameDocument*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: IsInSameDocument
  nameWithType: TextPointer.IsInSameDocument
- uid: System.Windows.Documents.TextPointer.LogicalDirection*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: LogicalDirection
  nameWithType: TextPointer.LogicalDirection
- uid: System.Windows.Documents.TextPointer.Paragraph*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: Paragraph
  nameWithType: TextPointer.Paragraph
- uid: System.Windows.Documents.TextPointer.Parent*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: Parent
  nameWithType: TextPointer.Parent
- uid: System.Windows.Documents.TextPointer.ToString*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: ToString
  nameWithType: TextPointer.ToString
