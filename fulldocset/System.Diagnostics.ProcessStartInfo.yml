### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.ProcessStartInfo
  id: ProcessStartInfo
  children:
  - System.Diagnostics.ProcessStartInfo.#ctor
  - System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  - System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  - System.Diagnostics.ProcessStartInfo.Arguments
  - System.Diagnostics.ProcessStartInfo.CreateNoWindow
  - System.Diagnostics.ProcessStartInfo.Domain
  - System.Diagnostics.ProcessStartInfo.Environment
  - System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  - System.Diagnostics.ProcessStartInfo.ErrorDialog
  - System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  - System.Diagnostics.ProcessStartInfo.FileName
  - System.Diagnostics.ProcessStartInfo.LoadUserProfile
  - System.Diagnostics.ProcessStartInfo.Password
  - System.Diagnostics.ProcessStartInfo.PasswordInClearText
  - System.Diagnostics.ProcessStartInfo.RedirectStandardError
  - System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  - System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  - System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  - System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  - System.Diagnostics.ProcessStartInfo.UserName
  - System.Diagnostics.ProcessStartInfo.UseShellExecute
  - System.Diagnostics.ProcessStartInfo.Verb
  - System.Diagnostics.ProcessStartInfo.Verbs
  - System.Diagnostics.ProcessStartInfo.WindowStyle
  - System.Diagnostics.ProcessStartInfo.WorkingDirectory
  langs:
  - csharp
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
  type: Class
  summary: "Задает набор значений, которые будут использоваться при запуске процесса."
  remarks: "Изменение панели инструментов используется совместно с <xref:System.Diagnostics.Process>компонента.</xref:System.Diagnostics.Process> При запуске процесса с помощью <xref:System.Diagnostics.Process>класс, у вас есть доступ для обработки сведений, доступных при подключении к выполняющемуся процессу.</xref:System.Diagnostics.Process>       Класс ProcessStartInfo для улучшения контроля над процессом, при запуске. Необходимо задать по крайней мере <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>Свойства, либо вручную или с помощью конструктора.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Имя файла — любое приложение или документ. Здесь документ определяется как файл любого типа, который содержит открытый или по умолчанию действие, связанное с ним. Можно просмотреть зарегистрированные типы файлов и связанные с ними приложения для компьютера с помощью **свойства папки** диалоговое окно «», которая доступна через операционную систему. **Дополнительно** кнопки приводит к диалоговым окном, которое показывает, является ли открытые действия, связанного с зарегистрированным файлов определенного типа.       Кроме того можно задать другие свойства, которые определяют действия, выполняемые с этим файлом. Можно указать значение для типа <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>свойство <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>свойство.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Например можно указать «печать» для типа документа. Кроме того, можно указать <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>значения свойства на аргументы командной строки для передачи процедура открытия файла.</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> Например, если задать приложение текстового редактора в <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>Свойства, можно использовать <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>свойство, чтобы указать текстовый файл должен открываться в редакторе.</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A>       Стандартный ввод обычно является клавиатура и стандартный выход и Стандартная ошибка — экран монитора. Тем не менее, можно использовать <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>, <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>, и <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>Свойства, чтобы замедлить процесс получения входных данных из или возвращают выходные данные в файл или другое устройство.</xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> </xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> </xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A> Если вы используете <xref:System.Diagnostics.Process.StandardInput%2A>, <xref:System.Diagnostics.Process.StandardOutput%2A>, или <xref:System.Diagnostics.Process.StandardError%2A>Свойства <xref:System.Diagnostics.Process>компонента, необходимо сначала задать соответствующее значение в свойстве ProcessStartInfo.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process.StandardInput%2A> В противном случае система создает исключение при чтении или записи в поток.       Задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>Укажите, следует ли начать процесс с помощью оболочки операционной системы.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>       Можно изменить значение любого свойства ProcessStartInfo до момента запуска процесса. После запуска процесса изменение этих значений не оказывает влияния.      Настроек [!NOTE] настроек этот класс содержит запрос компоновки на уровне класса, который применяется ко всем элементам. Объект <xref:System.Security.SecurityException>возникает, когда непосредственный вызывающий объект не имеет разрешения с полным доверием.</xref:System.Security.SecurityException> Дополнительные сведения о требованиях безопасности см. в разделе [требования связывания](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how to use the ProcessStartInfo class to start Internet Explorer, providing the destination URLs as ProcessStartInfo arguments.  \n  \n [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/t-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/t-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/t-system.diagnostics.pro_2_1.cpp)]"
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]

      public sealed class ProcessStartInfo
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.#ctor
  id: '#ctor'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ProcessStartInfo()
  nameWithType: ProcessStartInfo.ProcessStartInfo()
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> класса без указания имени файла, с которым должен запускаться процесс."
  remarks: "Необходимо задать по крайней мере <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>перед началом процесса.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Имя файла — любое приложение или документ. В этом случае документ определяется как файл любого типа, который содержит открытый или по умолчанию действие, связанное с ним. Можно просмотреть зарегистрированные типы файлов и связанные с ними приложения для компьютера с помощью **свойства папки** диалоговое окно «», которая доступна через операционную систему. **Дополнительно** кнопки приводит к диалоговым окном, которое показывает, является ли открытые действия, связанного с зарегистрированным файлов определенного типа.       При необходимости можно также задать другие свойства, прежде чем начать процесс. <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>Свойство предоставляет действия, такие как «печать», с файлом, указанным в <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>свойство.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> </xref:System.Diagnostics.ProcessStartInfo.Verb%2A> <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>Свойство предоставляет способ передачи аргументов командной строки в файл, когда система открывает его.</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>"
  syntax:
    content: public ProcessStartInfo ();
    parameters: []
  overload: System.Diagnostics.ProcessStartInfo.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ProcessStartInfo(String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> класса и указывает имя файла, например приложение или документ, с которым должен запускаться процесс."
  remarks: "Имя файла — любое приложение или документ. В этом случае документ определяется как файл любого типа, который содержит открытый или по умолчанию действие, связанное с ним. Можно просмотреть зарегистрированные типы файлов и связанные с ними приложения для компьютера с помощью **свойства папки** диалоговое окно «», которая доступна через операционную систему. **Дополнительно** кнопки приводит к диалоговым окном, которое показывает, является ли открытые действия, связанного с зарегистрированным файлов определенного типа.       Вы можете изменить <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>свойство после вызова этого конструктора, до момента запуска процесса.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> После запуска процесса изменение этих значений не оказывает влияния."
  syntax:
    content: public ProcessStartInfo (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "Приложение или документ, с которым должен запускаться процесс."
  overload: System.Diagnostics.ProcessStartInfo.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ProcessStartInfo(String,String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String,String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Diagnostics.ProcessStartInfo&quot;> </xref> класса, задает имя файла приложения, с которым должен запускаться процесс и задает набор аргументов командной строки для передачи в приложение."
  remarks: "Имя файла — любое приложение или документ. В этом случае документ определяется как файл любого типа, который содержит открытый или по умолчанию действие, связанное с ним. Можно просмотреть зарегистрированные типы файлов и связанные с ними приложения для компьютера с помощью **свойства папки** диалоговое окно «», которая доступна через операционную систему. **Дополнительно** кнопки приводит к диалоговым окном, которое показывает, является ли открытые действия, связанного с зарегистрированным файлов определенного типа.       Вы можете изменить <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>или <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>свойства после вызова этого конструктора, до момента запуска процесса.</xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> </xref:System.Diagnostics.ProcessStartInfo.FileName%2A> После запуска процесса изменение этих значений не оказывает влияния."
  syntax:
    content: public ProcessStartInfo (string fileName, string arguments);
    parameters:
    - id: fileName
      type: System.String
      description: "Приложение, с которым должен запускаться процесс."
    - id: arguments
      type: System.String
      description: "Аргументы командной строки для передачи в приложение при запуске процесса."
  overload: System.Diagnostics.ProcessStartInfo.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Arguments
  id: Arguments
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Arguments
  nameWithType: ProcessStartInfo.Arguments
  fullName: System.Diagnostics.ProcessStartInfo.Arguments
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает набор аргументов командной строки для использования при запуске приложения."
  remarks: ''
  example:
  - "The first example below creates a small application (argsecho.exe) that echos its arguments to the console. The second example creates an application that invokes argsecho.exe to demonstrate different variations for the Arguments property.  \n  \n [!code-vb[Process.Start_static#3](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_2_1.vb)]\n [!code-cs[Process.Start_static#3](~/add/codesnippet/csharp/p-system.diagnostics.pro_2_1.cs)]\n [!code-cpp[Process.Start_static#3](~/add/codesnippet/cpp/p-system.diagnostics.pro_2_1.cpp)]  \n  \n [!code-vb[Process.Start_static#2](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_2_2.vb)]\n [!code-cs[Process.Start_static#2](~/add/codesnippet/csharp/p-system.diagnostics.pro_2_2.cs)]\n [!code-cpp[Process.Start_static#2](~/add/codesnippet/cpp/p-system.diagnostics.pro_2_2.cpp)]"
  syntax:
    content: public string Arguments { get; set; }
    return:
      type: System.String
      description: "Одна строка, содержащая аргументы для передачи в целевое приложение, указанное в <xref:System.Diagnostics.ProcessStartInfo.FileName*>свойство.</xref:System.Diagnostics.ProcessStartInfo.FileName*> Значение по умолчанию — пустая строка (»»). В Windows Vista и более ранних версиях операционной системы Windows длина аргументов, добавляемых к длине полного пути к процессу должна быть меньше 2080. В Windows 7 и более поздних версиях длина должна быть меньше 32699.       Аргументы анализируются и интерпретируются целевым приложением, поэтому они должны соответствовать ожидаемым аргументам приложения. Для приложений, как показано в приведенных ниже примерах пробелы считаются разделителями между несколькими аргументами. Один аргумент, включающий пробелы должны быть заключены в кавычки, но кавычки не указываются в целевом приложении. Включении кавычек в финальном проанализированном аргументе, добавить escape-символ каждому знаку."
  overload: System.Diagnostics.ProcessStartInfo.Arguments*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  id: CreateNoWindow
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: CreateNoWindow
  nameWithType: ProcessStartInfo.CreateNoWindow
  fullName: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает значение, указывающее, следует ли запускать процесс в новом окне."
  remarks: "Если <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>свойство `true` или <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>и <xref:System.Diagnostics.ProcessStartInfo.Password%2A>свойства не являются `null`, CreateNoWindow значение свойства учитывается и создается новое окно.</xref:System.Diagnostics.ProcessStartInfo.Password%2A> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>"
  example:
  - >-
    [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_19_1.cpp)]
     [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_19_1.vb)]
     [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_19_1.cs)]
  syntax:
    content: public bool CreateNoWindow { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если процесс должен запускаться без создания нового окна, содержащего его; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.CreateNoWindow*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Domain
  id: Domain
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Domain
  nameWithType: ProcessStartInfo.Domain
  fullName: System.Diagnostics.ProcessStartInfo.Domain
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает значение, определяющее домен, используемый при запуске процесса."
  syntax:
    content: public string Domain { get; set; }
    return:
      type: System.String
      description: "Домен Active Directory, используемый при запуске процесса. Свойства домена имеет главным образом для пользователей, работающих в корпоративной среде, в которых используется Active Directory."
  overload: System.Diagnostics.ProcessStartInfo.Domain*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Environment
  id: Environment
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Environment
  nameWithType: ProcessStartInfo.Environment
  fullName: System.Diagnostics.ProcessStartInfo.Environment
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает переменные среды, которые применяются к этому процессу и его дочерних процессов."
  remarks: "The environment variables contain search paths for files, directories for temporary files, application-specific options, and other similar information. Although you cannot directly set the Environment property, you can modify the generic dictionary returned by the property. For example, the following code adds a TempPath environment variable: `myProcess.StartInfo.Environment.Add(\"TempPath\", \"C:\\\\Temp\")`.  You must set the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> property to `false` to start the process after changing the Environment property. If <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true`, an <xref:System.InvalidOperationException> is thrown when the <xref:System.Diagnostics.Process.Start%2A> method is called.  \n  \n On .NET Framework applications, using the Environment property is the same as using the <xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A> property."
  syntax:
    content: public System.Collections.Generic.IDictionary<string,string> Environment { get; }
    return:
      type: System.Collections.Generic.IDictionary{System.String,System.String}
      description: "Универсальный словарь, содержащий переменные среды, которые применяются к этому процессу и его дочерних процессов. Значение по умолчанию — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.Environment*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  id: EnvironmentVariables
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: EnvironmentVariables
  nameWithType: ProcessStartInfo.EnvironmentVariables
  fullName: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает пути поиска файлов, каталоги временных файлов, параметры данного приложения и другие аналогичные сведения."
  remarks: 'Несмотря на то, что не удается установить свойства переменных среды, можно изменить <xref:System.Collections.Specialized.StringDictionary>возвращаемый этим свойством.</xref:System.Collections.Specialized.StringDictionary> Например, следующий код добавляет переменную среды каталог временных файлов: `myProcess.StartInfo.EnvironmentVariables.Add(&quot;TempPath&quot;, &quot;C:\\Temp&quot;)`.  Необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>Свойства `false` для запуска процесса после изменения свойства переменных среды.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Если <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>является `true`, <xref:System.InvalidOperationException>возникает, когда <xref:System.Diagnostics.Process.Start%2A>вызывается метод.</xref:System.Diagnostics.Process.Start%2A> </xref:System.InvalidOperationException> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>'
  syntax:
    content: public System.Collections.Specialized.StringDictionary EnvironmentVariables { get; }
    return:
      type: System.Collections.Specialized.StringDictionary
      description: "Словарь строк, предоставляющий переменные среды, относящиеся к этому процессу и дочерним процессам. Значение по умолчанию — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.EnvironmentVariables*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialog
  id: ErrorDialog
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ErrorDialog
  nameWithType: ProcessStartInfo.ErrorDialog
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialog
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает значение, указывающее, отображается ли для пользователя диалоговое окно ошибки, если процесс не может быть запущен."
  remarks: >-
    > [!NOTE]

    >  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> must be `true` if you want to set ErrorDialog to `true`.
  syntax:
    content: public bool ErrorDialog { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если диалоговое окно ошибки должны отображаться на экране при невозможности запуска процесса; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.ErrorDialog*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  id: ErrorDialogParentHandle
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: ErrorDialogParentHandle
  nameWithType: ProcessStartInfo.ErrorDialogParentHandle
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает дескриптор окна, используемый при отображении диалоговое окно ошибки для процесса, который не может быть запущена."
  remarks: "Если <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>является `true`, свойство ErrorDialogParentHandle указывает родительского окна для диалогового окна, которое отображается.</xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A> Оно полезно для указания родительской для оставьте диалоговое окно перед приложения."
  syntax:
    content: public IntPtr ErrorDialogParentHandle { get; set; }
    return:
      type: System.IntPtr
      description: "Указатель на дескриптор диалоговое окно ошибки, сбоя при запуске результаты из процесса."
  overload: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.FileName
  id: FileName
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: FileName
  nameWithType: ProcessStartInfo.FileName
  fullName: System.Diagnostics.ProcessStartInfo.FileName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает приложение или документ для запуска."
  remarks: "Необходимо по крайней мере задайте в свойстве FileName, прежде чем начать процесс. Имя файла — любое приложение или документ. Документ определяется как файл любого типа, который содержит открытый или по умолчанию действие, связанное с ним. Можно просмотреть зарегистрированные типы файлов и связанные с ними приложения для компьютера с помощью **свойства папки** диалоговое окно «», которая доступна через операционную систему. **Дополнительно** кнопки приводит к диалоговым окном, которое показывает, является ли открытые действия, связанного с зарегистрированным файлов определенного типа.       Набор типов файлов, доступных пользователю отчасти зависит от значения <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>свойство.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Если <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>является `true`, можно запустить любой документ и выполнять операции над файлом, например печать, с <xref:System.Diagnostics.Process>компонента.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> Когда <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>— `false`, можно запускать только исполняемые файлы с <xref:System.Diagnostics.Process>компонента.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>       Можно запустить приложение ClickOnce, задав в свойстве FileName расположение (например, веб-адрес), из которого изначально устанавливалось приложение. Не запускать приложение ClickOnce, указав расположение его установки на жестком диске."
  example:
  - >-
    [!code-cpp[Process.Start_instance#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_27_1.cpp)]
     [!code-vb[Process.Start_instance#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_27_1.vb)]
     [!code-cs[Process.Start_instance#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_27_1.cs)]
  syntax:
    content: public string FileName { get; set; }
    return:
      type: System.String
      description: "Имя приложения для запуска, или имя документа, тип файла, который связан с приложением и, по умолчанию имеет значение откройте действие, доступные для него. Значение по умолчанию — пустая строка (»»)."
  overload: System.Diagnostics.ProcessStartInfo.FileName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.LoadUserProfile
  id: LoadUserProfile
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: LoadUserProfile
  nameWithType: ProcessStartInfo.LoadUserProfile
  fullName: System.Diagnostics.ProcessStartInfo.LoadUserProfile
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает значение, указывающее, является ли учетная запись пользователя Windows для загрузки из реестра."
  remarks: "Это свойство используется при запуске процесса, используя имя пользователя, пароль и домен.       Если значение равно `true`, профиль пользователя в `HKEY_USERS` загружается раздел реестра. Загрузка профиля может занять некоторое время. Таким образом, рекомендуется использовать это значение только в том случае, если необходимо получить доступ к информации в `HKEY_CURRENT_USER` раздел реестра.       В Windows Server 2003 и Windows 2000 профиль выгружается после завершения нового процесса, независимо от того, является ли процесс создал дочерние процессы.       В Windows XP профиль выгружается после завершения нового процесса и все дочерние процессы, созданные им будет прекращено."
  syntax:
    content: public bool LoadUserProfile { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>следует ли загружать профиль пользователя Windows; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.LoadUserProfile*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Password
  id: Password
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Password
  nameWithType: ProcessStartInfo.Password
  fullName: System.Diagnostics.ProcessStartInfo.Password
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает защищенную строку, которая содержит пароль пользователя, используемый при запуске процесса."
  remarks: "> [!IMPORTANT]\n>  The <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> property must be set if <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and Password are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.  \n  \n> [!NOTE]\n>  Setting the <xref:System.Diagnostics.ProcessStartInfo.Domain%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, and the Password properties in a <xref:System.Diagnostics.ProcessStartInfo> object is the recommended practice for starting a process with user credentials.  \n  \n A <xref:System.Security.SecureString> object is like a <xref:System.String> object in that it has a text value. However, the value of a <xref:System.Security.SecureString> object is automatically encrypted, it can be modified until your application marks it as read-only, and it can be deleted from computer memory by either your application or the .NET Framework garbage collector.  \n  \n For more information about secure strings and an example of how to obtain a password to set this property, see the <xref:System.Security.SecureString> class.  \n  \n> [!NOTE]\n>  If you provide a value for the Password property, the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> property must be `false`, or an <xref:System.InvalidOperationException> will be thrown when the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> method is called."
  syntax:
    content: public System.Security.SecureString Password { get; set; }
    return:
      type: System.Security.SecureString
      description: "Пароль пользователя, используемый при запуске процесса."
  overload: System.Diagnostics.ProcessStartInfo.Password*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.PasswordInClearText
  id: PasswordInClearText
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: PasswordInClearText
  nameWithType: ProcessStartInfo.PasswordInClearText
  fullName: System.Diagnostics.ProcessStartInfo.PasswordInClearText
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает пароль пользователя в виде открытого текста, используемый при запуске процесса."
  syntax:
    content: public string PasswordInClearText { get; set; }
    return:
      type: System.String
      description: "Пароль пользователя в виде открытого текста."
  overload: System.Diagnostics.ProcessStartInfo.PasswordInClearText*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  id: RedirectStandardError
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: RedirectStandardError
  nameWithType: ProcessStartInfo.RedirectStandardError
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает значение, указывающее, записывается ли вывод ошибок приложения &lt;xref:System.Diagnostics.Process.StandardError%2A?displayProperty=fullName&gt; потока."
  remarks: "Когда <xref:System.Diagnostics.Process>записывает текст в его стандартный поток ошибок, что текст обычно отображается на консоли.</xref:System.Diagnostics.Process> Путем перенаправления <xref:System.Diagnostics.Process.StandardError%2A>потока, можно управлять или подавлять вывод ошибок процесса.</xref:System.Diagnostics.Process.StandardError%2A> Например можно фильтровать текст, отформатировать его по-разному или записать выходные данные в консоль и назначенный файл журнала.      Настроек [!NOTE] настроек необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>для `false` чтобы присвоено RedirectStandardError `true`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> В противном случае чтение из <xref:System.Diagnostics.Process.StandardError%2A>поток вызывает исключение.</xref:System.Diagnostics.Process.StandardError%2A>       Перенаправленный <xref:System.Diagnostics.Process.StandardError%2A>возможность чтения потока, синхронно или асинхронно.</xref:System.Diagnostics.Process.StandardError%2A> Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>и <xref:System.IO.StreamReader.ReadToEnd%2A>синхронной операции чтения в поток вывода ошибок в процессе выполнения.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Эти синхронного чтения операций не завершены, пока не связанный с ним <xref:System.Diagnostics.Process>записывает его <xref:System.Diagnostics.Process.StandardError%2A>потока или закрывает поток.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process>       Напротив <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardError%2A>потока.</xref:System.Diagnostics.Process.StandardError%2A> </xref:System.Diagnostics.Process.BeginErrorReadLine%2A> Этот метод включает назначенный обработчик событий для выходного потока и немедленно возвращается вызывающему объекту, который может выполнять другую работу, пока вывод потока направлен обработчику событий.      Настроек [!NOTE] настроек приложения, которое обрабатывает асинхронный выход должен вызывать <xref:System.Diagnostics.Process.WaitForExit%2A>метод, чтобы гарантировать записан выходной буфер.</xref:System.Diagnostics.Process.WaitForExit%2A>       Синхронное чтение операций устанавливают зависимость между считыванием вызывающего оператора из <xref:System.Diagnostics.Process.StandardError%2A>поток и дочерний процесс записи в поток.</xref:System.Diagnostics.Process.StandardError%2A> Эти зависимости может привести к условиям взаимоблокировки. Если вызывающий объект считывает из перенаправленного потока дочернего процесса, он зависит от дочернего. Вызывающий объект ожидает операции чтения, пока дочерний элемент записывает в поток или закрывает поток. Если дочерний процесс записывает достаточно данных для заполнения своего перенаправленного потока, он зависит от родительского. Дочерний процесс ожидает следующей операции записи, пока родительский элемент считывает из полного потока или закрывает поток. Взаимоблокировка возникает, когда вызывающий объект и дочерний процесс ожидают друг друга для завершения операции и не может быть продолжена. Взаимоблокировок можно избежать, оценивая зависимости между вызывающим объектом и дочерним процессом.       Например следующий код C# показано, как считывание из перенаправленного потока и ожидание завершения дочернего процесса.      ```   // Start the child process.    Process p = new Process();    // Redirect the error stream of the child process.    p.StartInfo.UseShellExecute = false;    p.StartInfo.RedirectStandardError = true;    p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;    p.Start();    // Do not wait for the child process to exit before    // reading to the end of its redirected error stream.    // p.WaitForExit();    // Read the error stream first and then wait.    string error = p.StandardError.ReadToEnd();    p.WaitForExit();   ```В примере кода позволяет избежать состояния взаимоблокировки, вызвав `p.StandardError.ReadToEnd` перед `p.WaitForExit`. Условие взаимоблокировки могут случиться, если родительский процесс вызывает `p.WaitForExit` перед `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения перенаправленного потока. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса. Дочерний процесс неограниченно долго будет ожидать родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A>потока.</xref:System.Diagnostics.Process.StandardError%2A>       Нет аналогичная проблема возникает при считывании всего текста из стандартный выход и Стандартная ошибка потоков. Например следующий код C# выполняет операции чтения в обоих потоках.      ```   // Do not perform a synchronous read to the end of both   // redirected streams.   // string output = p.StandardOutput.ReadToEnd();   // string error = p.StandardError.ReadToEnd();   // p.WaitForExit();   // Use asynchronous read operations on at least one of the streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```В примере кода позволяет избежать состояния взаимоблокировки, выполняя асинхронные операции чтения на <xref:System.Diagnostics.Process.StandardOutput%2A>потока.</xref:System.Diagnostics.Process.StandardOutput%2A> Условие взаимоблокировки возникает, если родительский процесс вызывает `p.StandardOutput.ReadToEnd` следуют `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения его поток сообщений об ошибках. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса его <xref:System.Diagnostics.Process.StandardOutput%2A>потока.</xref:System.Diagnostics.Process.StandardOutput%2A> Дочерний процесс неограниченно долго будет ожидать родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A>потока.</xref:System.Diagnostics.Process.StandardError%2A>       Чтобы избежать этих зависимостей возможных взаимоблокировок можно использовать операции асинхронного чтения. Кроме того можно избежать состояния взаимоблокировки путем создания двух потоков и считывания выходных данных каждого потока в отдельном потоке."
  example:
  - "The following example uses the `net use` command together with a user-supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.  \n  \n [!code-cs[Process_StandardError#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_31_1.cs)]\n [!code-cpp[Process_StandardError#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_31_1.cpp)]\n [!code-vb[Process_StandardError#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_31_1.vb)]"
  syntax:
    content: public bool RedirectStandardError { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если необходимо записывать вывод ошибок &lt;xref:System.Diagnostics.Process.StandardError%2A?displayProperty=fullName&gt;; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.RedirectStandardError*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  id: RedirectStandardInput
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: RedirectStandardInput
  nameWithType: ProcessStartInfo.RedirectStandardInput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает значение, указывающее, считывается ли входные данные приложения из &lt;xref:System.Diagnostics.Process.StandardInput%2A?displayProperty=fullName&gt; потока."
  remarks: "Объект <xref:System.Diagnostics.Process>может считывать введенный текст из его стандартный входной поток, обычно это клавиатурный.</xref:System.Diagnostics.Process> Путем перенаправления <xref:System.Diagnostics.Process.StandardInput%2A>потока, можно программно указать входной поток процесса.</xref:System.Diagnostics.Process.StandardInput%2A> Например вместо ввода с клавиатуры, чтобы обеспечить текст из содержимого назначенного файла или выходных данных другого приложения.      Настроек [!NOTE] настроек необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>для `false` чтобы присвоено RedirectStandardInput `true`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> В противном случае запись в <xref:System.Diagnostics.Process.StandardInput%2A>поток вызывает исключение.</xref:System.Diagnostics.Process.StandardInput%2A>"
  example:
  - "The following example illustrates how to redirect the <xref:System.Diagnostics.Process.StandardInput%2A> stream of a process. The `sort` command is a console application that reads and sorts text input.  \n  \n The example starts the `sort` command with redirected input. It then prompts the user for text, and passes the text to the `sort` process through the redirected <xref:System.Diagnostics.Process.StandardInput%2A> stream. The `sort` results are displayed to the user on the console.  \n  \n [!code-cs[Process_StandardInput#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_43_1.cs)]\n [!code-cpp[Process_StandardInput#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_43_1.cpp)]\n [!code-vb[Process_StandardInput#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_43_1.vb)]"
  syntax:
    content: public bool RedirectStandardInput { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если входные данные должны считываться из &lt;xref:System.Diagnostics.Process.StandardInput%2A?displayProperty=fullName&gt;; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.RedirectStandardInput*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  id: RedirectStandardOutput
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: RedirectStandardOutput
  nameWithType: ProcessStartInfo.RedirectStandardOutput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает значение, указывающее, записываются ли текстовые выходные данные приложения в &lt;xref:System.Diagnostics.Process.StandardOutput%2A?displayProperty=fullName&gt; потока."
  remarks: "Когда <xref:System.Diagnostics.Process>записывает текст в его стандартный поток, что текст обычно отображается на консоли.</xref:System.Diagnostics.Process> При присвоении RedirectStandardOutput `true` для перенаправления <xref:System.Diagnostics.Process.StandardOutput%2A>потока, можно управлять или подавлять вывод процесса.</xref:System.Diagnostics.Process.StandardOutput%2A> Например можно фильтровать текст, отформатировать его по-разному или записать выходные данные в консоль и назначенный файл журнала.      Настроек [!NOTE] настроек необходимо задать <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>для `false` чтобы присвоено RedirectStandardOutput `true`.</xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> В противном случае чтение из <xref:System.Diagnostics.Process.StandardOutput%2A>поток вызывает исключение.</xref:System.Diagnostics.Process.StandardOutput%2A>       Перенаправленный <xref:System.Diagnostics.Process.StandardOutput%2A>возможность чтения потока, синхронно или асинхронно.</xref:System.Diagnostics.Process.StandardOutput%2A> Такие методы, как <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, и <xref:System.IO.StreamReader.ReadToEnd%2A>выполнения синхронных операций чтения в выходной поток процесса.</xref:System.IO.StreamReader.ReadToEnd%2A> </xref:System.IO.StreamReader.ReadLine%2A> </xref:System.IO.StreamReader.Read%2A> Эти синхронного чтения операций не завершены, пока не связанный с ним <xref:System.Diagnostics.Process>записывает его <xref:System.Diagnostics.Process.StandardOutput%2A>потока или закрывает поток.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process>       Напротив <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>начинается асинхронных операций чтения на <xref:System.Diagnostics.Process.StandardOutput%2A>потока.</xref:System.Diagnostics.Process.StandardOutput%2A> </xref:System.Diagnostics.Process.BeginOutputReadLine%2A> Этот метод позволяет назначенный обработчик событий (см. <xref:System.Diagnostics.Process.OutputDataReceived>) для выходного потока и сразу же возвращает вызывающему объекту, который может выполнять другую работу во время вывода потока направляется в обработчик событий.</xref:System.Diagnostics.Process.OutputDataReceived>      Настроек [!NOTE] настроек приложения, которое обрабатывает асинхронный выход должен вызывать <xref:System.Diagnostics.Process.WaitForExit%2A>метод, чтобы гарантировать записан выходной буфер.</xref:System.Diagnostics.Process.WaitForExit%2A>       Синхронное чтение операций устанавливают зависимость между считыванием вызывающего оператора из <xref:System.Diagnostics.Process.StandardOutput%2A>поток и дочерний процесс записи в поток.</xref:System.Diagnostics.Process.StandardOutput%2A> Эти зависимости может привести к условиям взаимоблокировки. Если вызывающий объект считывает из перенаправленного потока дочернего процесса, он зависит от дочернего. Вызывающий объект ожидает операции чтения, пока дочерний элемент записывает в поток или закрывает поток. Если дочерний процесс записывает достаточно данных для заполнения своего перенаправленного потока, он зависит от родительского. Дочерний процесс ожидает следующей операции записи, пока родительский элемент считывает из полного потока или закрывает поток. Взаимоблокировка возникает, когда вызывающий объект и дочерний процесс ожидают друг друга для завершения операции и не может быть продолжена. Взаимоблокировок можно избежать, оценивая зависимости между вызывающим объектом и дочерним процессом.       Например следующий код C# показано, как считывание из перенаправленного потока и ожидание завершения дочернего процесса.      ```   Process p = new Process();   p.StartInfo.UseShellExecute = false;   p.StartInfo.RedirectStandardOutput = true;   p.StartInfo.FileName = &quot;Write500Lines.exe&quot;;   p.Start();      // To avoid deadlocks, always read the output stream first and then wait.   string output = p.StandardOutput.ReadToEnd();   p.WaitForExit();   ```В примере кода позволяет избежать состояния взаимоблокировки, вызвав `p.StandardOutput.ReadToEnd` перед `p.WaitForExit`. Условие взаимоблокировки могут случиться, если родительский процесс вызывает `p.WaitForExit` перед `p.StandardOutput.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения перенаправленного потока. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса. Дочерний процесс неограниченно долго будет ожидать родительским для чтения из полной <xref:System.Diagnostics.Process.StandardOutput%2A>потока.</xref:System.Diagnostics.Process.StandardOutput%2A>       Нет аналогичная проблема возникает при считывании всего текста из стандартный выход и Стандартная ошибка потоков. Например следующий код C# выполняет операции чтения в обоих потоках.      ```   // To avoid deadlocks, use asynchronous read operations on at least one of the streams.   // Do not perform a synchronous read to the end of both redirected streams.   p.BeginOutputReadLine();   string error = p.StandardError.ReadToEnd();   p.WaitForExit();   ```В примере кода позволяет избежать состояния взаимоблокировки, выполняя асинхронные операции чтения на <xref:System.Diagnostics.Process.StandardOutput%2A>потока.</xref:System.Diagnostics.Process.StandardOutput%2A> Условие взаимоблокировки возникает, если родительский процесс вызывает `p.StandardOutput.ReadToEnd` следуют `p.StandardError.ReadToEnd` и дочерний процесс записывает достаточно текста для заполнения его поток сообщений об ошибках. Родительский процесс неограниченно долго будет ожидать завершения дочернего процесса его <xref:System.Diagnostics.Process.StandardOutput%2A>потока.</xref:System.Diagnostics.Process.StandardOutput%2A> Дочерний процесс неограниченно долго будет ожидать родительским для чтения из полной <xref:System.Diagnostics.Process.StandardError%2A>потока.</xref:System.Diagnostics.Process.StandardError%2A>       Чтобы избежать этих зависимостей возможных взаимоблокировок можно использовать операции асинхронного чтения. Кроме того можно избежать состояния взаимоблокировки путем создания двух потоков и считывания выходных данных каждого потока в отдельном потоке."
  example:
  - >-
    [!code-cpp[ProcessOneStream#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_20_1.cpp)]
     [!code-cs[ProcessOneStream#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_20_1.cs)]
     [!code-vb[ProcessOneStream#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_20_1.vb)]
  syntax:
    content: public bool RedirectStandardOutput { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если выходные данные должны записываться в &lt;xref:System.Diagnostics.Process.StandardOutput%2A?displayProperty=fullName&gt;; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  id: StandardErrorEncoding
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: StandardErrorEncoding
  nameWithType: ProcessStartInfo.StandardErrorEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает предпочтительную кодировку для вывода ошибок."
  remarks: "Если значение свойства StandardErrorEncoding `null`, процесс использует стандартную ошибку кодировку для вывода ошибок. Необходимо задать свойство StandardErrorEncoding, до запуска процесса. Задание этого свойства не гарантирует, что процесс будет использовать указанную кодировку; процесс будет использовать только кодировки, которые она поддерживает. Приложения должны быть проверены на наличие поддерживаемые кодировки."
  syntax:
    content: public System.Text.Encoding StandardErrorEncoding { get; set; }
    return:
      type: System.Text.Encoding
      description: "Объект, представляющий предпочтительную кодировку для вывода ошибок. Значение по умолчанию — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  id: StandardOutputEncoding
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: StandardOutputEncoding
  nameWithType: ProcessStartInfo.StandardOutputEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает предпочтительную кодировку для стандартного вывода."
  remarks: "Если значение свойства StandardOutputEncoding `null`, процесс использует стандартный вывод кодировку для стандартного вывода. Необходимо задать свойство StandardOutputEncoding, до запуска процесса. Задание этого свойства не гарантирует, что процесс будет использовать указанную кодировку. Чтобы определить, какие кодировки, поддерживаемые процессом следует выполнить проверку приложения."
  syntax:
    content: public System.Text.Encoding StandardOutputEncoding { get; set; }
    return:
      type: System.Text.Encoding
      description: "Объект, представляющий предпочтительную кодировку для стандартного вывода. Значение по умолчанию — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.UserName
  id: UserName
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: UserName
  nameWithType: ProcessStartInfo.UserName
  fullName: System.Diagnostics.ProcessStartInfo.UserName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает имя пользователя для использования при запуске процесса."
  remarks: "> [!IMPORTANT]\n>  The <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> property must be set if UserName and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.  \n  \n If the UserName property is not `null` or an empty string, the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> property must be `false`, or an <xref:System.InvalidOperationException> will be thrown when the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> method is called."
  syntax:
    content: public string UserName { get; set; }
    return:
      type: System.String
      description: "Имя пользователя для использования при запуске процесса."
  overload: System.Diagnostics.ProcessStartInfo.UserName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute
  id: UseShellExecute
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: UseShellExecute
  nameWithType: ProcessStartInfo.UseShellExecute
  fullName: System.Diagnostics.ProcessStartInfo.UseShellExecute
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает значение, указывающее, следует ли использовать оболочку операционной системы для запуска процесса."
  remarks: "Присвоение этому свойству `false` можно перенаправлять потоки ввода, вывода и ошибки.      Настроек [!NOTE] настроек UseShellExecute должно быть `false` Если <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>свойство не `null` или является пустой строкой или <xref:System.InvalidOperationException>возникает при <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName>вызывается метод.</xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=fullName> </xref:System.InvalidOperationException> </xref:System.Diagnostics.ProcessStartInfo.UserName%2A>       При использовании оболочки операционной системы для запуска процессов можно запустить любой документ (который является любым типом зарегистрированный файл, связанный с исполняемым, имеющий активное действие по умолчанию) и выполнять операции над файлом, например печать, с помощью <xref:System.Diagnostics.Process>объекта.</xref:System.Diagnostics.Process> При UseShellExecute `false`, можно запускать только исполняемые файлы с помощью <xref:System.Diagnostics.Process>объекта.</xref:System.Diagnostics.Process>      Настроек [!NOTE] настроек UseShellExecute должно быть `true` при установке <xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>Свойства `true`.</xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>       <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>Свойство ведет себя по-разному в зависимости от значения свойства UseShellExecute.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> При UseShellExecute `true`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>свойство определяет расположение исполняемого файла.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Если <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>является пустой строкой, предполагается, что текущий каталог содержит исполняемый файл.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>       При UseShellExecute `false`, <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>свойство не используется для поиска исполняемого файла.</xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A> Вместо этого он используется только процессом, который запущен и имеет смысл только в контексте нового процесса. При UseShellExecute `false`, <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>свойство может быть полный путь к исполняемому файлу или простое имя исполняемого файла, который система будет пытаться найти внутри папки, указанные в переменной среды PATH.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A>"
  example:
  - >-
    [!code-cpp[ProcessOneStream#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_44_1.cpp)]
     [!code-cs[ProcessOneStream#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_44_1.cs)]
     [!code-vb[ProcessOneStream#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_44_1.vb)]
  syntax:
    content: public bool UseShellExecute { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если оболочка должна использоваться при запуске процесса; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если процесс должен быть создан непосредственно из исполняемого файла. Значение по умолчанию — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.UseShellExecute*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Verb
  id: Verb
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Verb
  nameWithType: ProcessStartInfo.Verb
  fullName: System.Diagnostics.ProcessStartInfo.Verb
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает команду, используемую при открытии приложения или документа, указанного в <xref:System.Diagnostics.ProcessStartInfo.FileName*>свойство.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  remarks: "Каждого расширения имени файла имеет собственный набор команд, которые могут быть получены с помощью <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>свойство.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> Например «`print`» распечатает документ, указанный с помощью <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Команду по умолчанию можно задать, используя пустую строку (»»). Примеры команд, которые являются «Изменить», «Открыть», «OpenAsReadOnly», «Печать» и «Printto». Следует использовать только те команды, которые появятся в наборе команд, возвращаемом в <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>свойство.</xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>       При использовании свойство Verb, необходимо включить расширение имени файла при установке значения для <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>свойство.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Имя файла не указано расширение, если вручную ввести значение для свойства команды."
  example:
  - "The following code example starts a new process by using the specified verb and file name. This code example is part of a larger example provided for the <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> property.  \n  \n [!code-vb[ProcessVerbs_Diagnostics#4](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_9_1.vb)]\n [!code-cs[ProcessVerbs_Diagnostics#4](~/add/codesnippet/csharp/p-system.diagnostics.pro_9_1.cs)]"
  syntax:
    content: public string Verb { get; set; }
    return:
      type: System.String
      description: "Действие, выполняемое с файлом, который открывается данным процессом. Значение по умолчанию — пустая строка (&quot;»), что означает никаких действий."
  overload: System.Diagnostics.ProcessStartInfo.Verb*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.Verbs
  id: Verbs
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: Verbs
  nameWithType: ProcessStartInfo.Verbs
  fullName: System.Diagnostics.ProcessStartInfo.Verbs
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает набор команд, связанных с типом файла, указанного параметром <xref:System.Diagnostics.ProcessStartInfo.FileName*>свойство.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  remarks: "Свойство Verbs можно определить команды, используется файл, указанный параметром <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>свойство.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Можно задать <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>значение любой команды в наборе.</xref:System.Diagnostics.ProcessStartInfo.Verb%2A> Примеры команд, которые являются «Изменить», «Открыть», «OpenAsReadOnly», «Печать» и «Printto».       При использовании свойство Verbs должен включать расширение имени файла, при установке значения для <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>свойство.</xref:System.Diagnostics.ProcessStartInfo.FileName%2A> Расширение имени файла определяет набор возможных команд."
  example:
  - "The following code example displays the defined verbs for the chosen file name. If the user selects one of the defined verbs, the example starts a new process using the selected verb and the input file name.  \n  \n [!code-vb[ProcessVerbs_Diagnostics#3](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_7_1.vb)]\n [!code-cs[ProcessVerbs_Diagnostics#3](~/add/codesnippet/csharp/p-system.diagnostics.pro_7_1.cs)]"
  syntax:
    content: public string[] Verbs { get; }
    return:
      type: System.String[]
      description: "Указывает действия, которые система может применить к файлу <xref:System.Diagnostics.ProcessStartInfo.FileName*>свойство.</xref:System.Diagnostics.ProcessStartInfo.FileName*>"
  overload: System.Diagnostics.ProcessStartInfo.Verbs*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.WindowStyle
  id: WindowStyle
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: WindowStyle
  nameWithType: ProcessStartInfo.WindowStyle
  fullName: System.Diagnostics.ProcessStartInfo.WindowStyle
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает состояние окна, используемое при запуске процесса."
  remarks: ''
  example:
  - >-
    [!code-vb[Process.Start_static#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_42_1.vb)]
     [!code-cs[Process.Start_static#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_42_1.cs)]
     [!code-cpp[Process.Start_static#1](~/add/codesnippet/cpp/p-system.diagnostics.pro_42_1.cpp)]
  syntax:
    content: public System.Diagnostics.ProcessWindowStyle WindowStyle { get; set; }
    return:
      type: System.Diagnostics.ProcessWindowStyle
      description: "Одно из значений перечисления, которое показывает, запущен ли процесс в окне, которое развернуто, свернутое, обычное (ни полноэкранное ни свернутое) или невидимое. Значение по умолчанию — <xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessStartInfo.WindowStyle*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "Стиль окна не является одним из <xref href=&quot;System.Diagnostics.ProcessWindowStyle&quot;> </xref> членов перечисления."
  platform:
  - net462
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  id: WorkingDirectory
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  name: WorkingDirectory
  nameWithType: ProcessStartInfo.WorkingDirectory
  fullName: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Когда <> </> *настроек свойство <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>, возвращает или задает рабочую папку для запускаемого процесса. Когда <> </> *настроек — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, возвращает или задает каталог, содержащий запускаемого процесса."
  remarks: "> [!IMPORTANT]\n>  The WorkingDirectory property must be set if <xref:System.Diagnostics.ProcessStartInfo.UserName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A> are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.  \n  \n If the directory is already part of the system path variable, you do not have to repeat the directory's location in this property.  \n  \n The WorkingDirectory property behaves differently when <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` than when <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `false`. When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true`, the WorkingDirectory property specifies the location of the executable. If WorkingDirectory is an empty string, the current directory is understood to contain the executable.  \n  \n> [!NOTE]\n>  When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true`, the working directory of the application that starts the executable is also the working directory of the executable.  \n  \n When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `false`, the WorkingDirectory property is not used to find the executable. Instead, its value applies to the process that is started and only has meaning within the context of the new process."
  syntax:
    content: public string WorkingDirectory { get; set; }
    return:
      type: System.String
      description: "Когда <> </> *настроек — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>, полное имя каталога, содержащего запускаемого процесса. Когда <> </> *настроек свойство <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>, рабочую папку для запускаемого процесса. Значение по умолчанию — пустая строка (»»)."
  overload: System.Diagnostics.ProcessStartInfo.WorkingDirectory*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Diagnostics.ProcessStartInfo.#ctor
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo()
  nameWithType: ProcessStartInfo.ProcessStartInfo()
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo()
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo(String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo(String,String)
  nameWithType: ProcessStartInfo.ProcessStartInfo(String,String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(String,String)
- uid: System.Diagnostics.ProcessStartInfo.Arguments
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Arguments
  nameWithType: ProcessStartInfo.Arguments
  fullName: System.Diagnostics.ProcessStartInfo.Arguments
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: CreateNoWindow
  nameWithType: ProcessStartInfo.CreateNoWindow
  fullName: System.Diagnostics.ProcessStartInfo.CreateNoWindow
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.ProcessStartInfo.Domain
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Domain
  nameWithType: ProcessStartInfo.Domain
  fullName: System.Diagnostics.ProcessStartInfo.Domain
- uid: System.Diagnostics.ProcessStartInfo.Environment
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Environment
  nameWithType: ProcessStartInfo.Environment
  fullName: System.Diagnostics.ProcessStartInfo.Environment
- uid: System.Collections.Generic.IDictionary{System.String,System.String}
  parent: System.Collections.Generic
  isExternal: true
  name: IDictionary<String,String>
  nameWithType: IDictionary<String,String>
  fullName: System.Collections.Generic.IDictionary<System.String,System.String>
  spec.csharp:
  - uid: System.Collections.Generic.IDictionary`2
    name: IDictionary
    nameWithType: IDictionary
    fullName: IDictionary<System.String,System.String>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: EnvironmentVariables
  nameWithType: ProcessStartInfo.EnvironmentVariables
  fullName: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
- uid: System.Collections.Specialized.StringDictionary
  parent: System.Collections.Specialized
  isExternal: false
  name: StringDictionary
  nameWithType: StringDictionary
  fullName: System.Collections.Specialized.StringDictionary
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialog
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialog
  nameWithType: ProcessStartInfo.ErrorDialog
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialog
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialogParentHandle
  nameWithType: ProcessStartInfo.ErrorDialogParentHandle
  fullName: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.ProcessStartInfo.FileName
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: FileName
  nameWithType: ProcessStartInfo.FileName
  fullName: System.Diagnostics.ProcessStartInfo.FileName
- uid: System.Diagnostics.ProcessStartInfo.LoadUserProfile
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: LoadUserProfile
  nameWithType: ProcessStartInfo.LoadUserProfile
  fullName: System.Diagnostics.ProcessStartInfo.LoadUserProfile
- uid: System.Diagnostics.ProcessStartInfo.Password
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Password
  nameWithType: ProcessStartInfo.Password
  fullName: System.Diagnostics.ProcessStartInfo.Password
- uid: System.Security.SecureString
  parent: System.Security
  isExternal: false
  name: SecureString
  nameWithType: SecureString
  fullName: System.Security.SecureString
- uid: System.Diagnostics.ProcessStartInfo.PasswordInClearText
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: PasswordInClearText
  nameWithType: ProcessStartInfo.PasswordInClearText
  fullName: System.Diagnostics.ProcessStartInfo.PasswordInClearText
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardError
  nameWithType: ProcessStartInfo.RedirectStandardError
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardError
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardInput
  nameWithType: ProcessStartInfo.RedirectStandardInput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardOutput
  nameWithType: ProcessStartInfo.RedirectStandardOutput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardErrorEncoding
  nameWithType: ProcessStartInfo.StandardErrorEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
- uid: System.Text.Encoding
  parent: System.Text
  isExternal: true
  name: Encoding
  nameWithType: Encoding
  fullName: System.Text.Encoding
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardOutputEncoding
  nameWithType: ProcessStartInfo.StandardOutputEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
- uid: System.Diagnostics.ProcessStartInfo.UserName
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UserName
  nameWithType: ProcessStartInfo.UserName
  fullName: System.Diagnostics.ProcessStartInfo.UserName
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UseShellExecute
  nameWithType: ProcessStartInfo.UseShellExecute
  fullName: System.Diagnostics.ProcessStartInfo.UseShellExecute
- uid: System.Diagnostics.ProcessStartInfo.Verb
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verb
  nameWithType: ProcessStartInfo.Verb
  fullName: System.Diagnostics.ProcessStartInfo.Verb
- uid: System.Diagnostics.ProcessStartInfo.Verbs
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verbs
  nameWithType: ProcessStartInfo.Verbs
  fullName: System.Diagnostics.ProcessStartInfo.Verbs
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.ProcessStartInfo.WindowStyle
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WindowStyle
  nameWithType: ProcessStartInfo.WindowStyle
  fullName: System.Diagnostics.ProcessStartInfo.WindowStyle
- uid: System.Diagnostics.ProcessWindowStyle
  parent: System.Diagnostics
  isExternal: false
  name: ProcessWindowStyle
  nameWithType: ProcessWindowStyle
  fullName: System.Diagnostics.ProcessWindowStyle
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WorkingDirectory
  nameWithType: ProcessStartInfo.WorkingDirectory
  fullName: System.Diagnostics.ProcessStartInfo.WorkingDirectory
- uid: System.Diagnostics.ProcessStartInfo.#ctor*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ProcessStartInfo
  nameWithType: ProcessStartInfo.ProcessStartInfo
- uid: System.Diagnostics.ProcessStartInfo.Arguments*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Arguments
  nameWithType: ProcessStartInfo.Arguments
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: CreateNoWindow
  nameWithType: ProcessStartInfo.CreateNoWindow
- uid: System.Diagnostics.ProcessStartInfo.Domain*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Domain
  nameWithType: ProcessStartInfo.Domain
- uid: System.Diagnostics.ProcessStartInfo.Environment*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Environment
  nameWithType: ProcessStartInfo.Environment
- uid: System.Diagnostics.ProcessStartInfo.EnvironmentVariables*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: EnvironmentVariables
  nameWithType: ProcessStartInfo.EnvironmentVariables
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialog*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialog
  nameWithType: ProcessStartInfo.ErrorDialog
- uid: System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: ErrorDialogParentHandle
  nameWithType: ProcessStartInfo.ErrorDialogParentHandle
- uid: System.Diagnostics.ProcessStartInfo.FileName*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: FileName
  nameWithType: ProcessStartInfo.FileName
- uid: System.Diagnostics.ProcessStartInfo.LoadUserProfile*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: LoadUserProfile
  nameWithType: ProcessStartInfo.LoadUserProfile
- uid: System.Diagnostics.ProcessStartInfo.Password*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Password
  nameWithType: ProcessStartInfo.Password
- uid: System.Diagnostics.ProcessStartInfo.PasswordInClearText*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: PasswordInClearText
  nameWithType: ProcessStartInfo.PasswordInClearText
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardError
  nameWithType: ProcessStartInfo.RedirectStandardError
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardInput
  nameWithType: ProcessStartInfo.RedirectStandardInput
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: RedirectStandardOutput
  nameWithType: ProcessStartInfo.RedirectStandardOutput
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardErrorEncoding
  nameWithType: ProcessStartInfo.StandardErrorEncoding
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: StandardOutputEncoding
  nameWithType: ProcessStartInfo.StandardOutputEncoding
- uid: System.Diagnostics.ProcessStartInfo.UserName*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UserName
  nameWithType: ProcessStartInfo.UserName
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: UseShellExecute
  nameWithType: ProcessStartInfo.UseShellExecute
- uid: System.Diagnostics.ProcessStartInfo.Verb*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verb
  nameWithType: ProcessStartInfo.Verb
- uid: System.Diagnostics.ProcessStartInfo.Verbs*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: Verbs
  nameWithType: ProcessStartInfo.Verbs
- uid: System.Diagnostics.ProcessStartInfo.WindowStyle*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WindowStyle
  nameWithType: ProcessStartInfo.WindowStyle
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory*
  parent: System.Diagnostics.ProcessStartInfo
  isExternal: false
  name: WorkingDirectory
  nameWithType: ProcessStartInfo.WorkingDirectory
