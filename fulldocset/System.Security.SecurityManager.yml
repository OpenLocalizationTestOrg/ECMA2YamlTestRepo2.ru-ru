### YamlMime:ManagedReference
items:
- uid: System.Security.SecurityManager
  id: SecurityManager
  children:
  - System.Security.SecurityManager.CheckExecutionRights
  - System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture
  - System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  - System.Security.SecurityManager.IsGranted(System.Security.IPermission)
  - System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  - System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  - System.Security.SecurityManager.PolicyHierarchy
  - System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])
  - System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  - System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)
  - System.Security.SecurityManager.SavePolicy
  - System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)
  - System.Security.SecurityManager.SecurityEnabled
  langs:
  - csharp
  name: SecurityManager
  nameWithType: SecurityManager
  fullName: System.Security.SecurityManager
  type: Class
  summary: "Предоставляет главную точку доступа для классов, взаимодействующих с системой безопасности. Этот класс не наследуется."
  remarks: "Система безопасности предоставляет методы доступа и управления конфигурации политики безопасности. Не удается создать экземпляры SecurityManager."
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public static class SecurityManager
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Security.SecurityManager.CheckExecutionRights
  id: CheckExecutionRights
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: CheckExecutionRights
  nameWithType: SecurityManager.CheckExecutionRights
  fullName: System.Security.SecurityManager.CheckExecutionRights
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Возвращает или задает значение, указывающее, требуется ли коду <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref> для выполнения."
  remarks: "Если это свойство имеет `false`, включая код без <xref:System.Security.Permissions.SecurityPermissionFlag>могут выполнять.</xref:System.Security.Permissions.SecurityPermissionFlag> Проверка выполнения высока и устранения преимущества разрешения политики. Это свойство позволяет отключить проверку при необходимости выполнения.       Изменение этого свойства не сохраняется до <xref:System.Security.SecurityManager.SavePolicy%2A>называется.</xref:System.Security.SecurityManager.SavePolicy%2A> Новые процессы не затрагиваются изменением пока оно сохраняется в реестре."
  syntax:
    content: public static bool CheckExecutionRights { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если код должен иметь <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref> для выполнения; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.SecurityManager.CheckExecutionRights*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Код, который вызывает этот метод не имеет <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture
  id: CurrentThreadRequiresSecurityContextCapture
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: CurrentThreadRequiresSecurityContextCapture()
  nameWithType: SecurityManager.CurrentThreadRequiresSecurityContextCapture()
  fullName: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Определяет, требуется ли текущий поток записи контекста безопасности, если состояние безопасности должен быть восстановлен на более позднее время."
  remarks: "Можно использовать метод CurrentThreadRequiresSecurityContextCapture, прежде чем кэшировать конфиденциальных данных, получаемых после выполнения всех требований безопасности, успешно.       Если <xref:System.Security.CodeAccessPermission.Assert%2A>был вызван метод выше в стеке, не следует кэшировать данные без записи соответствующего контекста безопасности.</xref:System.Security.CodeAccessPermission.Assert%2A> В противном случае — конфиденциальных данных, получаемых в <xref:System.Security.CodeAccessPermission.Assert%2A>могут стать доступны для кода, то есть не работает с, <xref:System.Security.CodeAccessPermission.Assert%2A>на месте.</xref:System.Security.CodeAccessPermission.Assert%2A> </xref:System.Security.CodeAccessPermission.Assert%2A>      Настроек [!IMPORTANT] настроек возвращаемое значение является надежным, только когда она `false`, что означает, что поток гарантированно не требует записи контекста безопасности. Метод может возвращать значение true, если записи контекста безопасности нет необходимости, во избежание возникновения уязвимостей системы безопасности.       CurrentThreadRequiresSecurityContextCapture является критическим с точки зрения безопасности, так как его основное назначение — Чтобы избежать ненужных безопасности контекста захватывает, который указывает, что код, использующий его конфиденциальные и необходимо проверить."
  syntax:
    content: public static bool CurrentThreadRequiresSecurityContextCapture ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Если стек содержит нет доменов приложения с частичным доверием, не частично доверенным сборкам и нет активного <> </> *настроек или <> </> *настроек модификаторы. <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Если общеязыковая среда выполнения не может гарантировать, что стек не содержит ни одного из них."
  overload: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture*
  exceptions: []
  platform:
  - net462
- uid: System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)
  id: GetStandardSandbox(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: GetStandardSandbox(Evidence)
  nameWithType: SecurityManager.GetStandardSandbox(Evidence)
  fullName: System.Security.SecurityManager.GetStandardSandbox(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Возвращает набор разрешений, можно безопасно предоставить приложению с предоставленного свидетельства."
  remarks: "> [!NOTE]Настроек в [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], узел свидетельства в `evidence` должен содержать <xref:System.Security.Policy.Zone?displayProperty=fullName>свидетельство.</xref:System.Security.Policy.Zone?displayProperty=fullName>   >> В следующей таблице показаны наборы разрешений, которые возвращаются для каждой зоны.      | Зоны | Набор разрешений |   |----------|--------------------|   | <xref:System.Security.SecurityZone>| `FullTrust`|   | <xref:System.Security.SecurityZone>| `LocalIntranet`|   | <xref:System.Security.SecurityZone>| `Internet`|   | <xref:System.Security.SecurityZone>| `Internet`|   | <xref:System.Security.SecurityZone>| None |   | <xref:System.Security.SecurityZone>| None |       Другие свидетельства, такие как <xref:System.Security.Policy.Url>или <xref:System.Security.Policy.Site>, может считаться.</xref:System.Security.Policy.Site> </xref:System.Security.Policy.Url> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone> </xref:System.Security.SecurityZone>       Возвращаемый набор разрешений может использоваться в &quot;песочнице&quot; для запуска приложения. Обратите внимание, что этот метод не задает политику, но позволяет основному приложению определить, является ли набор разрешений, запрошенный приложением разумного. Этот метод можно использовать для сопоставления зоны &quot;песочницу&quot;."
  example:
  - "The following example shows how to use the GetStandardSandbox method to obtain the permission set for a sandboxed application. For more information about running an application in a sandbox, see [How to: Run Partially Trusted Code in a Sandbox](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[sandboxingApis#1](~/add/codesnippet/visualbasic/2aad9996-0182-4c3d-a405-_1.vb)]\n [!code-cs[sandboxingApis#1](~/add/codesnippet/csharp/2aad9996-0182-4c3d-a405-_1.cs)]"
  syntax:
    content: public static System.Security.PermissionSet GetStandardSandbox (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Свидетельство узла для сопоставления в набор разрешений."
    return:
      type: System.Security.PermissionSet
      description: "Набор разрешений, который может использоваться для выдачи для приложения, которое имеет предоставленного свидетельства."
  overload: System.Security.SecurityManager.GetStandardSandbox*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>evidence</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  id: GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: GetZoneAndOrigin(ArrayList,ArrayList)
  nameWithType: SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
  fullName: System.Security.SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Получает идентификатор разрешенной зоны и наборы разрешений идентификатора URL для текущей сборки."
  remarks: "Этот метод рекомендуется для использования свидетельства URL-адрес и зону для выполнения сборки для вызова <xref:System.Security.SecurityManager.ResolvePolicy%2A>для каждого типа свидетельство.</xref:System.Security.SecurityManager.ResolvePolicy%2A> Наборы разрешений, возвращенные <xref:System.Security.SecurityManager.ResolvePolicy%2A>вызовы определить разрешения, предоставленные выполняющейся сборки, на основе его зоны и URL-адрес источника.</xref:System.Security.SecurityManager.ResolvePolicy%2A>      Настроек [!NOTE] настроек этот член создает запрос ссылки для открытого ключа ECMA, который не является действительным ключом шифрования, а ключ псевдо. В .NET Framework в запрос ссылки для открытого ключа Microsoft автоматически преобразуется компоновки для псевдо ключ ECMA. Исключение безопасности основывается на открытом ключе Майкрософт, а не псевдо ключ ECMA."
  syntax:
    content: public static void GetZoneAndOrigin (out System.Collections.ArrayList zone, out System.Collections.ArrayList origin);
    parameters:
    - id: zone
      type: System.Collections.ArrayList
      description: "Выходной параметр, содержащий <xref href=&quot;System.Collections.ArrayList&quot;> </xref> из предоставленных <xref:System.Security.Permissions.ZoneIdentityPermissionAttribute.Zone*>объектов.</xref:System.Security.Permissions.ZoneIdentityPermissionAttribute.Zone*>"
    - id: origin
      type: System.Collections.ArrayList
      description: "Выходной параметр, содержащий <xref href=&quot;System.Collections.ArrayList&quot;> </xref> из предоставленных <xref href=&quot;System.Security.Permissions.UrlIdentityPermission&quot;> </xref> объектов."
  overload: System.Security.SecurityManager.GetZoneAndOrigin*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Запрос <xref href=&quot;System.Security.Permissions.StrongNameIdentityPermission&quot;> </xref> сбой."
  platform:
  - net462
- uid: System.Security.SecurityManager.IsGranted(System.Security.IPermission)
  id: IsGranted(System.Security.IPermission)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: IsGranted(IPermission)
  nameWithType: SecurityManager.IsGranted(IPermission)
  fullName: System.Security.SecurityManager.IsGranted(IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Определяет, является ли разрешения вызывающему."
  remarks: "Предоставление разрешений определяется политикой и отличается от требований, подлежащих переопределению, например утверждений. Кроме того IsGranted проверяет только предоставление разрешения сборке вызывающего кода, независимо от других вызывающих объектов в стеке."
  syntax:
    content: public static bool IsGranted (System.Security.IPermission perm);
    parameters:
    - id: perm
      type: System.Security.IPermission
      description: "Разрешение для проверки разрешений вызывающего объекта."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если разрешений, предоставленных вызывающему включает разрешение <code> perm </code>; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.SecurityManager.IsGranted*
  exceptions: []
  platform:
  - net462
- uid: System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  id: LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: LoadPolicyLevelFromFile(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Загружает <xref href=&quot;System.Security.Policy.PolicyLevel&quot;> </xref> из указанного файла."
  syntax:
    content: public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile (string path, System.Security.PolicyLevelType type);
    parameters:
    - id: path
      type: System.String
      description: "Физический путь к файлу, содержащему сведения о политике безопасности."
    - id: type
      type: System.Security.PolicyLevelType
      description: "Одно из значений перечисления, указывающее тип уровня политики для загрузки."
    return:
      type: System.Security.Policy.PolicyLevel
      description: "Уровень загрузки политики."
  overload: System.Security.SecurityManager.LoadPolicyLevelFromFile*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Файл, указанный в <code> path </code> параметр не существует."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Код, который вызывает этот метод не имеет <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>.       - или - код, который вызывает этот метод не имеет <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>.       - или - код, который вызывает этот метод не имеет <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>.       - или - код, который вызывает этот метод не имеет <xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Этот метод использует политику разграничения доступа кода, которая является устаревшим в [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Чтобы включить политику CAS для обеспечения совместимости с предыдущими версиями платформы .NET Framework, используйте [ &lt;legacyCasPolicy&gt; элемент](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  id: LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: LoadPolicyLevelFromString(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Загружает <xref href=&quot;System.Security.Policy.PolicyLevel&quot;> </xref> из указанной строки."
  syntax:
    content: public static System.Security.Policy.PolicyLevel LoadPolicyLevelFromString (string str, System.Security.PolicyLevelType type);
    parameters:
    - id: str
      type: System.String
      description: "XML-представление уровня политики безопасности в том же виде, в котором он отображается в файле конфигурации."
    - id: type
      type: System.Security.PolicyLevelType
      description: "Одно из значений перечисления, указывающее тип уровня политики для загрузки."
    return:
      type: System.Security.Policy.PolicyLevel
      description: "Уровень загрузки политики."
  overload: System.Security.SecurityManager.LoadPolicyLevelFromString*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>str</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> str </code> Указан недопустимый параметр."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Код, который вызывает этот метод не имеет <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.PolicyHierarchy
  id: PolicyHierarchy
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: PolicyHierarchy()
  nameWithType: SecurityManager.PolicyHierarchy()
  fullName: System.Security.SecurityManager.PolicyHierarchy()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Предоставляет перечислитель для доступа к иерархии политики безопасности, уровней, таких как политики пользователей и компьютеров."
  remarks: "Возвращаемый перечислитель предоставляет последовательных <xref:System.Security.Policy.PolicyLevel>объекты, представляющие политику на соответствующем (компьютера, пользователя, предприятия, домена приложения) уровне иерархии.</xref:System.Security.Policy.PolicyLevel> Эти объекты являются объектами динамической политики; Изменение этих объектов может привести к непредсказуемым результатам.       Минимальная иерархия политик состоит из уровне компьютера, предприятия и уровень пользователя. Тем не менее иерархия может содержать дополнительные уровни."
  syntax:
    content: public static System.Collections.IEnumerator PolicyHierarchy ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "Перечислитель для <xref href=&quot;System.Security.Policy.PolicyLevel&quot;> </xref> объектами, которые образуют иерархию политик безопасности."
  overload: System.Security.SecurityManager.PolicyHierarchy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Этот метод использует политику разграничения доступа кода, которая является устаревшим в [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Чтобы включить политику CAS для обеспечения совместимости с предыдущими версиями платформы .NET Framework, используйте [ &lt;legacyCasPolicy&gt; элемент](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Код, который вызывает этот метод не имеет <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)
  id: ResolvePolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicy(Evidence)
  nameWithType: SecurityManager.ResolvePolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Определяет, какие разрешения для предоставления кода на основе заданного свидетельства."
  remarks: "Этот метод вызывает обработчик политики безопасности, передавая ему свидетельство идентификатора вызывающего кода. Результат определяется политикой безопасности."
  syntax:
    content: public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Набор свидетельств, используемых для оценки политики."
    return:
      type: System.Security.PermissionSet
      description: "Набор разрешений, которые могут быть предоставлены системой безопасности."
  overload: System.Security.SecurityManager.ResolvePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Этот метод использует политику разграничения доступа кода, которая является устаревшим в [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Чтобы включить политику CAS для обеспечения совместимости с предыдущими версиями платформы .NET Framework, используйте [ &lt;legacyCasPolicy&gt; элемент](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])
  id: ResolvePolicy(System.Security.Policy.Evidence[])
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicy(Evidence[])
  nameWithType: SecurityManager.ResolvePolicy(Evidence[])
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Определяет, какие разрешения для предоставления кода на основе заданного свидетельства."
  remarks: "Этот метод вызывает обработчик политики безопасности, передавая ему массив <xref:System.Security.Policy.Evidence>объектов.</xref:System.Security.Policy.Evidence> Возвращаемый набор разрешений представляет только те разрешения, которые относятся к каждому свидетельству в массиве. Эти разрешения являются эквивалентен или подмножество разрешения, которые были бы предоставлены политикой для каждого конкретного свидетельства. Этот метод работает, как если бы выполнялся пересечения результатов разрешения политик для каждого из <xref:System.Security.Policy.Evidence>объекты в массиве.</xref:System.Security.Policy.Evidence>"
  syntax:
    content: public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence[] evidences);
    parameters:
    - id: evidences
      type: System.Security.Policy.Evidence[]
      description: "Массив объектов свидетельств, используемых для оценки политики."
    return:
      type: System.Security.PermissionSet
      description: "Набор разрешений, который подходит для всех предоставленного свидетельства."
  overload: System.Security.SecurityManager.ResolvePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Этот метод использует политику разграничения доступа кода, которая является устаревшим в [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Чтобы включить политику CAS для обеспечения совместимости с предыдущими версиями платформы .NET Framework, используйте [ &lt;legacyCasPolicy&gt; элемент](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  id: ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Определяет, какие разрешения для предоставления кода на основе указанного свидетельства и запросов."
  remarks: "Этот метод вызывает обработчик политики безопасности, передавая ему свидетельство идентификатора вызывающего кода и набор разрешений, код запросов. Результат определяется политикой безопасности. Этот метод возвращает набор разрешений, которые должны быть предоставлены системой безопасности и возвращает набор разрешений, которые должны быть отклонены как выходной параметр. Действующие разрешения, предоставленные являются членами набора предоставленных разрешений, которые не являются запрещенного набора."
  syntax:
    content: public static System.Security.PermissionSet ResolvePolicy (System.Security.Policy.Evidence evidence, System.Security.PermissionSet reqdPset, System.Security.PermissionSet optPset, System.Security.PermissionSet denyPset, out System.Security.PermissionSet denied);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Набор свидетельств, используемых для оценки политики."
    - id: reqdPset
      type: System.Security.PermissionSet
      description: "Разрешения, которые требуется выполнить коду."
    - id: optPset
      type: System.Security.PermissionSet
      description: "Необязательные разрешения, которые будут использоваться, если предоставлено, но не являются обязательными для выполнения кода."
    - id: denyPset
      type: System.Security.PermissionSet
      description: "Запрещенные разрешения, которые никогда не должны предоставляться коду, даже если для политики, которые в противном случае он."
    - id: denied
      type: System.Security.PermissionSet
      description: "Выходной параметр, содержащий набор разрешений, которые не предоставляются."
    return:
      type: System.Security.PermissionSet
      description: "Набор разрешений, которые должны быть предоставлены системой безопасности."
  overload: System.Security.SecurityManager.ResolvePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Этот метод использует политику разграничения доступа кода, которая является устаревшим в [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Чтобы включить политику CAS для обеспечения совместимости с предыдущими версиями платформы .NET Framework, используйте [ &lt;legacyCasPolicy&gt; элемент](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "Политика не может предоставить минимальные требуемые разрешения, указанные <code> reqdPset </code> параметра."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)
  id: ResolvePolicyGroups(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolvePolicyGroups(Evidence)
  nameWithType: SecurityManager.ResolvePolicyGroups(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicyGroups(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Получает коллекцию групп кода, соответствующих указанному свидетельству."
  remarks: "Этот метод полезен при анализе как определенная конфигурация политики взаимодействует с определенными типами свидетельства.       Группы кода возвращаются со всех применимых уровней в иерархии политик соответствия `evidence` параметра."
  syntax:
    content: public static System.Collections.IEnumerator ResolvePolicyGroups (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Набор свидетельств, относительно которого оценивается политика."
    return:
      type: System.Collections.IEnumerator
      description: "Перечисление набора групп кода, соответствующих свидетельству."
  overload: System.Security.SecurityManager.ResolvePolicyGroups*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Этот метод использует политику разграничения доступа кода, которая является устаревшим в [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Чтобы включить политику CAS для обеспечения совместимости с предыдущими версиями платформы .NET Framework, используйте [ &lt;legacyCasPolicy&gt; элемент](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)
  id: ResolveSystemPolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: ResolveSystemPolicy(Evidence)
  nameWithType: SecurityManager.ResolveSystemPolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolveSystemPolicy(Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Определяет, какие разрешения следует предоставить коду исходя из указанного свидетельства, за исключением политик <xref href=&quot;System.AppDomain&quot;> </xref> уровне."
  remarks: "Этот метод вызывает обработчик политики безопасности и предоставляет ему свидетельство идентификатора вызывающего кода. Результат определяется политикой безопасности системы исключают любой <xref:System.AppDomain>политики.</xref:System.AppDomain>"
  syntax:
    content: public static System.Security.PermissionSet ResolveSystemPolicy (System.Security.Policy.Evidence evidence);
    parameters:
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "Набор свидетельств, используемых для оценки политики."
    return:
      type: System.Security.PermissionSet
      description: "Набор разрешений, которые могут быть предоставлены системой безопасности."
  overload: System.Security.SecurityManager.ResolveSystemPolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Этот метод использует политику разграничения доступа кода, которая является устаревшим в [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Чтобы включить политику CAS для обеспечения совместимости с предыдущими версиями платформы .NET Framework, используйте [ &lt;legacyCasPolicy&gt; элемент](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.SavePolicy
  id: SavePolicy
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: SavePolicy()
  nameWithType: SecurityManager.SavePolicy()
  fullName: System.Security.SecurityManager.SavePolicy()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Сохраняет измененное состояние политики безопасности."
  remarks: "Этот метод сохраняет политику, как представлено <xref:System.Security.SecurityManager.PolicyHierarchy%2A>, <xref:System.Security.Policy.PolicyLevel>, и другие классы, представляющими текущую конфигурацию политики безопасности.</xref:System.Security.Policy.PolicyLevel> </xref:System.Security.SecurityManager.PolicyHierarchy%2A> Если этот метод вызывается, изменения, внесенные в объекты политики не будут сохранены и не повлияет на последующие запуски приложения."
  syntax:
    content: public static void SavePolicy ();
    parameters: []
  overload: System.Security.SecurityManager.SavePolicy*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Этот метод использует политику разграничения доступа кода, которая является устаревшим в [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Чтобы включить политику CAS для обеспечения совместимости с предыдущими версиями платформы .NET Framework, используйте [ &lt;legacyCasPolicy&gt; элемент](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Код, который вызывает этот метод не имеет <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  platform:
  - net462
- uid: System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)
  id: SavePolicyLevel(System.Security.Policy.PolicyLevel)
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: SavePolicyLevel(PolicyLevel)
  nameWithType: SecurityManager.SavePolicyLevel(PolicyLevel)
  fullName: System.Security.SecurityManager.SavePolicyLevel(PolicyLevel)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Сохраняет измененный уровень политики безопасности загружен с <xref:System.Security.SecurityManager.LoadPolicyLevelFromFile*>.</xref:System.Security.SecurityManager.LoadPolicyLevelFromFile*>"
  remarks: "<xref:System.Security.Policy.PolicyLevel>Будет сохранен в то же расположение, из которого загружен.</xref:System.Security.Policy.PolicyLevel>"
  syntax:
    content: public static void SavePolicyLevel (System.Security.Policy.PolicyLevel level);
    parameters:
    - id: level
      type: System.Security.Policy.PolicyLevel
      description: "Чтобы сохранить объект уровня политики."
  overload: System.Security.SecurityManager.SavePolicyLevel*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Код, который вызывает этот метод не имеет <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Этот метод использует политику разграничения доступа кода, которая является устаревшим в [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]. Чтобы включить политику CAS для обеспечения совместимости с предыдущими версиями платформы .NET Framework, используйте [ &lt;legacyCasPolicy&gt; элемент](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md)."
  platform:
  - net462
- uid: System.Security.SecurityManager.SecurityEnabled
  id: SecurityEnabled
  parent: System.Security.SecurityManager
  langs:
  - csharp
  name: SecurityEnabled
  nameWithType: SecurityManager.SecurityEnabled
  fullName: System.Security.SecurityManager.SecurityEnabled
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "Возвращает или задает значение, указывающее, включена ли безопасность."
  remarks: "Это свойство используется [Caspol.exe (средство политики безопасности доступа кода)](~/add/includes/ajax-current-ext-md.md) `-security` (`-s`) параметр отключает безопасность на основе кода.              SecurityEnabled позволяет администраторам отключать управления доступом для кода. При отключении управления доступом для кода все требования доступа для кода удовлетворяются. Фактически весь код `FullTrust`. Отключение управления доступом для кода позволяет обойти системы безопасности для выполнения кода немного быстрее, чем предоставление политики безопасности эквивалентный `FullTrust` ко всему коду. Это свойство не отключает безопасность на основе ролей; Таким образом <xref:System.Security.Permissions.PrincipalPermission>запросы не затрагиваются.</xref:System.Security.Permissions.PrincipalPermission>      Настроек [!CAUTION] настроек отключение управления доступом для кода система становится уязвимой для атак вредоносных программ, как вирусы и черви. Отключение управления доступом для кода не блокирует автоматически выполнение каким-либо образом управляемого кода. Причины только управляемый код может выполняться без ограничений системы безопасности доступа кода, поэтому должно использоваться только с большой осторожностью. Отключение системы безопасности для повышения производительности должно осуществляться только при были выполнены другие меры безопасности для защиты системы безопасности. Примеры таких дополнительных мер безопасности, относится отключение от общедоступных сетей, физическая защита компьютера и т.п.       Изменение этого свойства не сохраняется в реестре только <xref:System.Security.SecurityManager.SavePolicy%2A>называется.</xref:System.Security.SecurityManager.SavePolicy%2A> Новые процессы не затрагиваются изменением пока оно сохраняется в реестре. Изменение значения этого свойства для выполняющегося процесса не меняет состояние должным образом обязательно. Чтобы изменения вступили в силу, необходимо вызвать метод <xref:System.Security.SecurityManager.SavePolicy%2A>и запустить новый процесс.</xref:System.Security.SecurityManager.SavePolicy%2A>"
  syntax:
    content: public static bool SecurityEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если безопасность включена. в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.SecurityManager.SecurityEnabled*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Код, который вызывает этот метод не имеет <xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Security.Policy.PolicyException
  parent: System.Security.Policy
  isExternal: false
  name: PolicyException
  nameWithType: PolicyException
  fullName: System.Security.Policy.PolicyException
- uid: System.Security.SecurityManager.CheckExecutionRights
  parent: System.Security.SecurityManager
  isExternal: false
  name: CheckExecutionRights
  nameWithType: SecurityManager.CheckExecutionRights
  fullName: System.Security.SecurityManager.CheckExecutionRights
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture
  parent: System.Security.SecurityManager
  isExternal: false
  name: CurrentThreadRequiresSecurityContextCapture()
  nameWithType: SecurityManager.CurrentThreadRequiresSecurityContextCapture()
  fullName: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture()
- uid: System.Security.SecurityManager.GetStandardSandbox(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetStandardSandbox(Evidence)
  nameWithType: SecurityManager.GetStandardSandbox(Evidence)
  fullName: System.Security.SecurityManager.GetStandardSandbox(Evidence)
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.Security.SecurityManager.GetZoneAndOrigin(System.Collections.ArrayList@,System.Collections.ArrayList@)
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetZoneAndOrigin(ArrayList,ArrayList)
  nameWithType: SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
  fullName: System.Security.SecurityManager.GetZoneAndOrigin(ArrayList,ArrayList)
- uid: System.Collections.ArrayList
  parent: System.Collections
  isExternal: false
  name: ArrayList
  nameWithType: ArrayList
  fullName: System.Collections.ArrayList
- uid: System.Security.SecurityManager.IsGranted(System.Security.IPermission)
  parent: System.Security.SecurityManager
  isExternal: false
  name: IsGranted(IPermission)
  nameWithType: SecurityManager.IsGranted(IPermission)
  fullName: System.Security.SecurityManager.IsGranted(IPermission)
- uid: System.Security.IPermission
  parent: System.Security
  isExternal: false
  name: IPermission
  nameWithType: IPermission
  fullName: System.Security.IPermission
- uid: System.Security.SecurityManager.LoadPolicyLevelFromFile(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromFile(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromFile(String,PolicyLevelType)
- uid: System.Security.Policy.PolicyLevel
  parent: System.Security.Policy
  isExternal: false
  name: PolicyLevel
  nameWithType: PolicyLevel
  fullName: System.Security.Policy.PolicyLevel
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Security.PolicyLevelType
  parent: System.Security
  isExternal: false
  name: PolicyLevelType
  nameWithType: PolicyLevelType
  fullName: System.Security.PolicyLevelType
- uid: System.Security.SecurityManager.LoadPolicyLevelFromString(System.String,System.Security.PolicyLevelType)
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromString(String,PolicyLevelType)
  nameWithType: SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
  fullName: System.Security.SecurityManager.LoadPolicyLevelFromString(String,PolicyLevelType)
- uid: System.Security.SecurityManager.PolicyHierarchy
  parent: System.Security.SecurityManager
  isExternal: false
  name: PolicyHierarchy()
  nameWithType: SecurityManager.PolicyHierarchy()
  fullName: System.Security.SecurityManager.PolicyHierarchy()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy(Evidence)
  nameWithType: SecurityManager.ResolvePolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence)
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence[])
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy(Evidence[])
  nameWithType: SecurityManager.ResolvePolicy(Evidence[])
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence[])
- uid: System.Security.Policy.Evidence[]
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence[]
  spec.csharp:
  - uid: System.Security.Policy.Evidence
    name: Evidence
    nameWithType: Evidence
    fullName: Evidence[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Security.SecurityManager.ResolvePolicy(System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet@)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.Security.SecurityManager.ResolvePolicy(Evidence,PermissionSet,PermissionSet,PermissionSet,PermissionSet)
- uid: System.Security.SecurityManager.ResolvePolicyGroups(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicyGroups(Evidence)
  nameWithType: SecurityManager.ResolvePolicyGroups(Evidence)
  fullName: System.Security.SecurityManager.ResolvePolicyGroups(Evidence)
- uid: System.Security.SecurityManager.ResolveSystemPolicy(System.Security.Policy.Evidence)
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolveSystemPolicy(Evidence)
  nameWithType: SecurityManager.ResolveSystemPolicy(Evidence)
  fullName: System.Security.SecurityManager.ResolveSystemPolicy(Evidence)
- uid: System.Security.SecurityManager.SavePolicy
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicy()
  nameWithType: SecurityManager.SavePolicy()
  fullName: System.Security.SecurityManager.SavePolicy()
- uid: System.Security.SecurityManager.SavePolicyLevel(System.Security.Policy.PolicyLevel)
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicyLevel(PolicyLevel)
  nameWithType: SecurityManager.SavePolicyLevel(PolicyLevel)
  fullName: System.Security.SecurityManager.SavePolicyLevel(PolicyLevel)
- uid: System.Security.SecurityManager.SecurityEnabled
  parent: System.Security.SecurityManager
  isExternal: false
  name: SecurityEnabled
  nameWithType: SecurityManager.SecurityEnabled
  fullName: System.Security.SecurityManager.SecurityEnabled
- uid: System.Security.SecurityManager.CheckExecutionRights*
  parent: System.Security.SecurityManager
  isExternal: false
  name: CheckExecutionRights
  nameWithType: SecurityManager.CheckExecutionRights
- uid: System.Security.SecurityManager.CurrentThreadRequiresSecurityContextCapture*
  parent: System.Security.SecurityManager
  isExternal: false
  name: CurrentThreadRequiresSecurityContextCapture
  nameWithType: SecurityManager.CurrentThreadRequiresSecurityContextCapture
- uid: System.Security.SecurityManager.GetStandardSandbox*
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetStandardSandbox
  nameWithType: SecurityManager.GetStandardSandbox
- uid: System.Security.SecurityManager.GetZoneAndOrigin*
  parent: System.Security.SecurityManager
  isExternal: false
  name: GetZoneAndOrigin
  nameWithType: SecurityManager.GetZoneAndOrigin
- uid: System.Security.SecurityManager.IsGranted*
  parent: System.Security.SecurityManager
  isExternal: false
  name: IsGranted
  nameWithType: SecurityManager.IsGranted
- uid: System.Security.SecurityManager.LoadPolicyLevelFromFile*
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromFile
  nameWithType: SecurityManager.LoadPolicyLevelFromFile
- uid: System.Security.SecurityManager.LoadPolicyLevelFromString*
  parent: System.Security.SecurityManager
  isExternal: false
  name: LoadPolicyLevelFromString
  nameWithType: SecurityManager.LoadPolicyLevelFromString
- uid: System.Security.SecurityManager.PolicyHierarchy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: PolicyHierarchy
  nameWithType: SecurityManager.PolicyHierarchy
- uid: System.Security.SecurityManager.ResolvePolicy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicy
  nameWithType: SecurityManager.ResolvePolicy
- uid: System.Security.SecurityManager.ResolvePolicyGroups*
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolvePolicyGroups
  nameWithType: SecurityManager.ResolvePolicyGroups
- uid: System.Security.SecurityManager.ResolveSystemPolicy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: ResolveSystemPolicy
  nameWithType: SecurityManager.ResolveSystemPolicy
- uid: System.Security.SecurityManager.SavePolicy*
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicy
  nameWithType: SecurityManager.SavePolicy
- uid: System.Security.SecurityManager.SavePolicyLevel*
  parent: System.Security.SecurityManager
  isExternal: false
  name: SavePolicyLevel
  nameWithType: SecurityManager.SavePolicyLevel
- uid: System.Security.SecurityManager.SecurityEnabled*
  parent: System.Security.SecurityManager
  isExternal: false
  name: SecurityEnabled
  nameWithType: SecurityManager.SecurityEnabled
