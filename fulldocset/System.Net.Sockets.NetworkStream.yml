### YamlMime:ManagedReference
items:
- uid: System.Net.Sockets.NetworkStream
  id: NetworkStream
  children:
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  - System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.CanRead
  - System.Net.Sockets.NetworkStream.CanSeek
  - System.Net.Sockets.NetworkStream.CanTimeout
  - System.Net.Sockets.NetworkStream.CanWrite
  - System.Net.Sockets.NetworkStream.Close(System.Int32)
  - System.Net.Sockets.NetworkStream.DataAvailable
  - System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  - System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.Finalize
  - System.Net.Sockets.NetworkStream.Flush
  - System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  - System.Net.Sockets.NetworkStream.Length
  - System.Net.Sockets.NetworkStream.Position
  - System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Readable
  - System.Net.Sockets.NetworkStream.ReadTimeout
  - System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  - System.Net.Sockets.NetworkStream.Socket
  - System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Writeable
  - System.Net.Sockets.NetworkStream.WriteTimeout
  langs:
  - csharp
  name: NetworkStream
  nameWithType: NetworkStream
  fullName: System.Net.Sockets.NetworkStream
  type: Class
  summary: "Предоставляет основной поток данных для доступа к сети."
  remarks: "NetworkStream класс предоставляет методы для отправки и получения данных через <xref:System.Net.Sockets.SocketType>сокетов в блокирующем режиме.</xref:System.Net.Sockets.SocketType> Дополнительные сведения о блокирующей версии неблокирующего <xref:System.Net.Sockets.Socket>s, в разделе [использование асинхронных сокетов клиента](~/add/includes/ajax-current-ext-md.md).</xref:System.Net.Sockets.Socket> Класс NetworkStream для обоих синхронной и асинхронной передачи. Дополнительные сведения о синхронной и асинхронной связи см. в разделе [сокеты](~/add/includes/ajax-current-ext-md.md).       Чтобы создать NetworkStream, необходимо предоставить подключенных <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> Можно также указать, какие <xref:System.IO.FileAccess>разрешения NetworkStream имеют на предоставленный <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.IO.FileAccess> По умолчанию Закрытие NetworkStream не закрывает указанный <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> Следует ли NetworkStream иметь разрешение на закрытие обеспечивающего <xref:System.Net.Sockets.Socket>, необходимо указать `true` значения `ownsSocket` параметр.</xref:System.Net.Sockets.Socket>       Используйте <xref:System.Net.Sockets.NetworkStream.Write%2A>и <xref:System.Net.Sockets.NetworkStream.Read%2A>методы для простой одного потока синхронной блокировки ввода-вывода.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream.Write%2A> Если вы хотите обработки вашей ввода-вывода с помощью отдельных потоков, рассмотрите возможность использования <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>и <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>методов, или <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>и <xref:System.Net.Sockets.NetworkStream.EndRead%2A>методы для обмена данными.</xref:System.Net.Sockets.NetworkStream.EndRead%2A> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>       NetworkStream не поддерживает произвольный доступ к сети потока данных. Значение <xref:System.Net.Sockets.NetworkStream.CanSeek%2A>Свойства, которое указывает, поддерживает ли поток поиск, всегда является `false`; чтения <xref:System.Net.Sockets.NetworkStream.Position%2A>Свойства, чтение <xref:System.Net.Sockets.NetworkStream.Length%2A>Свойства, или вызова, <xref:System.Net.Sockets.NetworkStream.Seek%2A>метод вызывает исключение <xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Net.Sockets.NetworkStream.Seek%2A> </xref:System.Net.Sockets.NetworkStream.Length%2A> </xref:System.Net.Sockets.NetworkStream.Position%2A> </xref:System.Net.Sockets.NetworkStream.CanSeek%2A>       Операций чтения и записи в экземпляре класса NetworkStream без необходимости синхронизации могут выполняться одновременно. При условии, что имеется один уникальный поток для операций записи и один уникальный поток для операций чтения, будет перекрестных конфликтов между чтения и записи потоков и синхронизация не требуется."
  example:
  - "The following code example demonstrates how to create a NetworkStream from a connected <xref:System.Net.Sockets.SocketType><xref:System.Net.Sockets.Socket> and perform basic synchronous blocking I/O.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/t-system.net.sockets.net_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/t-system.net.sockets.net_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/t-system.net.sockets.net_1.cs)]"
  syntax:
    content: 'public class NetworkStream : System.IO.Stream'
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  id: '#ctor(System.Net.Sockets.Socket)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Создает новый экземпляр <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> класса для указанного <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Создается с доступом на чтение и запись на указанный <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> <xref:System.Net.Sockets.NetworkStream>Не владеет базовой <xref:System.Net.Sockets.Socket>поэтому вызов <xref:System.Net.Sockets.NetworkStream.Close%2A>метода не закрывает <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example illustrates how to create a <xref:System.Net.Sockets.NetworkStream> with a <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/m-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/m-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/m-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>, <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Будет использовать для отправки и получения данных.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code> Параметра не подключен.       - или - <xref:System.Net.Sockets.Socket.SocketType*>свойство <code> socket </code> не &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - или - <code> socket </code> параметр находится в состоянии неблокируемый."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> класса для указанного <xref:System.Net.Sockets.Socket>с указанным <xref:System.Net.Sockets.Socket>владения.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Создается с доступом на чтение и запись на указанный <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Если значение `ownsSocket` параметр `true`, <xref:System.Net.Sockets.NetworkStream>принимает право на владение базовым <xref:System.Net.Sockets.Socket>и вызов <xref:System.Net.Sockets.NetworkStream.Close%2A>метода также закрывает основной <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with ownership of the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/59c93a1c-9c9b-46b2-a872-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/59c93a1c-9c9b-46b2-a872-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/59c93a1c-9c9b-46b2-a872-_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>, <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Будет использовать для отправки и получения данных.</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "Значение <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> указывает, что <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> будет распоряжаться <xref:System.Net.Sockets.Socket>; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code> Параметра не подключен.       - или - значение <xref:System.Net.Sockets.Socket.SocketType*>Свойства <code> socket </code> не &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - или - <code> socket </code> параметр находится в состоянии неблокируемый."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Создает новый экземпляр <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> класса для указанного <xref:System.Net.Sockets.Socket>с заданными правами доступа.</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Создается с указанным доступом к указанным <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> С помощью этого конструктора <xref:System.Net.Sockets.NetworkStream>не владеет базовой <xref:System.Net.Sockets.Socket>поэтому вызов <xref:System.Net.Sockets.NetworkStream.Close%2A>метода не приводит к закрытию базового <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       `access` Параметр задает <xref:System.Net.Sockets.NetworkStream.CanRead%2A>и <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>Свойства <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream.CanRead%2A> При указании <xref:System.IO.FileAccess>, то <xref:System.Net.Sockets.NetworkStream>разрешает вызовы <xref:System.Net.Sockets.NetworkStream.Write%2A>метод.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> При указании <xref:System.IO.FileAccess>, то <xref:System.Net.Sockets.NetworkStream>разрешает вызовы <xref:System.Net.Sockets.NetworkStream.Read%2A>метод.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> При указании <xref:System.IO.FileAccess>, оба вызова метода разрешены.</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/586c6962-cd9c-4b70-aa3e-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/586c6962-cd9c-4b70-aa3e-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/586c6962-cd9c-4b70-aa3e-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>, <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Будет использовать для отправки и получения данных.</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "Побитовое сочетание <xref href=&quot;System.IO.FileAccess&quot;> </xref> значения, указывающие тип доступа, предоставленный <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> на предоставленный <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code> Параметра не подключен.       - или - <xref:System.Net.Sockets.Socket.SocketType*>свойство <code> socket </code> не &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - или - <code> socket </code> параметр находится в состоянии неблокируемый."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Создает новый экземпляр <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> класса для указанного <xref:System.Net.Sockets.Socket>с заданными правами доступа и указанным <xref:System.Net.Sockets.Socket>владения.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>Создается с доступом на чтение и запись на указанный <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Если значение `ownsSocket` параметр `true`, <xref:System.Net.Sockets.NetworkStream>принимает право на владение базовым <xref:System.Net.Sockets.Socket>и вызов <xref:System.Net.Sockets.NetworkStream.Close%2A>метода также закрывает основной <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       `access` Параметр задает <xref:System.Net.Sockets.NetworkStream.CanRead%2A>и <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>Свойства <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream.CanRead%2A> При указании <xref:System.IO.FileAccess>, то <xref:System.Net.Sockets.NetworkStream>разрешает вызовы <xref:System.Net.Sockets.NetworkStream.Write%2A>метод.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> При указании <xref:System.IO.FileAccess>, то <xref:System.Net.Sockets.NetworkStream>разрешает вызовы <xref:System.Net.Sockets.NetworkStream.Read%2A>метод.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> При указании <xref:System.IO.FileAccess>, оба вызова метода разрешены.</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>. Ownership of the <xref:System.Net.Sockets.Socket> is given to this <xref:System.Net.Sockets.NetworkStream> by specifying `true` for the `ownsSocket` parameter.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/db34d484-28c0-47ef-b5ca-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/db34d484-28c0-47ef-b5ca-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/db34d484-28c0-47ef-b5ca-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>, <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Будет использовать для отправки и получения данных.</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "Побитовое сочетание <xref href=&quot;System.IO.FileAccess&quot;> </xref> значения, которое указывает тип доступа, предоставленный <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> на предоставленный <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "Значение <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> указывает, что <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> будет распоряжаться <xref:System.Net.Sockets.Socket>; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code> Параметра не подключен.       - или - <xref:System.Net.Sockets.Socket.SocketType*>свойство <code> socket </code> не &lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;.</xref:System.Net.Sockets.Socket.SocketType*>       - или - <code> socket </code> параметр находится в состоянии неблокируемый."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Начинает асинхронное чтение из <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Метод BeginRead запускает асинхронное чтение данных из входящих сетевых буферов. Метод BeginRead дает возможность принимать данные в отдельном потоке.       Необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback>делегата и передает его имя в метод BeginRead.</xref:System.AsyncCallback> По крайней мере к `state` параметр должен содержать <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Так как может потребоваться получить поступившие данные в рамках метода обратного вызова, следует создать небольшой класс или структуру для хранения буфера чтения и любых других полезных сведений. Передайте этот экземпляр структуры или класса метод BeginRead через `state` параметра.       Метод обратного вызова должен вызывать <xref:System.Net.Sockets.NetworkStream.EndRead%2A>метод.</xref:System.Net.Sockets.NetworkStream.EndRead%2A> Когда приложение вызывает метод BeginRead, система будет ждать получения данных или возникает ошибка и затем система будет использовать отдельный поток для выполнения указанный метод обратного вызова и блоки на <xref:System.Net.Sockets.NetworkStream.EndRead%2A>до указанных <xref:System.Net.Sockets.NetworkStream>считывает данные или создает исключение.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndRead%2A> Исходный поток для блокировки после вызова метода BeginRead используйте <xref:System.Threading.WaitHandle.WaitOne%2A>метод.</xref:System.Threading.WaitHandle.WaitOne%2A> Вызовите <xref:System.Threading.EventWaitHandle.Set%2A>в методе обратного вызова, если необходимо продолжить исполнение исходного потока.</xref:System.Threading.EventWaitHandle.Set%2A> Дополнительные сведения о создании методов обратного вызова см. в разделе [маршалинг делегата как метода обратного вызова](~/add/includes/ajax-current-ext-md.md).       Метод BeginRead считывает столько доступных данных, до числа байтов, указанное в `size` параметра.      Настроек [!NOTE] настроек при получении <xref:System.IO.IOException>Проверьте <xref:System.Exception.InnerException%2A>свойство, чтобы определить, если она была вызвана <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> В этом случае используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A>свойство для получения определенного кода ошибки и ссылки на подробное описание ошибки документации по кодам ошибок API Windows Sockets версии 2 в библиотеке MSDN.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       Чтение и запись операции могут выполняться одновременно на экземпляре <xref:System.Net.Sockets.NetworkStream>класс без необходимости синхронизации.</xref:System.Net.Sockets.NetworkStream> При условии, что имеется один уникальный поток для операций записи и один уникальный поток для операций чтения, будет перекрестных конфликтов между чтения и записи потоков и синхронизация не требуется."
  example:
  - "The following code example uses BeginRead to read data asynchronously from the network stream. The `myReadCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginRead returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/visualbasic/b2716ae9-7520-4d87-8b97-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/csharp/b2716ae9-7520-4d87-8b97-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/cpp/b2716ae9-7520-4d87-8b97-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Массив объектов типа <xref:System.Byte>это расположение в памяти для хранения данных, считанных из <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Расположение в `buffer` начинается сохранение данных."
    - id: size
      type: System.Int32
      description: "Число байтов, считываемых из <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>Делегат, который выполняется при завершении BeginRead.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Объект, содержащий любые дополнительные данные, определяемые пользователем."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>, Представляющий асинхронного вызова.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code> Параметр меньше 0.       - или - <code> offset </code> параметр больше, чем длина <code> buffer </code> параметр &quot;.       - или - <code> size </code> меньше 0.       - или - <code> size </code> больше, чем длина <code> buffer </code> минус значение <code> offset </code> параметра."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Базовый <xref:System.Net.Sockets.Socket>закрыт.</xref:System.Net.Sockets.Socket>       - или - произошла ошибка при чтении из сети.       - или - произошла ошибка при обращении к сокету. Дополнительные сведения см."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Закрыт."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Начинает асинхронную запись в поток."
  remarks: "Метод BeginWrite начинает операцию асинхронной передачи на удаленный узел. Вызов метода BeginWrite дает возможность отправлять данные в отдельном потоке.       Необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback>делегата и передает его имя в метод BeginWrite.</xref:System.AsyncCallback> По крайней мере к `state` параметр должен содержать <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Если обратного вызова необходимы дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.NetworkStream>и другие необходимые сведения.</xref:System.Net.Sockets.NetworkStream> Передайте этот экземпляр структуры или класса метод BeginWrite через `state` параметра.       Метод обратного вызова должен реализовывать <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>метод.</xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Когда приложение вызывает метод BeginWrite, система использует отдельный поток для выполнения указанный метод обратного вызова и блокирует на <xref:System.Net.Sockets.NetworkStream.EndWrite%2A>до <xref:System.Net.Sockets.NetworkStream>отправляет запрошенного числа байтов или создает исключение.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> Исходный поток для блокировки после вызова метода BeginWrite используйте <xref:System.Threading.WaitHandle.WaitOne%2A>метод.</xref:System.Threading.WaitHandle.WaitOne%2A> Вызовите <xref:System.Threading.EventWaitHandle.Set%2A>в методе обратного вызова, если необходимо продолжить исполнение исходного потока.</xref:System.Threading.EventWaitHandle.Set%2A> Дополнительные сведения о создании методов обратного вызова см. в разделе [маршалинг делегата как метода обратного вызова](~/add/includes/ajax-current-ext-md.md).      Настроек [!NOTE] настроек при получении <xref:System.IO.IOException>Проверьте <xref:System.Exception.InnerException%2A>свойство, чтобы определить, если она была вызвана <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> В этом случае используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A>свойство для получения определенного кода ошибки и ссылки на подробное описание ошибки документации по кодам ошибок API Windows Sockets версии 2 в библиотеке MSDN.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       Чтение и запись операции могут выполняться одновременно на экземпляре <xref:System.Net.Sockets.NetworkStream>класс без необходимости синхронизации.</xref:System.Net.Sockets.NetworkStream> При условии, что имеется один уникальный поток для операций записи и один уникальный поток для операций чтения, будет перекрестных конфликтов между чтения и записи потоков и синхронизация не требуется."
  example:
  - "The following code example uses BeginWrite to write data asynchronously to a network stream. The `myWriteCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginWrite returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/visualbasic/d3b03755-0183-42fc-98c1-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/csharp/d3b03755-0183-42fc-98c1-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/cpp/d3b03755-0183-42fc-98c1-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Массив объектов типа <xref:System.Byte>, содержащий данные для записи <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Расположение в `buffer` начинается отправка данных."
    - id: size
      type: System.Int32
      description: "Число байтов для записи <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>Делегат, который выполняется при завершении BeginWrite.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Объект, содержащий любые дополнительные данные, определяемые пользователем."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>, Представляющий асинхронного вызова.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code> Параметр меньше 0.       - или - <code> offset </code> параметр больше, чем длина <code> buffer </code>.       - или - <code> size </code> параметр меньше 0.       - или - <code> size </code> параметр больше, чем длина <code> buffer </code> минус значение <code> offset </code> параметра."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Базовый <xref:System.Net.Sockets.Socket>закрыт.</xref:System.Net.Sockets.Socket>       - или - произошел сбой при записи в сеть.       - или - произошла ошибка при обращении к сокету. Дополнительные сведения см."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Закрыт."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanRead
  id: CanRead
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Возвращает значение, указывающее, является ли <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> поддерживает чтение."
  remarks: "Если CanRead `true`, <xref:System.Net.Sockets.NetworkStream>разрешает вызовы <xref:System.Net.Sockets.NetworkStream.Read%2A>метод.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> Укажите соответствующие <xref:System.IO.FileAccess>значения в конструкторе, чтобы задать для удобства чтения и записи для объекта <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> перечисления</xref:System.IO.FileAccess> Когда задано свойство CanRead <xref:System.Net.Sockets.NetworkStream>инициализируется.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanRead to verify that the <xref:System.Net.Sockets.NetworkStream> is readable. It then performs a read operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_6_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_6_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_6_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если данные могут быть прочитаны из потока; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanSeek
  id: CanSeek
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Возвращает значение, указывающее, поддерживает ли поток поиск. Это свойство в настоящее время не поддерживается. Это свойство всегда возвращает <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>во всех случаях, чтобы указать, что <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> не удается выполнить поиск в определенное расположение в потоке."
  overload: System.Net.Sockets.NetworkStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  id: CanTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Указывает, являются ли свойства времени ожидания для <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Это свойство присутствует, поскольку оно унаследовано из <xref:System.IO.Stream>.</xref:System.IO.Stream>"
  syntax:
    content: public override bool CanTimeout { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>во всех случаях."
  overload: System.Net.Sockets.NetworkStream.CanTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanWrite
  id: CanWrite
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Возвращает значение, указывающее, является ли <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> поддерживает запись."
  remarks: "Если CanWrite `true`, <xref:System.Net.Sockets.NetworkStream>разрешает вызовы <xref:System.Net.Sockets.NetworkStream.Write%2A>метод.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> Укажите соответствующие <xref:System.IO.FileAccess>значения в конструкторе, чтобы задать для удобства чтения и записи для объекта <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> перечисления</xref:System.IO.FileAccess> Когда задано свойство CanWrite <xref:System.Net.Sockets.NetworkStream>инициализируется.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanWrite to verify that the <xref:System.Net.Sockets.NetworkStream> is writable. It then performs a write operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/p-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/p-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/p-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если данные могут быть записаны <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  id: Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Закрывает <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> после ожидания в указанное время, чтобы разрешить отправку данных."
  remarks: "Метод Close освобождает управляемые и неуправляемые ресурсы, связанные с <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> Если <xref:System.Net.Sockets.NetworkStream>владеет основным <xref:System.Net.Sockets.Socket>, также закрывается.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       Если <xref:System.Net.Sockets.NetworkStream>был связан с <xref:System.Net.Sockets.TcpClient>метод Close закрывается TCP-соединение, но не удаления связанного <xref:System.Net.Sockets.TcpClient>.</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.NetworkStream>"
  syntax:
    content: public void Close (int timeout);
    parameters:
    - id: timeout
      type: System.Int32
      description: "32-разрядное знаковое целое число, указывающее количество миллисекунд ожидания для отправки оставшихся данных перед закрытием."
  overload: System.Net.Sockets.NetworkStream.Close*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> timeout </code> Параметр является меньше -1."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  id: DataAvailable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Возвращает значение, указывающее, доступен ли данные на <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> для чтения."
  remarks: "Используйте свойство DataAvailable, чтобы определить, если данные можно считывать. Если DataAvailable `true`, вызов <xref:System.Net.Sockets.NetworkStream.Read%2A>возвращается немедленно.</xref:System.Net.Sockets.NetworkStream.Read%2A> Удаленный узел отключается или закрывает соединение, DataAvailable может вызвать <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException>"
  example:
  - "The following code example reads from the <xref:System.Net.Sockets.NetworkStream> as long as data is available.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_2_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_2_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_2_1.cs)]"
  syntax:
    content: public virtual bool DataAvailable { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>При наличии данных в потоке для чтения; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.DataAvailable*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Закрыт."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Базовый <xref:System.Net.Sockets.Socket>закрыт.</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Используйте &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; свойство для получения определенного кода ошибки и ссылки на подробное описание ошибки документации по кодам ошибок API Windows Sockets версии 2 в библиотеке MSDN."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Освобождает неуправляемые ресурсы, используемые <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> и при необходимости освобождает также управляемые ресурсы."
  remarks: "Этот метод вызывается методом открытые `Dispose` метод и <xref:System.Object.Finalize%2A>метод.</xref:System.Object.Finalize%2A> `Dispose`вызывает защищенный `Dispose(Boolean)` метод с `disposing` равным `true`. <xref:System.Object.Finalize%2A>вызывает `Dispose` с `disposing` значение `false`.</xref:System.Object.Finalize%2A>       При `disposing` параметр `true`, данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, которые <xref:System.Net.Sockets.NetworkStream>ссылки.</xref:System.Net.Sockets.NetworkStream> Этот метод вызывает `Dispose` метод для каждого объекта, на который указывает ссылка."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>для освобождения управляемых и неуправляемых ресурсов; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для освобождения только неуправляемых ресурсов."
  overload: System.Net.Sockets.NetworkStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Обрабатывает завершение асинхронного чтения."
  remarks: "Метод EndRead завершает асинхронную операцию чтения, запущенную <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>метод.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>       Перед вызовом метода <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>, необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback>делегировать.</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>возвращает.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Метод обратного вызова должен принимать <xref:System.IAsyncResult>возвращенные <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>методу в качестве параметра.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult>       В методе обратного вызова <xref:System.IAsyncResult.AsyncState%2A>свойство <xref:System.IAsyncResult>получить состояние объекта, переданного в <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>метод.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A> Извлеките полученный <xref:System.Net.Sockets.NetworkStream>из этого объекта состояния.</xref:System.Net.Sockets.NetworkStream> После получения <xref:System.Net.Sockets.NetworkStream>, вызовите метод EndRead для успешного завершения операции чтения и возвращают число считанных байтов.</xref:System.Net.Sockets.NetworkStream>       Метод EndRead блокируется до данные недоступны. Метод EndRead считывает столько данных доступно до числа байтов, указанного в `size` параметр <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>метод.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> Если удаленный узел отключает <xref:System.Net.Sockets.Socket>Получено подключения и все доступные данные, метод EndRead немедленно завершается и возвращает нуль байт.</xref:System.Net.Sockets.Socket>       Чтобы получить поступившие данные, вызовите <xref:System.IAsyncResult.AsyncState%2A>свойство <xref:System.IAsyncResult>и извлеките буфер, содержащийся в объекте результирующего состояния.</xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A>      Настроек [!NOTE] настроек при получении <xref:System.IO.IOException>Проверьте <xref:System.Exception.InnerException%2A>свойство, чтобы определить, если она была вызвана <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> В этом случае используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A>свойство для получения определенного кода ошибки и ссылки на подробное описание ошибки документации по кодам ошибок API Windows Sockets версии 2 в библиотеке MSDN.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myReadCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> as the callback method. EndRead is implemented in `myReadCallback` to complete the asynchronous read call started by <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/visualbasic/m-system.net.sockets.net_2_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/csharp/m-system.net.sockets.net_2_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/cpp/m-system.net.sockets.net_2_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>, Представляющий асинхронный вызов.</xref:System.IAsyncResult>"
    return:
      type: System.Int32
      description: "Количество прочитанных байтов из <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.EndRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Базовый <xref:System.Net.Sockets.Socket>закрыт.</xref:System.Net.Sockets.Socket>       - или - произошла ошибка при обращении к сокету. Дополнительные сведения см."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Закрыт."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Обрабатывает завершение асинхронной записи."
  remarks: "Метод EndWrite завершения операции асинхронного чтения, запущенный в <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>       Перед вызовом метода <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>, необходимо создать метод обратного вызова, который реализует <xref:System.AsyncCallback>делегировать.</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>возвращает.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> Метод обратного вызова должен принимать <xref:System.IAsyncResult>возвращенные <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>методу в качестве параметра.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> </xref:System.IAsyncResult>       В методе обратного вызова <xref:System.IAsyncResult.AsyncState%2A>свойство `IAsyncResult` параметр, чтобы получить <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IAsyncResult.AsyncState%2A> После получения <xref:System.Net.Sockets.NetworkStream>, можно вызвать метод EndWrite для успешного завершения операции отправки и вернуть количество байтов, отправленных.</xref:System.Net.Sockets.NetworkStream>       Метод EndWrite блокируется до отправки запрошенное количество байтов.      Настроек [!NOTE] настроек при получении <xref:System.IO.IOException>Проверьте <xref:System.Exception.InnerException%2A>свойство, чтобы определить, если она была вызвана <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> В этом случае используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A>свойство для получения определенного кода ошибки и ссылки на подробное описание ошибки документации по кодам ошибок API Windows Sockets версии 2 в библиотеке MSDN.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myWriteCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> as the callback method. EndWrite is implemented in `myWriteCallback` to complete the asynchronous write call started by <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_3_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_3_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_3_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>, Представляющий асинхронного вызова.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Базовый <xref:System.Net.Sockets.Socket>закрыт.</xref:System.Net.Sockets.Socket>       - или - произошла ошибка при записи в сеть.       - или - произошла ошибка при обращении к сокету. Дополнительные сведения см."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Закрыт."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Finalize
  id: Finalize
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Освобождает все ресурсы, используемые <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Этот метод переопределяет <xref:System.Object.Finalize%2A?displayProperty=fullName>.</xref:System.Object.Finalize%2A?displayProperty=fullName> Код приложения не должен вызывать этот метод; Объект <xref:System.Object.Finalize%2A>метод автоматически вызывается во время сборки мусора, если завершение работы сборщика мусора была отключена с помощью вызова <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName>метод.</xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> </xref:System.Object.Finalize%2A>       Дополнительные сведения об использовании метода Finalize см. в разделе [методы Finalize и деструкторы](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70), [очистки неуправляемых ресурсов](~/add/includes/ajax-current-ext-md.md), и [переопределение метода Finalize](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)."
  syntax:
    content: ~NetworkStream ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Flush
  id: Flush
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Удаляет данные из потока. Этот метод зарезервирован для будущего использования."
  remarks: "Реализует метод Flush <xref:System.IO.Stream.Flush%2A?displayProperty=fullName>метод, однако, поскольку <xref:System.Net.Sockets.NetworkStream>является не помещаются в буфер, не оказывает воздействия на сетевые потоки.</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.Stream.Flush%2A?displayProperty=fullName> Вызов метода очистки не вызывает исключение."
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Удаляет данные из потока в асинхронной операции."
  remarks: "Эта операция не будет блокирована. Возвращенный <xref:System.Threading.Tasks.Task>объекта будет выполнена после очистки данных из потока для <xref:System.Net.Sockets.NetworkStream>экземпляра.</xref:System.Net.Sockets.NetworkStream> </xref:System.Threading.Tasks.Task>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Токен отмены, используемый для распространения уведомления о, что эта операция должна быть отменена."
    return:
      type: System.Threading.Tasks.Task
      description: "Возвращает <xref:System.Threading.Tasks.Task>.</xref:System.Threading.Tasks.Task>       Объект задачи, представляющий асинхронную операцию."
  overload: System.Net.Sockets.NetworkStream.FlushAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Length
  id: Length
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Возвращает длину данных, доступных в потоке. Это свойство не поддерживается и всегда вызывает исключение <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "Длина данных в потоке."
  overload: System.Net.Sockets.NetworkStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Любое использование этого свойства."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Position
  id: Position
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Возвращает или задает текущую позицию в потоке. Это свойство не поддерживается и всегда вызывает исключение <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "Текущая позиция в потоке."
  overload: System.Net.Sockets.NetworkStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Любое использование этого свойства."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Считывает данные из <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Этот метод считывает данные в `buffer` параметра и возвращает количество успешно прочитанных байтов. Если данные недоступны для чтения, метод Read возвращает 0. Операция чтения считывает столько доступных данных, до числа байтов, указанное в `size` параметра. Если удаленный узел отключает соединение и получил все доступные данные, метод Read сразу же завершает работу и возвращают&0; байт.      Настроек [!NOTE] настроек проверьте <xref:System.Net.Sockets.NetworkStream>доступен для чтения, вызвав <xref:System.Net.Sockets.NetworkStream.CanRead%2A>свойство.</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream> При попытке чтения из <xref:System.Net.Sockets.NetworkStream>недоступны для чтения, вы получите <xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream>      Настроек [!NOTE] настроек при получении <xref:System.IO.IOException>Проверьте <xref:System.Exception.InnerException%2A>свойство, чтобы определить, если она была вызвана <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> В этом случае используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A>свойство для получения определенного кода ошибки и ссылки на подробное описание ошибки документации по кодам ошибок API Windows Sockets версии 2 в библиотеке MSDN.</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "The following code example uses <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> to determine if data is available to be read. If data is available, it reads from the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_1_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Массив объектов типа <xref:System.Byte>это расположение в памяти для хранения данных, считанных из <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Расположение в `buffer` начинается сохранение данных."
    - id: size
      type: System.Int32
      description: "Число байтов, считываемых из <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
    return:
      type: System.Int32
      description: "Количество прочитанных байтов из <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code> Параметр меньше 0.       - или - <code> offset </code> параметр больше, чем длина <code> buffer </code>.       - или - <code> size </code> параметр меньше 0.       - или - <code> size </code> параметр больше, чем длина <code> buffer </code> минус значение <code> offset </code> параметра.       - или - произошла ошибка при обращении к сокету. Дополнительные сведения см."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Базовый <xref:System.Net.Sockets.Socket>закрыт.</xref:System.Net.Sockets.Socket>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Закрыт.       - или - ошибка при чтении из сети."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Readable
  id: Readable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Возвращает или задает значение, указывающее, является ли <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> могут быть прочитаны."
  remarks: "Должен быть производным от <xref:System.Net.Sockets.NetworkStream>класс, используемый для чтения свойство.</xref:System.Net.Sockets.NetworkStream> Если доступная для чтения `true`, <xref:System.Net.Sockets.NetworkStream>разрешает вызовы <xref:System.Net.Sockets.NetworkStream.Read%2A>метод.</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> Можно также определить ли <xref:System.Net.Sockets.NetworkStream>доступен для чтения, путем проверки общедоступного <xref:System.Net.Sockets.NetworkStream.CanRead%2A>свойство.</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream>       Доступное для чтения свойство устанавливается, когда <xref:System.Net.Sockets.NetworkStream>инициализируется.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Readable property to determine if the <xref:System.Net.Sockets.NetworkStream> is readable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_7_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_7_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_7_1.vb)]"
  syntax:
    content: protected bool Readable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы указать, что <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> можно считать; в противном случае — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Readable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  id: ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Возвращает или задает количество времени, которое блокирует операцию чтения, ожидание данных."
  remarks: "Если операция чтения не завершается в течение времени, заданного этим свойством, операции чтения вызывает <xref:System.IO.IOException>.</xref:System.IO.IOException>      Настроек [!NOTE] настроек это свойство влияет только синхронных операций чтения, выполненных вызов <xref:System.Net.Sockets.NetworkStream.Read%2A>метод.</xref:System.Net.Sockets.NetworkStream.Read%2A> Это свойство не влияет на асинхронных операций чтения, выполненных вызов <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>метод.</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>"
  example:
  - "The following code example sets the read time-out for a network stream to 10 milliseconds.  \n  \n [!code-cs[NCLTcpClientSync#2](~/add/codesnippet/csharp/p-system.net.sockets.net_4_1.cs)]"
  syntax:
    content: public override int ReadTimeout { get; set; }
    return:
      type: System.Int32
      description: "Объект <xref:System.Int32>задает количество времени, в миллисекундах, по истечении которого происходит сбой операции чтения.</xref:System.Int32> Значение по умолчанию <xref:System.Threading.Timeout.Infinite>, указывает, что операции чтения время ожидания не истекает.</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.ReadTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Указанное значение меньше или равно нулю и не <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Задает текущую позицию потока на заданное значение. Этот метод не поддерживается и всегда вызывает исключение <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "Этот параметр не используется."
    - id: origin
      type: System.IO.SeekOrigin
      description: "Этот параметр не используется."
    return:
      type: System.Int64
      description: "Позиция в потоке."
  overload: System.Net.Sockets.NetworkStream.Seek*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Любое использование этого свойства."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Задает длину потока. Этот метод всегда создает исключение <xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Этот параметр не используется."
  overload: System.Net.Sockets.NetworkStream.SetLength*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Любое использование этого свойства."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Socket
  id: Socket
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Возвращает базовый <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "Классы, производные от <xref:System.Net.Sockets.NetworkStream>можно использовать это свойство для получения базовых <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> Используйте основной <xref:System.Net.Sockets.Socket>возвращается из свойства сокета, если требуется доступ, выходящих за пределы которой <xref:System.Net.Sockets.NetworkStream>предоставляет.</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.Socket>      Настроек [!NOTE] настроек это свойство доступно только с помощью этого класса или производного класса."
  example:
  - "The following code example retrieves the underlying <xref:System.Net.Sockets.Socket> to verify an active connection.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_3_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_3_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_3_1.vb)]"
  syntax:
    content: protected System.Net.Sockets.Socket Socket { get; }
    return:
      type: System.Net.Sockets.Socket
      description: "Объект <xref:System.Net.Sockets.Socket>, представляющий на базовое сетевое подключение.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.Socket*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Записывает данные в <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  remarks: "Метод записи начинается с указанного `offset` и отправляет `size` байт из содержимого `buffer` к сети. Метод записи блокируется, пока не будет передано запрошенное количество байтов или <xref:System.Net.Sockets.SocketException>возникает исключение.</xref:System.Net.Sockets.SocketException> При получении <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>свойство для получения определенного кода ошибки и ссылки на подробное описание ошибки документации по кодам ошибок API Windows Sockets версии 2 в библиотеке MSDN.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      Настроек [!NOTE] настроек проверьте <xref:System.Net.Sockets.NetworkStream>доступен для записи, обратившись к <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>свойство.</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream> При попытке записи <xref:System.Net.Sockets.NetworkStream>защищены от записи, вы получите <xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream> Если появляется <xref:System.IO.IOException>Проверьте <xref:System.Exception.InnerException%2A>свойство, чтобы определить, если она была вызвана <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException>"
  example:
  - "The following code example checks to see whether the <xref:System.Net.Sockets.NetworkStream> is writable. If it is, then Write is used to write a small message.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/87c395a5-03ea-4324-8b05-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/87c395a5-03ea-4324-8b05-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/87c395a5-03ea-4324-8b05-_1.cs)]"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "Массив объектов типа <xref:System.Byte>, содержащий данные для записи <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>.</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "Расположение в `buffer` из которого записываются данные."
    - id: size
      type: System.Int32
      description: "Число байтов для записи <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code> Параметр меньше 0.       - или - <code> offset </code> параметр больше, чем длина <code> buffer </code>.       - или - <code> size </code> параметр меньше 0.       - или - <code> size </code> параметр больше, чем длина <code> buffer </code> минус значение <code> offset </code> параметра."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка при записи в сеть.       - или - произошла ошибка при обращении к сокету. Дополнительные сведения см."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> Закрыт.       - или - произошла ошибка при чтении из сети."
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Writeable
  id: Writeable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Возвращает значение, указывающее, является ли <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref> доступен для записи."
  remarks: "Должен быть производным от <xref:System.Net.Sockets.NetworkStream>класс, используемый для записи свойства.</xref:System.Net.Sockets.NetworkStream> Если Writeable `true`, <xref:System.Net.Sockets.NetworkStream>разрешает вызовы <xref:System.Net.Sockets.NetworkStream.Write%2A>метод.</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> Можно также определить ли <xref:System.Net.Sockets.NetworkStream>доступен для записи, путем проверки общедоступного <xref:System.Net.Sockets.NetworkStream.CanWrite%2A>свойство.</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream>       Если задано свойство Writeable <xref:System.Net.Sockets.NetworkStream>инициализируется.</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Writeable property to determine if the <xref:System.Net.Sockets.NetworkStream> is writable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_5_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_5_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_5_1.vb)]"
  syntax:
    content: protected bool Writeable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если данные могут быть записаны в поток; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.NetworkStream.Writeable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  id: WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Возвращает или задает количество времени, которое блокирует операцию записи, ожидание данных."
  remarks: "Если операция записи не завершается в течение времени, заданного этим свойством, операция записи вызывает <xref:System.IO.IOException>.</xref:System.IO.IOException>      Настроек [!NOTE] настроек это свойство влияет только синхронной записи операций путем вызова <xref:System.Net.Sockets.NetworkStream.Write%2A>метод.</xref:System.Net.Sockets.NetworkStream.Write%2A> Это свойство не влияет на асинхронных операций записи при вызове <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>метода.</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>"
  example:
  - "The following code example sets the write time-out for a network stream to 10 milliseconds.  \n  \n [!code-cpp[NCLTcpServerSync#0](~/add/codesnippet/cpp/p-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NCLTcpServerSync#0](~/add/codesnippet/csharp/p-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int WriteTimeout { get; set; }
    return:
      type: System.Int32
      description: "Объект <xref:System.Int32>задает количество времени, в миллисекундах, по истечении которого происходит сбой операции записи.</xref:System.Int32> Значение по умолчанию <xref:System.Threading.Timeout.Infinite>, указывает, что операция записи время ожидания не истекает.</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.WriteTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Указанное значение меньше или равно нулю и не <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Net.Sockets.SocketException
  isExternal: true
  name: System.Net.Sockets.SocketException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: true
  name: Socket
  nameWithType: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.Net.Sockets.NetworkStream.CanRead
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.Finalize
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
- uid: System.Net.Sockets.NetworkStream.Flush
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Net.Sockets.NetworkStream.Length
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Net.Sockets.NetworkStream.Position
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Readable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
- uid: System.Net.Sockets.NetworkStream.Socket
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Writeable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
- uid: System.Net.Sockets.NetworkStream.#ctor*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream
  nameWithType: NetworkStream.NetworkStream
- uid: System.Net.Sockets.NetworkStream.BeginRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead
  nameWithType: NetworkStream.BeginRead
- uid: System.Net.Sockets.NetworkStream.BeginWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite
  nameWithType: NetworkStream.BeginWrite
- uid: System.Net.Sockets.NetworkStream.CanRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close
  nameWithType: NetworkStream.Close
- uid: System.Net.Sockets.NetworkStream.DataAvailable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose
  nameWithType: NetworkStream.Dispose
- uid: System.Net.Sockets.NetworkStream.EndRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead
  nameWithType: NetworkStream.EndRead
- uid: System.Net.Sockets.NetworkStream.EndWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite
  nameWithType: NetworkStream.EndWrite
- uid: System.Net.Sockets.NetworkStream.Finalize*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize
  nameWithType: NetworkStream.Finalize
- uid: System.Net.Sockets.NetworkStream.Flush*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush
  nameWithType: NetworkStream.Flush
- uid: System.Net.Sockets.NetworkStream.FlushAsync*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync
  nameWithType: NetworkStream.FlushAsync
- uid: System.Net.Sockets.NetworkStream.Length*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
- uid: System.Net.Sockets.NetworkStream.Position*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read
  nameWithType: NetworkStream.Read
- uid: System.Net.Sockets.NetworkStream.Readable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek
  nameWithType: NetworkStream.Seek
- uid: System.Net.Sockets.NetworkStream.SetLength*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength
  nameWithType: NetworkStream.SetLength
- uid: System.Net.Sockets.NetworkStream.Socket*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write
  nameWithType: NetworkStream.Write
- uid: System.Net.Sockets.NetworkStream.Writeable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
