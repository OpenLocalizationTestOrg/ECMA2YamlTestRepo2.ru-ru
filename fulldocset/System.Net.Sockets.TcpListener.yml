### YamlMime:ManagedReference
items:
- uid: System.Net.Sockets.TcpListener
  id: TcpListener
  children:
  - System.Net.Sockets.TcpListener.#ctor(System.Int32)
  - System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
  - System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
  - System.Net.Sockets.TcpListener.AcceptSocket
  - System.Net.Sockets.TcpListener.AcceptSocketAsync
  - System.Net.Sockets.TcpListener.AcceptTcpClient
  - System.Net.Sockets.TcpListener.AcceptTcpClientAsync
  - System.Net.Sockets.TcpListener.Active
  - System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)
  - System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)
  - System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  - System.Net.Sockets.TcpListener.Create(System.Int32)
  - System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)
  - System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)
  - System.Net.Sockets.TcpListener.ExclusiveAddressUse
  - System.Net.Sockets.TcpListener.LocalEndpoint
  - System.Net.Sockets.TcpListener.Pending
  - System.Net.Sockets.TcpListener.Server
  - System.Net.Sockets.TcpListener.Start
  - System.Net.Sockets.TcpListener.Start(System.Int32)
  - System.Net.Sockets.TcpListener.Stop
  langs:
  - csharp
  name: TcpListener
  nameWithType: TcpListener
  fullName: System.Net.Sockets.TcpListener
  type: Class
  summary: "Прослушивает подключения от клиентов сети TCP."
  remarks: "Класс TcpListener предоставляет простые методы, которые прослушивать и принимать входящие запросы на подключение в блокирующем синхронном режиме. Можно использовать любой <xref:System.Net.Sockets.TcpClient>или <xref:System.Net.Sockets.Socket>соединяться с TcpListener.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpClient> Создание с помощью TcpListener <xref:System.Net.IPEndPoint>, локальный IP-адрес и номер порта или номер порта.</xref:System.Net.IPEndPoint> Укажите <xref:System.Net.IPAddress.Any>для локального IP-адреса и значение 0 для номера локального порта, если требуется, чтобы эти значения были присвоены основным поставщиком услуг.</xref:System.Net.IPAddress.Any> Если вы решите сделать это, можно использовать <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>свойство для идентификации связанных сведений после подключения сокета.</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       Используйте <xref:System.Net.Sockets.TcpListener.Start%2A>метод, чтобы начать прослушивание входящих запросов на подключение.</xref:System.Net.Sockets.TcpListener.Start%2A> <xref:System.Net.Sockets.TcpListener.Start%2A>очередь входящих подключений, пока не будет либо вызывает <xref:System.Net.Sockets.TcpListener.Stop%2A>метод, или он поставил в очередь <xref:System.Net.Sockets.SocketOptionName>.</xref:System.Net.Sockets.SocketOptionName> </xref:System.Net.Sockets.TcpListener.Stop%2A></xref:System.Net.Sockets.TcpListener.Start%2A> Используйте <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>или <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>для приема подключения из входной очереди подключений.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Эти два метода будет блокировать. Если вы хотите избежать блокировки, можно использовать <xref:System.Net.Sockets.TcpListener.Pending%2A>метод, чтобы определить, если запросы на подключение в очереди.</xref:System.Net.Sockets.TcpListener.Pending%2A>       Вызовите <xref:System.Net.Sockets.TcpListener.Stop%2A>метод закрытия TcpListener.</xref:System.Net.Sockets.TcpListener.Stop%2A>      Настроек [!NOTE] настроек <xref:System.Net.Sockets.TcpListener.Stop%2A>метод не закрывает все допустимые подключения.</xref:System.Net.Sockets.TcpListener.Stop%2A> Вы несете ответственность за закрытие их отдельно."
  example:
  - "The following code example creates a TcpListener.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener#1](~/add/codesnippet/cpp/t-system.net.sockets.tcp_0_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener#1](~/add/codesnippet/csharp/t-system.net.sockets.tcp_0_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener#1](~/add/codesnippet/visualbasic/t-system.net.sockets.tcp_0_1.vb)]  \n  \n See <xref:System.Net.Sockets.TcpClient> for a client example."
  syntax:
    content: public class TcpListener
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: TcpListener(Int32)
  nameWithType: TcpListener.TcpListener(Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(Int32)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> класс, который прослушивает указанный порт."
  remarks: "Этот конструктор устарел. Используйте <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=fullName>или <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=fullName>конструкторов.</xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=fullName> </xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=fullName>       Этот конструктор позволяет указать номер порта для прослушивания входящих попыток подключения. С помощью этого конструктора основной поставщик услуг присваивает наиболее подходящий сетевой адрес. Если неважно, какой локальный порт используется, можно указать 0 для номера порта. В этом случае поставщик услуг присвоит доступный номер порта от 1024 до 5000. При использовании этого подхода можно выяснить, какой локальный сетевой адрес и номер порта присвоены с помощью <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>свойство.</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       Вызовите <xref:System.Net.Sockets.TcpListener.Start%2A>метод, чтобы начать прослушивание входящих попыток подключения.</xref:System.Net.Sockets.TcpListener.Start%2A>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.TcpListener> using a local port number.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/add/codesnippet/cpp/m-system.net.sockets.tcp_18_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/add/codesnippet/csharp/m-system.net.sockets.tcp_18_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_18_1.vb)]"
  syntax:
    content: public TcpListener (int port);
    parameters:
    - id: port
      type: System.Int32
      description: "Порт для прослушивания входящих попыток подключения."
  overload: System.Net.Sockets.TcpListener.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>port</code>не находится между <xref:System.Net.IPEndPoint.MinPort> и <xref:System.Net.IPEndPoint.MaxPort>."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
  id: '#ctor(System.Net.IPEndPoint)'
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: TcpListener(IPEndPoint)
  nameWithType: TcpListener.TcpListener(IPEndPoint)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPEndPoint)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> класса с заданной локальной конечной точкой."
  remarks: "Этот конструктор позволяет указать локальный IP-адрес и номер порта, на котором будет прослушивать входящие подключения попыток. Прежде чем использовать этот конструктор, необходимо создать <xref:System.Net.IPEndPoint>с помощью нужный локальный IP-адрес и порт номер.</xref:System.Net.IPEndPoint> Передать этот <xref:System.Net.IPEndPoint>конструктору как `localEP` параметр.</xref:System.Net.IPEndPoint>       Если неважно, какой локальный адрес будет присвоен, можно создать <xref:System.Net.IPEndPoint>с помощью <xref:System.Net.IPAddress.Any?displayProperty=fullName>как параметр address и базовой службы Поставщик присвоит наиболее подходящий сетевой адрес.</xref:System.Net.IPAddress.Any?displayProperty=fullName> </xref:System.Net.IPEndPoint> Это поможет упростить приложение, если имеется несколько сетевых интерфейсов. Если неважно, какой локальный порт используется, можно создать <xref:System.Net.IPEndPoint>используется значение 0 для номера порта.</xref:System.Net.IPEndPoint> В этом случае поставщик услуг присвоит доступный номер порта от 1024 до 5000. При использовании этого подхода можно выяснить, какой локальный сетевой адрес и номер порта присвоены с помощью <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>свойство.</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       Вызовите <xref:System.Net.Sockets.TcpListener.Start%2A>метод, чтобы начать прослушивание входящих попыток подключения.</xref:System.Net.Sockets.TcpListener.Start%2A>      Настроек [!NOTE] настроек данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example creates an instance of the <xref:System.Net.Sockets.TcpListener> class using the local endpoint.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_20_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_20_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_20_1.vb)]"
  syntax:
    content: public TcpListener (System.Net.IPEndPoint localEP);
    parameters:
    - id: localEP
      type: System.Net.IPEndPoint
      description: "<xref:System.Net.IPEndPoint>, Представляющий локальную конечную точку, к которому требуется привязать прослушивателя <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.IPEndPoint>"
  overload: System.Net.Sockets.TcpListener.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>localEP</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
  id: '#ctor(System.Net.IPAddress,System.Int32)'
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: TcpListener(IPAddress,Int32)
  nameWithType: TcpListener.TcpListener(IPAddress,Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPAddress,Int32)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> попыток класс, который прослушивает входящие соединения на указанный локальный IP-адрес и порт номер."
  remarks: "Этот конструктор позволяет указать локальный IP-адрес и номер порта, на котором будет прослушивать входящие подключения попыток. Перед вызовом конструктора, необходимо сначала создать <xref:System.Net.IPAddress>с помощью необходимый локальный адрес.</xref:System.Net.IPAddress> Передать этот <xref:System.Net.IPAddress>конструктору как `localaddr` параметр.</xref:System.Net.IPAddress> Если неважно, какой локальный адрес будет присвоен, укажите <xref:System.Net.IPAddress.Any?displayProperty=fullName>для `localaddr` параметр и основной поставщик услуг присвоит наиболее подходящий сетевой адрес.</xref:System.Net.IPAddress.Any?displayProperty=fullName> Это поможет упростить приложение, если имеется несколько сетевых интерфейсов. Если неважно, какой локальный порт используется, можно указать 0 для номера порта. В этом случае поставщик услуг присвоит доступный номер порта от 1024 до 5000. При использовании этого подхода можно выяснить, какой локальный сетевой адрес и номер порта присвоены с помощью <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>свойство.</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       Вызовите <xref:System.Net.Sockets.TcpListener.Start%2A>метод, чтобы начать прослушивание входящих попыток подключения.</xref:System.Net.Sockets.TcpListener.Start%2A>      Настроек [!NOTE] настроек данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example creates an instance of the <xref:System.Net.Sockets.TcpListener> class using a local IP address and port number.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/add/codesnippet/cpp/m-system.net.sockets.tcp_19_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/add/codesnippet/csharp/m-system.net.sockets.tcp_19_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_19_1.vb)]"
  syntax:
    content: public TcpListener (System.Net.IPAddress localaddr, int port);
    parameters:
    - id: localaddr
      type: System.Net.IPAddress
      description: "<xref:System.Net.IPAddress>, Представляющий локальный IP-адрес.</xref:System.Net.IPAddress>"
    - id: port
      type: System.Int32
      description: "Порт для прослушивания входящих попыток подключения."
  overload: System.Net.Sockets.TcpListener.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>localaddr</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>port</code>не находится между <xref:System.Net.IPEndPoint.MinPort> и <xref:System.Net.IPEndPoint.MaxPort>."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptSocket
  id: AcceptSocket
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptSocket()
  nameWithType: TcpListener.AcceptSocket()
  fullName: System.Net.Sockets.TcpListener.AcceptSocket()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Принимает ожидающий запрос на подключение."
  remarks: "AcceptSocket — это блокирующий метод, возвращающий <xref:System.Net.Sockets.Socket>, можно использовать для отправки и получения данных.</xref:System.Net.Sockets.Socket> Если вы хотите избежать блокировки, используйте <xref:System.Net.Sockets.TcpListener.Pending%2A>метод для определения запросов на подключение в очереди входящих подключений.</xref:System.Net.Sockets.TcpListener.Pending%2A>       <xref:System.Net.Sockets.Socket>Вернул инициализируется при помощи IP адрес и номер порта удаленного узла.</xref:System.Net.Sockets.Socket> Можно использовать любой из <xref:System.Net.Sockets.Socket.Send%2A>и <xref:System.Net.Sockets.Socket.Receive%2A>методов, доступных в <xref:System.Net.Sockets.Socket>класса для взаимодействия с удаленным узлом.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.Receive%2A> </xref:System.Net.Sockets.Socket.Send%2A> По окончании с помощью <xref:System.Net.Sockets.Socket>, необходимо вызвать его <xref:System.Net.Sockets.Socket.Close%2A>метод.</xref:System.Net.Sockets.Socket.Close%2A> </xref:System.Net.Sockets.Socket> Если приложения относительно прост, рассмотрите возможность использования <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>метод вместо метода AcceptSocket.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpClient>предоставляет простые методы для отправки и получения данных по сети в блокирующем синхронном режиме.</xref:System.Net.Sockets.TcpClient>      Настроек [!NOTE] настроек данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "In the following code example, the AcceptSocket method is used to return a <xref:System.Net.Sockets.Socket>. This <xref:System.Net.Sockets.Socket> is used to communicate with the newly connected client.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/add/codesnippet/cpp/m-system.net.sockets.tcp_7_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/add/codesnippet/csharp/m-system.net.sockets.tcp_7_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_7_1.vb)]"
  syntax:
    content: public System.Net.Sockets.Socket AcceptSocket ();
    parameters: []
    return:
      type: System.Net.Sockets.Socket
      description: "Объект <xref:System.Net.Sockets.Socket>используется для отправки и получения данных.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.AcceptSocket*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Прослушиватель не была запущена с помощью вызова <xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptSocketAsync
  id: AcceptSocketAsync
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptSocketAsync()
  nameWithType: TcpListener.AcceptSocketAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptSocketAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Принимает ожидающий запрос на подключение в качестве асинхронной операции."
  remarks: "Эта операция не будет блокирована. Возвращенный <xref:System.Threading.Tasks.Task%601>объекта будет выполнена после принятия подключение через сокет.</xref:System.Threading.Tasks.Task%601>       <xref:System.Net.Sockets.Socket>Возвращается в <xref:System.Threading.Tasks.Task%601>инициализируется при помощи IP адрес и номер порта удаленного узла.</xref:System.Threading.Tasks.Task%601> </xref:System.Net.Sockets.Socket> Можно использовать любой из <xref:System.Net.Sockets.Socket.Send%2A>и <xref:System.Net.Sockets.Socket.Receive%2A>методов, доступных в <xref:System.Net.Sockets.Socket>класса для взаимодействия с удаленным узлом.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.Receive%2A> </xref:System.Net.Sockets.Socket.Send%2A> По окончании с помощью <xref:System.Net.Sockets.Socket>, необходимо вызвать его <xref:System.Net.Sockets.Socket.Close%2A>метод.</xref:System.Net.Sockets.Socket.Close%2A> </xref:System.Net.Sockets.Socket> Если приложения относительно прост, рассмотрите возможность использования <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>метод вместо метода AcceptSocketAsync.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpClient>предоставляет простые методы для отправки и получения данных по сети в блокирующем синхронном режиме.</xref:System.Net.Sockets.TcpClient>      Настроек [!NOTE] настроек данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Threading.Tasks.Task<System.Net.Sockets.Socket> AcceptSocketAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task{System.Net.Sockets.Socket}
      description: "Возвращает &lt;xref:System.Threading.Tasks.Task%601&gt; объект задачи, представляющий асинхронную операцию. &lt;Xref:System.Threading.Tasks.Task%601.Result%2A&gt; свойство объекта задачи возвращает <xref:System.Net.Sockets.Socket>используется для отправки и получения данных.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.AcceptSocketAsync*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Прослушиватель не была запущена с помощью вызова <xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptTcpClient
  id: AcceptTcpClient
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptTcpClient()
  nameWithType: TcpListener.AcceptTcpClient()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClient()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Принимает ожидающий запрос на подключение."
  remarks: "AcceptTcpClient — это блокирующий метод, возвращающий <xref:System.Net.Sockets.TcpClient>, можно использовать для отправки и получения данных.</xref:System.Net.Sockets.TcpClient> Используйте <xref:System.Net.Sockets.TcpListener.Pending%2A>метод, чтобы определить, если запросы на подключение доступны в очереди входящих подключений, чтобы избежать блокировки.</xref:System.Net.Sockets.TcpListener.Pending%2A>       Используйте <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName>метод, чтобы получить базовые <xref:System.Net.Sockets.NetworkStream>возвращаемый <xref:System.Net.Sockets.TcpClient>.</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName> <xref:System.Net.Sockets.NetworkStream>Будет предоставляют методы для отправки и получения с удаленным узлом.</xref:System.Net.Sockets.NetworkStream> После завершения использования с <xref:System.Net.Sockets.TcpClient>, необходимо вызвать его <xref:System.Net.Sockets.TcpClient.Close%2A>метод.</xref:System.Net.Sockets.TcpClient.Close%2A> </xref:System.Net.Sockets.TcpClient> Если требуется больше гибкости, чем <xref:System.Net.Sockets.TcpClient>предложения, рассмотрите возможность использования <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> </xref:System.Net.Sockets.TcpClient>      Настроек [!NOTE] настроек данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "In the following code example, the AcceptTcpClient method is used to return a <xref:System.Net.Sockets.TcpClient>. This <xref:System.Net.Sockets.TcpClient> is used to communicate with the newly connected client.  \n  \n [!code-cs[Classic TcpListenerExample#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_15_1.cs)]\n [!code-cpp[Classic TcpListenerExample#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_15_1.cpp)]\n [!code-vb[Classic TcpListenerExample#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_15_1.vb)]"
  syntax:
    content: public System.Net.Sockets.TcpClient AcceptTcpClient ();
    parameters: []
    return:
      type: System.Net.Sockets.TcpClient
      description: "Объект <xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref> используется для отправки и получения данных."
  overload: System.Net.Sockets.TcpListener.AcceptTcpClient*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Прослушиватель не была запущена с помощью вызова <xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Используйте &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; , чтобы получить конкретный код ошибки. Если вы получили этот код, можно ссылаться на подробное описание ошибки документации по кодам ошибок API Windows Sockets версии 2 в библиотеке MSDN."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptTcpClientAsync
  id: AcceptTcpClientAsync
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptTcpClientAsync()
  nameWithType: TcpListener.AcceptTcpClientAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClientAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Принимает ожидающий запрос на подключение в качестве асинхронной операции."
  remarks: "Эта операция не будет блокирована. Возвращенный <xref:System.Threading.Tasks.Task%601>объекта будет выполнена после принятия соединения по протоколу TCP.</xref:System.Threading.Tasks.Task%601>       Используйте <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName>метод, чтобы получить базового <xref:System.Net.Sockets.NetworkStream>объекта, возвращенные <xref:System.Net.Sockets.TcpClient>в списке <xref:System.Threading.Tasks.Task%601>.</xref:System.Threading.Tasks.Task%601> </xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName> <xref:System.Net.Sockets.NetworkStream>Будет предоставляют методы для отправки и получения с удаленным узлом.</xref:System.Net.Sockets.NetworkStream> После завершения использования с <xref:System.Net.Sockets.TcpClient>, необходимо вызвать его <xref:System.Net.Sockets.TcpClient.Close%2A>метод.</xref:System.Net.Sockets.TcpClient.Close%2A> </xref:System.Net.Sockets.TcpClient> Если требуется больше гибкости, чем <xref:System.Net.Sockets.TcpClient>предложения, рассмотрите возможность использования <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>или <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A>.</xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> </xref:System.Net.Sockets.TcpClient>      Настроек [!NOTE] настроек данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Threading.Tasks.Task<System.Net.Sockets.TcpClient> AcceptTcpClientAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task{System.Net.Sockets.TcpClient}
      description: "Возвращает &lt;xref:System.Threading.Tasks.Task%601&gt; объект задачи, представляющий асинхронную операцию. &lt;Xref:System.Threading.Tasks.Task%601.Result%2A&gt; свойство объекта задачи возвращает <xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref> используется для отправки и получения данных."
  overload: System.Net.Sockets.TcpListener.AcceptTcpClientAsync*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Прослушиватель не была запущена с помощью вызова <xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Используйте &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; , чтобы получить конкретный код ошибки. Если вы получили этот код, можно ссылаться на подробное описание ошибки документации по кодам ошибок API Windows Sockets версии 2 в библиотеке MSDN."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Active
  id: Active
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Active
  nameWithType: TcpListener.Active
  fullName: System.Net.Sockets.TcpListener.Active
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Возвращает значение, указывающее, является ли <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> активно прослушивает соответствующий порт для клиентских подключений."
  remarks: "Классы, производные от <xref:System.Net.Sockets.TcpListener>это свойство можно использовать для определения <xref:System.Net.Sockets.Socket>в настоящее время прослушивание входящих попыток подключения.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener> <xref:System.Net.Sockets.TcpClient.Active%2A>Свойство может использоваться, чтобы избежать избыточных <xref:System.Net.Sockets.TcpListener.Start%2A>пытается.</xref:System.Net.Sockets.TcpListener.Start%2A> </xref:System.Net.Sockets.TcpClient.Active%2A>"
  syntax:
    content: protected bool Active { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> активно прослушивания; в противном случае — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.TcpListener.Active*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)
  id: AllowNatTraversal(System.Boolean)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AllowNatTraversal(Boolean)
  nameWithType: TcpListener.AllowNatTraversal(Boolean)
  fullName: System.Net.Sockets.TcpListener.AllowNatTraversal(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Включает или отключает обход сетевых адресов (NAT) для <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> экземпляра."
  remarks: "Метод AllowNatTraversal используется для включения или отключения прохождения NAT для <xref:System.Net.Sockets.TcpListener>экземпляра.</xref:System.Net.Sockets.TcpListener> Обход NAT может предоставляться Teredo, 6to4 или туннель ISATAP.       Когда `allowed` параметр имеет значение false, <xref:System.Net.Sockets.SocketOptionName>на связанного сокета был установлен в <xref:System.Net.Sockets.IPProtectionLevel>.</xref:System.Net.Sockets.IPProtectionLevel> </xref:System.Net.Sockets.SocketOptionName> Это явно отключает прохождения NAT для <xref:System.Net.Sockets.TcpListener>экземпляра.</xref:System.Net.Sockets.TcpListener>       Когда `allowed` параметр имеет значение true, <xref:System.Net.Sockets.SocketOptionName>для связанного сокета был установлен в <xref:System.Net.Sockets.IPProtectionLevel>.</xref:System.Net.Sockets.IPProtectionLevel> </xref:System.Net.Sockets.SocketOptionName> Это может позволить прохождения NAT для <xref:System.Net.Sockets.TcpListener>в зависимости от правил брандмауэра на месте в системе.</xref:System.Net.Sockets.TcpListener>       Метод AllowNatTraversal должен быть вызван до вызова метода <xref:System.Net.Sockets.TcpListener.Start%2A>метод, чтобы начать прослушивание входящих запросов на подключение (перед привязкой сокета).</xref:System.Net.Sockets.TcpListener.Start%2A> При вызове метода AllowNatTraversal после <xref:System.Net.Sockets.TcpListener.Start%2A>метод, то <xref:System.InvalidOperationException>будет создано.</xref:System.InvalidOperationException> </xref:System.Net.Sockets.TcpListener.Start%2A>       Адрес Teredo — IPv6-адрес с префиксом 2001:: / 32. Адреса Teredo можно возвращенные с помощью обычного разрешения имен DNS или перечислены как IPv6-адрес локального интерфейса."
  syntax:
    content: public void AllowNatTraversal (bool allowed);
    parameters:
    - id: allowed
      type: System.Boolean
      description: "Логическое значение, указывающее, следует ли включить или отключить прохождения NAT."
  overload: System.Net.Sockets.TcpListener.AllowNatTraversal*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Метод AllowNatTraversal был вызван после вызова <xref:System.Net.Sockets.TcpListener.Start*>метода</xref:System.Net.Sockets.TcpListener.Start*>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)
  id: BeginAcceptSocket(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: BeginAcceptSocket(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptSocket(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptSocket(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Начинает асинхронную операцию, чтобы принять попытку входящего подключения."
  remarks: "Асинхронная операция BeginAcceptSocket необходимо завершить путем вызова <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A>метод.</xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> Как правило, вызывается метод `callback` делегата.       Этот метод блокируется до завершения операции. Для блокирования до завершения операции, используйте <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>метод.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>       Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/add/includes/ajax-current-ext-md.md).      Настроек [!NOTE] настроек можно вызвать <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>свойство возвращаемого <xref:System.Net.Sockets.Socket>для идентификации удаленного узла сетевой адрес и номер порта.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>      Настроек [!NOTE] настроек при получении <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>свойство, чтобы получить конкретный код ошибки и обратитесь к документации Windows Sockets версии 2 API ошибок кода в библиотеке MSDN по [http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/) подробное описание ошибки.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      Настроек [!NOTE] настроек данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates the use of the BeginAcceptSocket method to create and connect a socket. The callback delegate calls the <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/cpp/1d0c3046-b366-41a2-aab6-_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/csharp/1d0c3046-b366-41a2-aab6-_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/visualbasic/1d0c3046-b366-41a2-aab6-_1.vb)]"
  syntax:
    content: public IAsyncResult BeginAcceptSocket (AsyncCallback callback, object state);
    parameters:
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>Делегат, который ссылается на метод, который вызывается при завершении операции.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Определяемый пользователем объект, содержащий сведения об операции принятия. Этот объект передается `callback` делегат при завершении операции."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Который ссылается на асинхронное создание <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.IAsyncResult>"
  overload: System.Net.Sockets.TcpListener.BeginAcceptSocket*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Произошла ошибка при попытке доступа к сокету. Дополнительные сведения см."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref:System.Net.Sockets.Socket>Было закрыто.</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  id: BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: BeginAcceptTcpClient(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Начинает асинхронную операцию, чтобы принять попытку входящего подключения."
  remarks: "Асинхронная операция BeginAcceptTcpClient необходимо завершить путем вызова <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A>метод.</xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> Как правило, вызывается метод `callback` делегата.       Этот метод блокируется до завершения операции. Для блокирования до завершения операции, используйте <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>метод.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>       Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/add/includes/ajax-current-ext-md.md).      Настроек [!NOTE] настроек при получении <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>свойство, чтобы получить конкретный код ошибки и обратитесь к документации Windows Sockets версии 2 API ошибок кода в библиотеке MSDN по [http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/) подробное описание ошибки.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      Настроек [!NOTE] настроек данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates the use of the BeginAcceptTcpClient method to create and connect a socket. The callback delegate calls the <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/cpp/5290dfb8-7e8f-4cf6-b64e-_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/csharp/5290dfb8-7e8f-4cf6-b64e-_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/visualbasic/5290dfb8-7e8f-4cf6-b64e-_1.vb)]"
  syntax:
    content: public IAsyncResult BeginAcceptTcpClient (AsyncCallback callback, object state);
    parameters:
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>Делегат, который ссылается на метод, который вызывается при завершении операции.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Определяемый пользователем объект, содержащий сведения об операции принятия. Этот объект передается `callback` делегат при завершении операции."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>, Ссылается на асинхронное создание объекта <xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref>.</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.TcpListener.BeginAcceptTcpClient*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Произошла ошибка при попытке доступа к сокету. Дополнительные сведения см."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref:System.Net.Sockets.Socket>Было закрыто.</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Create(System.Int32)
  id: Create(System.Int32)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Create(Int32)
  nameWithType: TcpListener.Create(Int32)
  fullName: System.Net.Sockets.TcpListener.Create(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Создает новый <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> экземпляра на указанный порт."
  syntax:
    content: public static System.Net.Sockets.TcpListener Create (int port);
    parameters:
    - id: port
      type: System.Int32
      description: "Порт для прослушивания входящих попыток подключения."
    return:
      type: System.Net.Sockets.TcpListener
      description: "Returns <xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>.       Новый <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> экземпляра на указанный порт."
  overload: System.Net.Sockets.TcpListener.Create*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)
  id: EndAcceptSocket(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: EndAcceptSocket(IAsyncResult)
  nameWithType: TcpListener.EndAcceptSocket(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptSocket(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Асинхронно принимает входящие попытки подключения и создает новый <xref:System.Net.Sockets.Socket>для обработки связи с удаленным узлом.</xref:System.Net.Sockets.Socket>"
  remarks: "Этот метод блокируется до операции завершения. Для синхронного выполнения этой операции, используйте <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>метод.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>      Настроек [!NOTE] настроек можно вызвать <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>свойство возвращаемого <xref:System.Net.Sockets.Socket>для идентификации удаленного узла сетевой адрес и номер порта.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>      Настроек [!NOTE] настроек при получении <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>свойство, чтобы получить конкретный код ошибки и обратитесь к документации Windows Sockets версии 2 API ошибок кода в библиотеке MSDN по [http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/) подробное описание ошибки.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      Настроек [!NOTE] настроек данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates the use of the <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> method to create and connect a socket. The callback delegate calls the EndAcceptSocket method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/cpp/m-system.net.sockets.tcp_14_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/csharp/m-system.net.sockets.tcp_14_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_14_1.vb)]"
  syntax:
    content: public System.Net.Sockets.Socket EndAcceptSocket (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Возвращается путем вызова <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*>метод.</xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*> </xref:System.IAsyncResult>"
    return:
      type: System.Net.Sockets.Socket
      description: "A <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>       <xref:System.Net.Sockets.Socket>Используется для отправки и получения данных.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.EndAcceptSocket*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Базовый <xref:System.Net.Sockets.Socket>было закрыто.</xref:System.Net.Sockets.Socket>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> asyncResult </code> Параметр не был создан с помощью вызова <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*>метод.</xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Метод EndAcceptSocket был вызван ранее."
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Произошла ошибка при попытке доступа к <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> Дополнительные сведения см."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)
  id: EndAcceptTcpClient(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: EndAcceptTcpClient(IAsyncResult)
  nameWithType: TcpListener.EndAcceptTcpClient(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptTcpClient(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Асинхронно принимает входящие попытки подключения и создает новый <xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref> для обработки связи с удаленным узлом."
  remarks: "Этот метод блокируется до операции завершения. Для синхронного выполнения этой операции, используйте <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>метод.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>      Настроек [!NOTE] настроек можно вызвать <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>свойства базового сокета (<xref:System.Net.Sockets.TcpClient.Client%2A>) для определения удаленного узла сетевой адрес и номер порта.</xref:System.Net.Sockets.TcpClient.Client%2A> </xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>      Настроек [!NOTE] настроек при получении <xref:System.Net.Sockets.SocketException>, используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>свойство, чтобы получить конкретный код ошибки и обратитесь к документации Windows Sockets версии 2 API ошибок кода в библиотеке MSDN по [http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/) подробное описание ошибки.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      Настроек [!NOTE] настроек данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates the use of the <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> method to create and connect a socket. The callback delegate calls the EndAcceptTcpClient method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/cpp/m-system.net.sockets.tcp_8_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/csharp/m-system.net.sockets.tcp_8_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_8_1.vb)]"
  syntax:
    content: public System.Net.Sockets.TcpClient EndAcceptTcpClient (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Возвращается путем вызова <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient*>метод.</xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient*> </xref:System.IAsyncResult>"
    return:
      type: System.Net.Sockets.TcpClient
      description: "A <xref href=&quot;System.Net.Sockets.TcpClient&quot;></xref>.       <xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref> Используется для отправки и получения данных."
  overload: System.Net.Sockets.TcpListener.EndAcceptTcpClient*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.ExclusiveAddressUse
  id: ExclusiveAddressUse
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: ExclusiveAddressUse
  nameWithType: TcpListener.ExclusiveAddressUse
  fullName: System.Net.Sockets.TcpListener.ExclusiveAddressUse
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Возвращает или задает <xref:System.Boolean>значение, указывающее, является ли <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> допускает только один основной сокет для прослушивания конкретного порта</xref:System.Boolean>"
  remarks: "По умолчанию несколько прослушивателей может прослушивать определенный порт. Однако только один из прослушивателей выполнять операции на сетевом трафике, отправляемом на порт. Если более одного прослушивателя пытается выполнить привязку к конкретному порту, тем более конкретные IP-адрес обрабатывает сетевого трафика, отправляемого на порт. Можно использовать <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>свойство, чтобы предотвратить несколько прослушивателей с прослушивания конкретного порта, выполните следующие действия.</xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>       Задать это свойство до вызова метода <xref:System.Net.Sockets.TcpListener.Start%2A>, или вызов <xref:System.Net.Sockets.TcpListener.Stop%2A>метод и задайте для этого свойства.</xref:System.Net.Sockets.TcpListener.Stop%2A> </xref:System.Net.Sockets.TcpListener.Start%2A>"
  example:
  - "The following code example gets and sets the ExclusiveAddressUse property.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#2](~/add/codesnippet/cpp/p-system.net.sockets.tcp_9_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#2](~/add/codesnippet/csharp/p-system.net.sockets.tcp_9_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#2](~/add/codesnippet/visualbasic/p-system.net.sockets.tcp_9_1.vb)]"
  syntax:
    content: public bool ExclusiveAddressUse { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> позволяет только одному <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> на прослушивание определенного порта; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. . Значение по умолчанию — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> для Windows Server 2003 и Windows XP с пакетом обновления 2 и более поздней версии, и <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для всех остальных версий."
  overload: System.Net.Sockets.TcpListener.ExclusiveAddressUse*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref> Запущена. Вызовите <xref href=&quot;System.Net.Sockets.TcpListener.Stop&quot;> </xref> метода и затем установить <xref:System.Net.Sockets.Socket.ExclusiveAddressUse*>свойство.</xref:System.Net.Sockets.Socket.ExclusiveAddressUse*>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Произошла ошибка при попытке доступа к основному сокету."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Базовый <xref:System.Net.Sockets.Socket>было закрыто.</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.LocalEndpoint
  id: LocalEndpoint
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: LocalEndpoint
  nameWithType: TcpListener.LocalEndpoint
  fullName: System.Net.Sockets.TcpListener.LocalEndpoint
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Возвращает базовый <xref:System.Net.EndPoint>текущего <xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref>.</xref:System.Net.EndPoint>"
  remarks: "Свойство LocalEndpoint используется для идентификации локальной сетевой интерфейс и номер порта, используемого для прослушивания входящих клиентских запросов на подключение после подключения к сокету. Сначала необходимо привести это <xref:System.Net.EndPoint>на <xref:System.Net.IPEndPoint>.</xref:System.Net.IPEndPoint> </xref:System.Net.EndPoint> Затем можно вызвать <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName>Свойства, чтобы получить локальный IP-адрес и <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName>Свойства, чтобы получить имя локального порта.</xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> </xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName>"
  example:
  - "The following code example displays the local IP address and port number on which the <xref:System.Net.Sockets.TcpListener> is listening for incoming connection requests.  \n  \n [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/cpp/p-system.net.sockets.tcp_5_1.cpp)]\n [!code-cs[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/csharp/p-system.net.sockets.tcp_5_1.cs)]\n [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/visualbasic/p-system.net.sockets.tcp_5_1.vb)]"
  syntax:
    content: public System.Net.EndPoint LocalEndpoint { get; }
    return:
      type: System.Net.EndPoint
      description: "<xref:System.Net.EndPoint>К которому <xref:System.Net.Sockets.Socket>привязан.</xref:System.Net.Sockets.Socket> </xref:System.Net.EndPoint>"
  overload: System.Net.Sockets.TcpListener.LocalEndpoint*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Pending
  id: Pending
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Pending()
  nameWithType: TcpListener.Pending()
  fullName: System.Net.Sockets.TcpListener.Pending()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Определяет, имеются ожидающие запросы на подключение."
  remarks: "Это неблокирующий метод определяет, имеются все ожидающие запросы на подключение. Так как <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>и <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>методов блокировки выполнения до <xref:System.Net.Sockets.TcpListener.Start%2A>метод поставил в очередь входящий запрос на подключение, ожидающие метод можно использовать для определения доступных подключений перед попыткой принять их.</xref:System.Net.Sockets.TcpListener.Start%2A> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>"
  example:
  - "The following code example checks the Pending method. If a connection request is waiting to be accepted, then a call to the <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> method is made.  \n  \n [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_5_1.cpp)]\n [!code-cs[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_5_1.cs)]\n [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_5_1.vb)]"
  syntax:
    content: public bool Pending ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если имеются ожидающие подключения; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.Sockets.TcpListener.Pending*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Прослушиватель не была запущена с помощью вызова <xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Server
  id: Server
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Server
  nameWithType: TcpListener.Server
  fullName: System.Net.Sockets.TcpListener.Server
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Возвращает основной сетевой <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.TcpListener>Создает <xref:System.Net.Sockets.Socket>для прослушивания входящих клиентских запросов на подключение.</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.TcpListener> Классы, производные от <xref:System.Net.Sockets.TcpListener>можно использовать это свойство, чтобы получить <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener> Используйте основной <xref:System.Net.Sockets.Socket>возвращенная свойством сервера, если требуется доступ, выходящих за пределы которой <xref:System.Net.Sockets.TcpListener>предоставляет.</xref:System.Net.Sockets.TcpListener> </xref:System.Net.Sockets.Socket>      Настроек [!NOTE] настроек свойства сервера возвращаются только <xref:System.Net.Sockets.Socket>используемый для прослушивания входящих клиентских запросов на подключение.</xref:System.Net.Sockets.Socket> Используйте <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>метод для принятия ожидающего запроса на подключение и для получения <xref:System.Net.Sockets.Socket>для отправки и получения данных.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Можно также использовать <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>метод для принятия ожидающего запроса на подключение и для получения <xref:System.Net.Sockets.TcpClient>для отправки и получения данных.</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>"
  example:
  - "The following code example demonstrates the use of the Server property. The underlying <xref:System.Net.Sockets.Socket> is retrieved and the <xref:System.Net.Sockets.SocketOptionName><xref:System.Net.Sockets.Socket> option is configured to time out after 10 seconds if data still remains in the network buffer after the connection is closed.  \n  \n [!code-vb[TcpListenerProtectedMembers1#1](~/add/codesnippet/visualbasic/p-system.net.sockets.tcp_10_1.vb)]\n [!code-cs[TcpListenerProtectedMembers1#1](~/add/codesnippet/csharp/p-system.net.sockets.tcp_10_1.cs)]"
  syntax:
    content: public System.Net.Sockets.Socket Server { get; }
    return:
      type: System.Net.Sockets.Socket
      description: "Базовый <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.Server*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Start
  id: Start
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Start()
  nameWithType: TcpListener.Start()
  fullName: System.Net.Sockets.TcpListener.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Начинает прослушивание входящих запросов на подключение."
  remarks: "Метод Start Инициализирует базовый <xref:System.Net.Sockets.Socket>, связывает его с локальной конечной точкой и выполняет прослушивание входящих попыток подключения.</xref:System.Net.Sockets.Socket> Если получен запрос на подключение, метод Start будет поместить запрос в очередь и продолжит ожидание дополнительные запросы, пока не будет вызван <xref:System.Net.Sockets.TcpListener.Stop%2A>метод.</xref:System.Net.Sockets.TcpListener.Stop%2A> Если <xref:System.Net.Sockets.TcpListener>получает запрос на соединение после его в очереди уже имеется максимальное число подключений, он будет вызывать <xref:System.Net.Sockets.SocketException>на клиентском компьютере.</xref:System.Net.Sockets.SocketException> </xref:System.Net.Sockets.TcpListener>       Чтобы удалить подключение из входной очереди, используйте <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>метод или <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>метод.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>Удалит подключение из очереди и возвращать метод <xref:System.Net.Sockets.TcpClient>, можно использовать для отправки и получения данных.</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>Метод будет возвращать <xref:System.Net.Sockets.Socket>, можно использовать для сделайте то же самое.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Если приложению требуется только синхронный ввод-вывод, используйте <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Для более тщательного контроля поведения используйте <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Оба эти метода блокированными, пока запрос на подключение в очереди.       Используйте <xref:System.Net.Sockets.TcpListener.Stop%2A>метод закрытия <xref:System.Net.Sockets.TcpListener>и прекратить прослушивание.</xref:System.Net.Sockets.TcpListener> </xref:System.Net.Sockets.TcpListener.Stop%2A> Вы несете ответственность за закрытие каждого из принятых подключений отдельно.      Настроек [!NOTE] настроек данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how Start is used to listen for incoming client connection attempts.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/cpp/m-system.net.sockets.tcp_6_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/csharp/m-system.net.sockets.tcp_6_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_6_1.vb)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Net.Sockets.TcpListener.Start*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Используйте &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; , чтобы получить конкретный код ошибки. Если вы получили этот код, можно ссылаться на подробное описание ошибки документации по кодам ошибок API Windows Sockets версии 2 в библиотеке MSDN."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Start(System.Int32)
  id: Start(System.Int32)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Start(Int32)
  nameWithType: TcpListener.Start(Int32)
  fullName: System.Net.Sockets.TcpListener.Start(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Начинает прослушивание входящих запросов на подключение максимальное количество ожидающих подключений."
  remarks: "<xref:System.Net.Sockets.TcpListener.Start%2A>Метод инициализирует базовый <xref:System.Net.Sockets.Socket>, связывает его с локальной конечной точкой и выполняет прослушивание входящих попыток подключения.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.Start%2A> Если получен запрос на подключение, <xref:System.Net.Sockets.TcpListener.Start%2A>будет поместить запрос в очередь и продолжит ожидание дополнительные запросы, пока не будет вызван <xref:System.Net.Sockets.TcpListener.Stop%2A>метод.</xref:System.Net.Sockets.TcpListener.Stop%2A> </xref:System.Net.Sockets.TcpListener.Start%2A> Если <xref:System.Net.Sockets.TcpListener>получает запрос на соединение после его в очереди уже имеется максимальное число подключений, он будет вызывать <xref:System.Net.Sockets.SocketException>на клиентском компьютере.</xref:System.Net.Sockets.SocketException> </xref:System.Net.Sockets.TcpListener>       Чтобы удалить подключение из входной очереди, используйте <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>метод или <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>метод.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>Удалит подключение из очереди и возвращать метод <xref:System.Net.Sockets.TcpClient>, можно использовать для отправки и получения данных.</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>Метод будет возвращать <xref:System.Net.Sockets.Socket>, можно использовать для сделайте то же самое.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Если приложению требуется только синхронный ввод-вывод, используйте <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Для детального контроля поведения используйте <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>метод.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Оба эти метода блокированными, пока запрос на подключение в очереди.       Используйте <xref:System.Net.Sockets.TcpListener.Stop%2A>метод закрытия <xref:System.Net.Sockets.TcpListener>и прекратить прослушивание.</xref:System.Net.Sockets.TcpListener> </xref:System.Net.Sockets.TcpListener.Stop%2A> Вы несете ответственность за закрытие каждого из принятых подключений отдельно.      Настроек [!NOTE] настроек используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>свойство, чтобы получить конкретный код ошибки и обратитесь к документации Windows Sockets версии 2 API ошибок кода в библиотеке MSDN по [http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/) подробное описание ошибки.</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>      Настроек [!NOTE] настроек данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates how <xref:System.Net.Sockets.TcpListener.Start%2A> is used to listen for incoming client connection attempts.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/cpp/m-system.net.sockets.tcp_17_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/csharp/m-system.net.sockets.tcp_17_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_17_1.vb)]"
  syntax:
    content: public void Start (int backlog);
    parameters:
    - id: backlog
      type: System.Int32
      description: "Максимальная длина очереди ожидающих подключений."
  overload: System.Net.Sockets.TcpListener.Start*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Произошла ошибка при обращении к сокету. Дополнительные сведения см."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>  backlog </code> Параметр — меньше нуля или превышает максимальное число разрешенных подключений."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Базовый <xref:System.Net.Sockets.Socket>имеет значение null.</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Stop
  id: Stop
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Stop()
  nameWithType: TcpListener.Stop()
  fullName: System.Net.Sockets.TcpListener.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "Закрывает прослушиватель."
  remarks: "Остановка закрывает прослушиватель. Запросы на подключение, неподдерживаемого в очереди будут потеряны. Удаленных узлов, Ожидание подключения могут быть приняты вызовет <xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> Вы несете ответственность за закрытие каждого из принятых подключений отдельно.      Настроек [!NOTE] настроек данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. в разделе [Трассировка сети в .NET Framework](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example demonstrates using the Stop method to close the underlying <xref:System.Net.Sockets.Socket>.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_9_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_9_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_9_1.vb)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Net.Sockets.TcpListener.Stop*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "Используйте &lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt; , чтобы получить конкретный код ошибки. Если вы получили этот код, можно ссылаться на подробное описание ошибки документации по кодам ошибок API Windows Sockets версии 2 в библиотеке MSDN."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Net.Sockets.SocketException
  isExternal: true
  name: System.Net.Sockets.SocketException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Net.Sockets.TcpListener.#ctor(System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener(Int32)
  nameWithType: TcpListener.TcpListener(Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener(IPEndPoint)
  nameWithType: TcpListener.TcpListener(IPEndPoint)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPEndPoint)
- uid: System.Net.IPEndPoint
  parent: System.Net
  isExternal: true
  name: IPEndPoint
  nameWithType: IPEndPoint
  fullName: System.Net.IPEndPoint
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener(IPAddress,Int32)
  nameWithType: TcpListener.TcpListener(IPAddress,Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPAddress,Int32)
- uid: System.Net.IPAddress
  parent: System.Net
  isExternal: true
  name: IPAddress
  nameWithType: IPAddress
  fullName: System.Net.IPAddress
- uid: System.Net.Sockets.TcpListener.AcceptSocket
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocket()
  nameWithType: TcpListener.AcceptSocket()
  fullName: System.Net.Sockets.TcpListener.AcceptSocket()
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: true
  name: Socket
  nameWithType: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.TcpListener.AcceptSocketAsync
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocketAsync()
  nameWithType: TcpListener.AcceptSocketAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptSocketAsync()
- uid: System.Threading.Tasks.Task{System.Net.Sockets.Socket}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Socket>
  nameWithType: Task<Socket>
  fullName: System.Threading.Tasks.Task<System.Net.Sockets.Socket>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Net.Sockets.Socket>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Net.Sockets.Socket
    name: Socket
    nameWithType: Socket
    fullName: Socket
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Net.Sockets.TcpListener.AcceptTcpClient
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClient()
  nameWithType: TcpListener.AcceptTcpClient()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClient()
- uid: System.Net.Sockets.TcpClient
  parent: System.Net.Sockets
  isExternal: false
  name: TcpClient
  nameWithType: TcpClient
  fullName: System.Net.Sockets.TcpClient
- uid: System.Net.Sockets.TcpListener.AcceptTcpClientAsync
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClientAsync()
  nameWithType: TcpListener.AcceptTcpClientAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClientAsync()
- uid: System.Threading.Tasks.Task{System.Net.Sockets.TcpClient}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<TcpClient>
  nameWithType: Task<TcpClient>
  fullName: System.Threading.Tasks.Task<System.Net.Sockets.TcpClient>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Net.Sockets.TcpClient>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Net.Sockets.TcpClient
    name: TcpClient
    nameWithType: TcpClient
    fullName: TcpClient
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Net.Sockets.TcpListener.Active
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Active
  nameWithType: TcpListener.Active
  fullName: System.Net.Sockets.TcpListener.Active
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AllowNatTraversal(Boolean)
  nameWithType: TcpListener.AllowNatTraversal(Boolean)
  fullName: System.Net.Sockets.TcpListener.AllowNatTraversal(Boolean)
- uid: System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptSocket(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptSocket(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptSocket(AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptTcpClient(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
- uid: System.Net.Sockets.TcpListener.Create(System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Create(Int32)
  nameWithType: TcpListener.Create(Int32)
  fullName: System.Net.Sockets.TcpListener.Create(Int32)
- uid: System.Net.Sockets.TcpListener
  parent: System.Net.Sockets
  isExternal: false
  name: TcpListener
  nameWithType: TcpListener
  fullName: System.Net.Sockets.TcpListener
- uid: System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptSocket(IAsyncResult)
  nameWithType: TcpListener.EndAcceptSocket(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptSocket(IAsyncResult)
- uid: System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptTcpClient(IAsyncResult)
  nameWithType: TcpListener.EndAcceptTcpClient(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptTcpClient(IAsyncResult)
- uid: System.Net.Sockets.TcpListener.ExclusiveAddressUse
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: ExclusiveAddressUse
  nameWithType: TcpListener.ExclusiveAddressUse
  fullName: System.Net.Sockets.TcpListener.ExclusiveAddressUse
- uid: System.Net.Sockets.TcpListener.LocalEndpoint
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: LocalEndpoint
  nameWithType: TcpListener.LocalEndpoint
  fullName: System.Net.Sockets.TcpListener.LocalEndpoint
- uid: System.Net.EndPoint
  parent: System.Net
  isExternal: true
  name: EndPoint
  nameWithType: EndPoint
  fullName: System.Net.EndPoint
- uid: System.Net.Sockets.TcpListener.Pending
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Pending()
  nameWithType: TcpListener.Pending()
  fullName: System.Net.Sockets.TcpListener.Pending()
- uid: System.Net.Sockets.TcpListener.Server
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Server
  nameWithType: TcpListener.Server
  fullName: System.Net.Sockets.TcpListener.Server
- uid: System.Net.Sockets.TcpListener.Start
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Start()
  nameWithType: TcpListener.Start()
  fullName: System.Net.Sockets.TcpListener.Start()
- uid: System.Net.Sockets.TcpListener.Start(System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Start(Int32)
  nameWithType: TcpListener.Start(Int32)
  fullName: System.Net.Sockets.TcpListener.Start(Int32)
- uid: System.Net.Sockets.TcpListener.Stop
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Stop()
  nameWithType: TcpListener.Stop()
  fullName: System.Net.Sockets.TcpListener.Stop()
- uid: System.Net.Sockets.TcpListener.#ctor*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener
  nameWithType: TcpListener.TcpListener
- uid: System.Net.Sockets.TcpListener.AcceptSocket*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocket
  nameWithType: TcpListener.AcceptSocket
- uid: System.Net.Sockets.TcpListener.AcceptSocketAsync*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocketAsync
  nameWithType: TcpListener.AcceptSocketAsync
- uid: System.Net.Sockets.TcpListener.AcceptTcpClient*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClient
  nameWithType: TcpListener.AcceptTcpClient
- uid: System.Net.Sockets.TcpListener.AcceptTcpClientAsync*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClientAsync
  nameWithType: TcpListener.AcceptTcpClientAsync
- uid: System.Net.Sockets.TcpListener.Active*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Active
  nameWithType: TcpListener.Active
- uid: System.Net.Sockets.TcpListener.AllowNatTraversal*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AllowNatTraversal
  nameWithType: TcpListener.AllowNatTraversal
- uid: System.Net.Sockets.TcpListener.BeginAcceptSocket*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptSocket
  nameWithType: TcpListener.BeginAcceptSocket
- uid: System.Net.Sockets.TcpListener.BeginAcceptTcpClient*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptTcpClient
  nameWithType: TcpListener.BeginAcceptTcpClient
- uid: System.Net.Sockets.TcpListener.Create*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Create
  nameWithType: TcpListener.Create
- uid: System.Net.Sockets.TcpListener.EndAcceptSocket*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptSocket
  nameWithType: TcpListener.EndAcceptSocket
- uid: System.Net.Sockets.TcpListener.EndAcceptTcpClient*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptTcpClient
  nameWithType: TcpListener.EndAcceptTcpClient
- uid: System.Net.Sockets.TcpListener.ExclusiveAddressUse*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: ExclusiveAddressUse
  nameWithType: TcpListener.ExclusiveAddressUse
- uid: System.Net.Sockets.TcpListener.LocalEndpoint*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: LocalEndpoint
  nameWithType: TcpListener.LocalEndpoint
- uid: System.Net.Sockets.TcpListener.Pending*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Pending
  nameWithType: TcpListener.Pending
- uid: System.Net.Sockets.TcpListener.Server*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Server
  nameWithType: TcpListener.Server
- uid: System.Net.Sockets.TcpListener.Start*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Start
  nameWithType: TcpListener.Start
- uid: System.Net.Sockets.TcpListener.Stop*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Stop
  nameWithType: TcpListener.Stop
