### YamlMime:ManagedReference
items:
- uid: System.Security.Principal.WindowsIdentity
  id: WindowsIdentity
  children:
  - System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr)
  - System.Security.Principal.WindowsIdentity.#ctor(System.Security.Principal.WindowsIdentity)
  - System.Security.Principal.WindowsIdentity.#ctor(System.String)
  - System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr,System.String)
  - System.Security.Principal.WindowsIdentity.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Security.Principal.WindowsIdentity.#ctor(System.String,System.String)
  - System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr,System.String,System.Security.Principal.WindowsAccountType)
  - System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr,System.String,System.Security.Principal.WindowsAccountType,System.Boolean)
  - System.Security.Principal.WindowsIdentity.AccessToken
  - System.Security.Principal.WindowsIdentity.AuthenticationType
  - System.Security.Principal.WindowsIdentity.Claims
  - System.Security.Principal.WindowsIdentity.Clone
  - System.Security.Principal.WindowsIdentity.DefaultIssuer
  - System.Security.Principal.WindowsIdentity.DeviceClaims
  - System.Security.Principal.WindowsIdentity.Dispose
  - System.Security.Principal.WindowsIdentity.Dispose(System.Boolean)
  - System.Security.Principal.WindowsIdentity.GetAnonymous
  - System.Security.Principal.WindowsIdentity.GetCurrent
  - System.Security.Principal.WindowsIdentity.GetCurrent(System.Boolean)
  - System.Security.Principal.WindowsIdentity.GetCurrent(System.Security.Principal.TokenAccessLevels)
  - System.Security.Principal.WindowsIdentity.Groups
  - System.Security.Principal.WindowsIdentity.Impersonate
  - System.Security.Principal.WindowsIdentity.Impersonate(System.IntPtr)
  - System.Security.Principal.WindowsIdentity.ImpersonationLevel
  - System.Security.Principal.WindowsIdentity.IsAnonymous
  - System.Security.Principal.WindowsIdentity.IsAuthenticated
  - System.Security.Principal.WindowsIdentity.IsGuest
  - System.Security.Principal.WindowsIdentity.IsSystem
  - System.Security.Principal.WindowsIdentity.Name
  - System.Security.Principal.WindowsIdentity.Owner
  - System.Security.Principal.WindowsIdentity.RunImpersonated(Microsoft.Win32.SafeHandles.SafeAccessTokenHandle,System.Action)
  - System.Security.Principal.WindowsIdentity.RunImpersonated``1(Microsoft.Win32.SafeHandles.SafeAccess``0okenHandle,System.Func{``0})
  - System.Security.Principal.WindowsIdentity.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)
  - System.Security.Principal.WindowsIdentity.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Security.Principal.WindowsIdentity.Token
  - System.Security.Principal.WindowsIdentity.User
  - System.Security.Principal.WindowsIdentity.UserClaims
  langs:
  - csharp
  name: WindowsIdentity
  nameWithType: WindowsIdentity
  fullName: System.Security.Principal.WindowsIdentity
  type: Class
  summary: "Представляет пользователя Windows."
  remarks: "Вызовите <xref:System.Security.Principal.WindowsIdentity.GetCurrent%2A>метод, чтобы создать объект WindowsIdentity, представляющий текущего пользователя.</xref:System.Security.Principal.WindowsIdentity.GetCurrent%2A>      Настроек [!IMPORTANT] настроек этот тип реализует <xref:System.IDisposable>интерфейса.</xref:System.IDisposable> После завершения с помощью типа следует освободить его прямо или косвенно. Для удаления типа непосредственно вызвать его <xref:System.IDisposable.Dispose%2A>метод в `try` / `catch` блока.</xref:System.IDisposable.Dispose%2A> Чтобы удалить ее косвенно, использовать языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <xref:System.IDisposable>разделе интерфейса.</xref:System.IDisposable>"
  example:
  - "The following example shows the use of members of WindowsIdentity class.  For an example showing how to obtain a Windows account token through a call to the unmanaged Win32 `LogonUser` function, and use that token to impersonate another user, see the <xref:System.Security.Principal.WindowsImpersonationContext> class.  \n  \n [!code-cs[System.Security.Principal.WindowsIdentity_AllMembers#1](~/add/codesnippet/csharp/t-system.security.princi_5_1.cs)]\n [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#1](~/add/codesnippet/cpp/t-system.security.princi_5_1.cpp)]\n [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#1](~/add/codesnippet/visualbasic/t-system.security.princi_5_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class WindowsIdentity : System.Security.Claims.ClaimsIdentity, IDisposable, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
  inheritance:
  - System.Object
  - System.Security.Claims.ClaimsIdentity
  implements:
  - System.IDisposable
  - System.Runtime.Serialization.IDeserializationCallback
  - System.Runtime.Serialization.ISerializable
  inheritedMembers:
  - System.Security.Claims.ClaimsIdentity.Actor
  - System.Security.Claims.ClaimsIdentity.AddClaim(System.Security.Claims.Claim)
  - System.Security.Claims.ClaimsIdentity.AddClaims(System.Collections.Generic.IEnumerable{System.Security.Claims.Claim})
  - System.Security.Claims.ClaimsIdentity.BootstrapContext
  - System.Security.Claims.ClaimsIdentity.CreateClaim(System.IO.BinaryReader)
  - System.Security.Claims.ClaimsIdentity.CustomSerializationData
  - System.Security.Claims.ClaimsIdentity.DefaultNameClaimType
  - System.Security.Claims.ClaimsIdentity.DefaultRoleClaimType
  - System.Security.Claims.ClaimsIdentity.FindAll(System.Predicate{System.Security.Claims.Claim})
  - System.Security.Claims.ClaimsIdentity.FindAll(System.String)
  - System.Security.Claims.ClaimsIdentity.FindFirst(System.Predicate{System.Security.Claims.Claim})
  - System.Security.Claims.ClaimsIdentity.FindFirst(System.String)
  - System.Security.Claims.ClaimsIdentity.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Security.Claims.ClaimsIdentity.HasClaim(System.Predicate{System.Security.Claims.Claim})
  - System.Security.Claims.ClaimsIdentity.HasClaim(System.String,System.String)
  - System.Security.Claims.ClaimsIdentity.Label
  - System.Security.Claims.ClaimsIdentity.NameClaimType
  - System.Security.Claims.ClaimsIdentity.RemoveClaim(System.Security.Claims.Claim)
  - System.Security.Claims.ClaimsIdentity.RoleClaimType
  - System.Security.Claims.ClaimsIdentity.TryRemoveClaim(System.Security.Claims.Claim)
  - System.Security.Claims.ClaimsIdentity.WriteTo(System.IO.BinaryWriter)
  - System.Security.Claims.ClaimsIdentity.WriteTo(System.IO.BinaryWriter,System.Byte[])
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr)
  id: '#ctor(System.IntPtr)'
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: WindowsIdentity(IntPtr)
  nameWithType: WindowsIdentity.WindowsIdentity(IntPtr)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(IntPtr)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> класса для пользователя, представленного заданным токеном учетной записи Windows."
  remarks: "В следующей таблице показаны исходные значения свойств для экземпляра класса <xref:System.Security.Principal.WindowsIdentity>.</xref:System.Security.Principal.WindowsIdentity>      | Свойство | Начальное значение |   |--------------|-------------------|   | <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A>| `Negotiate`|   | <xref:System.Security.Principal.WindowsAccountType>| `Normal`|   | <xref:System.Security.Principal.WindowsIdentity.IsAuthenticated%2A>| `false`|      Настроек [!NOTE] настроек можно получить маркер, представленный параметром `userToken` путем вызова неуправляемого кода, например Win32 API `LogonUser` функция.</xref:System.Security.Principal.WindowsIdentity.IsAuthenticated%2A> </xref:System.Security.Principal.WindowsAccountType> </xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> Всегда выпуска `userToken` , вызвав Win32 API `CloseHandle` функции. Дополнительные сведения о вызове неуправляемого кода см. в разделе [использование неуправляемых функций DLL](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public WindowsIdentity (IntPtr userToken);
    parameters:
    - id: userToken
      type: System.IntPtr
      description: "Токен учетной записи для пользователя, от лица которого запущен код."
  overload: System.Security.Principal.WindowsIdentity.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userToken</code>— 0.       - или - <code>userToken</code> дублирован и недопустим для олицетворения."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений.       - или - произошла ошибка Win32."
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.Security.Principal.WindowsIdentity)
  id: '#ctor(System.Security.Principal.WindowsIdentity)'
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: WindowsIdentity(WindowsIdentity)
  nameWithType: WindowsIdentity.WindowsIdentity(WindowsIdentity)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(WindowsIdentity)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> класса, используя указанный <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> объекта."
  syntax:
    content: protected WindowsIdentity (System.Security.Principal.WindowsIdentity identity);
    parameters:
    - id: identity
      type: System.Security.Principal.WindowsIdentity
      description: "Объект, из которого создается новый экземпляр <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref>."
  overload: System.Security.Principal.WindowsIdentity.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: WindowsIdentity(String)
  nameWithType: WindowsIdentity.WindowsIdentity(String)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(String)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> класса для пользователя, представленного в указанной основной имя пользователя (UPN)."
  remarks: "Имя участника-пользователя имеет формат *username*@*domainname*.com, другими словами, адрес электронной почты. UPN определяется параметром `sUserPrincipalName` используется для получения маркера для этого пользователя с помощью Win32 API `LsaLogonUser` функции. В свою очередь этот маркер используется для идентификации пользователя. Исключение может быть возвращено из-за невозможности выполнить вход с использованием предоставленного имени участника-пользователя.      Настроек [!NOTE] настроек этот конструктор предназначен для использования только на компьютеры, присоединенные к Windows Server 2003 или более поздней версии доменов. Для более ранних типов домена создается исключение. Это ограничение является тем, что этот конструктор использует [KERB_S4U_LOGON структуры](http://go.microsoft.com/fwlink/?LinkId=143533), которая была впервые появился в Windows Server 2003."
  syntax:
    content: public WindowsIdentity (string sUserPrincipalName);
    parameters:
    - id: sUserPrincipalName
      type: System.String
      description: "Имя участника-пользователя, от лица которого запущен код."
  overload: System.Security.Principal.WindowsIdentity.#ctor*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Windows вернул код состояния Windows NT STATUS_ACCESS_DENIED."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Возникает нехватка памяти."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений.       - или - компьютер не присоединен к Windows 2003 или более поздней версии домена.       - или - компьютер под управлением Windows 2003 или более поздней версии.       - или - пользователь не является членом домена, которому присоединен компьютер."
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr,System.String)
  id: '#ctor(System.IntPtr,System.String)'
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: WindowsIdentity(IntPtr,String)
  nameWithType: WindowsIdentity.WindowsIdentity(IntPtr,String)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(IntPtr,String)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> класса для пользователя, представленного заданным токеном учетной записи Windows и типом проверки подлинности."
  remarks: "В следующей таблице показаны исходные значения свойств для экземпляра класса <xref:System.Security.Principal.WindowsIdentity>.</xref:System.Security.Principal.WindowsIdentity>      | Свойство | Начальное значение |   |--------------|-------------------|   | <xref:System.Security.Principal.WindowsAccountType>| `Normal`|   | <xref:System.Security.Principal.WindowsIdentity.IsAuthenticated%2A>| `false`|       Значение `type` параметр используется для задания <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A>параметр.</xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> </xref:System.Security.Principal.WindowsIdentity.IsAuthenticated%2A> </xref:System.Security.Principal.WindowsAccountType> Если `type` — `null`, установка системы безопасности <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A>для `Negotiate` в Windows Vista и более поздних версиях операционной системы Windows, а также `Kerberos` в более ранних версиях операционной системы Windows.</xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> Система безопасности не использует это значение; Это только в информационных целях.      Настроек [!NOTE] настроек можно получить маркер, представленный параметром `userToken` путем вызова неуправляемого кода, например Win32 API `LogonUser` функции. Всегда выпуска `userToken` , вызвав Win32 API `CloseHandle` функции. Дополнительные сведения о вызове неуправляемого кода см. в разделе [использование неуправляемых функций DLL](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code shows the use of the <xref:System.Security.Principal.WindowsIdentity.%23ctor%2A> constructor to create a new instance of the  <xref:System.Security.Principal.WindowsIdentity> class for the user represented by the specified Windows account token and the specified authentication type. This code example is part of a larger example provided for the <xref:System.Security.Principal.WindowsIdentity> class.  \n  \n [!code-cs[System.Security.Principal.WindowsIdentity_AllMembers#4](~/add/codesnippet/csharp/dc54fc11-729f-4337-b932-_1.cs)]\n [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#4](~/add/codesnippet/cpp/dc54fc11-729f-4337-b932-_1.cpp)]\n [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#4](~/add/codesnippet/visualbasic/dc54fc11-729f-4337-b932-_1.vb)]"
  syntax:
    content: public WindowsIdentity (IntPtr userToken, string type);
    parameters:
    - id: userToken
      type: System.IntPtr
      description: "Токен учетной записи для пользователя, от лица которого запущен код."
    - id: type
      type: System.String
      description: "(Использовать только для справки.) Тип проверки подлинности, применяемой для идентификации пользователя. Дополнительные сведения см. заметки."
  overload: System.Security.Principal.WindowsIdentity.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userToken</code>— 0.       - или - <code>userToken</code> дублирован и недопустим для олицетворения."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений.       - или - произошла ошибка Win32."
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: '#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)'
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: WindowsIdentity(SerializationInfo,StreamingContext)
  nameWithType: WindowsIdentity.WindowsIdentity(SerializationInfo,StreamingContext)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(SerializationInfo,StreamingContext)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> класса для пользователя, представленного данными в <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> потока."
  remarks: >-
    > [!IMPORTANT]

    >  Calling this method with untrusted data is a security risk. Call this method only with trusted data. For more information, see [Untrusted Data Security Risks](http://go.microsoft.com/fwlink/?LinkId=330378).
  syntax:
    content: public WindowsIdentity (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "Объект, содержащий сведения об учетной записи пользователя."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "Объект, указывающий характеристики потока."
  overload: System.Security.Principal.WindowsIdentity.#ctor*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Объект <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> не может быть сериализован в процессах."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений.       - или - произошла ошибка Win32."
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: WindowsIdentity(String,String)
  nameWithType: WindowsIdentity.WindowsIdentity(String,String)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(String,String)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> класса для пользователя, представленного указанным имя участника пользователя (UPN) и типом проверки подлинности."
  remarks: "Значение `type` параметр используется для задания <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A>параметр.</xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> Если `type` — `null`, установка системы безопасности <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A>для `Negotiate` в Windows Vista и более поздних версиях операционной системы Windows, а также `Kerberos` в более ранних версиях операционной системы Windows.</xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> Система безопасности не использует это значение; Это только в информационных целях.       UPN определяется параметром `sUserPrincipalName` используется для получения маркера для этого пользователя с помощью Win32 API `LsaLogonUser` функции. В свою очередь этот маркер используется для идентификации пользователя. Исключение может быть возвращено из-за невозможности выполнить вход с использованием предоставленного имени участника-пользователя.      Настроек [!NOTE] настроек этот конструктор предназначен для использования только на компьютеры, присоединенные к Windows Server 2003 или более поздней версии доменов. Для более ранних типов домена создается исключение. Это ограничение является тем, что этот конструктор использует [KERB_S4U_LOGON структуры](http://go.microsoft.com/fwlink/?LinkId=143533), которая была впервые появился в Windows Server 2003."
  syntax:
    content: public WindowsIdentity (string sUserPrincipalName, string type);
    parameters:
    - id: sUserPrincipalName
      type: System.String
      description: "Имя участника-пользователя, от лица которого запущен код."
    - id: type
      type: System.String
      description: "(Использовать только для справки.) Тип проверки подлинности, применяемой для идентификации пользователя. Дополнительные сведения см. заметки."
  overload: System.Security.Principal.WindowsIdentity.#ctor*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Windows вернул код состояния Windows NT STATUS_ACCESS_DENIED."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Возникает нехватка памяти."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений.       - или - компьютер не присоединен к Windows 2003 или более поздней версии домена.       - или - компьютер под управлением Windows 2003 или более поздней версии.       - или - пользователь не является членом домена, которому присоединен компьютер."
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr,System.String,System.Security.Principal.WindowsAccountType)
  id: '#ctor(System.IntPtr,System.String,System.Security.Principal.WindowsAccountType)'
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: WindowsIdentity(IntPtr,String,WindowsAccountType)
  nameWithType: WindowsIdentity.WindowsIdentity(IntPtr,String,WindowsAccountType)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(IntPtr,String,WindowsAccountType)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> класса для пользователя, представленного заданным токеном учетной записи Windows, типом проверки подлинности и типом учетной записи Windows."
  remarks: "В следующей таблице показаны исходные значения свойств для экземпляра класса <xref:System.Security.Principal.WindowsIdentity>.</xref:System.Security.Principal.WindowsIdentity>      | Свойство | Начальное значение |   |--------------|-------------------|   | <xref:System.Security.Principal.WindowsIdentity.IsAuthenticated%2A>| `false`|       Значение `type` параметр используется для задания <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A>параметр.</xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> </xref:System.Security.Principal.WindowsIdentity.IsAuthenticated%2A> Если `type` — `null`, установка системы безопасности <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A>для `Negotiate` в Windows Vista и более поздних версиях операционной системы Windows, а также `Kerberos` в более ранних версиях операционной системы Windows.</xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> Система безопасности не использует это значение; Это только в информационных целях.      Настроек [!NOTE] настроек можно получить маркер, представленный параметром `userToken` путем вызова неуправляемого кода, например Win32 API `LogonUser` функции. Всегда выпуска `userToken` , вызвав Win32 API `CloseHandle` функции. Дополнительные сведения о вызове неуправляемого кода см. в разделе [использование неуправляемых функций DLL](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code shows the use of the WindowsIdentity constructor to create a new instance of the <xref:System.Security.Principal.WindowsIdentity> class for the user represented by the specified Windows account token, the specified authentication type, and the specified Windows account type. This code example is part of a larger example provided for the <xref:System.Security.Principal.WindowsIdentity> class.  \n  \n [!code-cs[System.Security.Principal.WindowsIdentity_AllMembers#7](~/add/codesnippet/csharp/6cec7b3f-80c5-417d-99d8-_1.cs)]\n [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#7](~/add/codesnippet/cpp/6cec7b3f-80c5-417d-99d8-_1.cpp)]\n [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#7](~/add/codesnippet/visualbasic/6cec7b3f-80c5-417d-99d8-_1.vb)]"
  syntax:
    content: public WindowsIdentity (IntPtr userToken, string type, System.Security.Principal.WindowsAccountType acctType);
    parameters:
    - id: userToken
      type: System.IntPtr
      description: "Токен учетной записи для пользователя, от лица которого запущен код."
    - id: type
      type: System.String
      description: "(Использовать только для справки.) Тип проверки подлинности, применяемой для идентификации пользователя. Дополнительные сведения см. заметки."
    - id: acctType
      type: System.Security.Principal.WindowsAccountType
      description: "Одно из значений перечисления."
  overload: System.Security.Principal.WindowsIdentity.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userToken</code>— 0.       - или - <code>userToken</code> дублирован и недопустим для олицетворения."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений.       - или - произошла ошибка Win32."
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr,System.String,System.Security.Principal.WindowsAccountType,System.Boolean)
  id: '#ctor(System.IntPtr,System.String,System.Security.Principal.WindowsAccountType,System.Boolean)'
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: WindowsIdentity(IntPtr,String,WindowsAccountType,Boolean)
  nameWithType: WindowsIdentity.WindowsIdentity(IntPtr,String,WindowsAccountType,Boolean)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(IntPtr,String,WindowsAccountType,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> класса для пользователя, представленного заданным токеном учетной записи Windows, типом проверки подлинности, типом учетной записи Windows и состояния проверки подлинности."
  remarks: "Значение `type` параметр используется для задания <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A>параметр.</xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> Если `type` — `null`, установка системы безопасности <xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A>для `Negotiate` в Windows Vista и более поздних версиях операционной системы Windows, а также `Kerberos` в более ранних версиях операционной системы Windows.</xref:System.Security.Principal.WindowsIdentity.AuthenticationType%2A> Система безопасности не использует это значение; Это только в информационных целях.       Вы можете получить маркер, представленный параметром `userToken` путем вызова неуправляемого кода, например Win32 API `LogonUser` функции. Всегда выпуска `userToken` , вызвав Win32 API `CloseHandle` функции. Дополнительные сведения о вызове неуправляемого кода см. в разделе [использование неуправляемых функций DLL](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code shows the use of the WindowsIdentity constructor to create a new instance of the <xref:System.Security.Principal.WindowsIdentity> class for the user represented by the specified Windows account token, the specified authentication type, the specified Windows account type, and the specified authentication status. This code example is part of a larger example provided for the <xref:System.Security.Principal.WindowsIdentity> class.  \n  \n [!code-cs[System.Security.Principal.WindowsIdentity_AllMembers#17](~/add/codesnippet/csharp/851e6c2b-b248-45b7-9cd4-_1.cs)]\n [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#17](~/add/codesnippet/cpp/851e6c2b-b248-45b7-9cd4-_1.cpp)]\n [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#17](~/add/codesnippet/visualbasic/851e6c2b-b248-45b7-9cd4-_1.vb)]"
  syntax:
    content: public WindowsIdentity (IntPtr userToken, string type, System.Security.Principal.WindowsAccountType acctType, bool isAuthenticated);
    parameters:
    - id: userToken
      type: System.IntPtr
      description: "Токен учетной записи для пользователя, от лица которого запущен код."
    - id: type
      type: System.String
      description: "(Использовать только для справки.) Тип проверки подлинности, применяемой для идентификации пользователя. Дополнительные сведения см. заметки."
    - id: acctType
      type: System.Security.Principal.WindowsAccountType
      description: "Одно из значений перечисления."
    - id: isAuthenticated
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы указать, что пользователь проходит проверку подлинности; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.Principal.WindowsIdentity.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userToken</code>— 0.       - или - <code>userToken</code> дублирован и недопустим для олицетворения."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений.       - или - произошла ошибка Win32."
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.AccessToken
  id: AccessToken
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: AccessToken
  nameWithType: WindowsIdentity.AccessToken
  fullName: System.Security.Principal.WindowsIdentity.AccessToken
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Получает это <xref href=&quot;Microsoft.Win32.SafeHandles.SafeAccessTokenHandle&quot;> </xref> для этого <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> экземпляра."
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeAccessTokenHandle AccessToken { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeAccessTokenHandle
      description: "Возвращает <xref href=&quot;Microsoft.Win32.SafeHandles.SafeAccessTokenHandle&quot;> </xref>."
  overload: System.Security.Principal.WindowsIdentity.AccessToken*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.AuthenticationType
  id: AuthenticationType
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: AuthenticationType
  nameWithType: WindowsIdentity.AuthenticationType
  fullName: System.Security.Principal.WindowsIdentity.AuthenticationType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает тип проверки подлинности, применяемой для идентификации пользователя."
  remarks: "Это свойство является информационным; он не используется системой безопасности. В Windows Vista и более поздних версиях операционной системы Windows, значение по умолчанию для этого свойства — `Negotiate`, который выбирает лучший поставщик поддержки безопасности (SSP) на основе политики безопасности настроенного клиента. Значение свойства по умолчанию для более ранних версий операционной системы Windows не `Kerberos`."
  syntax:
    content: public override sealed string AuthenticationType { get; }
    return:
      type: System.String
      description: "Тип проверки подлинности, применяемой для идентификации пользователя."
  overload: System.Security.Principal.WindowsIdentity.AuthenticationType*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Windows вернул код состояния Windows NT STATUS_ACCESS_DENIED."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Возникает нехватка памяти."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений.       - или - компьютер не присоединен к Windows 2003 или более поздней версии домена.       - или - компьютер под управлением Windows 2003 или более поздней версии.       - или - пользователь не является членом домена, которому присоединен компьютер."
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.Claims
  id: Claims
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: Claims
  nameWithType: WindowsIdentity.Claims
  fullName: System.Security.Principal.WindowsIdentity.Claims
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает все утверждения для пользователя, представленного этим идентификатором Windows."
  syntax:
    content: public override System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> Claims { get; }
    return:
      type: System.Collections.Generic.IEnumerable{System.Security.Claims.Claim}
      description: "Коллекция утверждений для этого <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> объекта."
  overload: System.Security.Principal.WindowsIdentity.Claims*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.Clone
  id: Clone
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: Clone()
  nameWithType: WindowsIdentity.Clone()
  fullName: System.Security.Principal.WindowsIdentity.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Создает новый объект, являющийся копией текущего экземпляра."
  syntax:
    content: public override System.Security.Claims.ClaimsIdentity Clone ();
    parameters: []
    return:
      type: System.Security.Claims.ClaimsIdentity
      description: "Копия текущего экземпляра."
  overload: System.Security.Principal.WindowsIdentity.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.DefaultIssuer
  id: DefaultIssuer
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: DefaultIssuer
  nameWithType: WindowsIdentity.DefaultIssuer
  fullName: System.Security.Principal.WindowsIdentity.DefaultIssuer
  type: Field
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Определяет имя по умолчанию <xref href=&quot;System.Security.Claims.ClaimsIdentity&quot;> </xref> издателя."
  syntax:
    content: public const string DefaultIssuer;
    return:
      type: System.String
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.DeviceClaims
  id: DeviceClaims
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: DeviceClaims
  nameWithType: WindowsIdentity.DeviceClaims
  fullName: System.Security.Principal.WindowsIdentity.DeviceClaims
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает утверждения, имеющие <xref href=&quot;System.Security.Claims.ClaimTypes.WindowsDeviceClaim&quot;> </xref> ключ свойства."
  syntax:
    content: public virtual System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> DeviceClaims { get; }
    return:
      type: System.Collections.Generic.IEnumerable{System.Security.Claims.Claim}
      description: "Коллекция утверждений, имеющих <xref href=&quot;System.Security.Claims.ClaimTypes.WindowsDeviceClaim&quot;> </xref> ключ свойства."
  overload: System.Security.Principal.WindowsIdentity.DeviceClaims*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.Dispose
  id: Dispose
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: Dispose()
  nameWithType: WindowsIdentity.Dispose()
  fullName: System.Security.Principal.WindowsIdentity.Dispose()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Освобождает все ресурсы, используемые <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref>."
  remarks: "После использования <xref:System.Security.Principal.WindowsIdentity>.</xref:System.Security.Principal.WindowsIdentity> всегда вызывать Dispose. Метод Dispose оставляет <xref:System.Security.Principal.WindowsIdentity>окажется в неработоспособном состоянии.</xref:System.Security.Principal.WindowsIdentity> После вызова Dispose, необходимо освободить все ссылки на <xref:System.Security.Principal.WindowsIdentity>, сборщик мусора мог освободить память, <xref:System.Security.Principal.WindowsIdentity>занимаемую.</xref:System.Security.Principal.WindowsIdentity> </xref:System.Security.Principal.WindowsIdentity> Дополнительные сведения см. в разделе [очистки неуправляемых ресурсов](~/add/includes/ajax-current-ext-md.md) и [метода](~/add/includes/ajax-current-ext-md.md).      Настроек [!NOTE] настроек всегда вызова Dispose перед освобождением последней ссылки на <xref:System.Security.Principal.WindowsIdentity>.</xref:System.Security.Principal.WindowsIdentity> В противном случае им ресурсы не будут освобождены пока сборщик мусора не вызовет метод <xref:System.Security.Principal.WindowsIdentity>объекта `Finalize` метод.</xref:System.Security.Principal.WindowsIdentity>"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.Security.Principal.WindowsIdentity.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: WindowsIdentity.Dispose(Boolean)
  fullName: System.Security.Principal.WindowsIdentity.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Освобождает неуправляемые ресурсы, используемые <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> и при необходимости освобождает также управляемые ресурсы."
  remarks: "Этот метод вызывается методом открытые `Dispose()`метод и <xref:System.Object.Finalize%2A>метод.</xref:System.Object.Finalize%2A> `Dispose()`вызывает защищенный `Dispose(Boolean)` метод с `disposing` равным `true`. <xref:System.Object.Finalize%2A>вызывает `Dispose` с `disposing` значение `false`.</xref:System.Object.Finalize%2A>       При `disposing` параметр `true`, данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, которые <xref:System.Security.Principal.WindowsIdentity>ссылки.</xref:System.Security.Principal.WindowsIdentity> Этот метод вызывает `Dispose()` метод для каждого объекта, на который указывает ссылка."
  syntax:
    content: protected virtual void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>для освобождения управляемых и неуправляемых ресурсов; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для освобождения только неуправляемых ресурсов."
  overload: System.Security.Principal.WindowsIdentity.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.GetAnonymous
  id: GetAnonymous
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: GetAnonymous()
  nameWithType: WindowsIdentity.GetAnonymous()
  fullName: System.Security.Principal.WindowsIdentity.GetAnonymous()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> , который можно использовать как контрольного значения в коде чтобы представлять анонимного пользователя. Значение свойства не представляет встроенный анонимный идентификатор, используемый операционной системой Windows."
  remarks: "Это свойство возвращает пустую коллекцию <xref:System.Security.Principal.WindowsIdentity>объект, который позволяет обрабатывать операции как анонимный.</xref:System.Security.Principal.WindowsIdentity> Значение свойства не соответствует анонимного пользователя Windows и не может использоваться для олицетворения. Кроме того Обратите внимание, что удостоверение, возвращаемый этим свойством не статическим. Каждый вызов GetAnonymous возвращает разные Анонимное удостоверение.       Можно использовать <xref:System.Security.Principal.WindowsIdentity.IsAnonymous%2A>Свойства для определения возвращаемого значения из GetAnonymous.</xref:System.Security.Principal.WindowsIdentity.IsAnonymous%2A> Однако <xref:System.Security.Principal.WindowsIdentity.IsAnonymous%2A>обнаруживает Анонимное удостоверение Windows и Анонимное удостоверение, возвращаемый этим методом.</xref:System.Security.Principal.WindowsIdentity.IsAnonymous%2A> Чтобы использовать последний идентификатор, кэшировать GetAnonymous возвращаемое значение, не полагаясь на <xref:System.Security.Principal.WindowsIdentity.IsAnonymous%2A>свойство.</xref:System.Security.Principal.WindowsIdentity.IsAnonymous%2A>"
  example:
  - "The following code shows the use of the GetAnonymous method to return a <xref:System.Security.Principal.WindowsIdentity> object that represents an anonymous Windows user. This code example is part of a larger example provided for the <xref:System.Security.Principal.WindowsIdentity> class.  \n  \n [!code-cs[System.Security.Principal.WindowsIdentity_AllMembers#15](~/add/codesnippet/csharp/m-system.security.princi_5_1.cs)]\n [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#15](~/add/codesnippet/cpp/m-system.security.princi_5_1.cpp)]\n [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#15](~/add/codesnippet/visualbasic/m-system.security.princi_5_1.vb)]"
  syntax:
    content: public static System.Security.Principal.WindowsIdentity GetAnonymous ();
    parameters: []
    return:
      type: System.Security.Principal.WindowsIdentity
      description: "Объект, представляющий анонимного пользователя."
  overload: System.Security.Principal.WindowsIdentity.GetAnonymous*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.GetCurrent
  id: GetCurrent
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: GetCurrent()
  nameWithType: WindowsIdentity.GetCurrent()
  fullName: System.Security.Principal.WindowsIdentity.GetCurrent()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> , представляющий текущего пользователя Windows."
  remarks: ''
  example:
  - "The following code shows the use of the GetCurrent method to return a <xref:System.Security.Principal.WindowsIdentity> object that represents the current Windows user. This code example is part of a larger example provided for the <xref:System.Security.Principal.WindowsIdentity> class.  \n  \n [!code-cs[System.Security.Principal.WindowsIdentity_AllMembers#13](~/add/codesnippet/csharp/m-system.security.princi_7_1.cs)]\n [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#13](~/add/codesnippet/cpp/m-system.security.princi_7_1.cpp)]\n [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#13](~/add/codesnippet/visualbasic/m-system.security.princi_7_1.vb)]"
  syntax:
    content: public static System.Security.Principal.WindowsIdentity GetCurrent ();
    parameters: []
    return:
      type: System.Security.Principal.WindowsIdentity
      description: "Объект, представляющий текущего пользователя."
  overload: System.Security.Principal.WindowsIdentity.GetCurrent*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.GetCurrent(System.Boolean)
  id: GetCurrent(System.Boolean)
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: GetCurrent(Boolean)
  nameWithType: WindowsIdentity.GetCurrent(Boolean)
  fullName: System.Security.Principal.WindowsIdentity.GetCurrent(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> , представляющий удостоверение Windows для потока или процесса, в зависимости от значения <code> ifImpersonating </code> параметра."
  remarks: "Если `ifImpersonating` — `true` и не олицетворяет поток, возвращенный <xref:System.Security.Principal.WindowsIdentity>объект не имеет значения.</xref:System.Security.Principal.WindowsIdentity>  Если `ifImpersonating` — `false` и поток олицетворяет, <xref:System.Security.Principal.WindowsIdentity>для потока, возвращается.</xref:System.Security.Principal.WindowsIdentity>  Если `ifImpersonating` — `false` и поток не олицетворяет, <xref:System.Security.Principal.WindowsIdentity>для процесса, возвращается.</xref:System.Security.Principal.WindowsIdentity>"
  syntax:
    content: public static System.Security.Principal.WindowsIdentity GetCurrent (bool ifImpersonating);
    parameters:
    - id: ifImpersonating
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы вернуть <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> только в том случае, если поток в настоящее время олицетворяет; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для возврата <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> потока, если он олицетворяет или <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> процесса, если поток в настоящее время не олицетворяет."
    return:
      type: System.Security.Principal.WindowsIdentity
      description: "Объект, представляющий пользователя Windows."
  overload: System.Security.Principal.WindowsIdentity.GetCurrent*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.GetCurrent(System.Security.Principal.TokenAccessLevels)
  id: GetCurrent(System.Security.Principal.TokenAccessLevels)
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: GetCurrent(TokenAccessLevels)
  nameWithType: WindowsIdentity.GetCurrent(TokenAccessLevels)
  fullName: System.Security.Principal.WindowsIdentity.GetCurrent(TokenAccessLevels)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> , представляющий текущего пользователя Windows, с помощью указанного требуемого уровня токена доступа."
  remarks: "`desiredAccess` Указывает маски доступа, определяющий запрошенных типов доступа в маркер доступа. Эти требуемые типы доступа сравниваются со списком управления доступом маркера (DACL), чтобы определить, какие типы доступ разрешен или запрещен."
  syntax:
    content: public static System.Security.Principal.WindowsIdentity GetCurrent (System.Security.Principal.TokenAccessLevels desiredAccess);
    parameters:
    - id: desiredAccess
      type: System.Security.Principal.TokenAccessLevels
      description: "Побитовое сочетание значений перечисления."
    return:
      type: System.Security.Principal.WindowsIdentity
      description: "Объект, представляющий текущего пользователя."
  overload: System.Security.Principal.WindowsIdentity.GetCurrent*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.Groups
  id: Groups
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: Groups
  nameWithType: WindowsIdentity.Groups
  fullName: System.Security.Principal.WindowsIdentity.Groups
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает группы текущий Windows, которым принадлежит пользователь."
  remarks: ''
  example:
  - "The following code example shows the use of the Groups property to display the identity references for the groups the current user belongs to.  This code example is part of a larger example provided for the <xref:System.Security.Principal.WindowsIdentity> class.  \n  \n [!code-cs[System.Security.Principal.WindowsIdentity_AllMembers#20](~/add/codesnippet/csharp/p-system.security.princi_8_1.cs)]\n [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#20](~/add/codesnippet/visualbasic/p-system.security.princi_8_1.vb)]"
  syntax:
    content: public System.Security.Principal.IdentityReferenceCollection Groups { get; }
    return:
      type: System.Security.Principal.IdentityReferenceCollection
      description: "Объект, представляющий группы, к которой принадлежит текущий пользователь Windows."
  overload: System.Security.Principal.WindowsIdentity.Groups*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.Impersonate
  id: Impersonate
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: Impersonate()
  nameWithType: WindowsIdentity.Impersonate()
  fullName: System.Security.Principal.WindowsIdentity.Impersonate()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Олицетворяет пользователя, представленного <xref href=&quot;System.Security.Principal.WindowsIdentity&quot;> </xref> объекта."
  remarks: "На платформах Windows NT текущий пользователь должен иметь права на олицетворение."
  example:
  - "The following example demonstrates how to obtain a Windows account token by calling the unmanaged Win32 `LogonUser` function, and how to use that token to impersonate another user and then revert to the original identity.  \n  \n [!code-cpp[WindowsIdentity Impersonation#1](~/add/codesnippet/cpp/m-system.security.princi_2_1.cpp)]\n [!code-cs[WindowsIdentity Impersonation#1](~/add/codesnippet/csharp/m-system.security.princi_2_1.cs)]\n [!code-vb[WindowsIdentity Impersonation#1](~/add/codesnippet/visualbasic/m-system.security.princi_2_1.vb)]"
  syntax:
    content: public virtual System.Security.Principal.WindowsImpersonationContext Impersonate ();
    parameters: []
    return:
      type: System.Security.Principal.WindowsImpersonationContext
      description: "Объект, представляющий пользователя Windows до олицетворения; Это можно использовать для возврата к исходному контексту пользователя."
  overload: System.Security.Principal.WindowsIdentity.Impersonate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Предпринята попытка выполнить олицетворение Анонимное удостоверение."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Произошла ошибка Win32."
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.Impersonate(System.IntPtr)
  id: Impersonate(System.IntPtr)
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: Impersonate(IntPtr)
  nameWithType: WindowsIdentity.Impersonate(IntPtr)
  fullName: System.Security.Principal.WindowsIdentity.Impersonate(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Олицетворяет пользователя, представленного заданным токеном."
  remarks: "На платформах Windows NT текущий пользователь должен иметь права на олицетворение.      Настроек [!NOTE] настроек вызов метода Impersonate `userToken` значение <xref:System.IntPtr>эквивалентно вызову Win32 `RevertToSelf` функция.</xref:System.IntPtr> Если другой пользователь в настоящее время олицетворяется, управление возвращается исходного пользователя.       Дополнительные сведения о вызовах неуправляемого кода см. в разделе [использование неуправляемых функций DLL](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example demonstrates how to obtain a Windows account token by calling the unmanaged Win32 `LogonUser` function, and how to use that token to impersonate another user and then revert to the original identity.  \n  \n [!code-vb[WindowsIdentity Impersonation2#1](~/add/codesnippet/visualbasic/m-system.security.princi_3_1.vb)]\n [!code-cs[WindowsIdentity Impersonation2#1](~/add/codesnippet/csharp/m-system.security.princi_3_1.cs)]"
  syntax:
    content: public static System.Security.Principal.WindowsImpersonationContext Impersonate (IntPtr userToken);
    parameters:
    - id: userToken
      type: System.IntPtr
      description: "Дескриптор токена учетной записи Windows. Этот токен обычно извлекается посредством вызова неуправляемого кода, например вызов API-интерфейса Win32 <xref uid=&quot;langword_csharp_LogonUser&quot; name=&quot;LogonUser&quot; href=&quot;&quot;> </xref> функции."
    return:
      type: System.Security.Principal.WindowsImpersonationContext
      description: "Объект, представляющий пользователя Windows до олицетворения; Этот объект можно использовать для возврата к исходному контексту пользователя."
  overload: System.Security.Principal.WindowsIdentity.Impersonate*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Windows вернул код состояния Windows NT STATUS_ACCESS_DENIED."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Возникает нехватка памяти."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.ImpersonationLevel
  id: ImpersonationLevel
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: ImpersonationLevel
  nameWithType: WindowsIdentity.ImpersonationLevel
  fullName: System.Security.Principal.WindowsIdentity.ImpersonationLevel
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает уровень олицетворения для пользователя."
  remarks: "Описывает уровень олицетворения, используемый для подключения к WMI."
  example:
  - "The following code example shows the use of the ImpersonationLevel property to display the impersonation level for the current user. This code example is part of a larger example provided for the <xref:System.Security.Principal.WindowsIdentity> class.  \n  \n [!code-cs[System.Security.Principal.WindowsIdentity_AllMembers#21](~/add/codesnippet/csharp/p-system.security.princi_3_1.cs)]\n [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#21](~/add/codesnippet/visualbasic/p-system.security.princi_3_1.vb)]"
  syntax:
    content: public System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; }
    return:
      type: System.Security.Principal.TokenImpersonationLevel
      description: "Одно из значений перечисления, указывающее уровень олицетворения."
  overload: System.Security.Principal.WindowsIdentity.ImpersonationLevel*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.IsAnonymous
  id: IsAnonymous
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: IsAnonymous
  nameWithType: WindowsIdentity.IsAnonymous
  fullName: System.Security.Principal.WindowsIdentity.IsAnonymous
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает значение, указывающее, определена ли учетная запись пользователя как анонимная системой."
  remarks: "Свойство IsAnonymous обнаруживает Анонимное удостоверение Windows и Анонимное удостоверение, который возвращается <xref:System.Security.Principal.WindowsIdentity.GetAnonymous%2A>метод.</xref:System.Security.Principal.WindowsIdentity.GetAnonymous%2A>       Анонимных учетных записей обычно только возникают только в приложениях ASP.NET при анонимный доступ разрешен Internet Information Services (IIS)."
  example:
  - "The following code shows the use of the IsAnonymous property to detect whether the user account is identified as an anonymous account by the system. This code example is part of a larger example provided for the <xref:System.Security.Principal.WindowsIdentity> class.  \n  \n [!code-cs[System.Security.Principal.WindowsIdentity_AllMembers#9](~/add/codesnippet/csharp/p-system.security.princi_4_1.cs)]\n [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#9](~/add/codesnippet/cpp/p-system.security.princi_4_1.cpp)]\n [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#9](~/add/codesnippet/visualbasic/p-system.security.princi_4_1.vb)]"
  syntax:
    content: public virtual bool IsAnonymous { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если учетная запись пользователя является анонимной; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.Principal.WindowsIdentity.IsAnonymous*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.IsAuthenticated
  id: IsAuthenticated
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: IsAuthenticated
  nameWithType: WindowsIdentity.IsAuthenticated
  fullName: System.Security.Principal.WindowsIdentity.IsAuthenticated
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает значение, указывающее, прошел ли пользователь проверку подлинности в Windows."
  syntax:
    content: public override bool IsAuthenticated { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если пользователь прошел проверку подлинности; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.Principal.WindowsIdentity.IsAuthenticated*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.IsGuest
  id: IsGuest
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: IsGuest
  nameWithType: WindowsIdentity.IsGuest
  fullName: System.Security.Principal.WindowsIdentity.IsGuest
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает значение, показывающее, определена ли учетная запись пользователя как <xref href=&quot;System.Security.Principal.WindowsAccountType&quot;> </xref> учетной записи в системе."
  remarks: ''
  example:
  - "The following code shows the use of the IsGuest property to return a value indicating whether the user account is identified as a <xref:System.Security.Principal.WindowsAccountType> account by the system. This code example is part of a larger example provided for the <xref:System.Security.Principal.WindowsIdentity> class.  \n  \n [!code-cs[System.Security.Principal.WindowsIdentity_AllMembers#12](~/add/codesnippet/csharp/p-system.security.princi_11_1.cs)]\n [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#12](~/add/codesnippet/cpp/p-system.security.princi_11_1.cpp)]\n [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#12](~/add/codesnippet/visualbasic/p-system.security.princi_11_1.vb)]"
  syntax:
    content: public virtual bool IsGuest { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если учетная запись пользователя является <xref href=&quot;System.Security.Principal.WindowsAccountType&quot;> </xref> учетной записи; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.Principal.WindowsIdentity.IsGuest*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.IsSystem
  id: IsSystem
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: IsSystem
  nameWithType: WindowsIdentity.IsSystem
  fullName: System.Security.Principal.WindowsIdentity.IsSystem
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает значение, показывающее, определена ли учетная запись пользователя как <xref href=&quot;System.Security.Principal.WindowsAccountType&quot;> </xref> учетной записи в системе."
  remarks: ''
  example:
  - "The following code shows the use of the IsSystem property to return a value indicating whether the user account is identified as a <xref:System.Security.Principal.WindowsAccountType> account by the system. This code example is part of a larger example provided for the <xref:System.Security.Principal.WindowsIdentity> class.  \n  \n [!code-cs[System.Security.Principal.WindowsIdentity_AllMembers#11](~/add/codesnippet/csharp/p-system.security.princi_9_1.cs)]\n [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#11](~/add/codesnippet/cpp/p-system.security.princi_9_1.cpp)]\n [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#11](~/add/codesnippet/visualbasic/p-system.security.princi_9_1.vb)]"
  syntax:
    content: public virtual bool IsSystem { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если учетная запись пользователя является <xref href=&quot;System.Security.Principal.WindowsAccountType&quot;> </xref> учетной записи; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.Principal.WindowsIdentity.IsSystem*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.Name
  id: Name
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: Name
  nameWithType: WindowsIdentity.Name
  fullName: System.Security.Principal.WindowsIdentity.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает имя входа пользователя Windows."
  remarks: "Имя входа находится в формате домен\\имя_пользователя."
  example:
  - "The following code shows the use of the Name property to get the user's Windows logon name. This code example is part of a larger example provided for the <xref:System.Security.Principal.WindowsIdentity> class.  \n  \n [!code-cs[System.Security.Principal.WindowsIdentity_AllMembers#8](~/add/codesnippet/csharp/p-system.security.princi_2_1.cs)]\n [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#8](~/add/codesnippet/cpp/p-system.security.princi_2_1.cpp)]\n [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#8](~/add/codesnippet/visualbasic/p-system.security.princi_2_1.vb)]"
  syntax:
    content: public override string Name { get; }
    return:
      type: System.String
      description: "Имя входа Windows пользователя, от лица которого запущен код."
  overload: System.Security.Principal.WindowsIdentity.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.Owner
  id: Owner
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: Owner
  nameWithType: WindowsIdentity.Owner
  fullName: System.Security.Principal.WindowsIdentity.Owner
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает идентификатор безопасности (SID) для владельца токена."
  remarks: "ИД безопасности однозначно определяет пользователя или группу во всех реализациях Windows NT.  Возвращенный ИД безопасности определяет владельца по умолчанию SID, который будет применяться ко вновь созданным объектам."
  example:
  - "The following code example shows the use of the Owner property to display the security identifier for the token owner.  This code example is part of a larger example provided for the <xref:System.Security.Principal.WindowsIdentity> class  \n  \n [!code-cs[System.Security.Principal.WindowsIdentity_AllMembers#19](~/add/codesnippet/csharp/p-system.security.princi_5_1.cs)]\n [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#19](~/add/codesnippet/visualbasic/p-system.security.princi_5_1.vb)]"
  syntax:
    content: public System.Security.Principal.SecurityIdentifier Owner { get; }
    return:
      type: System.Security.Principal.SecurityIdentifier
      description: "Объект для владельца токена."
  overload: System.Security.Principal.WindowsIdentity.Owner*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.RunImpersonated(Microsoft.Win32.SafeHandles.SafeAccessTokenHandle,System.Action)
  id: RunImpersonated(Microsoft.Win32.SafeHandles.SafeAccessTokenHandle,System.Action)
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: RunImpersonated(SafeAccessTokenHandle,Action)
  nameWithType: WindowsIdentity.RunImpersonated(SafeAccessTokenHandle,Action)
  fullName: System.Security.Principal.WindowsIdentity.RunImpersonated(SafeAccessTokenHandle,Action)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Выполняет указанное действие с олицетворенным удостоверением Windows. Вместо олицетворенного вызова метода и выполнения функции в <xref href=&quot;System.Security.Principal.WindowsImpersonationContext&quot;> </xref>, можно использовать RunImpersonated и предоставить функцию непосредственно в качестве параметра."
  remarks: ''
  example:
  - "The following example demonstrates the use of the <xref:System.Security.Principal.WindowsIdentity> class to impersonate a user.  \n  \n> [!WARNING]\n>  This sample asks the user to enter a password on the console screen. The password will be visible on the screen, because the console window does not support masked input natively.  \n  \n```c#  \n// The following example demonstrates the use of the WindowsIdentity class to impersonate a user.   \n// IMPORTANT NOTE:   \n// This sample asks the user to enter a password on the console screen.   \n// The password will be visible on the screen, because the console window   \n// does not support masked input natively.  \n  \nusing System;  \nusing System.Runtime.InteropServices;  \nusing System.Security;  \nusing System.Security.Principal;  \nusing Microsoft.Win32.SafeHandles;  \n  \npublic class ImpersonationDemo  \n{  \n    [DllImport(\"advapi32.dll\", SetLastError = true, CharSet = CharSet.Unicode)]  \n    public static extern bool LogonUser(String lpszUsername, String lpszDomain, String lpszPassword,  \n        int dwLogonType, int dwLogonProvider, out SafeAccessTokenHandle phToken);  \n  \n    public static void Main()  \n    {  \n        // Get the user token for the specified user, domain, and password using the   \n        // unmanaged LogonUser method.   \n        // The local machine name can be used for the domain name to impersonate a user on this machine.  \n        Console.Write(\"Enter the name of the domain on which to log on: \");  \n        string domainName = Console.ReadLine();  \n  \n        Console.Write(\"Enter the login of a user on {0} that you wish to impersonate: \", domainName);  \n        string userName = Console.ReadLine();  \n  \n        Console.Write(\"Enter the password for {0}: \", userName);  \n  \n        const int LOGON32_PROVIDER_DEFAULT = 0;  \n        //This parameter causes LogonUser to create a primary token.   \n        const int LOGON32_LOGON_INTERACTIVE = 2;  \n  \n        // Call LogonUser to obtain a handle to an access token.   \n        SafeAccessTokenHandle safeAccessTokenHandle;  \n        bool returnValue = LogonUser(userName, domainName, Console.ReadLine(),  \n            LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT,  \n            out safeAccessTokenHandle);  \n  \n        if (false == returnValue)  \n        {  \n            int ret = Marshal.GetLastWin32Error();  \n            Console.WriteLine(\"LogonUser failed with error code : {0}\", ret);  \n            throw new System.ComponentModel.Win32Exception(ret);  \n        }  \n  \n        Console.WriteLine(\"Did LogonUser Succeed? \" + (returnValue ? \"Yes\" : \"No\"));  \n        // Check the identity.  \n        Console.WriteLine(\"Before impersonation: \" + WindowsIdentity.GetCurrent().Name);  \n  \n        // Note: if you want to run as unimpersonated, pass  \n        //       'SafeAccessTokenHandle.InvalidHandle' instead of variable 'safeAccessTokenHandle'  \n        WindowsIdentity.RunImpersonated(  \n            safeAccessTokenHandle,  \n            // User action  \n            () =>  \n            {  \n                // Check the identity.  \n                Console.WriteLine(\"During impersonation: \" + WindowsIdentity.GetCurrent().Name);  \n            }  \n            );  \n  \n        // Check the identity again.  \n        Console.WriteLine(\"After impersonation: \" + WindowsIdentity.GetCurrent().Name);  \n    }  \n}  \n  \n```"
  syntax:
    content: public static void RunImpersonated (Microsoft.Win32.SafeHandles.SafeAccessTokenHandle safeAccessTokenHandle, Action action);
    parameters:
    - id: safeAccessTokenHandle
      type: Microsoft.Win32.SafeHandles.SafeAccessTokenHandle
      description: "Дескриптор SafeAccessTokenHandle олицетворенного удостоверения Windows."
    - id: action
      type: System.Action
      description: "System.Action для запуска."
  overload: System.Security.Principal.WindowsIdentity.RunImpersonated*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.RunImpersonated``1(Microsoft.Win32.SafeHandles.SafeAccess``0okenHandle,System.Func{``0})
  id: RunImpersonated``1(Microsoft.Win32.SafeHandles.SafeAccess``0okenHandle,System.Func{``0})
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: RunImpersonated(SafeAccessTokenHandle,Func<T>)
  nameWithType: WindowsIdentity.RunImpersonated(SafeAccessTokenHandle,Func<T>)
  fullName: System.Security.Principal.WindowsIdentity.RunImpersonated(SafeAccessTokenHandle,Func<T>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  syntax:
    content: public static T RunImpersonated<T> (Microsoft.Win32.SafeHandles.SafeAccessTokenHandle safeAccessTokenHandle, Func<T> func);
    parameters:
    - id: safeAccessTokenHandle
      type: Microsoft.Win32.SafeHandles.SafeAccessTokenHandle
      description: "Для добавления."
    - id: func
      type: System.Func{T}
      description: "Для добавления."
    return:
      type: T
      description: "Для добавления."
  overload: System.Security.Principal.WindowsIdentity.RunImpersonated<T>*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)
  id: System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)
  isEii: true
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(Object)
  nameWithType: WindowsIdentity.System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(Object)
  fullName: System.Security.Principal.WindowsIdentity.System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Реализует <xref href=&quot;System.Runtime.Serialization.ISerializable&quot;> </xref> интерфейса и вызывается событием десериализации после завершения десериализации."
  syntax:
    content: void IDeserializationCallback.OnDeserialization (object sender);
    parameters:
    - id: sender
      type: System.Object
      description: "Источник события десериализации."
  overload: System.Security.Principal.WindowsIdentity.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  isEii: true
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: WindowsIdentity.System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Security.Principal.WindowsIdentity.System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Наборы <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> объекта с информацией логического контекста, необходимой для повторного создания экземпляра данного контекста выполнения."
  remarks: "Этот метод устанавливает <xref:System.Runtime.Serialization.SerializationInfo>с логическим вызовов сведения о контексте.</xref:System.Runtime.Serialization.SerializationInfo> Во время десериализации объекта контекста выполнения воссоздается из <xref:System.Runtime.Serialization.SerializationInfo>переданного в потоке.</xref:System.Runtime.Serialization.SerializationInfo>       Дополнительные сведения см. в разделе <xref:System.Runtime.Serialization.SerializationInfo>.</xref:System.Runtime.Serialization.SerializationInfo>"
  syntax:
    content: void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "Объект, содержащий сведения, необходимые для сериализации <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "Объект, содержащий источник и назначение сериализованного потока, связанного с <xref href=&quot;System.Collections.Hashtable&quot;> </xref>."
  overload: System.Security.Principal.WindowsIdentity.System#Runtime#Serialization#ISerializable#GetObjectData*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.Token
  id: Token
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: Token
  nameWithType: WindowsIdentity.Token
  fullName: System.Security.Principal.WindowsIdentity.Token
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает токен учетной записи Windows для пользователя."
  remarks: "Без явного выпуска токен учетной записи, который возвращается свойством токен. Маркер выпускается <xref:System.Security.Principal.WindowsIdentity.Dispose%2A>метод, который можно вызвать в коде.</xref:System.Security.Principal.WindowsIdentity.Dispose%2A> <xref:System.Security.Principal.WindowsIdentity.Dispose%2A>вызывается автоматически при сборке мусора.</xref:System.Security.Principal.WindowsIdentity.Dispose%2A>      Настроек [!NOTE] настроек токен учетной записи, который возвращается свойством токен является дубликатом маркера Windows, который используется для создания <xref:System.Security.Principal.WindowsIdentity>объекта и освобождается автоматически платформой .NET Framework.</xref:System.Security.Principal.WindowsIdentity> Это поведение отличается от токен учетной записи ( `userToken` параметр конструктора), который используется для создания <xref:System.Security.Principal.WindowsIdentity>объекта.</xref:System.Security.Principal.WindowsIdentity> `userToken`токен учетной записи Windows, создается путем вызова `LogonUser` и должны быть закрыты во избежание утечки памяти."
  example:
  - "The following code shows the use of the <xref:System.Security.Principal.WindowsIdentity.IsSystem%2A> property to get the Windows account token for the user. This code example is part of a larger example provided for the <xref:System.Security.Principal.WindowsIdentity> class.  \n  \n [!code-cs[System.Security.Principal.WindowsIdentity_AllMembers#14](~/add/codesnippet/csharp/p-system.security.princi_0_1.cs)]\n [!code-cpp[System.Security.Principal.WindowsIdentity_AllMembers#14](~/add/codesnippet/cpp/p-system.security.princi_0_1.cpp)]\n [!code-vb[System.Security.Principal.WindowsIdentity_AllMembers#14](~/add/codesnippet/visualbasic/p-system.security.princi_0_1.vb)]"
  syntax:
    content: public virtual IntPtr Token { get; }
    return:
      type: System.IntPtr
      description: "Дескриптор токена доступа, связанный с текущим выполняемым потоком."
  overload: System.Security.Principal.WindowsIdentity.Token*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.User
  id: User
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: User
  nameWithType: WindowsIdentity.User
  fullName: System.Security.Principal.WindowsIdentity.User
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает идентификатор безопасности (SID) для пользователя."
  remarks: "ИД безопасности однозначно определяет пользователя или группу во всех реализациях Windows NT.      Настроек [!NOTE] настроек <xref:System.Security.Principal.WindowsIdentity>объект, возвращаемый <xref:System.Security.Principal.WindowsIdentity.GetAnonymous%2A>метод не является таким же, как анонимный пользователь Windows.</xref:System.Security.Principal.WindowsIdentity.GetAnonymous%2A> </xref:System.Security.Principal.WindowsIdentity> Это свойство возвращает `null` для анонимного пользователя, представленного <xref:System.Security.Principal.WindowsIdentity>объект, возвращаемый <xref:System.Security.Principal.WindowsIdentity.GetAnonymous%2A>метода; он не получает идентификатор, представляющий анонимного пользователя Windows.</xref:System.Security.Principal.WindowsIdentity.GetAnonymous%2A> </xref:System.Security.Principal.WindowsIdentity>"
  syntax:
    content: public System.Security.Principal.SecurityIdentifier User { get; }
    return:
      type: System.Security.Principal.SecurityIdentifier
      description: "Объект для пользователя."
  overload: System.Security.Principal.WindowsIdentity.User*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Principal.WindowsIdentity.UserClaims
  id: UserClaims
  parent: System.Security.Principal.WindowsIdentity
  langs:
  - csharp
  name: UserClaims
  nameWithType: WindowsIdentity.UserClaims
  fullName: System.Security.Principal.WindowsIdentity.UserClaims
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Principal
  summary: "Возвращает утверждения, имеющие <xref href=&quot;System.Security.Claims.ClaimTypes.WindowsUserClaim&quot;> </xref> ключ свойства."
  syntax:
    content: public virtual System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> UserClaims { get; }
    return:
      type: System.Collections.Generic.IEnumerable{System.Security.Claims.Claim}
      description: "Коллекция утверждений, имеющих <xref href=&quot;System.Security.Claims.ClaimTypes.WindowsUserClaim&quot;> </xref> ключ свойства."
  overload: System.Security.Principal.WindowsIdentity.UserClaims*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Security.Claims.ClaimsIdentity
  isExternal: false
  name: System.Security.Claims.ClaimsIdentity
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr)
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: WindowsIdentity(IntPtr)
  nameWithType: WindowsIdentity.WindowsIdentity(IntPtr)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(IntPtr)
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.Security.Principal.WindowsIdentity)
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: WindowsIdentity(WindowsIdentity)
  nameWithType: WindowsIdentity.WindowsIdentity(WindowsIdentity)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(WindowsIdentity)
- uid: System.Security.Principal.WindowsIdentity
  parent: System.Security.Principal
  isExternal: false
  name: WindowsIdentity
  nameWithType: WindowsIdentity
  fullName: System.Security.Principal.WindowsIdentity
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.String)
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: WindowsIdentity(String)
  nameWithType: WindowsIdentity.WindowsIdentity(String)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr,System.String)
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: WindowsIdentity(IntPtr,String)
  nameWithType: WindowsIdentity.WindowsIdentity(IntPtr,String)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(IntPtr,String)
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: WindowsIdentity(SerializationInfo,StreamingContext)
  nameWithType: WindowsIdentity.WindowsIdentity(SerializationInfo,StreamingContext)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.String,System.String)
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: WindowsIdentity(String,String)
  nameWithType: WindowsIdentity.WindowsIdentity(String,String)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(String,String)
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr,System.String,System.Security.Principal.WindowsAccountType)
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: WindowsIdentity(IntPtr,String,WindowsAccountType)
  nameWithType: WindowsIdentity.WindowsIdentity(IntPtr,String,WindowsAccountType)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(IntPtr,String,WindowsAccountType)
- uid: System.Security.Principal.WindowsAccountType
  parent: System.Security.Principal
  isExternal: false
  name: WindowsAccountType
  nameWithType: WindowsAccountType
  fullName: System.Security.Principal.WindowsAccountType
- uid: System.Security.Principal.WindowsIdentity.#ctor(System.IntPtr,System.String,System.Security.Principal.WindowsAccountType,System.Boolean)
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: WindowsIdentity(IntPtr,String,WindowsAccountType,Boolean)
  nameWithType: WindowsIdentity.WindowsIdentity(IntPtr,String,WindowsAccountType,Boolean)
  fullName: System.Security.Principal.WindowsIdentity.WindowsIdentity(IntPtr,String,WindowsAccountType,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.Principal.WindowsIdentity.AccessToken
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: AccessToken
  nameWithType: WindowsIdentity.AccessToken
  fullName: System.Security.Principal.WindowsIdentity.AccessToken
- uid: Microsoft.Win32.SafeHandles.SafeAccessTokenHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeAccessTokenHandle
  nameWithType: SafeAccessTokenHandle
  fullName: Microsoft.Win32.SafeHandles.SafeAccessTokenHandle
- uid: System.Security.Principal.WindowsIdentity.AuthenticationType
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: AuthenticationType
  nameWithType: WindowsIdentity.AuthenticationType
  fullName: System.Security.Principal.WindowsIdentity.AuthenticationType
- uid: System.Security.Principal.WindowsIdentity.Claims
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Claims
  nameWithType: WindowsIdentity.Claims
  fullName: System.Security.Principal.WindowsIdentity.Claims
- uid: System.Collections.Generic.IEnumerable{System.Security.Claims.Claim}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<Claim>
  nameWithType: IEnumerable<Claim>
  fullName: System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.Security.Claims.Claim>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Security.Claims.Claim
    name: Claim
    nameWithType: Claim
    fullName: Claim
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Security.Principal.WindowsIdentity.Clone
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Clone()
  nameWithType: WindowsIdentity.Clone()
  fullName: System.Security.Principal.WindowsIdentity.Clone()
- uid: System.Security.Principal.WindowsIdentity.DefaultIssuer
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: DefaultIssuer
  nameWithType: WindowsIdentity.DefaultIssuer
  fullName: System.Security.Principal.WindowsIdentity.DefaultIssuer
- uid: System.Security.Principal.WindowsIdentity.DeviceClaims
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: DeviceClaims
  nameWithType: WindowsIdentity.DeviceClaims
  fullName: System.Security.Principal.WindowsIdentity.DeviceClaims
- uid: System.Security.Principal.WindowsIdentity.Dispose
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Dispose()
  nameWithType: WindowsIdentity.Dispose()
  fullName: System.Security.Principal.WindowsIdentity.Dispose()
- uid: System.Security.Principal.WindowsIdentity.Dispose(System.Boolean)
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: WindowsIdentity.Dispose(Boolean)
  fullName: System.Security.Principal.WindowsIdentity.Dispose(Boolean)
- uid: System.Security.Principal.WindowsIdentity.GetAnonymous
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: GetAnonymous()
  nameWithType: WindowsIdentity.GetAnonymous()
  fullName: System.Security.Principal.WindowsIdentity.GetAnonymous()
- uid: System.Security.Principal.WindowsIdentity.GetCurrent
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: GetCurrent()
  nameWithType: WindowsIdentity.GetCurrent()
  fullName: System.Security.Principal.WindowsIdentity.GetCurrent()
- uid: System.Security.Principal.WindowsIdentity.GetCurrent(System.Boolean)
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: GetCurrent(Boolean)
  nameWithType: WindowsIdentity.GetCurrent(Boolean)
  fullName: System.Security.Principal.WindowsIdentity.GetCurrent(Boolean)
- uid: System.Security.Principal.WindowsIdentity.GetCurrent(System.Security.Principal.TokenAccessLevels)
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: GetCurrent(TokenAccessLevels)
  nameWithType: WindowsIdentity.GetCurrent(TokenAccessLevels)
  fullName: System.Security.Principal.WindowsIdentity.GetCurrent(TokenAccessLevels)
- uid: System.Security.Principal.TokenAccessLevels
  parent: System.Security.Principal
  isExternal: false
  name: TokenAccessLevels
  nameWithType: TokenAccessLevels
  fullName: System.Security.Principal.TokenAccessLevels
- uid: System.Security.Principal.WindowsIdentity.Groups
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Groups
  nameWithType: WindowsIdentity.Groups
  fullName: System.Security.Principal.WindowsIdentity.Groups
- uid: System.Security.Principal.IdentityReferenceCollection
  parent: System.Security.Principal
  isExternal: false
  name: IdentityReferenceCollection
  nameWithType: IdentityReferenceCollection
  fullName: System.Security.Principal.IdentityReferenceCollection
- uid: System.Security.Principal.WindowsIdentity.Impersonate
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Impersonate()
  nameWithType: WindowsIdentity.Impersonate()
  fullName: System.Security.Principal.WindowsIdentity.Impersonate()
- uid: System.Security.Principal.WindowsImpersonationContext
  parent: System.Security.Principal
  isExternal: false
  name: WindowsImpersonationContext
  nameWithType: WindowsImpersonationContext
  fullName: System.Security.Principal.WindowsImpersonationContext
- uid: System.Security.Principal.WindowsIdentity.Impersonate(System.IntPtr)
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Impersonate(IntPtr)
  nameWithType: WindowsIdentity.Impersonate(IntPtr)
  fullName: System.Security.Principal.WindowsIdentity.Impersonate(IntPtr)
- uid: System.Security.Principal.WindowsIdentity.ImpersonationLevel
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: ImpersonationLevel
  nameWithType: WindowsIdentity.ImpersonationLevel
  fullName: System.Security.Principal.WindowsIdentity.ImpersonationLevel
- uid: System.Security.Principal.TokenImpersonationLevel
  parent: System.Security.Principal
  isExternal: true
  name: TokenImpersonationLevel
  nameWithType: TokenImpersonationLevel
  fullName: System.Security.Principal.TokenImpersonationLevel
- uid: System.Security.Principal.WindowsIdentity.IsAnonymous
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: IsAnonymous
  nameWithType: WindowsIdentity.IsAnonymous
  fullName: System.Security.Principal.WindowsIdentity.IsAnonymous
- uid: System.Security.Principal.WindowsIdentity.IsAuthenticated
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: IsAuthenticated
  nameWithType: WindowsIdentity.IsAuthenticated
  fullName: System.Security.Principal.WindowsIdentity.IsAuthenticated
- uid: System.Security.Principal.WindowsIdentity.IsGuest
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: IsGuest
  nameWithType: WindowsIdentity.IsGuest
  fullName: System.Security.Principal.WindowsIdentity.IsGuest
- uid: System.Security.Principal.WindowsIdentity.IsSystem
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: IsSystem
  nameWithType: WindowsIdentity.IsSystem
  fullName: System.Security.Principal.WindowsIdentity.IsSystem
- uid: System.Security.Principal.WindowsIdentity.Name
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Name
  nameWithType: WindowsIdentity.Name
  fullName: System.Security.Principal.WindowsIdentity.Name
- uid: System.Security.Principal.WindowsIdentity.Owner
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Owner
  nameWithType: WindowsIdentity.Owner
  fullName: System.Security.Principal.WindowsIdentity.Owner
- uid: System.Security.Principal.SecurityIdentifier
  parent: System.Security.Principal
  isExternal: false
  name: SecurityIdentifier
  nameWithType: SecurityIdentifier
  fullName: System.Security.Principal.SecurityIdentifier
- uid: System.Security.Principal.WindowsIdentity.RunImpersonated(Microsoft.Win32.SafeHandles.SafeAccessTokenHandle,System.Action)
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: RunImpersonated(SafeAccessTokenHandle,Action)
  nameWithType: WindowsIdentity.RunImpersonated(SafeAccessTokenHandle,Action)
  fullName: System.Security.Principal.WindowsIdentity.RunImpersonated(SafeAccessTokenHandle,Action)
- uid: System.Action
  parent: System
  isExternal: true
  name: Action
  nameWithType: Action
  fullName: System.Action
- uid: System.Security.Principal.WindowsIdentity.RunImpersonated``1(Microsoft.Win32.SafeHandles.SafeAccess``0okenHandle,System.Func{``0})
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: RunImpersonated(SafeAccessTokenHandle,Func<T>)
  nameWithType: WindowsIdentity.RunImpersonated(SafeAccessTokenHandle,Func<T>)
  fullName: System.Security.Principal.WindowsIdentity.RunImpersonated(SafeAccessTokenHandle,Func<T>)
- uid: T
  isExternal: true
  name: T
  nameWithType: T
  fullName: T
- uid: System.Func{T}
  parent: System
  isExternal: true
  name: Func<T>
  nameWithType: Func<T>
  fullName: System.Func<T>
  spec.csharp:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: Func<T>
  - name: <
    nameWithType: <
    fullName: <
  - uid: T
    name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Security.Principal.WindowsIdentity.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(Object)
  nameWithType: WindowsIdentity.System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(Object)
  fullName: System.Security.Principal.WindowsIdentity.System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Security.Principal.WindowsIdentity.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: WindowsIdentity.System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Security.Principal.WindowsIdentity.System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo,StreamingContext)
- uid: System.Security.Principal.WindowsIdentity.Token
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Token
  nameWithType: WindowsIdentity.Token
  fullName: System.Security.Principal.WindowsIdentity.Token
- uid: System.Security.Principal.WindowsIdentity.User
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: User
  nameWithType: WindowsIdentity.User
  fullName: System.Security.Principal.WindowsIdentity.User
- uid: System.Security.Principal.WindowsIdentity.UserClaims
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: UserClaims
  nameWithType: WindowsIdentity.UserClaims
  fullName: System.Security.Principal.WindowsIdentity.UserClaims
- uid: System.Security.Principal.WindowsIdentity.#ctor*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: WindowsIdentity
  nameWithType: WindowsIdentity.WindowsIdentity
- uid: System.Security.Principal.WindowsIdentity.AccessToken*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: AccessToken
  nameWithType: WindowsIdentity.AccessToken
- uid: System.Security.Principal.WindowsIdentity.AuthenticationType*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: AuthenticationType
  nameWithType: WindowsIdentity.AuthenticationType
- uid: System.Security.Principal.WindowsIdentity.Claims*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Claims
  nameWithType: WindowsIdentity.Claims
- uid: System.Security.Principal.WindowsIdentity.Clone*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Clone
  nameWithType: WindowsIdentity.Clone
- uid: System.Security.Principal.WindowsIdentity.DeviceClaims*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: DeviceClaims
  nameWithType: WindowsIdentity.DeviceClaims
- uid: System.Security.Principal.WindowsIdentity.Dispose*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Dispose
  nameWithType: WindowsIdentity.Dispose
- uid: System.Security.Principal.WindowsIdentity.GetAnonymous*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: GetAnonymous
  nameWithType: WindowsIdentity.GetAnonymous
- uid: System.Security.Principal.WindowsIdentity.GetCurrent*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: GetCurrent
  nameWithType: WindowsIdentity.GetCurrent
- uid: System.Security.Principal.WindowsIdentity.Groups*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Groups
  nameWithType: WindowsIdentity.Groups
- uid: System.Security.Principal.WindowsIdentity.Impersonate*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Impersonate
  nameWithType: WindowsIdentity.Impersonate
- uid: System.Security.Principal.WindowsIdentity.ImpersonationLevel*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: ImpersonationLevel
  nameWithType: WindowsIdentity.ImpersonationLevel
- uid: System.Security.Principal.WindowsIdentity.IsAnonymous*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: IsAnonymous
  nameWithType: WindowsIdentity.IsAnonymous
- uid: System.Security.Principal.WindowsIdentity.IsAuthenticated*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: IsAuthenticated
  nameWithType: WindowsIdentity.IsAuthenticated
- uid: System.Security.Principal.WindowsIdentity.IsGuest*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: IsGuest
  nameWithType: WindowsIdentity.IsGuest
- uid: System.Security.Principal.WindowsIdentity.IsSystem*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: IsSystem
  nameWithType: WindowsIdentity.IsSystem
- uid: System.Security.Principal.WindowsIdentity.Name*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Name
  nameWithType: WindowsIdentity.Name
- uid: System.Security.Principal.WindowsIdentity.Owner*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Owner
  nameWithType: WindowsIdentity.Owner
- uid: System.Security.Principal.WindowsIdentity.RunImpersonated*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: RunImpersonated
  nameWithType: WindowsIdentity.RunImpersonated
- uid: System.Security.Principal.WindowsIdentity.RunImpersonated<T>*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: RunImpersonated<T>
  nameWithType: WindowsIdentity.RunImpersonated<T>
- uid: System.Security.Principal.WindowsIdentity.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: System.Runtime.Serialization.IDeserializationCallback.OnDeserialization
  nameWithType: WindowsIdentity.System.Runtime.Serialization.IDeserializationCallback.OnDeserialization
- uid: System.Security.Principal.WindowsIdentity.System#Runtime#Serialization#ISerializable#GetObjectData*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: System.Runtime.Serialization.ISerializable.GetObjectData
  nameWithType: WindowsIdentity.System.Runtime.Serialization.ISerializable.GetObjectData
- uid: System.Security.Principal.WindowsIdentity.Token*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: Token
  nameWithType: WindowsIdentity.Token
- uid: System.Security.Principal.WindowsIdentity.User*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: User
  nameWithType: WindowsIdentity.User
- uid: System.Security.Principal.WindowsIdentity.UserClaims*
  parent: System.Security.Principal.WindowsIdentity
  isExternal: false
  name: UserClaims
  nameWithType: WindowsIdentity.UserClaims
