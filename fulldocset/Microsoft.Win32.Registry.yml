### YamlMime:ManagedReference
items:
- uid: Microsoft.Win32.Registry
  id: Registry
  children:
  - Microsoft.Win32.Registry.ClassesRoot
  - Microsoft.Win32.Registry.CurrentConfig
  - Microsoft.Win32.Registry.CurrentUser
  - Microsoft.Win32.Registry.DynData
  - Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)
  - Microsoft.Win32.Registry.LocalMachine
  - Microsoft.Win32.Registry.PerformanceData
  - Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)
  - Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)
  - Microsoft.Win32.Registry.Users
  langs:
  - csharp
  name: Registry
  nameWithType: Registry
  fullName: Microsoft.Win32.Registry
  type: Class
  summary: "Предоставляет <xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref> объекты, представляющие корневые разделы в реестре Windows и <xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> методы для доступа к пары &quot;ключ значение&quot;."
  remarks: "Этот класс предоставляет набор стандартных корневых ключей, найденных в реестре компьютеров под управлением Windows. Реестр является средством хранения сведений о приложениях, пользователей и параметры системы по умолчанию. Например приложения используют реестр для хранения сведений, которые необходимо сохранить после закрытия приложения и доступа к этой информации при перезагрузке приложения. Например можно сохранять цветовые настройки, положение или размер окна. Можно управлять эти данные для каждого пользователя, сохраняя данные в другое расположение в реестре.       Базовое или корневое <xref:Microsoft.Win32.RegistryKey>экземпляров, предоставляемые `Registry` класс разграничения базовый механизм хранения подразделы и значения в реестре.</xref:Microsoft.Win32.RegistryKey> Все ключи доступны только для чтения, так как реестр зависит от их существования. Ключи, предоставляемые `Registry` являются: <xref:Microsoft.Win32.Registry.CurrentUser>хранит сведения о настройках пользователя.</xref:Microsoft.Win32.Registry.CurrentUser>       <xref:Microsoft.Win32.Registry.LocalMachine>Сохраняет сведения о конфигурации для локального компьютера.</xref:Microsoft.Win32.Registry.LocalMachine>       <xref:Microsoft.Win32.Registry.ClassesRoot>Хранит сведения о типах (и классах) и их свойств.</xref:Microsoft.Win32.Registry.ClassesRoot>       <xref:Microsoft.Win32.Registry.Users>Хранит сведения о пользовательских настроек по умолчанию.</xref:Microsoft.Win32.Registry.Users>       <xref:Microsoft.Win32.Registry.PerformanceData>Хранит сведения о производительности для компонентов программного обеспечения.</xref:Microsoft.Win32.Registry.PerformanceData>       <xref:Microsoft.Win32.Registry.CurrentConfig>Хранит данные пользователя определенного оборудования.</xref:Microsoft.Win32.Registry.CurrentConfig>       <xref:Microsoft.Win32.Registry.DynData>Сохранение динамических данных.</xref:Microsoft.Win32.Registry.DynData>       После определения корневого ключа, из которой требуется для хранения или извлечения информации из реестра, можно использовать <xref:Microsoft.Win32.RegistryKey>класса, чтобы добавить или удалить подразделы и изменять значения для заданного ключа.</xref:Microsoft.Win32.RegistryKey>       Устройства можно разместить сведения в реестр автоматически, используя интерфейс Plug and Play. Программное обеспечение для установки драйверов устройств можно поместить сведения в реестре, написав стандартным API-интерфейсам.      ## Также содержит статические методы для получение и настройка значений в .NET Framework версии 2.0 класса реестра `static` <xref:Microsoft.Win32.Registry.GetValue%2A>и <xref:Microsoft.Win32.Registry.SetValue%2A>методов задания и получения значения из реестра.</xref:Microsoft.Win32.Registry.SetValue%2A> </xref:Microsoft.Win32.Registry.GetValue%2A> Эти методы откройте и закройте параметры реестра каждый раз, они используются, поэтому они не выполняют, а также аналогичные методы в <xref:Microsoft.Win32.RegistryKey>класса, при доступе к большое количество значений.</xref:Microsoft.Win32.RegistryKey>       <xref:Microsoft.Win32.RegistryKey>Класс также предоставляет методы, которые позволяют задать безопасность управления доступом Windows для разделов реестра, чтобы проверить тип данных значения перед его возвращением и удалить ключи.</xref:Microsoft.Win32.RegistryKey>"
  example:
  - "This section contains two code examples. The first example demonstrates root keys, and the second example demonstrates the `static`<xref:Microsoft.Win32.Registry.GetValue%2A> and <xref:Microsoft.Win32.Registry.SetValue%2A> methods.  \n  \n Example 1  \n  \n The following code example demonstrates how to retrieve the subkeys of the HKEY_USERS key, and print their names to the screen. Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest. You can then use other operations in `RegistryKey` to manipulate that key.  \n  \n [!code-cs[Classic Registry.Users Example#1](~/add/codesnippet/csharp/t-microsoft.win32.registry_1.cs)]\n [!code-cpp[Classic Registry.Users Example#1](~/add/codesnippet/cpp/t-microsoft.win32.registry_1.cpp)]\n [!code-vb[Classic Registry.Users Example#1](~/add/codesnippet/visualbasic/t-microsoft.win32.registry_1.vb)]  \n  \n Example 2  \n  \n The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values. The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of `defaultValue` when a name/value pair does not exist.  \n  \n [!code-cs[Microsoft.Win32.Registry.GetSet#1](~/add/codesnippet/csharp/t-microsoft.win32.registry_2.cs)]\n [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/add/codesnippet/visualbasic/t-microsoft.win32.registry_2.vb)]\n [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/add/codesnippet/cpp/t-microsoft.win32.registry_2.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public static class Registry
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: Microsoft.Win32.Registry.ClassesRoot
  id: ClassesRoot
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  name: ClassesRoot
  nameWithType: Registry.ClassesRoot
  fullName: Microsoft.Win32.Registry.ClassesRoot
  type: Field
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "Определяет типы (или классы) документов и свойства, связанные с этими типами. Это поле считывает базовый ключ реестра HKEY_CLASSES_ROOT."
  remarks: "В стандартных приложениях и OLE-приложения используйте данные, хранящиеся в этом разделе. Этот ключ также обеспечивает обратную совместимость с базой данных регистрации Windows 3.1, сохраняя сведения для поддержки DDE и OLE. Средства просмотра файлов и расширения пользовательского интерфейса хранят свои идентификаторы класса OLE в этот ключ, и серверы обработки регистрируются в этом разделе."
  example:
  - "The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen. Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest. You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.  \n  \n [!code-vb[Classic Registry.ClassesRoot Example#1](~/add/codesnippet/visualbasic/f-microsoft.win32.regist_4_1.vb)]\n [!code-cpp[Classic Registry.ClassesRoot Example#1](~/add/codesnippet/cpp/f-microsoft.win32.regist_4_1.cpp)]\n [!code-cs[Classic Registry.ClassesRoot Example#1](~/add/codesnippet/csharp/f-microsoft.win32.regist_4_1.cs)]"
  syntax:
    content: public static readonly Microsoft.Win32.RegistryKey ClassesRoot;
    return:
      type: Microsoft.Win32.RegistryKey
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: Microsoft.Win32.Registry.CurrentConfig
  id: CurrentConfig
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  name: CurrentConfig
  nameWithType: Registry.CurrentConfig
  fullName: Microsoft.Win32.Registry.CurrentConfig
  type: Field
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "Содержит сведения о конфигурации, относящиеся к оборудованию, не относящиеся к пользователю. Это поле считывает базовый ключ реестра HKEY_CURRENT_CONFIG."
  remarks: "Этот член сопоставляется подраздел в <xref:Microsoft.Win32.Registry.LocalMachine>.</xref:Microsoft.Win32.Registry.LocalMachine>       Пример использования этого элемента — это приложение, которое сохраняет другое имя сервера для своих данных в зависимости от того, прикреплено ли система к сети."
  example:
  - "The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen. Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest. You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.  \n  \n [!code-cpp[Classic Registry.CurrentConfig Example#1](~/add/codesnippet/cpp/f-microsoft.win32.regist_1_1.cpp)]\n [!code-vb[Classic Registry.CurrentConfig Example#1](~/add/codesnippet/visualbasic/f-microsoft.win32.regist_1_1.vb)]\n [!code-cs[Classic Registry.CurrentConfig Example#1](~/add/codesnippet/csharp/f-microsoft.win32.regist_1_1.cs)]"
  syntax:
    content: public static readonly Microsoft.Win32.RegistryKey CurrentConfig;
    return:
      type: Microsoft.Win32.RegistryKey
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: Microsoft.Win32.Registry.CurrentUser
  id: CurrentUser
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  name: CurrentUser
  nameWithType: Registry.CurrentUser
  fullName: Microsoft.Win32.Registry.CurrentUser
  type: Field
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "Содержит сведения о текущих настройках пользователя. Это поле считывает базовый ключ реестра HKEY_CURRENT_USER"
  remarks: "Сведения, сохраненные в этом разделе относятся настройки переменных среды и данные о группы программ, цвета, принтеры, сетевые подключения и параметры приложения. Этот ключ позволяет устанавливать параметры для текущего пользователя. В этом разделе поставщики программного обеспечения сохраняют текущий пользовательские параметры, которые должны использоваться в своих приложениях. Microsoft, например, создает ключ приведенный для их приложений для использования, причем каждое приложение создает свой собственный подразделом ключ Майкрософт."
  example:
  - "The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen. Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest. You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.  \n  \n [!code-cpp[Classic Registry.CurrentUser Example#1](~/add/codesnippet/cpp/f-microsoft.win32.regist_6_1.cpp)]\n [!code-cs[Classic Registry.CurrentUser Example#1](~/add/codesnippet/csharp/f-microsoft.win32.regist_6_1.cs)]\n [!code-vb[Classic Registry.CurrentUser Example#1](~/add/codesnippet/visualbasic/f-microsoft.win32.regist_6_1.vb)]"
  syntax:
    content: public static readonly Microsoft.Win32.RegistryKey CurrentUser;
    return:
      type: Microsoft.Win32.RegistryKey
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: Microsoft.Win32.Registry.DynData
  id: DynData
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  name: DynData
  nameWithType: Registry.DynData
  fullName: Microsoft.Win32.Registry.DynData
  type: Field
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "Динамические данные реестра. Это поле считывает базовый ключ реестра HKEY_DYN_DATA."
  remarks: "Реестр Windows 98/Windows Me поддерживает статические данные (которые хранятся на диске в реестре) и динамических данных (которые часто изменяются, например Статистика производительности). Эта область динамических данных является механизм, позволяющий драйверы виртуальных устройств (VxD) для предоставления данных в режиме реального времени для приложений Win32, которые могут выполняться удаленно, как и локально. Она также позволяет системному монитору предоставлять статистику производительности для удаленных систем Windows 98/Windows Me.       Vxd не ограничены данными о производительности. Они могут предоставить любые данные, которые они хотят эффективно передать из кольца 0 в кольцо 3 без монополизации ресурсов ЦП. Реестр поддерживает динамические данные путем сохранения указателя на функцию, возвращающую значение (или много значений). Если вызов реестра запрашивает значения, связанные с динамическим ключом, эта функция вызывается для возврата необходимого значения или значений.      Настроек [!NOTE] настроек динамические разделы появились в Microsoft Windows 95 для обработки динамических данных реестра. Они поддерживаются только в Windows 98 и Windows Me."
  example:
  - "The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen. Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest. You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key. Note that this example can return no results, since there might not be dynamic data available, or you might not be running Windows 98/ME. Using this key may cause an error on other systems.  \n  \n [!code-vb[Classic Registry.DynData Example#1](~/add/codesnippet/visualbasic/f-microsoft.win32.regist_3_1.vb)]\n [!code-cs[Classic Registry.DynData Example#1](~/add/codesnippet/csharp/f-microsoft.win32.regist_3_1.cs)]\n [!code-cpp[Classic Registry.DynData Example#1](~/add/codesnippet/cpp/f-microsoft.win32.regist_3_1.cpp)]"
  syntax:
    content: public static readonly Microsoft.Win32.RegistryKey DynData;
    return:
      type: Microsoft.Win32.RegistryKey
      description: "Для добавления."
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Операционная система не поддерживает динамические данные; то есть он не является Windows 98, Windows 98 Second Edition или Windows Millennium Edition (Windows Me)."
  platform:
  - net462
- uid: Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)
  id: GetValue(System.String,System.String,System.Object)
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  name: GetValue(String,String,Object)
  nameWithType: Registry.GetValue(String,String,Object)
  fullName: Microsoft.Win32.Registry.GetValue(String,String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "Возвращает значение, связанное с указанным именем, в указанный раздел реестра. Если имя не найдено в указанном разделе, возвращает значение по умолчанию, указать, или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если указанный ключ не существует."
  remarks: "The string `valueName` is not case-sensitive.  \n  \n> [!NOTE]\n>  A registry key can contain one value that is not associated with any name. When this unnamed value is displayed in the registry editor, the string \"(Default)\" appears instead of a name. To retrieve this unnamed value, specify either `null` or the empty string (\"\") for `valuName`.  \n  \n Valid root names are HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG, and HKEY_DYN_DATA. For example, in Visual Basic the string \"HKEY_CURRENT_USER\\MyTestKey\" accesses key/value pairs for the subkey \"MyTestKey\" in the HKEY_CURRENT_USER root.  \n  \n When the <xref:Microsoft.Win32.RegistryKey.GetValue%2A> method retrieves expandable string values (<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>), it expands environment strings using data from the local environment. If a value containing expandable references to environment variables has been stored as a string (<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>), rather than as an expandable string (<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> does not expand it. You can expand such a string after it has been retrieved by calling the <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=fullName> method.  \n  \n> [!NOTE]\n>  The recommended way to retrieve data from HKEY_PERFORMANCE_DATA is to use the <xref:System.Diagnostics.PerformanceCounter> class rather than the <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=fullName> method.  \n  \n The GetValue and <xref:Microsoft.Win32.Registry.SetValue%2A> methods open and close registry keys each time they are used, so they do not perform as well as the methods of the <xref:Microsoft.Win32.RegistryKey> class if you access a large number of values.  \n  \n <xref:Microsoft.Win32.RegistryKey> also provides methods that allow you to add an access control list (ACL) to a registry key, to test the data type of a value before retrieving it, and to delete keys."
  example:
  - "The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values. The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of `defaultValue` when a name/value pair does not exist.  \n  \n [!code-cs[Microsoft.Win32.Registry.GetSet#1](~/add/codesnippet/csharp/m-microsoft.win32.regist_14_1.cs)]\n [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_14_1.vb)]\n [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/add/codesnippet/cpp/m-microsoft.win32.regist_14_1.cpp)]"
  syntax:
    content: public static object GetValue (string keyName, string valueName, object defaultValue);
    parameters:
    - id: keyName
      type: System.String
      description: "Полный путь ключа, начиная с корневой допустимый раздел реестра, например «HKEY_CURRENT_USER»."
    - id: valueName
      type: System.String
      description: "Имя пары имя/значение."
    - id: defaultValue
      type: System.Object
      description: "Значение, возвращаемое, если `valueName` не существует."
    return:
      type: System.Object
      description: "<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>Если заданные подраздела <code> keyName </code> не существует; в противном случае — значение, связанное с <code> valueName </code>, или <code> defaultValue </code> Если <code> valueName </code> не найден."
  overload: Microsoft.Win32.Registry.GetValue*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Пользователь не имеет разрешения, необходимые для чтения из раздела реестра."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref> , Содержит указанное значение, помечен для удаления."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>keyName</code>не начинается с правильного корневого раздела реестра."
  platform:
  - net462
- uid: Microsoft.Win32.Registry.LocalMachine
  id: LocalMachine
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  name: LocalMachine
  nameWithType: Registry.LocalMachine
  fullName: Microsoft.Win32.Registry.LocalMachine
  type: Field
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "Содержит данные о конфигурации для локального компьютера. Это поле считывает базовый ключ реестра HKEY_LOCAL_MACHINE."
  remarks: "`LocalMachine`содержит пять ключей: оборудования описание физического оборудования на компьютере, используйте драйверы устройств способом, оборудование и сопоставления и связанные данные, соединяющие драйверы режима ядра с кодом пользовательского режима. Все данные в этом разделе создается заново при каждом запуске системы. Описание подраздел описывает фактические аппаратные. Раздел DeviceMap содержит различные данные в форматах конкретных классов драйверов. ResourceMap подраздел описывает, какие драйверы устройств аппаратным ресурсам. Программа диагностики Windows NT (Winmsdp.exe) может передавать данные в соответствии с содержимым в виде для чтения.       SAM каталог базы данных служб информации о безопасности для пользователей и групп, а также для доменов в Windows 2000 Server (SAM — диспетчер учетных записей безопасности, известных как базы данных служб каталогов).       Безопасности содержит локальную политику безопасности, например особые права пользователя. Этот ключ используется только подсистемой безопасности Windows 2000.       Программное обеспечение, базе данных каждого компьютера. Этот раздел содержит данные о программах, установленных на локальном компьютере, вместе с различными элементами разнообразных данных о конфигурации.       Элементы управления системы запуска системы, загрузкой драйвера устройств, службами Windows 2000 и поведение операционной системы.       По соглашению, если существует схожие данные в группе <xref:Microsoft.Win32.Registry.CurrentUser>и под LocalMachine, данные в <xref:Microsoft.Win32.Registry.CurrentUser>имеет более высокий приоритет.</xref:Microsoft.Win32.Registry.CurrentUser> </xref:Microsoft.Win32.Registry.CurrentUser> Тем не менее значения в этом разделе можно также расширить (а не заменять) данные в Registry.LocalMachine. Кроме того некоторые элементы (например, элементы загрузки драйвера устройства) не имеют смысла, если они возникают вне Registry.LocalMachine."
  example:
  - "The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen. Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest. You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.  \n  \n [!code-cs[Classic Registry.LocalMachine Example#1](~/add/codesnippet/csharp/f-microsoft.win32.regist_0_1.cs)]\n [!code-cpp[Classic Registry.LocalMachine Example#1](~/add/codesnippet/cpp/f-microsoft.win32.regist_0_1.cpp)]\n [!code-vb[Classic Registry.LocalMachine Example#1](~/add/codesnippet/visualbasic/f-microsoft.win32.regist_0_1.vb)]"
  syntax:
    content: public static readonly Microsoft.Win32.RegistryKey LocalMachine;
    return:
      type: Microsoft.Win32.RegistryKey
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: Microsoft.Win32.Registry.PerformanceData
  id: PerformanceData
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  name: PerformanceData
  nameWithType: Registry.PerformanceData
  fullName: Microsoft.Win32.Registry.PerformanceData
  type: Field
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "Содержит сведения о производительности для компонентов программного обеспечения. Это поле считывает базовый ключ реестра раздел HKEY_PERFORMANCE_DATA."
  remarks: "Каждый программный компонент создает ключи для своих объектов и счетчиков, если он установлен и записывает данные счетчиков в процессе выполнения. Доступ к этим данным, что и к другим данным реестра, с помощью <xref:Microsoft.Win32.RegistryKey>функции.</xref:Microsoft.Win32.RegistryKey>       Несмотря на то, что реестр используется для сбора данных о производительности, данные не хранятся в базе данных реестра. Вместо этого при доступе к реестру с помощью этого параметра заставляет систему собирать данные из соответствующих системных диспетчеров объектов.       Чтобы получить данные о производительности из локальной системы, используйте <xref:Microsoft.Win32.RegistryKey.GetValue%2A>метод, с ключом Registry.PerformanceData.</xref:Microsoft.Win32.RegistryKey.GetValue%2A> Первый вызов открывает ключ (вам не обязательно явно сначала открыть раздел). Тем не менее, обязательно используйте <xref:Microsoft.Win32.RegistryKey.Close%2A>метод, чтобы закрыть дескриптор ключ, когда вы закончите, получение данных о производительности.</xref:Microsoft.Win32.RegistryKey.Close%2A> Пользователь не может установить или удалить программный компонент, данные о производительности во время использования.       Чтобы получить данные о производительности из удаленной системы, необходимо использовать <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A>метод с именем компьютера удаленной системы и ключом Registry.PerformanceData.</xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> Этот вызов извлекает ключ, представляющий данные о производительности для удаленной системы. Для получения данных, вызовите <xref:Microsoft.Win32.RegistryKey.GetValue%2A>с помощью этого ключа, а не ключом Registry.PerformanceData.</xref:Microsoft.Win32.RegistryKey.GetValue%2A>      Настроек [!NOTE] настроек на Windows Server 2003, пользователь должен хотя бы принадлежать к группе пользователей системного монитора для доступа к базовым подразделы."
  example:
  - "The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen. Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest. You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key. Note that this example can often return no results, since there might be no performance data.  \n  \n [!code-cs[Classic Registry.PerformanceData Example#1](~/add/codesnippet/csharp/f-microsoft.win32.regist_2_1.cs)]\n [!code-cpp[Classic Registry.PerformanceData Example#1](~/add/codesnippet/cpp/f-microsoft.win32.regist_2_1.cpp)]\n [!code-vb[Classic Registry.PerformanceData Example#1](~/add/codesnippet/visualbasic/f-microsoft.win32.regist_2_1.vb)]"
  syntax:
    content: public static readonly Microsoft.Win32.RegistryKey PerformanceData;
    return:
      type: Microsoft.Win32.RegistryKey
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)
  id: SetValue(System.String,System.String,System.Object)
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  name: SetValue(String,String,Object)
  nameWithType: Registry.SetValue(String,String,Object)
  fullName: Microsoft.Win32.Registry.SetValue(String,String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "Задает пары указанного имени и значения в указанный раздел реестра. Если указанный ключ не существует, он создается."
  remarks: "Starting with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the `valueName` parameter is no longer restricted to a maximum of 255 characters; however, the `keyName` parameter continues to have the 255-character restriction.  \n  \n Because many values can be stored in each key in the registry, you must use the `valueName` parameter to specify the particular value you want to set.  \n  \n> [!NOTE]\n>  A registry key can contain one value that is not associated with any name. When this unnamed value is displayed in the registry editor, the string \"(Default)\" appears instead of a name. To set this unnamed value, specify either `null` or the empty string (\"\") for `valueName`.  \n  \n If `valueName` does not exist in the key, it is created and the associated value is set to `value`.  \n  \n If `keyName` specifies a subkey that does not exist, the subkey is created in the specified root. For example, in Visual Basic the string \"HKEY_CURRENT_USER\\MyTestKey\" creates the subkey \"MyTestKey\" in the HKEY_CURRENT_USER root. The string \"HKEY_CURRENT_USER\\MyTestKey\\Key2\\Key3\" creates the nested subkeys \"MyTestKey\", \"MyTestKey\\Key2\", and \"MyTestKey\\Key2\\Key3\".  \n  \n Valid root names include HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG, and HKEY_DYN_DATA.  \n  \n> [!NOTE]\n>  The <xref:Microsoft.Win32.Registry.SetValue%2A> method opens a registry key, sets the value, and closes the key each time it is called. If you need to modify a large number of values, the <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=fullName> method might provide better performance. The <xref:Microsoft.Win32.RegistryKey> class also provides methods that allow you to add an access control list (ACL) to a registry key, to test the data type of a value before retrieving it, and to delete keys.  \n  \n This overload of <xref:Microsoft.Win32.Registry.SetValue%2A> stores 64-bit integers as strings (<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>). To store 64-bit numbers as <xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName> values, use the <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> method overload.  \n  \n This overload of <xref:Microsoft.Win32.Registry.SetValue%2A> stores all string values as <xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName> objects, even if they contain expandable references to environment variables. To save string values as expandable strings (<xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>), use the <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> method overload.  \n  \n This overload is equivalent to calling the <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> method overload with <xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>.  \n  \n> [!NOTE]\n>  On Windows 98 and Windows Millennium Edition (Windows Me), the registry is not Unicode, and not all Unicode characters are valid for all code pages. A Unicode character that is invalid for the current code page is replaced by the best available match. No exception is thrown."
  example:
  - "The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values. The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of `defaultValue` when a name/value pair does not exist.  \n  \n [!code-cs[Microsoft.Win32.Registry.GetSet#1](~/add/codesnippet/csharp/m-microsoft.win32.regist_8_1.cs)]\n [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/add/codesnippet/visualbasic/m-microsoft.win32.regist_8_1.vb)]\n [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/add/codesnippet/cpp/m-microsoft.win32.regist_8_1.cpp)]"
  syntax:
    content: public static void SetValue (string keyName, string valueName, object value);
    parameters:
    - id: keyName
      type: System.String
      description: "Полный путь ключа, начиная с корневой допустимый раздел реестра, например «HKEY_CURRENT_USER»."
    - id: valueName
      type: System.String
      description: "Имя пары имя/значение."
    - id: value
      type: System.Object
      description: "Значение для сохранения."
  overload: Microsoft.Win32.Registry.SetValue*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>value</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>keyName</code>не начинается с правильного корневого раздела реестра.       - или - <code>keyName</code> превышает максимально допустимую длину (255 символов)."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref> Доступно только для чтения и поэтому не может быть записан; например, это корневой узел."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Пользователь не имеет разрешения, необходимые для создания или изменения реестра."
  platform:
  - net462
- uid: Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)
  id: SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  name: SetValue(String,String,Object,RegistryValueKind)
  nameWithType: Registry.SetValue(String,String,Object,RegistryValueKind)
  fullName: Microsoft.Win32.Registry.SetValue(String,String,Object,RegistryValueKind)
  type: Method
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "Задает пары имя/значение в указанный раздел реестра, используя заданный тип данных реестра. Если указанный ключ не существует, он создается."
  remarks: "Starting with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the `valueName` parameter is no longer restricted to a maximum of 255 characters; however, the `keyName` parameter continues have the 255-character restriction.  \n  \n Because many values can be stored in each key in the registry, you must use the `valueName` parameter to specify the particular value you want to set.  \n  \n> [!NOTE]\n>  A registry key can contain one value that is not associated with any name. When this unnamed value is displayed in the registry editor, the string \"(Default)\" appears instead of a name. To set this unnamed value, specify either `null` or the empty string (\"\") for `valueName`.  \n  \n If `valueName` does not exist in the key, it is created and the associated value is set to `value`.  \n  \n If `keyName` specifies a subkey that does not exist, the subkey is created in the specified root. For example, in Visual Basic the string \"HKEY_CURRENT_USER\\MyTestKey\" creates the subkey \"MyTestKey\" in the HKEY_CURRENT_USER root. The string \"HKEY_CURRENT_USER\\MyTestKey\\Key2\\Key3\" creates the nested subkeys \"MyTestKey\", \"MyTestKey\\Key2\", and \"MyTestKey\\Key2\\Key3\".  \n  \n Valid root names include HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG, and HKEY_DYN_DATA.  \n  \n> [!NOTE]\n>  The <xref:Microsoft.Win32.Registry.SetValue%2A> method opens a registry key, sets the value, and closes the key each time it is called. If you need to modify a large number of values, the <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=fullName> method might provide better performance. The <xref:Microsoft.Win32.RegistryKey> class also provides methods that allow you to add an access control list (ACL) to a registry key, to test the data type of a value before retrieving it, and to delete keys.  \n  \n If the type of the specified `value` does not match the specified `valueKind`, and the data cannot be converted, <xref:System.ArgumentException> is thrown. For example, you can store a <xref:System.Int64?displayProperty=fullName> as a <xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>, but only if its value is less than the maximum value of a <xref:System.Int32?displayProperty=fullName>. You cannot store a single string value as a <xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>.  \n  \n> [!NOTE]\n>  If boxed values are passed for <xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName> or <xref:Microsoft.Win32.RegistryValueKind?displayProperty=fullName>, the conversion is done using the invariant culture.  \n  \n> [!NOTE]\n>  On Windows 98 and Windows Millennium Edition (Windows Me), the registry is not Unicode, and not all Unicode characters are valid for all code pages. A Unicode character that is invalid for the current code page is replaced by the best available match. No exception is thrown."
  example:
  - "The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values. The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of `defaultValue` when a name/value pair does not exist.  \n  \n [!code-cs[Microsoft.Win32.Registry.GetSet#1](~/add/codesnippet/csharp/7747259a-b475-4eec-8a66-_1.cs)]\n [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/add/codesnippet/visualbasic/7747259a-b475-4eec-8a66-_1.vb)]\n [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/add/codesnippet/cpp/7747259a-b475-4eec-8a66-_1.cpp)]"
  syntax:
    content: public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);
    parameters:
    - id: keyName
      type: System.String
      description: "Полный путь ключа, начиная с корневой допустимый раздел реестра, например «HKEY_CURRENT_USER»."
    - id: valueName
      type: System.String
      description: "Имя пары имя/значение."
    - id: value
      type: System.Object
      description: "Значение для сохранения."
    - id: valueKind
      type: Microsoft.Win32.RegistryValueKind
      description: "Тип данных реестра, используемый для хранения данных."
  overload: Microsoft.Win32.Registry.SetValue*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>value</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>keyName</code>не начинается с правильного корневого раздела реестра.       - или - <code>keyName</code> превышает максимально допустимую длину (255 символов).       - или - тип <code>value</code> не соответствует типу данных реестра, определяемое <code>valueKind</code>, поэтому данные не удалось правильно преобразовать."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<xref href=&quot;Microsoft.Win32.RegistryKey&quot;> </xref> Доступно только для чтения и поэтому не может быть записан; например, это корневой узел или ключ не был открыт с доступом на запись."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Пользователь не имеет разрешения, необходимые для создания или изменения реестра."
  platform:
  - net462
- uid: Microsoft.Win32.Registry.Users
  id: Users
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  name: Users
  nameWithType: Registry.Users
  fullName: Microsoft.Win32.Registry.Users
  type: Field
  assemblies:
  - mscorlib
  namespace: Microsoft.Win32
  summary: "Содержит сведения о пользовательских настроек по умолчанию. Это поле считывает базовый ключ реестра HKEY_USERS."
  remarks: "Этот раздел содержит ветвь для каждого пользователя компьютера. Конфигурация по умолчанию предоставляется для новых пользователей на локальном компьютере и для текущего пользователя по умолчанию, если пользователь не изменил параметры. Поскольку Windows 98 / ME также поддерживает Registry.Users, приложения могут обращаться к сведения о пользователе так же, как и в среде Windows 2000. Сведения о каждом пользователе хранятся в отдельном файле, который можно сохранить локально или на сетевом сервере. Windows 98 / ME можно скопировать этот файл в текущей системе пользователя, чтобы параметры можно переместить с одного компьютера на другой с пользователем."
  example:
  - "The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen. Use the <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A> method to create an instance of the particular subkey of interest. You can then use other operations in <xref:Microsoft.Win32.RegistryKey> to manipulate that key.  \n  \n [!code-cs[Classic Registry.Users Example#1](~/add/codesnippet/csharp/f-microsoft.win32.regist_5_1.cs)]\n [!code-cpp[Classic Registry.Users Example#1](~/add/codesnippet/cpp/f-microsoft.win32.regist_5_1.cpp)]\n [!code-vb[Classic Registry.Users Example#1](~/add/codesnippet/visualbasic/f-microsoft.win32.regist_5_1.vb)]"
  syntax:
    content: public static readonly Microsoft.Win32.RegistryKey Users;
    return:
      type: Microsoft.Win32.RegistryKey
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: Microsoft.Win32.Registry.ClassesRoot
  parent: Microsoft.Win32.Registry
  isExternal: false
  name: ClassesRoot
  nameWithType: Registry.ClassesRoot
  fullName: Microsoft.Win32.Registry.ClassesRoot
- uid: Microsoft.Win32.RegistryKey
  parent: Microsoft.Win32
  isExternal: false
  name: RegistryKey
  nameWithType: RegistryKey
  fullName: Microsoft.Win32.RegistryKey
- uid: Microsoft.Win32.Registry.CurrentConfig
  parent: Microsoft.Win32.Registry
  isExternal: false
  name: CurrentConfig
  nameWithType: Registry.CurrentConfig
  fullName: Microsoft.Win32.Registry.CurrentConfig
- uid: Microsoft.Win32.Registry.CurrentUser
  parent: Microsoft.Win32.Registry
  isExternal: false
  name: CurrentUser
  nameWithType: Registry.CurrentUser
  fullName: Microsoft.Win32.Registry.CurrentUser
- uid: Microsoft.Win32.Registry.DynData
  parent: Microsoft.Win32.Registry
  isExternal: false
  name: DynData
  nameWithType: Registry.DynData
  fullName: Microsoft.Win32.Registry.DynData
- uid: Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)
  parent: Microsoft.Win32.Registry
  isExternal: false
  name: GetValue(String,String,Object)
  nameWithType: Registry.GetValue(String,String,Object)
  fullName: Microsoft.Win32.Registry.GetValue(String,String,Object)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: Microsoft.Win32.Registry.LocalMachine
  parent: Microsoft.Win32.Registry
  isExternal: false
  name: LocalMachine
  nameWithType: Registry.LocalMachine
  fullName: Microsoft.Win32.Registry.LocalMachine
- uid: Microsoft.Win32.Registry.PerformanceData
  parent: Microsoft.Win32.Registry
  isExternal: false
  name: PerformanceData
  nameWithType: Registry.PerformanceData
  fullName: Microsoft.Win32.Registry.PerformanceData
- uid: Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)
  parent: Microsoft.Win32.Registry
  isExternal: false
  name: SetValue(String,String,Object)
  nameWithType: Registry.SetValue(String,String,Object)
  fullName: Microsoft.Win32.Registry.SetValue(String,String,Object)
- uid: Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)
  parent: Microsoft.Win32.Registry
  isExternal: false
  name: SetValue(String,String,Object,RegistryValueKind)
  nameWithType: Registry.SetValue(String,String,Object,RegistryValueKind)
  fullName: Microsoft.Win32.Registry.SetValue(String,String,Object,RegistryValueKind)
- uid: Microsoft.Win32.RegistryValueKind
  parent: Microsoft.Win32
  isExternal: false
  name: RegistryValueKind
  nameWithType: RegistryValueKind
  fullName: Microsoft.Win32.RegistryValueKind
- uid: Microsoft.Win32.Registry.Users
  parent: Microsoft.Win32.Registry
  isExternal: false
  name: Users
  nameWithType: Registry.Users
  fullName: Microsoft.Win32.Registry.Users
- uid: Microsoft.Win32.Registry.GetValue*
  parent: Microsoft.Win32.Registry
  isExternal: false
  name: GetValue
  nameWithType: Registry.GetValue
- uid: Microsoft.Win32.Registry.SetValue*
  parent: Microsoft.Win32.Registry
  isExternal: false
  name: SetValue
  nameWithType: Registry.SetValue
