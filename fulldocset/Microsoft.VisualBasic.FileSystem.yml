### YamlMime:ManagedReference
items:
- uid: Microsoft.VisualBasic.FileSystem
  id: FileSystem
  children:
  - Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  - Microsoft.VisualBasic.FileSystem.CurDir
  - Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  - Microsoft.VisualBasic.FileSystem.Dir
  - Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  - Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  - Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FreeFile
  - Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  - Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.Kill(System.String)
  - Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.Reset
  - Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  - Microsoft.VisualBasic.FileSystem.TAB
  - Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  langs:
  - csharp
  name: FileSystem
  nameWithType: FileSystem
  fullName: Microsoft.VisualBasic.FileSystem
  type: Class
  summary: "<xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> Модуль содержит процедуры, которые используются для выполнения операций файла, каталога или папки и системы. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем использование <xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref> модуля. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Этот модуль поддерживает ключевые слова языка Visual Basic и члены библиотеки времени выполнения, доступ к файлам и папкам."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/t-microsoft.visualbasic._17_1.vb)]"
  syntax:
    content: >-
      [Microsoft.VisualBasic.CompilerServices.StandardModule]

      [System.Security.SecurityCritical]

      public sealed class FileSystem
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  id: ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Изменяет текущий каталог или папку. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_ChDir &quot; name=&quot;ChDir &quot; href=&quot;&quot;> </xref>функции. Дополнительные сведения см. в разделе <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: "`ChDir` Функция меняет каталог по умолчанию, но не диск по умолчанию. Например, если диск по умолчанию — C, следующая инструкция изменяет каталог по умолчанию на диске D, но C остается диска по умолчанию: [!code-vb [VbVbalrCatRef&#39;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_1.vb) ] можно сделать относительный изменения каталога является путем ввода двух точек, следующим образом: [!code-vb [VbVbalrCatRef&#40;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_2.vb) ]       >  [!IMPORTANT] настроек `ChDir` функция требует разрешение неуправляемого кода, что может повлиять на его выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.SecurityPermission>и.</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDir` function to change the current directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#41](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_3.vb)]"
  syntax:
    content: public static void ChDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Обязательный параметр. Объект <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> выражение, которое определяет, какой каталог или папка становится новым каталогом по умолчанию или папку. `Path`может содержать диск. Если диск не указан, <xref uid=&quot;langword_csharp_ChDir&quot; name=&quot;ChDir&quot; href=&quot;&quot;> </xref> меняет каталог по умолчанию или папку на текущем диске."
  overload: Microsoft.VisualBasic.FileSystem.ChDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>является пустым."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Указан недопустимый диск или накопитель недоступен."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  id: ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Изменяет текущий диск."
  remarks: "`ChDrive` Функция требует разрешение неуправляемого кода, что может повлиять на его выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.SecurityPermission>и [разрешений доступа к коду](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._181_1.vb)]"
  syntax:
    content: public static void ChDrive (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Обязательный параметр. Строковое выражение, задающее существующий диск. Если указать пустую строку (&quot;»), текущий диск не изменится. Если `Drive` аргументом является строка нескольких знаков <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> используется только первая буква."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Указан недопустимый диск или накопитель недоступен."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  id: ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Изменяет текущий диск."
  remarks: "`ChDrive` Функция требует разрешение неуправляемого кода, что может повлиять на его выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.SecurityPermission>и [разрешений доступа к коду](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._225_1.vb)]"
  syntax:
    content: public static void ChDrive (string Drive);
    parameters:
    - id: Drive
      type: System.String
      description: "Обязательный параметр. Строковое выражение, задающее существующий диск. Если указать пустую строку (&quot;»), текущий диск не изменится. Если `Drive` аргументом является строка нескольких знаков <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref> используется только первая буква."
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Указан недопустимый диск или накопитель недоступен."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  id: CurDir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Возвращает строку, представляющую текущий путь. <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> Предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._123_1.vb)]"
  syntax:
    content: public static string CurDir ();
    parameters: []
    return:
      type: System.String
      description: "Строка, представляющая текущий путь."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  id: CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Возвращает строку, представляющую текущий путь. <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> Предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._203_1.vb)]"
  syntax:
    content: public static string CurDir (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "Необязательный параметр. <xref uid=&quot;langword_csharp_Char&quot; name=&quot;Char&quot; href=&quot;&quot;></xref>выражение, задающее существующий диск. Если диск не указан или если `Drive` представляет собой строку нулевой длины (&quot;»), <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref> возвращает путь для текущего диска."
    return:
      type: System.String
      description: "Строка, представляющая текущий путь."
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir
  id: Dir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Возвращает строку, представляющую имя файла, каталога или папки, соответствующее указанному шаблону, атрибуту файла или метке тома диска. <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> Предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> функции. В разделе <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>Подробнее.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "`Dir` Функция поддерживает использование нескольких знаков (`*`) и одного знака (`?`) можно указать несколько файлов.       `VbVolume`Возвращает метку тома диска вместо определенное имя файла.       Необходимо указать `PathName` при первом вызове `Dir` функции. Для получения следующего элемента, можно выполнять последующие вызовы `Dir` функции без параметров.      Настроек [!IMPORTANT] настроек работал правильно, `Dir` функция требует <xref:System.Security.Permissions.FileIOPermissionAccess>и <xref:System.Security.Permissions.FileIOPermissionAccess>флаги из <xref:System.Security.Permissions.FileIOPermission>должны быть предоставлены в исполняемый код.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, и [разрешений доступа к коду](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       `Attributes` Используются значения перечисления аргументов: ^ ^ ^   |-|-|-|   | Значение | Константа | Описание |   | `Normal`|`vbnormal`| По умолчанию. Указывает файлы без атрибутов. |   | `ReadOnly`|`vbReadOnly`| Определяет файлы, доступные только для чтения, а также файлы без атрибутов. |   | `Hidden`|`vbHidden`| Определяет скрытые файлы, а также файлы без атрибутов. |   | `System`|`vbSystem`| Определяет системные файлы, а также файлы без атрибутов. |   | `Volume`|`vbVolume`| Определяет метку тома. Если указано другого атрибута `vbVolume` игнорируется. |   | `Directory`|`vbDirectory`| Указывает каталоги или папки, а также файлы без атрибутов. |   | `Archive`|`vbArchive`| Файл был изменен с момента последнего резервного копирования. |   | `Alias`|`vbAlias`| Файл имеет другое имя. |      Настроек [!NOTE] настроек эти перечисления определены в языке Visual Basic и может использоваться в любом месте в коде вместо фактических значений."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._44_1.vb)]"
  syntax:
    content: public static string Dir ();
    parameters: []
    return:
      type: System.String
      description: "Строка, представляющая имя файла, каталога или папки, соответствующее указанному шаблону или атрибут файла или метки тома диска."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  id: Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Возвращает строку, представляющую имя файла, каталога или папки, соответствующее указанному шаблону, атрибуту файла или метке тома диска. <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> Предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> функции. В разделе <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>Подробнее.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "`Dir` Функция поддерживает использование нескольких знаков (`*`) и одного знака (`?`) можно указать несколько файлов.       `VbVolume`Возвращает метку тома диска вместо определенное имя файла.       Необходимо указать `PathName` при первом вызове `Dir` функции. Для получения следующего элемента, можно выполнять последующие вызовы `Dir` функции без параметров.      Настроек [!IMPORTANT] настроек работал правильно, `Dir` функция требует <xref:System.Security.Permissions.FileIOPermissionAccess>и <xref:System.Security.Permissions.FileIOPermissionAccess>флаги из <xref:System.Security.Permissions.FileIOPermission>должны быть предоставлены в исполняемый код.</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, и [разрешений доступа к коду](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675).</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       `Attributes` Используются значения перечисления аргументов: ^ ^ ^   |-|-|-|   | Значение | Константа | Описание |   | `Normal`|`vbnormal`| По умолчанию. Указывает файлы без атрибутов. |   | `ReadOnly`|`vbReadOnly`| Определяет файлы только для чтения в дополнение к файлам без атрибутов. |   | `Hidden`|`vbHidden`| Задает скрытые файлы, кроме файлов без атрибутов. |   | `System`|`vbSystem`| Определяет системные файлы в дополнение к файлам без атрибутов. |   | `Volume`|`vbVolume`| Определяет метку тома. Если указано другого атрибута `vbVolume` игнорируется. |   | `Directory`|`vbDirectory`| Указывает каталоги или папки, в дополнение к файлам без атрибутов. |   | `Archive`|`vbArchive`| Файл был изменен с момента последнего резервного копирования. |   | `Alias`|`vbAlias`| Файл имеет другое имя. |      Настроек [!NOTE] настроек эти перечисления определены в языке Visual Basic и может использоваться в любом месте в коде вместо фактических значений."
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/0bb37160-d621-482a-af3b-_1.vb)]"
  syntax:
    content: public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);
    parameters:
    - id: PathName
      type: System.String
      description: "Необязательный параметр. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>выражение, задающее имя файла, папки или папки имя или метку тома диска. Строка нулевой длины (<xref uid=&quot;langword_csharp_&quot;&quot;&quot; name=&quot;&quot;&quot;&quot; href=&quot;&quot;></xref>) возвращается, если `PathName` не найден."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Необязательный параметр. Перечисление или числовое выражение, значение которого определяет атрибуты файла. Если не указано, <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref> возвращает файлы, соответствующие `PathName` , но не иметь атрибутов."
    return:
      type: System.String
      description: "Строка, представляющая имя файла, каталога или папки, соответствующее указанному шаблону или атрибут файла или метки тома диска."
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  id: EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Возвращает значение типа Boolean <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> при открытии конца файла для <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> или последовательных <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> был достигнут."
  remarks: "Используйте `EOF` Чтобы избежать ошибки, возникающей при попытке прочитать данные за пределами файла.       `EOF` Возврата функцией `False` достигнут конец файла. В файлах, открытых для `Random` или `Binary` доступ, `EOF` возвращает `False` до последнего выполнения `FileGet` функции не удалось прочитать запись целиком.       В файлах, открытых для `Binary` доступа, попытка прочитать файл с помощью `Input` функции до `EOF` возвращает `True` приводит к ошибке. Используйте `LOF` и `Loc` функции вместо `EOF` при чтении двоичных файлов с `Input`, или используйте `Get` при использовании `EOF` функции. В файлах, открытых для `Output`, `EOF` всегда возвращает `True`."
  example:
  - "This example uses the `EOF` function to detect the end of a file. This example assumes that `Testfile` is a text file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#62](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._184_1.vb)]"
  syntax:
    content: public static bool EOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> , Содержащее любой допустимый номер файла."
    return:
      type: System.Boolean
      description: "Возвращает значение типа Boolean <xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;> </xref> при открытии конца файла для <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> или последовательных <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> был достигнут."
  overload: Microsoft.VisualBasic.FileSystem.EOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  id: FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Возвращает перечисление, представляющее режим файла для файлов, открытых с использованием <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> функции. <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> Предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileAttr &quot; name=&quot;FileAttr &quot; href=&quot;&quot;> </xref>функции. В разделе <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>Подробнее.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Эта функция возвращает перечисление, представляющее режим файла для файлов, открытых с использованием `FileOpen` функции."
  example:
  - "This example uses the `FileAttr` function to return the file mode of an open file.  \n  \n [!code-vb[VbVbalrCatRef#46](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._147_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>. Любой допустимый номер файла."
    return:
      type: Microsoft.VisualBasic.OpenMode
      description: "Следующие значения перечисления определяют режим доступа к файлу:       <table><tbody><tr><td> Значение       </td><td> Режим       </td></tr><tr><td> 1       </td><td><xref uid=&quot;langword_csharp_OpenMode.Input&quot; name=&quot;OpenMode.Input&quot; href=&quot;&quot;></xref></td></tr><tr><td> 2       </td><td><xref uid=&quot;langword_csharp_OpenMode.Output&quot; name=&quot;OpenMode.Output&quot; href=&quot;&quot;></xref></td></tr><tr><td> 4       </td><td><xref uid=&quot;langword_csharp_OpenMode.Random&quot; name=&quot;OpenMode.Random&quot; href=&quot;&quot;></xref></td></tr><tr><td> 8       </td><td><xref uid=&quot;langword_csharp_OpenMode.Append&quot; name=&quot;OpenMode.Append&quot; href=&quot;&quot;></xref></td></tr><tr><td> 32       </td><td><xref uid=&quot;langword_csharp_OpenMode.Binary&quot; name=&quot;OpenMode.Binary&quot; href=&quot;&quot;></xref></td></tr></tbody></table>"
  overload: Microsoft.VisualBasic.FileSystem.FileAttr*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  id: FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Завершает операции ввода вывода (I/O) в файл, открытый с помощью <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> функции. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;></xref>предоставляет более высокую производительность и производительности операций файлового ввода-вывода. В разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> для получения дополнительной информации."
  remarks: "`FileClose` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [как: чтение текста из файлов с помощью StreamReader](~/add/includes/ajax-current-ext-md.md),[как: запись текста в файлы с помощью StreamWriter](~/add/includes/ajax-current-ext-md.md), и [Пошаговое руководство: управление файлами и каталогами в Visual Basic](~/add/includes/ajax-current-ext-md.md).       Если не указан `FileNumbers`, открываемые всех активных файлах `FileOpen` функция закрываются.       При закрытии файлов, открытых для `Output` или `Append`, последнее содержимое буфера вывода записывается в буфер операционной системы для этого файла. Все буферное пространство, связанное с закрытого файла освобождается.       Если `FileClose` функция выполняется, а связь файла с его файл заканчивается."
  example:
  - "This example uses the `FileClose`function to close a file opened for `Input`.  \n  \n [!code-vb[VbVbalrCatRef#69](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._41_1.vb)]"
  syntax:
    content: public static void FileClose (int[] FileNumbers);
    parameters:
    - id: FileNumbers
      type: System.Int32[]
      description: "Необязательный параметр. Массив параметров из 0 или нескольких каналов должен быть закрыт."
  overload: Microsoft.VisualBasic.FileSystem.FileClose*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>не существует."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  id: FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Копирование файла. <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> Предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileCopy&quot; name=&quot;FileCopy&quot; href=&quot;&quot;> </xref>. В разделе <xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>Подробнее.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>"
  remarks: "При попытке использовать `FileCopy` работать в открытом файле, происходит ошибка.       `FileCopy`требуется полное доверие для работы на локальном диске."
  example:
  - "This example uses the `FileCopy` function to copy one file to another. For purposes of this example, assume that `SrcFile` is a file that contains data.  \n  \n [!code-vb[VbVbalrCatRef#2](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._96_1.vb)]"
  syntax:
    content: public static void FileCopy (string Source, string Destination);
    parameters:
    - id: Source
      type: System.String
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>выражение, указывающее имя файла для копирования. `Source`может включать каталог или папку и диск исходного файла."
    - id: Destination
      type: System.String
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>выражение, задающее имя конечного файла. `Destination`может включать каталог или папку и диск конечного файла."
  overload: Microsoft.VisualBasic.FileSystem.FileCopy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Source</code>или <code>Destination</code> недопустимо или не указано."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Файл уже открыт."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Файл не существует."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  id: FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Возвращает <xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;> </xref> значение, указывающее дату и время записи файла. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileDateTime&quot; name=&quot;FileDateTime&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*></xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: ''
  example:
  - "This example uses the `FileDateTime` function to determine the date and time a file was created or last modified. The format of the date and time displayed is based on the locale settings of the system.  \n  \n [!code-vb[VbVbalrCatRef#34](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._22_1.vb)]"
  syntax:
    content: public static DateTime FileDateTime (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>выражение, указывающее имя файла. `PathName`может включать каталог или папку и имя диска."
    return:
      type: System.DateTime
      description: "<xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;></xref>значение, указывающее дату и время файл создания или последнего изменения."
  overload: Microsoft.VisualBasic.FileSystem.FileDateTime*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>PathName</code>является недопустимым или содержит подстановочные знаки."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Конечный файл не существует."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  id: FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого файла на диске в переменную. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/ad6628f8-6ae5-47af-a394-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Boolean
      description: "Обязательный параметр. Допустимое имя переменной, в которую считываются данные."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается чтение."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  id: FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого файла на диске в переменную. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used. Then the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/9daa1fad-0f67-40af-bac0-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Byte
      description: "Обязательный параметр. Допустимое имя переменной, в которую считываются данные."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается чтение."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  id: FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого файла на диске в переменную. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/31a532e9-297f-48c8-a186-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Char
      description: "Обязательный параметр. Допустимое имя переменной, в которую считываются данные."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается чтение."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  id: FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого файла на диске в переменную. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/d9877ddb-692f-47fe-8c26-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.DateTime
      description: "Обязательный параметр. Допустимое имя переменной, в которую считываются данные."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается чтение."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  id: FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого файла на диске в переменную. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/3d9f416d-1287-4566-b3fa-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Decimal
      description: "Обязательный параметр. Допустимое имя переменной, в которую считываются данные."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается чтение."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  id: FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого файла на диске в переменную. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/184fee0e-b744-4669-8fdf-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Double
      description: "Обязательный параметр. Допустимое имя переменной, в которую считываются данные."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается чтение."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  id: FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого файла на диске в переменную. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/45e0fdff-455b-4fd4-a7c2-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Int16
      description: "Обязательный параметр. Допустимое имя переменной, в которую считываются данные."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается чтение."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  id: FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого файла на диске в переменную. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/7db3ee1c-ee17-457b-bd2d-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Int32
      description: "Обязательный параметр. Допустимое имя переменной, в которую считываются данные."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается чтение."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  id: FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого файла на диске в переменную. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/bd48d1ef-82ea-4239-8c9b-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Int64
      description: "Обязательный параметр. Допустимое имя переменной, в которую считываются данные."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается чтение."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  id: FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого файла на диске в переменную. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/79f9948f-e0d0-41fe-a7b5-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Single
      description: "Обязательный параметр. Допустимое имя переменной, в которую считываются данные."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается чтение."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  id: FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого файла на диске в переменную. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/f351f02c-d919-4d73-938f-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.ValueType
      description: "Обязательный параметр. Допустимое имя переменной, в которую считываются данные."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается чтение."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  id: FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого файла на диске в переменную. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/cefffea4-17eb-455d-be3e-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.String
      description: "Обязательный параметр. Допустимое имя переменной, в которую считываются данные."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается чтение."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Необязательный параметр. Применяется только при записи строки. Указывает необходимость записать дескриптор строку, которая описывает длину&2; байта. Значение по умолчанию — <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  id: FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого файла на диске в переменную. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/c053ec00-d593-49bf-a3cb-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Array
      description: "Обязательный параметр. Допустимое имя переменной, в которую считываются данные."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается чтение."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Необязательный параметр. Применяется только при записи массива. Указывает ли массив следует рассматривать как динамический и необходим ли дескриптор массива, описывающий размер и границы массива."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Необязательный параметр. Применяется только при записи строки. Указывает необходимость записать дескриптор строку, которая описывает длину&2; байта. Значение по умолчанию — <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  id: FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого файла на диске в переменную.  <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileGetObject&quot; name=&quot;FileGetObject&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.  \n  \n If you intend to write out the `Variant` type, `FileGetObject` is required. When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.  \n  \n `FileGetObject` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGetObject` is usually written with `FilePutObject`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.  \n  \n-   If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.  \n  \n     For example, the following array declaration requires 218 bytes when the array is written to disk:  \n  \n     [!code-vb[VbVbalrCatRef#27](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_1.vb)]  \n  \n     The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 \\* 10 \\* 4).  \n  \n-   `FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors. The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGetObject`reads all variables from disk contiguously, that is, with no padding between records.  \n  \n-   For any array other than an array in a structure, `FileGetObject` reads only the data. No descriptor is read.  \n  \n `FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file."
  example:
  - "The following example reads a record into a test file and then retrieves it.  \n  \n [!code-vb[VbVbalrCatRef#26](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_2.vb)]"
  syntax:
    content: public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Object
      description: "Обязательный параметр. Допустимое имя переменной, в которую считываются данные."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается чтение."
  overload: Microsoft.VisualBasic.FileSystem.FileGetObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  id: FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Возвращает <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> значение, указывающее длину файла в байтах. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileLen&quot; name=&quot;FileLen&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "Если указанный файл открыт, когда `FileLen` вызывается функция, возвращаемое значение представляет размер файла на момент его открытия.      Настроек [!NOTE] настроек для получения текущей длины открытого файла используйте `LOF` функции."
  example:
  - "This example uses the `FileLen` function to return the length of a file in bytes. For purposes of this example, assume that `TestFile` is a file that contains some data.  \n  \n [!code-vb[VbVbalrCatRef#1](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._122_1.vb)]"
  syntax:
    content: public static long FileLen (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>выражение, определяющее файл. `PathName`может включать каталог или папку и имя диска."
    return:
      type: System.Int64
      description: "<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>значение, указывающее длину файла в байтах."
  overload: Microsoft.VisualBasic.FileSystem.FileLen*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Файл не существует."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  id: FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Открывает файл для ввода или вывода. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FileOpen` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Перед выполнением любой операции ввода-вывода на нем необходимо открыть файл. `FileOpen`выделяет буфер для ввода-вывода в файл и определяет режим доступа, используемый с буфером.      Настроек [!IMPORTANT] настроек при записи в файл приложения может потребоваться создать файл, если файл, к которому он пытается записать не существует. Для этого ему разрешения для каталога, в которой создан файл. Тем не менее если файл, указанный параметром `FileName` существует, приложение должно `Write` разрешение только на сам файл. Везде, где возможно, в целях повышения безопасности, создайте файл во время развертывания и предоставления `Write` разрешений к этому файлу только, а не для всего каталога. В целях повышения безопасности, записывают данные в каталоги пользователей, а не в корневой каталог или каталог Program Files.       Для открытия канала можно найти с помощью `FreeFile()` функции.      Настроек [!IMPORTANT] настроек `FileOpen` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления, который может повлиять на выполнение в случаях частичного доверия. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example illustrates various uses of the `FileOpen` function to enable input and output to a file.  \n  \n The following code opens the file `TestFile` in `Input` mode.  \n  \n [!code-vb[VbVbalrCatRef#5](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_1.vb)]  \n  \n This example opens the file in `Binary` mode for writing operations only.  \n  \n [!code-vb[VbVbalrCatRef#6](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_2.vb)]  \n  \n The following example opens the file in `Random` mode. The file contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#7](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_3.vb)]  \n  \n This code example opens the file in `Output` mode; any process can read or write to file.  \n  \n [!code-vb[VbVbalrCatRef#8](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_4.vb)]  \n  \n This code example opens the file in `Binary` mode for reading; other processes cannot read file.  \n  \n [!code-vb[VbVbalrCatRef#9](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_5.vb)]"
  syntax:
    content: public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла. Используйте <xref uid=&quot;langword_csharp_FreeFile&quot; name=&quot;FreeFile&quot; href=&quot;&quot;> </xref> функции для получения следующего свободного номера файла."
    - id: FileName
      type: System.String
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>выражение, указывающее имя файла — может включать каталог или папку и диск."
    - id: Mode
      type: Microsoft.VisualBasic.OpenMode
      description: 'Обязательный параметр. Enumeration specifying the file mode: <xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Output&quot; name=&quot;Output&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.OpenMode&quot;> </xref> .'
    - id: Access
      type: Microsoft.VisualBasic.OpenAccess
      description: 'Необязательный параметр. Перечисление операций, разрешенных на открытие файла: <xref uid=&quot;langword_csharp_Read&quot; name=&quot;Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref>, или <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. По умолчанию используется значение <xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.OpenAccess&quot;> </xref> .'
    - id: Share
      type: Microsoft.VisualBasic.OpenShare
      description: 'Необязательный параметр. Перечисление операций не разрешен на открытие файла с другими процессами: <xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Read&quot; name=&quot;Lock Read&quot; href=&quot;&quot;> </xref>, <xref uid=&quot;langword_csharp_Lock Write&quot; name=&quot;Lock Write&quot; href=&quot;&quot;> </xref>, и <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. По умолчанию используется значение <xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.OpenShare&quot;> </xref> .'
    - id: RecordLength
      type: System.Int32
      description: "Необязательный параметр. Число меньше или равно 32 767 (байт). Для файлов, открытых для произвольного доступа это значение является длиной записи. Для последовательных файлов это значение — количество знаков в буфере."
  overload: Microsoft.VisualBasic.FileSystem.FileOpen*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Длина записи является отрицательным (и не равно -1)."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileName</code>уже открыт, или <code>FileName</code> является недопустимым."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  id: FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные из переменной в файл на диске. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`допустимо только в `Random` и `Binary` режим.       Данные, записанные с `FilePut` обычно считываются из файла с помощью `FileGet`.       Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.       `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut`не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.      ## Случайные файлы режим для открытия в `Random` режиме, применяются следующие правила: - Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen`функции, будет создано исключение.      -Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.      -Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(`3`)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.      -Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(`8`)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.      -Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_1.vb) ] — в случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.      - `FilePut` записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.          Настроек [!NOTE] настроек строка полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск, ## открыть двоичный режим для файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим: - `RecordLength` предложения в `FileOpen` функция не имеет эффекта. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.      -Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.      - `FilePut` записывает строки переменной длины, которые не являются частью структуры дескриптор длиной&2; байта. Число записанных байтов равно количеству знаков в строке. Например, следующие инструкции записывают 11 байтов в файл номер 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_2.vb) ] - записи в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Boolean
      description: "Обязательный параметр. Допустимое имя переменной, которая содержит данные, записанные на диск."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается запись."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  id: FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные из переменной в файл на диске. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`допустимо только в `Random` и `Binary` режим.       Данные, записанные с `FilePut` обычно считываются из файла с помощью `FileGet`.       Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.       `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut`не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.      ## Случайные файлы режим для открытия в `Random` режиме, применяются следующие правила: - Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.      -Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.      -Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(`3`)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.      -Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(`8`)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.      -Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_1.vb) ] — в случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.      - `FilePut` записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.          Настроек [!NOTE] настроек строка полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск, ## открыть двоичный режим для файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим: - `RecordLength` предложения в `FileOpen` функция не имеет эффекта. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.      -Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.      - `FilePut` записывает строки переменной длины, которые не являются частью структуры дескриптор длиной&2; байта. Число записанных байтов равно количеству знаков в строке. Например, следующие инструкции записывают 11 байтов в файл номер 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_2.vb) ] - записи в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Byte
      description: "Обязательный параметр. Допустимое имя переменной, которая содержит данные, записанные на диск."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается запись."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  id: FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные из переменной в файл на диске. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`допустимо только в `Random` и `Binary` режим.       Данные, записанные с `FilePut` обычно считываются из файла с помощью `FileGet`.       Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.       `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut`не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.      ## Случайные файлы режим для открытия в `Random` режиме, применяются следующие правила: - Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.      -Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.      -Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(`3`)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.      -Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(`8`)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.      -Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_1.vb) ] — в случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.      - `FilePut` записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.          Настроек [!NOTE] настроек строка полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск, ## открыть двоичный режим для файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим: - `RecordLength` предложения в `FileOpen` функция не имеет эффекта. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.      -Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.      - `FilePut` записывает строки переменной длины, которые не являются частью структуры дескриптор длиной&2; байта. Число записанных байтов равно количеству знаков в строке. Например, следующие инструкции записывают 11 байтов в файл номер 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_2.vb) ] - записи в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Char
      description: "Обязательный параметр. Допустимое имя переменной, которая содержит данные, записанные на диск."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается запись."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  id: FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные из переменной в файл на диске. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`допустимо только в `Random` и `Binary` режим.       Данные, записанные с `FilePut` обычно считываются из файла с помощью `FileGet`.       Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.       `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut`не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.      ## Случайные файлы режим для открытия в `Random` режиме, применяются следующие правила: - Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.      -Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.      -Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(`3`)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.      -Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(`8`)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.      -Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_1.vb) ] — в случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.      - `FilePut` записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.          Настроек [!NOTE] настроек строка полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск, ## открыть двоичный режим для файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим: - `RecordLength` предложения в `FileOpen` функция не имеет эффекта. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.      -Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.      - `FilePut` записывает строки переменной длины, которые не являются частью структуры дескриптор длиной&2; байта. Число записанных байтов равно количеству знаков в строке. Например, следующие инструкции записывают 11 байтов в файл номер 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_2.vb) ] - записи в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.DateTime
      description: "Обязательный параметр. Допустимое имя переменной, которая содержит данные, записанные на диск."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается запись."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  id: FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные из переменной в файл на диске. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`допустимо только в `Random` и `Binary` режим.       Данные, записанные с `FilePut` обычно считываются из файла с помощью `FileGet`.       Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.       `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut`не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.      ## Случайные файлы режим для открытия в `Random` режиме, применяются следующие правила: - Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.      -Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.      -Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(`3`)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.      -Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(`8`)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.      -Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_1.vb) ] — в случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.      - `FilePut` записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.          Настроек [!NOTE] настроек строка полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск, ## открыть двоичный режим для файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим: - `RecordLength` предложения в `FileOpen` функция не имеет эффекта. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.      -Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.      - `FilePut` записывает строки переменной длины, которые не являются частью структуры дескриптор длиной&2; байта. Число записанных байтов равно количеству знаков в строке. Например, следующие инструкции записывают 11 байтов в файл номер 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_2.vb) ] - записи в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Decimal
      description: "Обязательный параметр. Допустимое имя переменной, которая содержит данные, записанные на диск."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается запись."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  id: FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные из переменной в файл на диске. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`допустимо только в `Random` и `Binary` режим.       Данные, записанные с `FilePut` обычно считываются из файла с помощью `FileGet`.       Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.       `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut`не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.      ## Случайные файлы режим для открытия в `Random` режиме, применяются следующие правила: - Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.      -Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.      -Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(`3`)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.      -Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(`8`)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.      -Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_1.vb) ] — в случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.      - `FilePut` записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.          Настроек [!NOTE] настроек строка полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск, ## открыть двоичный режим для файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим: - `RecordLength` предложения в `FileOpen` функция не имеет эффекта. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.      -Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.      - `FilePut` записывает строки переменной длины, которые не являются частью структуры дескриптор длиной&2; байта. Число записанных байтов равно количеству знаков в строке. Например, следующие инструкции записывают 11 байтов в файл номер 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_2.vb) ] - записи в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Double
      description: "Обязательный параметр. Допустимое имя переменной, которая содержит данные, записанные на диск."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается запись."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  id: FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные из переменной в файл на диске. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`допустимо только в `Random` и `Binary` режим.       Данные, записанные с `FilePut` обычно считываются из файла с помощью `FileGet`.       Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.       `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut`не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.      ## Случайные файлы режим для открытия в `Random` режиме, применяются следующие правила: - Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.      -Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.      -Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(`3`)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.      -Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор`VarType(`8`)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.      -Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_1.vb) ] — в случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.      - `FilePut` записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.          Настроек [!NOTE] настроек строка полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск, ## открыть двоичный режим для файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим: - `RecordLength` предложения в `FileOpen` функция не имеет эффекта. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.      -Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.      - `FilePut` записывает строки переменной длины, которые не являются частью структуры дескриптор длиной&2; байта. Число записанных байтов равно количеству знаков в строке. Например, следующие инструкции записывают 11 байтов в файл номер 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_2.vb) ] - записи в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Int16
      description: "Обязательный параметр. Допустимое имя переменной, которая содержит данные, записанные на диск."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается запись."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  id: FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные из переменной в файл на диске. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`допустимо только в `Random` и `Binary` режим.       Данные, записанные с `FilePut` обычно считываются из файла с помощью `FileGet`.       Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.       `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut`не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.      ## Случайные файлы режим для открытия в `Random` режиме, применяются следующие правила: - Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.      -Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.      -Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(`3`)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.      -Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(`8`)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.      -Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_1.vb) ] — в случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.      - `FilePut` записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.          Настроек [!NOTE] настроек строка полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск, ## открыть двоичный режим для файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим: - `RecordLength` предложения в `FileOpen` функция не имеет эффекта. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.      -Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.      - `FilePut` записывает строки переменной длины, которые не являются частью структуры дескриптор длиной&2; байта. Число записанных байтов равно количеству знаков в строке. Например, следующие инструкции записывают 11 байтов в файл номер 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_2.vb) ] - записи в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Int32
      description: "Обязательный параметр. Допустимое имя переменной, которая содержит данные, записанные на диск."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается запись."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  id: FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные из переменной в файл на диске. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`допустимо только в `Random` и `Binary` режим.       Данные, записанные с `FilePut` обычно считываются из файла с помощью `FileGet`.       Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.       `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut`не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.      ## Случайные файлы режим для открытия в `Random` режиме, применяются следующие правила: - Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.      -Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.      -Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(`3`)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.      -Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(`8`)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.      -Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_1.vb) ] — в случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.      - `FilePut` записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.          Настроек [!NOTE] настроек строка полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск, ## открыть двоичный режим для файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим: - `RecordLength` предложения в `FileOpen` функция не имеет эффекта. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.      -Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.      - `FilePut` записывает строки переменной длины, которые не являются частью структуры дескриптор длиной&2; байта. Число записанных байтов равно количеству знаков в строке. Например, следующие инструкции записывают 11 байтов в файл номер 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_2.vb) ] - записи в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Int64
      description: "Обязательный параметр. Допустимое имя переменной, которая содержит данные, записанные на диск."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается запись."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  id: FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные из переменной в файл на диске. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`допустимо только в `Random` и `Binary` режим.       Данные, записанные с `FilePut` обычно считываются из файла с помощью `FileGet`.       Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.       `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut`не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.      ## Случайные файлы режим для открытия в `Random` режиме, применяются следующие правила: - Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen`функции, будет создано исключение.      -Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.      -Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(`3`)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.      -Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(`8`)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.      -Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_1.vb) ] — в случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.      - `FilePut` записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.          Настроек [!NOTE] настроек строка полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск, ## открыть двоичный режим для файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим: - `RecordLength` предложения в `FileOpen` функция не имеет эффекта. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.      -Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.      - `FilePut` записывает строки переменной длины, которые не являются частью структуры дескриптор длиной&2; байта. Число записанных байтов равно количеству знаков в строке. Например, следующие инструкции записывают 11 байтов в файл номер 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_2.vb) ] - записи в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Single
      description: "Обязательный параметр. Допустимое имя переменной, которая содержит данные, записанные на диск."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается запись."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  id: FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные из переменной в файл на диске. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`допустимо только в `Random` и `Binary` режим.       Данные, записанные с `FilePut` обычно считываются из файла с помощью `FileGet`.       Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.       `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut`не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.      ## Случайные файлы режим для открытия в `Random` режиме, применяются следующие правила: - Если длина записываемых данных меньше, чем длина, указанная в`RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.      -Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.      -Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(`3`)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.      -Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(`8`)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.      -Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_1.vb) ] — в случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.      - `FilePut` записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.          Настроек [!NOTE] настроек строка полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск, ## открыть двоичный режим для файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим: - `RecordLength` предложения в `FileOpen` функция не имеет эффекта. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.      -Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.      - `FilePut` записывает строки переменной длины, которые не являются частью структуры дескриптор длиной&2; байта. Число записанных байтов равно количеству знаков в строке. Например, следующие инструкции записывают 11 байтов в файл номер 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_2.vb) ] - записи в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.ValueType
      description: "Обязательный параметр. Допустимое имя переменной, которая содержит данные, записанные на диск."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается запись."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  id: FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные из переменной в файл на диске. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`допустимо только в `Random` и `Binary` режим.       Данные, записанные с `FilePut` обычно считываются из файла с помощью `FileGet`.       Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.       `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut`не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.      ## Случайные файлы режим для открытия в `Random` режиме, применяются следующие правила: - Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.      -Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.      -Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(`3`)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.      -Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(`8`)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.      -Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_1.vb) ] — в случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.      - `FilePut` записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.          Настроек [!NOTE] настроек строка полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск, ## открыть двоичный режим для файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим: - `RecordLength` предложения в `FileOpen` функция не имеет эффекта. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.      -Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.      - `FilePut` записывает строки переменной длины, которые не являются частью структуры дескриптор длиной&2; байта. Число записанных байтов равно количеству знаков в строке. Например, следующие инструкции записывают 11 байтов в файл номер 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_2.vb) ] - записи в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_3.vb)]"
  syntax:
    content: public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Object
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Object
      description: "Обязательный параметр. Допустимое имя переменной, которая содержит данные, записанные на диск."
    - id: RecordNumber
      type: System.Object
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается запись."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  id: FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные из переменной в файл на диске. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>..."
  remarks: "`FilePut`допустимо только в `Random` и `Binary` режим.       Данные, записанные с `FilePut` обычно считываются из файла с помощью `FileGet`.       Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.       `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut`не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.      ## Случайные файлы режим для открытия в `Random` режиме, применяются следующие правила: - Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.      -Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.      -Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(`3`)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.      -Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(`8`)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.      -Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_1.vb) ] — в случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.      - `FilePut` записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.          Настроек [!NOTE] настроек строка полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск, ## открыть двоичный режим для файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим: - `RecordLength` предложения в `FileOpen` функция не имеет эффекта. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.      -Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.      - `FilePut` записывает строки переменной длины, которые не являются частью структуры дескриптор длиной&2; байта. Число записанных байтов равно количеству знаков в строке. Например, следующие инструкции записывают 11 байтов в файл номер 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_2.vb) ] - записи в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.String
      description: "Обязательный параметр. Допустимое имя переменной, которая содержит данные, записанные на диск."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается запись."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Необязательный параметр. Применяется только при записи строки. Указывает, следует ли записывать дескриптор длиной в&2; байта строки для строки в файл. Значение по умолчанию — <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  id: FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные из переменной в файл на диске. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePut`допустимо только в `Random` и `Binary` режим.       Данные, записанные с `FilePut` обычно считываются из файла с помощью `FileGet`.       Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, далее запись или байт после последнего `FileGet` или `FilePut` функцию или на который указывает последний `Seek` написана функция.       `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePut`не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePut`, вы должны делать то же самое с `FileGet`, и убедитесь, что строка инициализируется до длины ожидаемого.      ## Случайные файлы режим для открытия в `Random` режиме, применяются следующие правила: - Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePut` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку нельзя определить объем данных заполнения с достаточной точностью, обычно является хорошим длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, будет создано исключение.      -Если записываемая переменная является строкой, `FilePut` записывает двухбайтовый дескриптор, содержащий длину строки, а затем записывает данные, хранящиеся в переменной. Таким образом, длина записи, заданная параметром `RecordLength` предложения в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическая длина строки.      -Если записываемая переменная является объектом, содержащим числовой тип, `FilePut` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePut` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(`3`)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.      -Если записываемая переменная является объектом, содержащим строку, `FilePut` записывает двухбайтовый дескриптор `VarType(`8`)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.      -Если записываемая переменная является массивом, имеется выбор записывать дескриптор с указанием размера и размерности массива или нет. Visual Basic 6.0 и более ранних версиях записывает дескриптор файла для динамического массива, но не для массива фиксированного размера. Visual Basic 2005 по умолчанию дескриптор не записывается. Чтобы записать дескриптора, задайте `ArrayIsDynamic` параметр `True`. При записи массива, вы должны соответствовать способу, который будет считываться массива; Если массив будет читаться с дескриптором, необходимо написать дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions). Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Например, следующее объявление массива требуется 218 байтов при записи на диск.           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_1.vb) ] — в случае любого другого типа (не является строкой переменной длины или объект), записываемая переменная `FilePut` записывает только данные переменной. Длина записи, указанная по `RecordLength` предложения в `FileOpen` функция должна быть больше или равна длине записываемых данных.      - `FilePut` записывает элементы структуры, как если бы каждый были по отдельности, тем исключением, что между элементами не пишутся. `VBFixedString` Атрибут может применяться к строковым полям в структурах, чтобы указать размер строки при записи на диск.          Настроек [!NOTE] настроек строка полей, имеющих большее число байтов, чем указано в параметре `VBFixedString` атрибут усекаются при записи на диск, ## открыть двоичный режим для файлов в `Binary` режиме, большую часть `Random` применяются правила режиме, за некоторыми исключениями. Следующие правила для файлов, открытых в `Binary` режиме отличаются от правил для `Random` режим: - `RecordLength` предложения в `FileOpen` функция не имеет эффекта. `FilePut`Записывает все переменные на диск последовательно, то есть без заполнения между записями.      -Для любого массива, кроме массива в структуре `FilePut` записывает только данные. Дескриптор не записывается.      - `FilePut` записывает строки переменной длины, которые не являются частью структуры дескриптор длиной&2; байта. Число записанных байтов равно количеству знаков в строке. Например, следующие инструкции записывают 11 байтов в файл номер 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_2.vb) ] - записи в файл с помощью `FilePut` функция требует `Write` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Array
      description: "Обязательный параметр. Допустимое имя переменной, которая содержит данные, записанные на диск."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается запись."
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "Необязательный параметр. Применяется только при записи массива. Указывает ли массив следует рассматривать как динамический и следует ли записывать дескриптор массива для строки, определяющий ее длину."
    - id: StringIsFixedLength
      type: System.Boolean
      description: "Необязательный параметр. Применяется только при записи строки. Указывает, следует ли записывать дескриптор длиной в&2; байта строки для строки в файл. Значение по умолчанию — <xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 и не равно -1."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  id: FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные из переменной в файл на диске.  <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FilePutObject&quot; name=&quot;FilePutObject&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`FilePutObject` Функция используется вместо `FilePut` во избежание неоднозначности во время компиляции, если тип `Object` вместо передается другого типа, таких как `Integer`, `Long`, `Short`, и т. д.       `FilePutObject`Записывает и читает дескрипторы, которые описывают объект. Если требуется записать `Variant` типа `FilePutObject` является обязательным. Если вы сомневаетесь, при использовании объекта для второго параметра, рекомендуется всегда использовать `FilePutObject` и `FileGetObject`.       `FilePutObject`допустимо только в `Random` и `Binary` режим.       Данные, записанные с `FilePutObject` обычно считываются из файла с помощью `FileGetObject`.       Первая запись или байт в файле находится в позиции 1, вторая запись или байт в позиции 2 и т. д. Если не указан `RecordNumber`, `FilePutObject` записывает Далее запись или байт после последнего `FileGetObject` или `FilePutObject` функции (или запись или байт, на который указывает последний `Seek` функции).       `StringIsFixedLength` Аргумент управляет ли функция интерпретировать строку как фиксированной или переменной длины. `FilePutObject`не записывает дескриптор длины, если аргумент является `True`. Если вы используете `StringIsFixedLength`  =  `True` с `FilePutObject`, вы должны делать то же самое с `FileGetObject`, и Кроме того, необходимо убедиться, что строка инициализируется до длины ожидаемого.      ## Случайные файлы режим для открытия в `Random` режиме, применяются следующие правила: - Если длина записываемых данных меньше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции `FilePutObject` последующих записей границы. Расстояние между концом одной записи и началом следующей записи заполняется существующим содержимым буфера файла. Поскольку объем данных заполнения не может точно определить, рекомендуется обычно длина записи соответствует длине записываемых данных. Если длина записываемых данных больше, чем длина, указанная в `RecordLength` предложения `FileOpen` функции, вызывается исключение.      -Если записываемая переменная является объектом, содержащим числовой тип, `FilePutObject` записывает два байта, идентифицирующие `VarType` объекта и затем записывает переменную. Например, при записи объекта, содержащий целое число, `FilePutObject` записывает шесть байтов: два байта, идентифицирующие объект как `VarType(`3`)` (`Integer`) и четыре байта, содержащие данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере на два байта больше, чем фактическое число байтов, необходимое для хранения переменной.      -Если записываемая переменная является объектом, содержащим строку, `FilePutObject` записывает двухбайтовый дескриптор `VarType(`8`)` объекта, двухбайтовый дескриптор, указывающий длину строки, а затем сами данные. Длина записи, указанная по `RecordLength` параметр в `FileOpen` функция должна быть по крайней мере четыре байта больше, чем фактическая длина строки. Если вы хотите записать строку без дескриптора, следует передать `True` для `StringIsFixedLength` параметр и считываются должна быть правильной длины строки.      -Если записываемая переменная является массивом, то длина записи, указанная с `RecordLength` предложения в `FileOpen` функция должна быть больше или равно количеству байтов, необходимых для записи данных массива и его дескриптора. Дескриптор указывает ранг массива, размер и нижнюю границу для каждого ранга. Его длина равна 2 плюс 8 раз размерность: (2 + 8 * NumberOfDimensions).      ## Двоичные файлы режим для открытия в `Binary` режиме, все `Random` применяются правила режиме, за исключением: - `RecordLength` предложения в `FileOpen` функция не имеет эффекта. `FilePutObject`Записывает все переменные на диск последовательно, то есть без заполнения между записями."
  example:
  - "This example uses the `FilePutObject` function to write a string to a file.  \n  \n [!code-vb[VbVbalrCatRef#54](~/add/codesnippet/visualbasic/69f8d8bb-169c-4dec-b805-_1.vb)]"
  syntax:
    content: public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Object
      description: "Обязательный параметр. Допустимое имя переменной, которая содержит данные, записанные на диск."
    - id: RecordNumber
      type: System.Int64
      description: "Необязательный параметр. Номер записи (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref> файлы режиме) или номер байта (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режиме файлы) с которого начинается запись."
  overload: Microsoft.VisualBasic.FileSystem.FilePutObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  id: FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Присваивает ширину строки вывода в файл, открытый с помощью <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> функции."
  remarks: ''
  example:
  - "This example uses the `FileWidth` function to set the output line width for a file.  \n  \n [!code-vb[VbVbalrCatRef#10](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._187_1.vb)]"
  syntax:
    content: public static void FileWidth (int FileNumber, int RecordWidth);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: RecordWidth
      type: System.Int32
      description: "Обязательный параметр. Числовое выражение в диапазоне от 0 до 255 включительно, которое указывает, сколько знаков появится в строке перед началом новой строки. Если `RecordWidth` равен 0, то длина строки не ограничена. Значение по умолчанию для `RecordWidth` равно 0."
  overload: Microsoft.VisualBasic.FileSystem.FileWidth*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  id: FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Возвращает <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> значение, представляющее следующий номер файла, доступный для использования <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> функции."
  remarks: "Используйте `FreeFile` для номера файла, который уже не используется."
  example:
  - "This example uses the `FreeFile` function to return the next available file number. Five files are opened for output within the loop, and some sample data is written to each.  \n  \n [!code-vb[VbVbalrCatRef#55](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._104_1.vb)]"
  syntax:
    content: public static int FreeFile ();
    parameters: []
    return:
      type: System.Int32
      description: "Возвращает <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> значение, представляющее следующий номер файла, доступный для использования <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> функции."
  overload: Microsoft.VisualBasic.FileSystem.FreeFile*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Более 255 файлы используются."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  id: GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Возвращает <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref> значение, представляющее атрибуты файла, каталога или папки. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Чтобы определить, какие атрибуты установлены, используйте `And` оператор для выполнения побитового сравнения значения, возвращенного `GetAttr` функцией и значения атрибута файла необходимо. Если результат не равен нулю, этот атрибут имеет значение для указанного файла. Например, возвращаемое значение из следующих `And` выражение является нуль, если `Archive` не задан атрибут: ```vb#   Result = GetAttr(FName) And vbArchive   ``` возвращается ненулевое значение, если `Archive` установлен атрибут."
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._13_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>выражение, определяющее имя файла, каталога или папки. `PathName`может включать каталог или папку и имя диска."
    return:
      type: Microsoft.VisualBasic.FileAttribute
      description: "Значение, возвращаемое <xref uid=&quot;langword_csharp_GetAttr&quot; name=&quot;GetAttr&quot; href=&quot;&quot;> </xref> складывается из следующих значений перечисления:       <table><tbody><tr><td> Значение       </td><td> Постоянное описание       </td></tr><tr><td><xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbNormal&quot; name=&quot;vbNormal&quot; href=&quot;&quot;></xref>Normal.       </td></tr><tr><td><xref uid=&quot;langword_csharp_ReadOnly&quot; name=&quot;ReadOnly&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbReadOnly&quot; name=&quot;vbReadOnly&quot; href=&quot;&quot;></xref>Только для чтения.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Hidden&quot; name=&quot;Hidden&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbHidden&quot; name=&quot;vbHidden&quot; href=&quot;&quot;></xref>Скрытый.       </td></tr><tr><td><xref uid=&quot;langword_csharp_System&quot; name=&quot;System&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbSystem&quot; name=&quot;vbSystem&quot; href=&quot;&quot;></xref>Системный файл.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Directory&quot; name=&quot;Directory&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbDirectory&quot; name=&quot;vbDirectory&quot; href=&quot;&quot;></xref>Каталог или папку.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Archive&quot; name=&quot;Archive&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbArchive&quot; name=&quot;vbArchive&quot; href=&quot;&quot;></xref>Файл был изменен с момента последнего резервного копирования.       </td></tr><tr><td><xref uid=&quot;langword_csharp_Alias&quot; name=&quot;Alias&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbAlias&quot; name=&quot;vbAlias&quot; href=&quot;&quot;></xref>Файл имеет другое имя.       </td></tr></tbody></table><div class=&quot;alert NOTE&quot;>    Эти перечисления указаны в языке Visual Basic. Имена можно использовать в любом месте в коде вместо фактических значений.      </div>"
  overload: Microsoft.VisualBasic.FileSystem.GetAttr*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>Pathname</code>является недопустимым или содержит подстановочные знаки."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Конечный файл не существует."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  id: Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого последовательного файла и присваивает переменным данные."
  remarks: "`Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.      Настроек [!IMPORTANT] настроек при чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.       При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.      |||   |-|-|   | Данных | Значение, присвоенное переменной |   | Разделяющая запятая или пустая строка | Пустой |   | NULL #| `DBNull`|   | TRUE # или FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Значение даты и времени, представленного выражением |   |#ERROR `errornumber` #| `errornumber` (переменная является объектом, помеченным как ошибка) |       Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.      Настроек [!NOTE] настроек `Input` функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.      Настроек [!IMPORTANT] настроек чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._237_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref bool Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Boolean
      description: "Обязательный параметр. Переменная, которой присваиваются значения, считываемые из файла, не может быть переменной массива или объекта."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  id: Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого последовательного файла и присваивает переменным данные."
  remarks: "`Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.      Настроек [!IMPORTANT] настроек при чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.       При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.      |||   |-|-|   | Данных | Значение, присвоенное переменной |   | Разделяющая запятая или пустая строка | Пустой |   | NULL #| `DBNull`|   | TRUE # или FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Значение даты и времени, представленного выражением |   |#ERROR `errornumber` #| `errornumber` (переменная является объектом, помеченным как ошибка) |       Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.      Настроек [!NOTE] настроек `Input` функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.      Настроек [!IMPORTANT] настроек чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._73_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref byte Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Byte
      description: "Обязательный параметр. Переменная, которой присваиваются значения, считываемые из файла, не может быть переменной массива или объекта."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  id: Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого последовательного файла и присваивает переменным данные."
  remarks: "`Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.      Настроек [!IMPORTANT] настроек при чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.       При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.      |||   |-|-|   | Данных | Значение, присвоенное переменной |   | Разделяющая запятая или пустая строка | Пустой |   | NULL #| `DBNull`|   | TRUE # или FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Значение даты и времени, представленного выражением |   |#ERROR `errornumber` #| `errornumber` (переменная является объектом, помеченным как ошибка) |       Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.      Настроек [!NOTE] настроек `Input` функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.      Настроек [!IMPORTANT] настроек чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._91_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref char Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Char
      description: "Обязательный параметр. Переменная, которой присваиваются значения, считываемые из файла, не может быть переменной массива или объекта."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  id: Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого последовательного файла и присваивает переменным данные."
  remarks: "`Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.      Настроек [!IMPORTANT] настроек при чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.       При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.      |||   |-|-|   | Данных | Значение, присвоенное переменной |   | Разделяющая запятая или пустая строка | Пустой |   | NULL #| `DBNull`|   | TRUE # или FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Значение даты и времени, представленного выражением |   |#ERROR `errornumber` #| `errornumber` (переменная является объектом, помеченным как ошибка) |       Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.      Настроек [!NOTE] настроек `Input` функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.      Настроек [!IMPORTANT] настроек чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._169_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref DateTime Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.DateTime
      description: "Обязательный параметр. Переменная, которой присваиваются значения, считываемые из файла, не может быть переменной массива или объекта."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  id: Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого последовательного файла и присваивает переменным данные."
  remarks: "`Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.      Настроек [!IMPORTANT] настроек при чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.       При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.      |||   |-|-|   | Данных | Значение, присвоенное переменной |   | Разделяющая запятая или пустая строка | Пустой |   | NULL #| `DBNull`|   | TRUE # или FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Значение даты и времени, представленного выражением |   |#ERROR `errornumber` #| `errornumber` (переменная является объектом, помеченным как ошибка) |       Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.      Настроек [!NOTE] настроек `Input` функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.      Настроек [!IMPORTANT] настроек чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._46_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref decimal Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Decimal
      description: "Обязательный параметр. Переменная, которой присваиваются значения, считываемые из файла, не может быть переменной массива или объекта."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  id: Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого последовательного файла и присваивает переменным данные."
  remarks: "`Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.      Настроек [!IMPORTANT] настроек при чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.       При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.      |||   |-|-|   | Данных | Значение, присвоенное переменной |   | Разделяющая запятая или пустая строка | Пустой |   | NULL #| `DBNull`|   | TRUE # или FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Значение даты и времени, представленного выражением |   |#ERROR `errornumber` #| `errornumber` (переменная является объектом, помеченным как ошибка) |       Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.      Настроек [!NOTE] настроек `Input` функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.      Настроек [!IMPORTANT] настроек чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._204_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref double Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Double
      description: "Обязательный параметр. Переменная, которой присваиваются значения, считываемые из файла, не может быть переменной массива или объекта."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  id: Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого последовательного файла и присваивает переменным данные."
  remarks: "`Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.      Настроек [!IMPORTANT] настроек при чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.       При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.      |||   |-|-|   | Данных | Значение, присвоенное переменной |   | Разделяющая запятая или пустая строка | Пустой |   | NULL #| `DBNull`|   | TRUE # или FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Значение даты и времени, представленного выражением |   |#ERROR `errornumber` #| `errornumber` (переменная является объектом, помеченным как ошибка) |       Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.      Настроек [!NOTE] настроек `Input` функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.      Настроек [!IMPORTANT] настроек чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._81_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref short Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Int16
      description: "Обязательный параметр. Переменная, которой присваиваются значения, считываемые из файла, не может быть переменной массива или объекта."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  id: Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого последовательного файла и присваивает переменным данные."
  remarks: "`Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.      Настроек [!IMPORTANT] настроек при чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.       При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.      |||   |-|-|   | Данных | Значение, присвоенное переменной |   | Разделяющая запятая или пустая строка | Пустой |   | NULL #| `DBNull`|   | TRUE # или FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Значение даты и времени, представленного выражением |   |#ERROR `errornumber` #| `errornumber` (переменная является объектом, помеченным как ошибка) |       Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.      Настроек [!NOTE] настроек `Input` функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.      Настроек [!IMPORTANT] настроек чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._207_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref int Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Int32
      description: "Обязательный параметр. Переменная, которой присваиваются значения, считываемые из файла, не может быть переменной массива или объекта."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  id: Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого последовательного файла и присваивает переменным данные."
  remarks: "`Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.      Настроек [!IMPORTANT] настроек при чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.       При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.      |||   |-|-|   | Данных | Значение, присвоенное переменной |   | Разделяющая запятая или пустая строка | Пустой |   | NULL #| `DBNull`|   | TRUE # или FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Значение даты и времени, представленного выражением |   |#ERROR `errornumber` #| `errornumber` (переменная является объектом, помеченным как ошибка) |       Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.      Настроек [!NOTE] настроек `Input` функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.      Настроек [!IMPORTANT] настроек чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._31_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref long Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Int64
      description: "Обязательный параметр. Переменная, которой присваиваются значения, считываемые из файла, не может быть переменной массива или объекта."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  id: Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого последовательного файла и присваивает переменным данные."
  remarks: "`Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.      Настроек [!IMPORTANT] настроек при чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.       При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.      |||   |-|-|   | Данных | Значение, присвоенное переменной |   | Разделяющая запятая или пустая строка | Пустой |   | NULL #| `DBNull`|   | TRUE # или FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Значение даты и времени, представленного выражением |   |#ERROR `errornumber` #| `errornumber` (переменная является объектом, помеченным как ошибка) |       Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.      Настроек [!NOTE] настроек `Input` функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.      Настроек [!IMPORTANT] настроек чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._244_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref object Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Object
      description: "Обязательный параметр. Переменная, которой присваиваются значения, считываемые из файла, не может быть переменной массива или объекта."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  id: Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого последовательного файла и присваивает переменным данные."
  remarks: "`Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.      Настроек [!IMPORTANT] настроек при чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.       При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.      |||   |-|-|   | Данных | Значение, присвоенное переменной |   | Разделяющая запятая или пустая строка | Пустой |   | NULL #| `DBNull`|   | TRUE # или FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Значение даты и времени, представленного выражением |   |#ERROR `errornumber` #| `errornumber` (переменная является объектом, помеченным как ошибка) |       Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.      Настроек [!NOTE] настроек `Input` функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.      Настроек [!IMPORTANT] настроек чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._115_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref float Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.Single
      description: "Обязательный параметр. Переменная, которой присваиваются значения, считываемые из файла, не может быть переменной массива или объекта."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  id: Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает данные из открытого последовательного файла и присваивает переменным данные."
  remarks: "`Input` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Данные, считанные с `Input` обычно записываются в файл с помощью `Write`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.      Настроек [!IMPORTANT] настроек при чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic 2005.       При считывании стандартную строку или числовые данные присваиваются переменным без изменений. В следующей таблице показано, каким образом обрабатываются другие входные данные.      |||   |-|-|   | Данных | Значение, присвоенное переменной |   | Разделяющая запятая или пустая строка | Пустой |   | NULL #| `DBNull`|   | TRUE # или FALSE #| `True` or `False`|   |#`yyyy-mm-dd hh:mm:ss`#| Значение даты и времени, представленного выражением |   |#ERROR `errornumber` #| `errornumber` (переменная является объектом, помеченным как ошибка) |       Если при вводе элемента данных достигнут конец файла, ввод прекращается и происходит ошибка.      Настроек [!NOTE] настроек `Input` функция не локализовано. Например в немецкой версии, если записано 3,14159, возвращается только 3, поскольку запятая рассматривается как разделитель переменных вместо как десятичный разделитель.      Настроек [!IMPORTANT] настроек чтение из файла с помощью `Input` функция требует `Read` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._140_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref string Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Value
      type: System.String
      description: "Обязательный параметр. Переменная, которой присваиваются значения, считываемые из файла, не может быть переменной массива или объекта."
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  id: InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Возвращает <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> значение, содержащее знаки из файла, открытого в <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режим. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`InputString` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Данные, считанные с `InputString` функции обычно записываются в файл с помощью `Print` или `FilePut`. Эту функцию можно использовать только в файлах, открытых в `Input` или `Binary` режиме.       В отличие от `Input` функции `InputString` функция возвращает все символы, он считывает. Сюда входят запятые, символы возврата каретки, перевода строки, кавычки и начальные пробелы.       В файлах, открытых для `Binary` доступа, попытка прочитать файл с помощью `InputString` функции до `EOF` возвращает `True` приводит к ошибке. Используйте `LOF` и `Loc` функции вместо `EOF` при чтении двоичных файлов с помощью `InputString`, или используйте `FileGet` при использовании `EOF` функции.      Настроек [!NOTE] настроек при чтении из файла не принятия решений по безопасности о содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic."
  example:
  - "This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#33](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._220_1.vb)]"
  syntax:
    content: public static string InputString (int FileNumber, int CharCount);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: CharCount
      type: System.Int32
      description: "Обязательный параметр. Любое допустимое числовое выражение, указывающее число считываемых символов."
    return:
      type: System.String
      description: "Возвращает <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> значение, содержащее знаки из файла, открытого в <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref> режим. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.InputString*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>не существует."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>CharCount</code>&lt; 0 or &gt; 214."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  id: Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Удаляет файлы с диска. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_Kill&quot; name=&quot;Kill&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> ."
  remarks: "`Kill`поддерживает использование нескольких знаков (`*`) и одного знака (`?`) можно указать несколько файлов.       **Примечание по безопасности** для выполнения, `Kill` функция требует `Read` и `PathDiscovery` флаги из <xref:System.Security.Permissions.FileIOPermission>должны быть предоставлены в исполняемый код.</xref:System.Security.Permissions.FileIOPermission> Дополнительные сведения см. в разделе <xref:System.Security.SecurityException> [разрешений доступа к коду](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</xref:System.Security.SecurityException>"
  example:
  - "This example uses the `Kill` function to delete a file from a disk.  \n  \n [!code-vb[VbVbalrCatRef#60](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._250_1.vb)]"
  syntax:
    content: public static void Kill (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>выражение, задающее один или несколько файлов, которые должны быть удалены. `PathName`может включать каталог или папку и имя диска."
  overload: Microsoft.VisualBasic.FileSystem.Kill*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Удаляемые файлы открыты."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Удаляемые файлы не найдены."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Запрещено разрешение."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  id: LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Считывает одну строку из открытого последовательного файла и присваивает его <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> переменной."
  remarks: "`LineInput` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Данные, считанные с `LineInput` обычно записываются в файл с помощью `Print`.      Настроек [!IMPORTANT] настроек при чтении из файла нельзя судить о его содержимом по расширению имени файла. Например файл с именем Form1.vb не может быть исходным файлом Visual Basic.       `LineInput` Функция считывает строку символов, один файл во время, пока встретится символ возврата каретки (`Chr(`13`)`) или каретки и перевода строки веб-канала (`Chr(`13`)` + `Chr(`10`)`) последовательности. Веб-канала последовательностей каретки и перевода строки, добавляются в строку символов, вместо пропускаются.      Настроек [!IMPORTANT] настроек чтение из файла с помощью `LineInput` функция требует `Read` доступ из <xref:System.Security.Permissions.FileIOPermissionAccess>перечисления.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable. This example assumes that `TestFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#19](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._158_1.vb)]"
  syntax:
    content: public static string LineInput (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    return:
      type: System.String
      description: "Считывает одну строку из открытого последовательного файла и присваивает его <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref> переменной."
  overload: Microsoft.VisualBasic.FileSystem.LineInput*
  exceptions:
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "Достигнут конец файла."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>не существует."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  id: Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Возвращает <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> значение, указывающее текущую позицию чтения или записи в файл."
  remarks: "`Loc` Функции (с нуля); его использование для получения первого байта в файле возвратит 0.       `Loc` Функция предоставляется для обеспечения обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Ниже описаны возвращаемое значение для каждого режима доступа к файлу: ^ ^ ^   |-|-|   | Режим | Возвращаемое значение |   | `Random`| Номер последней записи, считывается или записывается в файл. |   | `Sequential`| Текущая позиция байта в файле, деленная на 128. Тем не менее, возвращаются сведения по `Loc` для последовательных файлов не используется и не требуется. |   | `Binary`| Позиция байта последнего чтения или записи. |"
  example:
  - "This example uses the `Loc` function to return the current read/write position in an open file. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#17](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._178_1.vb)]"
  syntax:
    content: public static long Loc (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любое допустимое <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> номер файла."
    return:
      type: System.Int64
      description: "Возвращает <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> значение, указывающее текущую позицию чтения или записи в файл."
  overload: Microsoft.VisualBasic.FileSystem.Loc*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  id: Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Управляет доступом других процессов ко всей или части файла, открытого с помощью <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> функции. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> и <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Lock` И `Unlock` функции используются в средах, где нескольким процессам может понадобиться доступ к тому же файлу.       `Lock`и `Unlock` функции всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.       Если `Record`, или `FromRecord` и `ToRecord` , не указан, блокировка будет использован для всего файла. Если `Record` отдельно указано будет заблокирована разблокирована.       Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` распространяется на весь файл, независимо от того, диапазон, заданный `FromRecord` и`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._243_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  id: Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Управляет доступом других процессов ко всей или части файла, открытого с помощью <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> функции. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> и <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Lock` И `Unlock` функции используются в средах, где нескольким процессам может понадобиться доступ к тому же файлу.       `Lock`и `Unlock` функции всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.       Если `Record`, или `FromRecord` и `ToRecord` , не указан, блокировка будет использован для всего файла. Если `Record` отдельно указано будет заблокирована разблокирована.       Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` распространяется на весь файл, независимо от того, диапазон, заданный `FromRecord` и`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._38_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Record
      type: System.Int64
      description: "Необязательный параметр. Номер записи или байта для блокировки или разблокировки"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  id: Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Управляет доступом других процессов ко всей или части файла, открытого с помощью <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> функции. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> и <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Lock` И `Unlock` функции используются в средах, где нескольким процессам может понадобиться доступ к тому же файлу.       `Lock`и `Unlock` функции всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.       Если `Record`, или `FromRecord` и `ToRecord` , не указан, блокировка будет использован для всего файла. Если `Record` отдельно указано будет заблокирована разблокирована.       Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` распространяется на весь файл, независимо от того, диапазон, заданный `FromRecord` и`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._116_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: FromRecord
      type: System.Int64
      description: "Необязательный параметр. Номер первой записи или байта для блокировки или разблокировки."
    - id: ToRecord
      type: System.Int64
      description: "Необязательный параметр. Номер последней записи или байта для блокировки или разблокировки."
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  id: LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Возвращает <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> , представляющее размер в байтах, файл открывается с помощью <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> функции. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Используйте `FileLen` функции для получения длины файла, который не был открыт."
  example:
  - "This example uses the `LOF` function to determine the size of an open file. This example assumes that `TestFile` is a text file that contains sample data.  \n  \n [!code-vb[VbVbalrCatRef#23](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._83_1.vb)]"
  syntax:
    content: public static long LOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> , Содержащее допустимый номер файла."
    return:
      type: System.Int64
      description: "Возвращает <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> , представляющее размер в байтах, файл открывается с помощью <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> функции. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>."
  overload: Microsoft.VisualBasic.FileSystem.LOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  id: MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Создает новый каталог. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>"
  remarks: "Эта функция создает новый каталог."
  example:
  - "This example uses the `MkDir` function to create a directory. If the drive is not specified, the new directory is created on the current drive.  \n  \n [!code-vb[VbVbalrCatRef#38](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._246_1.vb)]"
  syntax:
    content: public static void MkDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>выражение, определяющее каталог должен быть создан. `Path` Может содержать диск. Если диск не указан, <xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref> создает новый каталог на текущем диске."
  overload: Microsoft.VisualBasic.FileSystem.MkDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>не указан или пуст."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Запрещено разрешение."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Каталог уже существует."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  id: Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает формат отображения данных в последовательный файл."
  remarks: "`Print` И `PrintLine` функции предоставляются для обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`не включает символ перевода строки в конце строки; Однако `PrintLine` содержит символ перевода строки.       Данные, записанные с `Print` обычно считываются из файла с помощью `LineInput` или `Input`.       Если не указан `Output` для `PrintLine`, выводит пустую строку в файл; для `Print`, ничего не будет записано. Несколько выражений, разделенных запятыми, будут выровнены по границам табуляции, но смешивание запятых и `TAB` может привести к непредсказуемым результатам.       Для `Boolean` данных, либо `True` или `False` выводится на печать. `True` И `False` ключевые слова не преобразуются, независимо от языкового стандарта.       Дата данные записываются в файл с помощью стандартных короткого формата даты формата, распознаваемого системой. Когда дата или время отсутствует или ноль, только часть предоставляемых записывается в файл.       Ничего не записывается в файл, если `Output` данных пуст. Однако если `Output` данные списка `DBNull`, `Null` записывается в файл.       Для `Error` данные, выходные данные отображаются в виде `Error errorcode`. `Error` Ключевое слово не переводится независимо от языкового стандарта.       Все данные, записанные в файл с помощью `Print` международный стандартам; т. е. данные правильно отформатированы с использованием соответствующего десятичного разделителя. Если пользователь хочет вывести данные для использования в нескольких языковых стандартов `Write` следует использовать.       Запись в файл с помощью `Print` или `PrintLine` функции требует `Write` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._146_1.vb)]"
  syntax:
    content: public static void Print (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Output
      type: System.Object[]
      description: "Необязательный параметр. Ноль или более с разделителями запятыми выражений для записи в файл.       `Output` Аргумент принимать следующие значения: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: недопустимый режим файла.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` не существует."
  overload: Microsoft.VisualBasic.FileSystem.Print*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  id: PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает формат отображения данных в последовательный файл."
  remarks: "`Print` И `PrintLine` функции предоставляются для обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       `Print`не включает символ перевода строки в конце строки; Однако`PrintLine` содержит символ перевода строки.       Данные, записанные с `Print` обычно считываются из файла с помощью `LineInput` или `Input`.       Если не указан `Output` для `PrintLine`, выводит пустую строку в файл; для `Print`, ничего не будет записано. Несколько выражений, разделенных запятыми, будут выровнены по границам табуляции, но смешивание запятых и `TAB` может привести к непредсказуемым результатам.       Для `Boolean` данных, либо `True` или `False` выводится на печать. `True` И `False` ключевые слова не преобразуются, независимо от языкового стандарта.       Даты данные записываются в файл с помощью стандартных короткого формата даты формата, распознаваемого системой. Когда дата или время отсутствует или ноль, только часть предоставляемых записывается в файл.       Ничего не записывается в файл, если `Output` данных пуст. Однако если `Output` данные списка `DBNull`, `Null` записывается в файл.       Для `Error` данные, выходные данные отображаются в виде `Error errorcode`. `Error` Ключевое слово не переводится независимо от языкового стандарта.       Все данные, записанные в файл с помощью `Print` международный стандартам; т. е. данные правильно отформатированы с использованием соответствующего десятичного разделителя. Если пользователь хочет вывести данные для использования в нескольких языковых стандартов `Write` следует использовать.       Запись в файл с помощью `Print` или `PrintLine` функции требует `Write` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._245_1.vb)]"
  syntax:
    content: public static void PrintLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Output
      type: System.Object[]
      description: "Необязательный параметр. Ноль или более с разделителями запятыми выражений для записи в файл.       `Output` Аргумент принимать следующие значения: <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>: недопустимый режим файла.       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>: `FileNumber` не существует."
  overload: Microsoft.VisualBasic.FileSystem.PrintLine*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  id: Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Переименовывает дисковый файл или каталог. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_Rename&quot; name=&quot;Rename&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Rename` Функция переименовывает файл и при необходимости перемещает его в другой каталог. `Rename` Функции можно переместить файл на дисках, но его можно только переименовать существующий каталог, когда оба `NewPath` и `OldPath` находятся на том же диске. `Rename`не удается создать новый файл или каталог.       С помощью `Rename` функции к открытому файлу приводит к ошибке. Необходимо закрыть открытый файл перед его переименованием. `Rename`аргументы не могут содержать нескольких знаков (*) и одного знака (?) подстановочные знаки.      Настроек [!IMPORTANT] настроек при использовании `Rename` для копирования файла из незащищенного расположения в защищенном месте, в файле сохраняются менее ограниченные права. Проверьте, что не представляете возможную угрозу безопасности."
  example:
  - "This example uses the `Rename` function to rename a file. For purposes of this example, assume that the directories that are specified already exist.  \n  \n [!code-vb[VbVbalrCatRef#30](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._97_1.vb)]"
  syntax:
    content: public static void Rename (string OldPath, string NewPath);
    parameters:
    - id: OldPath
      type: System.String
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>выражение, указывающее имя существующего файла и расположение. `OldPath`может содержать имя каталога и диска, где находится файл."
    - id: NewPath
      type: System.String
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>выражение, указывающее новое имя файла и расположение. `NewPath`может содержать каталог и диск конечного расположения. Имя файла, заданное `NewPath` не может уже существовать."
  overload: Microsoft.VisualBasic.FileSystem.Rename*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Указан недопустимый путь."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>OldPath</code>файл не существует."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Не удается переименовать другое устройство."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Reset
  id: Reset
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Закрывает все файлы, открытые с помощью на диске <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> функции. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_Reset&quot; name=&quot;Reset&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Reset` Функция закрывает все активные файлы, открытые `FileOpen` функцией и имеет ту же функцию, что `FileClose()` без параметров."
  example:
  - "This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk. Note the use of the `Object` variable `FileNumber` as both a string and a number.  \n  \n [!code-vb[VbVbalrCatRef#12](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._117_1.vb)]"
  syntax:
    content: public static void Reset ();
    parameters: []
  overload: Microsoft.VisualBasic.FileSystem.Reset*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  id: RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Удаляет существующий каталог. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>"
  remarks: "Произошла ошибка при попытке использовать `RmDir` на каталог, содержащий файлы. Используйте `Kill` функции, чтобы удалить все файлы, прежде чем пытаться удалить каталог."
  example:
  - "This example uses the `RmDir` function to remove an existing directory.  \n  \n [!code-vb[VbVbalrCatRef#31](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._20_1.vb)]"
  syntax:
    content: public static void RmDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>выражение, определяющее каталог или папку. `Path`может содержать диск. Если диск не указан, <xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref> удаляет каталог на текущем диске."
  overload: Microsoft.VisualBasic.FileSystem.RmDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>не указан или пуст."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Целевой каталог содержит файлы."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "Каталог не существует."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  id: Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Возвращает <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> указывающее текущую позицию чтения и записи в файл открыт с помощью <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> функции или задает позицию для следующей операции чтения и записи в файл открыт с помощью <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> функции. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`Возвращает значение от 1 до 2 147 483 647 (эквивалентно 2 ^ 31 – 1) включительно.       Ниже описаны возвращаемые значения для каждого режима доступа к файлу: ^ ^ ^   |-|-|   | Режим | Возвращаемое значение |   | `Random`| Номер следующей записи, чтения или записи |   | `Binary`, `Input`, `Output`, `Append`| Позиция байта, с которой происходит следующей операции. Первый байт в файле находится в позиции 1, второй байт в позиции 2 и т. д. |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_4.vb)]"
  syntax:
    content: public static long Seek (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> , Содержащее допустимый номер файла."
    return:
      type: System.Int64
      description: "Возвращает <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> указывающее текущую позицию чтения и записи в файл открыт с помощью <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> функции или задает позицию для следующей операции чтения и записи в файл открыт с помощью <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> функции."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  id: Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Возвращает <xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;> </xref> указывающее текущую позицию чтения и записи в файл открыт с помощью <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> функции или задает позицию для следующей операции чтения и записи в файл открыт с помощью <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref> функции. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Seek`Возвращает значение от 1 до 2 147 483 647 (эквивалентно 2 ^ 31 – 1) включительно.       Ниже описаны возвращаемые значения для каждого режима доступа к файлу: ^ ^ ^   |-|-|   | Режим | Возвращаемое значение |   | `Random`| Номер следующей записи, чтения или записи |   | `Binary`, `Input`, `Output`, `Append`| Позиция байта, с которой происходит следующей операции. Первый байт в файле находится в позиции 1, второй байт в позиции 2 и т. д. |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_4.vb)]"
  syntax:
    content: public static void Seek (int FileNumber, long Position);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> , Содержащее допустимый номер файла."
    - id: Position
      type: System.Int64
      description: "Обязательный параметр. Число в диапазоне 1 – 2 147 483 647 включительно, определяющее место следующей операции ввода-вывода будет выполняться."
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  id: SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Устанавливает атрибуты для файла. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_SetAttr&quot; name=&quot;SetAttr&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "Ошибка во время выполнения происходит при попытке установить атрибуты для открытого файла.       `Attributes` Используются значения перечисления аргументов: ^ ^ ^   |-|-|-|   | Значение | Константа | Описание |   | `Normal`|`vbNormal`| Обычный (по умолчанию). |   | `ReadOnly`|`vbReadOnly`| Только для чтения. |   | `Hidden`|`vbHidden`| Скрыто. |   | `System`|`vbSystem`| Системный файл. |   | `Volume`|`vbVolume`| Метка тома |   | `Directory`|`vbDirectory`| Каталог или папку. |   | `Archive`|`vbArchive`| Файл был изменен с момента последнего резервного копирования. |   | `Alias`|`vbAlias`| Файл имеет другое имя. |      Настроек [!NOTE] настроек эти перечисления указаны в языке Visual Basic. Имена можно использовать в любом месте в коде вместо фактических значений."
  example:
  - "This example uses the `SetAttr` function to set attributes for a file.  \n  \n [!code-vb[VbVbalrCatRef#14](~/add/codesnippet/visualbasic/7c37826d-7b37-4e2d-b69a-_1.vb)]"
  syntax:
    content: public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);
    parameters:
    - id: PathName
      type: System.String
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>выражение, указывающее имя файла. `PathName`может включать каталог или папку и диск."
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "Обязательный параметр. Константа или числовое выражение, сумма которого определяет атрибуты файла."
  overload: Microsoft.VisualBasic.FileSystem.SetAttr*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Attribute</code>Недопустимый тип."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  id: SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "При использовании <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> функции, чтобы изменить расположение выходных данных."
  remarks: "Если `Count` меньше ширины строки вывода, следующая позиция печати непосредственно следует за количество напечатанных пробелов. Если`Count` больше, чем длина выводимой строки `SPC` вычисляет следующую позицию печати по формуле: `currentprintposition`(+ (`Count``Mod``width`)) например, если текущая позиция печати равна 24, ширина строки вывода равна 80, и указании `SPC(`90`)`, следующая печать начнется с позиции 34 (текущая позиция печати + остаток от 90/80). Если разница между текущей позицией печати и шириной строки вывода меньше, чем `Count` (или `Count` `Mod` *ширина*), `SPC` функция переходит на начало следующей строки и создает пробелы, равные `Count` — (*ширина* — *текущая_позиция_печати*).      Настроек [!NOTE] настроек убедитесь, что столбцы таблицы достаточно широки, чтобы вместить длинные записи."
  example:
  - "This example uses the `SPC` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#16](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._222_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.SpcInfo SPC (short Count);
    parameters:
    - id: Count
      type: System.Int16
      description: "Обязательный параметр. Число пробелов, вставляемых перед отображением или печатью следующего выражения в списке."
    return:
      type: Microsoft.VisualBasic.SpcInfo
      description: "При использовании <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> функции, чтобы изменить расположение выходных данных."
  overload: Microsoft.VisualBasic.FileSystem.SPC*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB
  id: TAB
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "При использовании <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> функции, чтобы изменить расположение выходных данных."
  remarks: "Если текущая позиция печати в текущей строке больше, чем `Column`, `TAB` пропускает равно значению столбца `Column` на следующую строку. Если `Column` меньше 1 `TAB` перемещает позицию печати в столбец 1. Если `Column` больше, чем длина выводимой строки `TAB` вычисляет следующую позицию печати с помощью формулы: Mod столбца ширина, например, если *ширина* равна 80 и задано `TAB(`90`)`, следующая печать начнется со столбца 10 (остаток от 90/80). Если `Column` меньше, чем текущая позиция печати, печать начинается со следующей строки в рассчитанной позиции печати. Если рассчитанная позиция печати больше, чем текущая позиция печати, печать начинается в рассчитанной позиции печати в той же строке.       Крайняя левая позиция печати в строке вывода всегда равно 1. При использовании `Print` или `PrintLine` функции для печати файлов, позиция равна ширине выходного файла, который можно задать с помощью `FileWidth` функции.       `TAB` Функция также может использоваться с `WriteLine` функции. Его нельзя использовать с <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>или <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      Настроек [!NOTE] настроек убедитесь, что столбцы таблицы достаточно широки, чтобы вместить длинные записи."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._165_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB ();
    parameters: []
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "При использовании <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> функции, чтобы изменить расположение выходных данных."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  id: TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "При использовании <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> функции, чтобы изменить расположение выходных данных."
  remarks: "Если текущая позиция печати в текущей строке больше, чем `Column`, `TAB` пропускает равно значению столбца `Column` на следующую строку. Если `Column` меньше 1 `TAB` перемещает позицию печати в столбец 1. Если `Column` больше, чем длина выводимой строки `TAB` вычисляет следующую позицию печати с помощью формулы: Mod столбца ширина, например, если *ширины* равна 80 и задано `TAB(`90`)`, следующая печать начнется со столбца 10 (остаток от 90/80). Если `Column` меньше, чем текущая позиция печати, печать начинается со следующей строки в рассчитанной позиции печати. Если рассчитанная позиция печати больше, чем текущая позиция печати, печать начинается в рассчитанной позиции печати в той же строке.       Крайняя левая позиция печати в строке вывода всегда равно 1. При использовании `Print` или `PrintLine` функции для печати файлов, позиция равна ширине выходного файла, который можно задать с помощью `FileWidth` функции.       `TAB` Функция также может использоваться с `WriteLine` функции. Его нельзя использовать с <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>или <xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName> </xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      Настроек [!NOTE] настроек убедитесь, что столбцы таблицы достаточно широки, чтобы вместить длинные записи."
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._125_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB (short Column);
    parameters:
    - id: Column
      type: System.Int16
      description: "Необязательный параметр. Номер столбца перемещены перед отображением или печатью следующего выражения в списке. Если не указано, <xref uid=&quot;langword_csharp_TAB&quot; name=&quot;TAB&quot; href=&quot;&quot;> </xref> Перемещение курсора в начало следующей зоны печати."
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "При использовании <xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;> </xref> или <xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;> </xref> функции, чтобы изменить расположение выходных данных."
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  id: Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Управляет доступом других процессов ко всей или части файла, открытого с помощью <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> функции. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> и <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Lock` И `Unlock` функции используются в средах, где нескольким процессам может понадобиться доступ к тому же файлу.       `Lock`и `Unlock` функции всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.       Если `Record`, или `FromRecord` и `ToRecord` , не указан, блокировка будет использован для всего файла. Если `Record` отдельно указано будет заблокирована разблокирована.       Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` распространяется на весь файл, независимо от того, диапазон, заданный `FromRecord` и`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._26_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  id: Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Управляет доступом других процессов ко всей или части файла, открытого с помощью <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> функции. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> и <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Lock` И `Unlock` функции используются в средах, где нескольким процессам может понадобиться доступ к тому же файлу.       `Lock`и `Unlock` функции всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.       Если `Record`, или `FromRecord` и `ToRecord` , не указан, блокировка будет использован для всего файла. Если `Record` отдельно указано будет заблокирована разблокирована.       Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` распространяется на весь файл, независимо от того, диапазон, заданный `FromRecord` и`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._210_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: Record
      type: System.Int64
      description: "Необязательный параметр. Номер записи или байта для блокировки или разблокировки"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  id: Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Управляет доступом других процессов ко всей или части файла, открытого с помощью <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref> функции. <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref> Возможность предоставляет более высокую производительность и быстродействие операций файлового ввода-вывода, чем <xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;> </xref> и <xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>. Дополнительные сведения см. в разделе <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>."
  remarks: "`Lock` И `Unlock` функции используются в средах, где нескольким процессам может понадобиться доступ к тому же файлу.       `Lock`и `Unlock` функции всегда используются в парах. Аргументы для `Lock` и `Unlock` должны быть одинаковыми.       Если `Record`, или `FromRecord` и `ToRecord` , не указан, блокировка будет использован для всего файла. Если `Record` отдельно указано будет заблокирована разблокирована.       Если файл открыт для последовательного ввода или вывода, `Lock` и `Unlock` распространяется на весь файл, независимо от того, диапазон, заданный `FromRecord` и`ToRecord`."
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/93b8910d-5e06-4d09-8b8b-_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. Любой допустимый номер файла."
    - id: FromRecord
      type: System.Int64
      description: "Необязательный параметр. Номер первой записи или байта для блокировки или разблокировки."
    - id: ToRecord
      type: System.Int64
      description: "Необязательный параметр. Номер последней записи или байта для блокировки или разблокировки."
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  id: Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные в последовательный файл. Данные, записанные с <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> обычно считываются из файла с помощью <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "`Write` И `WriteLine` функции предоставляются для обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Если не указан `Output`, выводит пустую строку в файл. Несколько выражений могут разделяться запятыми.       В отличие от `Print` функции `Write` функция вставляет запятые между элементами и заключается в кавычки строки, записываемые в файл. Не нужно вставлять в список явные ограничители. Когда `Write` используется для записи данных в файл только числовые `Boolean`, даты, null, и `Error` поддерживаются форматы данных. Следующие универсальные предположения а затем данные всегда могут быть прочитаны и правильно интерпретированы с помощью `Input`, независимо от языкового стандарта:-числовые данные всегда записываются с использованием точки в качестве десятичного разделителя.      — Для `Boolean` данных, либо `#TRUE#` или `#FALSE#` выводится на печать. `True` И `False` ключевые слова не преобразуются, независимо от языкового стандарта.      -Дата данные записываются в файл с помощью универсальный формат даты. Когда дата или время отсутствует или ноль, только часть предоставляемых записывается в файл.      -Ничего не записывается в файл при `Output` данных пуст. Однако для пустых данных `#NULL#` записывается.      — Для `Error` данные, выходные данные отображаются в виде `#ERROR errorcode#`. `Error` Ключевого слова не преобразуются, независимо от языкового стандарта.       `WriteLine`Вставляет символ новой строки (то есть, возврат каретки и строки веб-канал, или `Chr(13) + Chr(10)`), после записи последнего символа `Output` в файл.       Можно вставить кавычки в строке с помощью двойных кавычек, или «». Например [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_1.vb) ] возвращает строку со значением `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       Запись в файл с помощью `Write` или `WriteLine` функции требует `Append` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_2.vb)]"
  syntax:
    content: public static void Write (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> Выражение, которое содержит любой допустимый номер файла."
    - id: Output
      type: System.Object[]
      description: "Необязательный параметр. Один или несколько разделенных запятыми выражений для записи в файл."
  overload: Microsoft.VisualBasic.FileSystem.Write*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Недопустимый режим файла."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  id: WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "Записывает данные в последовательный файл. Данные, записанные с <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref> обычно считываются из файла с помощью <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>."
  remarks: "`Write` И `WriteLine` функции предоставляются для обратной совместимости и может повлиять на производительность. Для приложений, отличных от прежних версий `My.Computer.FileSystem` объекта обеспечивает более высокую производительность. Дополнительные сведения см. в разделе [доступ к файлам с помощью Visual Basic](~/add/includes/ajax-current-ext-md.md).       Если не указан `Output`, выводит пустую строку в файл. Несколько выражений могут разделяться запятыми.       В отличие от `Print` функции `Write` функция вставляет запятые между элементами и заключается в кавычки строки, записываемые в файл. Не нужно вставлять в список явные ограничители. Когда `Write` используется для записи данных в файл только числовые `Boolean`, даты, null, и `Error` поддерживаются форматы данных. Следующие универсальные предположения а затем данные всегда могут быть прочитаны и правильно интерпретированы с помощью `Input`, независимо от языкового стандарта:-числовые данные всегда записываются с использованием точки в качестве десятичного разделителя.      — Для `Boolean` данных, либо `#TRUE#` или `#FALSE#` выводится на печать. `True` И `False` ключевые слова не преобразуются, независимо от языкового стандарта.      -Дата данные записываются в файл с помощью универсальный формат даты. Когда дата или время отсутствует или ноль, только часть предоставляемых записывается в файл.      -Ничего не записывается в файл при `Output` данных пуст. Однако для пустых данных `#NULL#` записывается.      — Для `Error` данные, выходные данные отображаются в виде `#ERROR errorcode#`. `Error` Ключевого слова не преобразуются, независимо от языкового стандарта.       `WriteLine`Вставляет символ новой строки (то есть, возврат каретки и строки веб-канал, или `Chr(13) + Chr(10)`), после записи последнего символа `Output` в файл.       Можно вставить кавычки в строке с помощью двойных кавычек, или «». Например [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_1.vb) ] возвращает строку со значением `Double quotation marks aren&quot;t &quot;difficult&quot; to handle`.       Запись в файл с помощью `Write` или `WriteLine` функции требует `Append` доступ из `FileIOPermissionAccess` перечисления. Дополнительные сведения см. в разделе <xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_2.vb)]"
  syntax:
    content: public static void WriteLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "Обязательный параметр. <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref> Выражение, которое содержит любой допустимый номер файла."
    - id: Output
      type: System.Object[]
      description: "Необязательный параметр. Один или несколько разделенных запятыми выражений для записи в файл."
  overload: Microsoft.VisualBasic.FileSystem.WriteLine*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
- uid: System.Char
  parent: System
  isExternal: true
  name: Char
  nameWithType: Char
  fullName: System.Char
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
- uid: Microsoft.VisualBasic.FileSystem.Dir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileAttribute
  parent: Microsoft.VisualBasic
  isExternal: false
  name: FileAttribute
  nameWithType: FileAttribute
  fullName: Microsoft.VisualBasic.FileAttribute
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
- uid: Microsoft.VisualBasic.OpenMode
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenMode
  nameWithType: OpenMode
  fullName: Microsoft.VisualBasic.OpenMode
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
- uid: System.Int32[]
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32[]
  spec.csharp:
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
- uid: System.Decimal
  parent: System
  isExternal: true
  name: Decimal
  nameWithType: Decimal
  fullName: System.Decimal
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
- uid: System.ValueType
  parent: System
  isExternal: true
  name: ValueType
  nameWithType: ValueType
  fullName: System.ValueType
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
- uid: Microsoft.VisualBasic.OpenAccess
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenAccess
  nameWithType: OpenAccess
  fullName: Microsoft.VisualBasic.OpenAccess
- uid: Microsoft.VisualBasic.OpenShare
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenShare
  nameWithType: OpenShare
  fullName: Microsoft.VisualBasic.OpenShare
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
- uid: Microsoft.VisualBasic.FileSystem.Reset
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
- uid: Microsoft.VisualBasic.SpcInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: SpcInfo
  nameWithType: SpcInfo
  fullName: Microsoft.VisualBasic.SpcInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
- uid: Microsoft.VisualBasic.TabInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: TabInfo
  nameWithType: TabInfo
  fullName: Microsoft.VisualBasic.TabInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.ChDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir
  nameWithType: FileSystem.ChDir
- uid: Microsoft.VisualBasic.FileSystem.ChDrive*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive
  nameWithType: FileSystem.ChDrive
- uid: Microsoft.VisualBasic.FileSystem.CurDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir
  nameWithType: FileSystem.CurDir
- uid: Microsoft.VisualBasic.FileSystem.Dir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir
  nameWithType: FileSystem.Dir
- uid: Microsoft.VisualBasic.FileSystem.EOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF
  nameWithType: FileSystem.EOF
- uid: Microsoft.VisualBasic.FileSystem.FileAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr
  nameWithType: FileSystem.FileAttr
- uid: Microsoft.VisualBasic.FileSystem.FileClose*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose
  nameWithType: FileSystem.FileClose
- uid: Microsoft.VisualBasic.FileSystem.FileCopy*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy
  nameWithType: FileSystem.FileCopy
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime
  nameWithType: FileSystem.FileDateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet
  nameWithType: FileSystem.FileGet
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject
  nameWithType: FileSystem.FileGetObject
- uid: Microsoft.VisualBasic.FileSystem.FileLen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen
  nameWithType: FileSystem.FileLen
- uid: Microsoft.VisualBasic.FileSystem.FileOpen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen
  nameWithType: FileSystem.FileOpen
- uid: Microsoft.VisualBasic.FileSystem.FilePut*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut
  nameWithType: FileSystem.FilePut
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject
  nameWithType: FileSystem.FilePutObject
- uid: Microsoft.VisualBasic.FileSystem.FileWidth*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth
  nameWithType: FileSystem.FileWidth
- uid: Microsoft.VisualBasic.FileSystem.FreeFile*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile
  nameWithType: FileSystem.FreeFile
- uid: Microsoft.VisualBasic.FileSystem.GetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr
  nameWithType: FileSystem.GetAttr
- uid: Microsoft.VisualBasic.FileSystem.Input*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input
  nameWithType: FileSystem.Input
- uid: Microsoft.VisualBasic.FileSystem.InputString*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString
  nameWithType: FileSystem.InputString
- uid: Microsoft.VisualBasic.FileSystem.Kill*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill
  nameWithType: FileSystem.Kill
- uid: Microsoft.VisualBasic.FileSystem.LineInput*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput
  nameWithType: FileSystem.LineInput
- uid: Microsoft.VisualBasic.FileSystem.Loc*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc
  nameWithType: FileSystem.Loc
- uid: Microsoft.VisualBasic.FileSystem.Lock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock
  nameWithType: FileSystem.Lock
- uid: Microsoft.VisualBasic.FileSystem.LOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF
  nameWithType: FileSystem.LOF
- uid: Microsoft.VisualBasic.FileSystem.MkDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir
  nameWithType: FileSystem.MkDir
- uid: Microsoft.VisualBasic.FileSystem.Print*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print
  nameWithType: FileSystem.Print
- uid: Microsoft.VisualBasic.FileSystem.PrintLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine
  nameWithType: FileSystem.PrintLine
- uid: Microsoft.VisualBasic.FileSystem.Rename*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename
  nameWithType: FileSystem.Rename
- uid: Microsoft.VisualBasic.FileSystem.Reset*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset
  nameWithType: FileSystem.Reset
- uid: Microsoft.VisualBasic.FileSystem.RmDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir
  nameWithType: FileSystem.RmDir
- uid: Microsoft.VisualBasic.FileSystem.Seek*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek
  nameWithType: FileSystem.Seek
- uid: Microsoft.VisualBasic.FileSystem.SetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr
  nameWithType: FileSystem.SetAttr
- uid: Microsoft.VisualBasic.FileSystem.SPC*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC
  nameWithType: FileSystem.SPC
- uid: Microsoft.VisualBasic.FileSystem.TAB*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB
  nameWithType: FileSystem.TAB
- uid: Microsoft.VisualBasic.FileSystem.Unlock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock
  nameWithType: FileSystem.Unlock
- uid: Microsoft.VisualBasic.FileSystem.Write*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write
  nameWithType: FileSystem.Write
- uid: Microsoft.VisualBasic.FileSystem.WriteLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine
  nameWithType: FileSystem.WriteLine
