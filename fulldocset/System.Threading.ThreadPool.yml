### YamlMime:ManagedReference
items:
- uid: System.Threading.ThreadPool
  id: ThreadPool
  children:
  - System.Threading.ThreadPool.BindHandle(System.IntPtr)
  - System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  - System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  - System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  - System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  langs:
  - csharp
  name: ThreadPool
  nameWithType: ThreadPool
  fullName: System.Threading.ThreadPool
  type: Class
  summary: "Предоставляет пул потоков, который может использоваться для выполнения задач, отправки рабочих элементов, обработки асинхронного ввода-вывода, ожидания от имени других потоков и обработки таймеров."
  remarks: "Многие приложения создают потоки, которые проводят много времени в бездействующее состояние ожидания возникновения события. Другие потоки могут входить в бездействующее состояние только для периодически опрашивать для изменения или обновления сведений о состоянии. Пул потоков позволяет более эффективно использовать потоки, предоставляя приложения с пулом рабочих потоков, управляемых системой. Примеры операций, которые используют пул потоков включают следующие: - при создании <xref:System.Threading.Tasks.Task>или <xref:System.Threading.Tasks.Task%601>объекта для выполнения некоторых задач асинхронно, по умолчанию, задача запланирована для выполнения в потоке пула потоков.</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      -Асинхронной таймеры используют пул потоков. Потоки из пула потоков выполнения обратные вызовы из <xref:System.Threading.Timer?displayProperty=fullName>класса и вызвать события из <xref:System.Timers.Timer?displayProperty=fullName>класса.</xref:System.Timers.Timer?displayProperty=fullName> </xref:System.Threading.Timer?displayProperty=fullName>      — При использовании дескрипторы ожидания зарегистрированного потока системы отслеживает состояние дескрипторов ожидания. По завершении операции ожидания рабочий поток из пула потоков выполняет соответствующую функцию обратного вызова.      -При вызове <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>метод в очередь метод для выполнения в потоке пула потоков.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Это можно сделать, передав в метод <xref:System.Threading.WaitCallback>делегировать.</xref:System.Threading.WaitCallback>   Делегат имеет подпись <CodeContentPlaceHolder>0</CodeContentPlaceHolder><CodeContentPlaceHolder>1</CodeContentPlaceHolder> где `state` — это объект, содержащий данные для использования в делегат.    Фактические данные могут передаваться делегата путем вызова <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>метод.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      Настроек [!NOTE] настроек потоков в пул управляемых потоков — это фоновые потоки. То есть их <xref:System.Threading.Thread.IsBackground%2A>Свойства `true`.</xref:System.Threading.Thread.IsBackground%2A> Это означает, что поток из пула потоков не будет хранить приложение, выполняемое после все основные потоки вышли из.      Настроек [!IMPORTANT] настроек когда пул потоков повторно использует поток, не очищает данные в локальном хранилище потока или в поля, отмеченные <xref:System.ThreadStaticAttribute>атрибут.</xref:System.ThreadStaticAttribute> Таким образом, когда метод проверяет локальное хранилище потока или полей, отмеченные <xref:System.ThreadStaticAttribute>атрибут, находит значения может быть оставлено на более ранних использование пула потоков.</xref:System.ThreadStaticAttribute>       Можно также поместить в очередь рабочих элементов, которые не относятся к операции ожидания в пуле потоков. Для запроса, что рабочий элемент должен обрабатываться потоком в пуле потоков, вызовите <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>метод.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Этот метод принимает в качестве параметра ссылку на метод или делегат, который будет вызываться из потока из пула потоков. Нет возможности для отмены рабочего элемента после ее поставлен в очередь.       Таймеры очереди и зарегистрированные операции ожидания также используют пул потоков. Их функции обратного вызова помещаются в очередь пула потоков.       Имеется один пул потоков для каждого процесса. Начиная с версии [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], по умолчанию размер пула потоков для процесса зависит от нескольких факторов, таких как размер виртуального адресного пространства. Процесс может вызвать <xref:System.Threading.ThreadPool.GetMaxThreads%2A>метод для определения количества потоков.</xref:System.Threading.ThreadPool.GetMaxThreads%2A> Число потоков в пуле потоков может быть изменен с помощью <xref:System.Threading.ThreadPool.SetMaxThreads%2A>метод.</xref:System.Threading.ThreadPool.SetMaxThreads%2A> Каждый поток использует размер стека по умолчанию и запускается с приоритетом по умолчанию.      Настроек [!NOTE] настроек неуправляемого кода, на котором размещена .NET Framework можно изменить размер пула потоков с помощью `CorSetMaxThreads` функции, определенные в файле mscoree.h.       Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу, пока не достигнет минимум для каждой категории. При достижении минимума пул потоков может создавать дополнительные потоки в этой категории или ожидать завершения некоторых задач. Начиная с версии [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], пул потоков создает и уничтожает рабочие потоки в целях оптимизации пропускной способности, которая определяется как количество задач, завершаемых за единицу времени. Слишком малое количество потоков может препятствовать оптимальному использованию доступных ресурсов, тогда как слишком большое количество потоков может усиливать конкуренцию за ресурсы.      Настроек [!NOTE] настроек Если потребность низкая, фактическое количество потоков из пула потоков может быть ниже минимальных значений.       Можно использовать <xref:System.Threading.ThreadPool.GetMinThreads%2A>для получения этих минимальных значений.</xref:System.Threading.ThreadPool.GetMinThreads%2A>      Настроек [!CAUTION] настроек можно использовать <xref:System.Threading.ThreadPool.SetMinThreads%2A>метод для увеличения минимального количества потоков.</xref:System.Threading.ThreadPool.SetMinThreads%2A> Однако необоснованное увеличение этих значений может привести к снижению производительности. Если одновременно запускается слишком много задач, все из них кажется медленным. В большинстве случаев пул потоков работает лучше использует собственный алгоритм выделения потоков."
  example:
  - "In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits. The `ThreadProc` method simply displays a message.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/t-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/t-system.threading.threa_5_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/t-system.threading.threa_5_1.cs)]  \n  \n If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method, the main thread exits before         method runs on the thread pool thread.  The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.  (This         is a simple example of a race condition.)"
  syntax:
    content: public static class ThreadPool
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  id: BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Связывает дескриптор операционной системы с <xref href=&quot;System.Threading.ThreadPool&quot;> </xref>."
  syntax:
    content: public static bool BindHandle (IntPtr osHandle);
    parameters:
    - id: osHandle
      type: System.IntPtr
      description: "<xref:System.IntPtr>, Хранящая дескриптор.</xref:System.IntPtr> Дескриптор должен быть открыт для перекрывающегося ввода-вывода в неуправляемой области."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если дескриптор является связанным; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  id: BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Связывает дескриптор операционной системы с <xref href=&quot;System.Threading.ThreadPool&quot;> </xref>."
  remarks: "`osHandle` Параметр должен быть <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>который является производным от абстрактного <xref:System.Runtime.InteropServices.SafeHandle>класса.</xref:System.Runtime.InteropServices.SafeHandle> </xref:Microsoft.Win32.SafeHandles.SafeFileHandle>"
  syntax:
    content: public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);
    parameters:
    - id: osHandle
      type: System.Runtime.InteropServices.SafeHandle
      description: "Объект <xref:System.Runtime.InteropServices.SafeHandle>, содержащий дескриптор операционной системы.</xref:System.Runtime.InteropServices.SafeHandle> Дескриптор должен быть открыт для перекрывающегося ввода-вывода в неуправляемой области."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если дескриптор является связанным; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>osHandle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  id: GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает разницу между максимальным числом потоков пула, возвращаемых <xref:System.Threading.ThreadPool.GetMaxThreads*>метод и число активных.</xref:System.Threading.ThreadPool.GetMaxThreads*>"
  remarks: "При возврате GetAvailableThreads переменную, указанную в `workerThreads` содержит число дополнительных рабочих потоков, которые могут быть запущены и переменную, указанную в `completionPortThreads` содержит число дополнительных потоков асинхронного ввода-вывода, можно запустить.       Если нет доступных потоков, запросы к пулу потоков дополнительных остаются в очереди, пока не станут доступными пула потоков."
  example:
  - "The following example displays the number of worker threads and I/O threads available when a simple app is started.  \n  \n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/csharp/m-system.threading.threa_23_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/visualbasic/m-system.threading.threa_23_1.vb)]"
  syntax:
    content: public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Число доступных рабочих потоков."
    - id: completionPortThreads
      type: System.Int32
      description: "Количество доступных потоков асинхронного ввода-вывода."
  overload: System.Threading.ThreadPool.GetAvailableThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  id: GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает количество запросов к пулу потоков, которые могут быть активными одновременно. Все запросы, превышающие это количество, остаются в очереди, пока не станут доступными пула потоков."
  remarks: "При возврате GetMaxThreads переменную, указанную в `workerThreads` содержит максимальное число рабочих потоков, допустимых в пуле потоков, а переменная, указанная параметром `completionPortThreads` содержит максимальное количество потоков асинхронного ввода-вывода, допустимых в пуле потоков.       Можно использовать <xref:System.Threading.ThreadPool.GetAvailableThreads%2A>метод, чтобы определить фактическое количество потоков в пуле потоков в любой момент времени.</xref:System.Threading.ThreadPool.GetAvailableThreads%2A>       Можно использовать <xref:System.Threading.ThreadPool.SetMaxThreads%2A>Чтобы задать максимальное число рабочих потоков и потоков асинхронного ввода-вывода в пуле потоков.</xref:System.Threading.ThreadPool.SetMaxThreads%2A>       Можно поместить в очередь многие запросы к пулу потоков, сколько позволяет системная память. Если запросов больше, чем потоки из пула потоков, дополнительные запросы остаются в очереди, пока не станут доступными пула потоков."
  example:
  - "The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool. A work item is queued that uses `FileStream` to asynchronously write to two files. The callback methods are timed to overlap. A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.  \n  \n [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_14_1.cpp)]\n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_14_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_14_1.vb)]"
  syntax:
    content: public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Максимальное число рабочих потоков в пуле потоков."
    - id: completionPortThreads
      type: System.Int32
      description: "Максимальное количество потоков асинхронного ввода-вывода в пуле потоков."
  overload: System.Threading.ThreadPool.GetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  id: GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Получает минимальное количество потоков, которые создаются пулом потоков по требованию по мере поступления новых запросов перед переходом на алгоритм управления созданием и уничтожением потоков."
  remarks: "Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу, пока не достигнет минимум для каждой категории. По умолчанию минимальное количество потоков равно числу процессоров в системе. По достижении минимального пула потоков может создавать дополнительные потоки в этой категории или ожидать завершения некоторых задач. Начиная с версии [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], пул потоков создает и уничтожает потоки в целях оптимизации пропускной способности, которая определяется как количество задач, завершаемых за единицу времени. Слишком малое количество потоков может препятствовать оптимальному использованию доступных ресурсов, тогда как слишком большое количество потоков может усиливать конкуренцию за ресурсы.      Настроек [!NOTE] настроек Если потребность низкая, фактическое количество потоков из пула потоков может быть ниже минимальных значений."
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_20_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_20_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_20_1.cpp)]"
  syntax:
    content: public static void GetMinThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "При возврате из этого метода содержит минимальное количество рабочих потоков, которые создаются пулом потоков по требованию."
    - id: completionPortThreads
      type: System.Int32
      description: "При возврате из этого метода содержит минимальное количество потоков асинхронного ввода-вывода, которые создаются пулом потоков по требованию."
  overload: System.Threading.ThreadPool.GetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  id: QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Помещает в очередь метод для выполнения. Метод выполняется, когда становится доступен поток из пула потоков."
  remarks: "Можно разместить данные, необходимые для метода в очереди в поля экземпляра класса, в котором определен метод, или можно использовать <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>перегрузку, которая принимает объект, содержащий необходимые данные.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      Настроек [!NOTE] настроек пользователей Visual Basic можно опустить <xref:System.Threading.WaitCallback>конструктор и просто использовать `AddressOf` оператор при передаче в метод обратного вызова <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.WaitCallback> Visual Basic автоматически вызывает соответствующий конструктор делегата.      ## Версия информации в .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>метод.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> В более ранних версиях информация об участнике не распространяются."
  example:
  - "The following example uses the QueueUserWorkItem method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available. No task information is supplied with this overload. Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/m-system.threading.threa_22_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/m-system.threading.threa_22_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/m-system.threading.threa_22_1.cs)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "Объект <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> , представляющий выполняемый метод."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если метод успешно помещен в очередь. <xref:System.NotSupportedException>создается, если рабочий элемент не может быть назначен.</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Размещается общеязыковой среды выполнения (CLR), и узел не поддерживает это действие."
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Помещает в очередь метод для выполнения и указывает объект, содержащий данные для использования методом. Метод выполняется, когда становится доступен поток из пула потоков."
  remarks: "Если метод обратного вызова требуются сложные данные, можно определить класс, содержащий данные.      Настроек [!NOTE] настроек пользователей Visual Basic можно опустить <xref:System.Threading.WaitCallback>конструктор и просто использовать `AddressOf` оператор при передаче в метод обратного вызова в QueueUserWorkItem.</xref:System.Threading.WaitCallback> Visual Basic автоматически вызывает соответствующий конструктор делегата.      ## Версия информации в .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>метод.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> В более ранних версиях информация об участнике не распространяются."
  example:
  - "The following example shows how to create an object that contains task information. It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/cpp/9389ae71-aa49-4ceb-9b0a-_1.cpp)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/csharp/9389ae71-aa49-4ceb-9b0a-_1.cs)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/visualbasic/9389ae71-aa49-4ceb-9b0a-_1.vb)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "Объект <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> представляющий выполняемый метод."
    - id: state
      type: System.Object
      description: "Объект, содержащий данные для использования методом."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если метод успешно помещен в очередь. <xref:System.NotSupportedException>создается, если рабочий элемент не может быть назначен.</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Размещается общеязыковой среды выполнения (CLR), и узел не поддерживает это действие."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Регистрирует делегат для ожидания <xref:System.Threading.WaitHandle>, указывая 32-разрядное целое число со знаком для тайм-аута в миллисекундах.</xref:System.Threading.WaitHandle>"
  remarks: "По окончании с помощью <xref:System.Threading.RegisteredWaitHandle>, возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод для освобождения ссылки на дескриптор ожидания.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод, даже если указать `true` для `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Метод RegisterWaitForSingleObject очередь указанный делегат в пул потоков. Рабочий поток выполняет делегат, когда происходит одно из следующих действий:-указанный объект содержится в сигнальное состояние.      — Время ожидания истекло.       Метод RegisterWaitForSingleObject проверяет текущее состояние указанного объекта <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> Если состояние объекта несигнальное, метод регистрирует операцию ожидания. Поток из пула потоков выполняет операцию ожидания. Делегат выполняется рабочим потоком, когда состояние объекта становится сигнальным или истекает время ожидания. Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или истекает время ожидания.      Настроек [!IMPORTANT] настроек с помощью <xref:System.Threading.Mutex>для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков.</xref:System.Threading.Mutex> Вместо <xref:System.Threading.Mutex>, используйте <xref:System.Threading.Semaphore>и максимальное число 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для мониторинга зарегистрированные операции ожидания. Таким образом, необходимо использовать один и тот же дескриптор операционной системы в нескольких вызовах RegisterWaitForSingleObject, необходимо дублировать дескриптор с помощью Win32 `DuplicateHandle` функции. Обратите внимание, что не следует посылать объект события, передаваемый RegisterWaitForSingleObject, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.       Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации. Изменение происходит только для объекта, чьи сигнальные состояния вызвали условия ожидания. Например счетчик семафора уменьшается на единицу.      ## Сведения о версии, начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>метод.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> В более ранних версиях информация об участнике не распространяются."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Для регистрации.</xref:System.Threading.WaitHandle> Использовать <xref:System.Threading.WaitHandle>отличный от <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> Делегат, который вызывается, когда `waitObject` , указанным параметром."
    - id: state
      type: System.Object
      description: "Объект, переданный делегату."
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "Время ожидания в миллисекундах. Если `millisecondsTimeOutInterval` параметр равен 0 (ноль), функция проверяет состояние объекта и немедленно возвращается. Если `millisecondsTimeOutInterval` равно -1, ожидания функции никогда не истекает."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы указать, что поток не будет ожидать `waitObject` параметра после вызова делегата; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для указания, что таймер сбрасывается каждый раз при завершении операции ожидания, пока ожидание не зарегистрирован."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> , Инкапсулирующий собственный дескриптор."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code> Параметр является меньше -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Регистрирует делегат для ожидания <xref:System.Threading.WaitHandle>, задавая 64-разрядное целое число со знаком для тайм-аута в миллисекундах.</xref:System.Threading.WaitHandle>"
  remarks: "По окончании с помощью <xref:System.Threading.RegisteredWaitHandle>, возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод для освобождения ссылки на дескриптор ожидания.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод, даже если указать `true` для `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Метод RegisterWaitForSingleObject очередь указанный делегат в пул потоков. Рабочий поток выполняет делегат, когда происходит одно из следующих действий:-указанный объект содержится в сигнальное состояние.      — Время ожидания истекло.       Метод RegisterWaitForSingleObject проверяет текущее состояние указанного объекта <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> Если состояние объекта несигнальное, метод регистрирует операцию ожидания. Поток из пула потоков выполняет операцию ожидания. Делегат выполняется рабочим потоком, когда состояние объекта становится сигнальным или истекает время ожидания. Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или истекает время ожидания.      Настроек [!IMPORTANT] настроек с помощью <xref:System.Threading.Mutex>для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков.</xref:System.Threading.Mutex> Вместо <xref:System.Threading.Mutex>, используйте <xref:System.Threading.Semaphore>и максимальное число 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для мониторинга зарегистрированные операции ожидания. Таким образом, необходимо использовать один и тот же дескриптор операционной системы в нескольких вызовах RegisterWaitForSingleObject, необходимо дублировать дескриптор с помощью Win32 `DuplicateHandle` функции. Обратите внимание, что не следует посылать объект события, передаваемый RegisterWaitForSingleObject, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.       Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации. Изменение происходит только для объекта, чьи сигнальные состояния вызвали условия ожидания. Например счетчик семафора уменьшается на единицу.      ## Сведения о версии, начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>метод.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> В более ранних версиях информация об участнике не распространяются."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Для регистрации.</xref:System.Threading.WaitHandle> Использовать <xref:System.Threading.WaitHandle>отличный от <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> Делегат, который вызывается, когда `waitObject` , указанным параметром."
    - id: state
      type: System.Object
      description: "Объект, переданный делегату."
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "Время ожидания в миллисекундах. Если `millisecondsTimeOutInterval` параметр равен 0 (ноль), функция проверяет состояние объекта и немедленно возвращается. Если `millisecondsTimeOutInterval` равно -1, ожидания функции никогда не истекает."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы указать, что поток не будет ожидать `waitObject` параметра после вызова делегата; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для указания, что таймер сбрасывается каждый раз при завершении операции ожидания, пока ожидание не зарегистрирован."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> , Инкапсулирующий собственный дескриптор."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code> Параметр является меньше -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Регистрирует делегат для ожидания <xref:System.Threading.WaitHandle>, указав <xref:System.TimeSpan>для времени ожидания.</xref:System.TimeSpan> </xref:System.Threading.WaitHandle>"
  remarks: "По окончании с помощью <xref:System.Threading.RegisteredWaitHandle>, возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод для освобождения ссылки на дескриптор ожидания.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод, даже если указать `true` для `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Метод RegisterWaitForSingleObject очередь указанный делегат в пул потоков. Рабочий поток выполняет делегат, когда происходит одно из следующих действий:-указанный объект содержится в сигнальное состояние.      — Время ожидания истекло.       Метод RegisterWaitForSingleObject проверяет текущее состояние указанного объекта <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> Если состояние объекта несигнальное, метод регистрирует операцию ожидания. Поток из пула потоков выполняет операцию ожидания. Делегат выполняется рабочим потоком, когда состояние объекта становится сигнальным или истекает время ожидания. Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или истекает время ожидания.      Настроек [!IMPORTANT] настроек с помощью <xref:System.Threading.Mutex>для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков.</xref:System.Threading.Mutex> Вместо <xref:System.Threading.Mutex>, используйте <xref:System.Threading.Semaphore>и максимальное число 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для мониторинга зарегистрированные операции ожидания. Таким образом, необходимо использовать один и тот же дескриптор операционной системы в нескольких вызовах RegisterWaitForSingleObject, необходимо дублировать дескриптор с помощью Win32 `DuplicateHandle` функции. Обратите внимание, что не следует посылать объект события, передаваемый RegisterWaitForSingleObject, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.       Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации. Изменение происходит только для объекта, чьи сигнальные состояния вызвали условия ожидания. Например счетчик семафора уменьшается на единицу.      ## Сведения о версии, начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>метод.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> В более ранних версиях информация об участнике не распространяются."
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Для регистрации.</xref:System.Threading.WaitHandle> Использовать <xref:System.Threading.WaitHandle>отличный от <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> Делегат, который вызывается, когда `waitObject` , указанным параметром."
    - id: state
      type: System.Object
      description: "Объект, переданный делегату."
    - id: timeout
      type: System.TimeSpan
      description: "Время ожидания, представленное <xref:System.TimeSpan>.</xref:System.TimeSpan> Если `timeout` равно 0 (ноль), функция проверяет состояние объекта и немедленно возвращается. Если `timeout` равно -1, ожидания функции никогда не истекает."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы указать, что поток не будет ожидать `waitObject` параметра после вызова делегата; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для указания, что таймер сбрасывается каждый раз при завершении операции ожидания, пока ожидание не зарегистрирован."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> , Инкапсулирующий собственный дескриптор."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> timeout </code> Параметр является меньше -1."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code> timeout </code> Параметра больше &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Регистрирует делегат для ожидания <xref:System.Threading.WaitHandle>, указывая 32-разрядное целое число без знака для тайм-аута в миллисекундах.</xref:System.Threading.WaitHandle>"
  remarks: "По окончании с помощью <xref:System.Threading.RegisteredWaitHandle>, возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод для освобождения ссылки на дескриптор ожидания.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод, даже если указать `true` для `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>Метод ставит в очередь указанный делегат в пул потоков.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Рабочий поток выполняет делегат, когда происходит одно из следующих действий:-указанный объект содержится в сигнальное состояние.      — Время ожидания истекло.       <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>Метод проверяет текущее состояние указанного объекта <xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle> </xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Если состояние объекта несигнальное, метод регистрирует операцию ожидания. Поток из пула потоков выполняет операцию ожидания. Делегат выполняется рабочим потоком, когда состояние объекта становится сигнальным или истекает время ожидания. Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или истекает время ожидания.      Настроек [!IMPORTANT] настроек с помощью <xref:System.Threading.Mutex>для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков.</xref:System.Threading.Mutex> Вместо <xref:System.Threading.Mutex>, используйте <xref:System.Threading.Semaphore>и максимальное число 1.</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для мониторинга зарегистрированные операции ожидания. Таким образом, если необходимо использовать один и тот же дескриптор операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, необходимо дублировать дескриптор с помощью Win32 `DuplicateHandle` функция.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Обратите внимание, что не следует посылать событие объекта, передаваемого <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>       Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации. Изменение происходит только для объекта, чьи сигнальные состояния вызвали условия ожидания. Например счетчик семафора уменьшается на единицу.      ## Сведения о версии, начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>метод.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> В более ранних версиях информация об участнике не распространяются."
  example:
  - "The following example shows how to use the RegisterWaitForSingleObject method to execute a specified callback method when a specified wait handle is signaled. In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.  \n  \n The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes. The example creates a `TaskInfo` object and assigns it some string data. The <xref:System.Threading.RegisteredWaitHandle> that is returned by the RegisterWaitForSingleObject method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.  \n  \n In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the RegisterWaitForSingleObject method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.  \n  \n When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked. The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred. If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks. In the case of a time-out, the task continues to wait. The `WaitProc` method ends by printing a message to the console.  \n  \n [!code-cs[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/csharp/2f901dc9-3ce0-4cdc-bf06-_1.cs)]\n [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/cpp/2f901dc9-3ce0-4cdc-bf06-_1.cpp)]\n [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/visualbasic/2f901dc9-3ce0-4cdc-bf06-_1.vb)]"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Для регистрации.</xref:System.Threading.WaitHandle> Использовать <xref:System.Threading.WaitHandle>отличный от <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref> Делегат, который вызывается, когда `waitObject` , указанным параметром."
    - id: state
      type: System.Object
      description: "Объект, переданный делегату."
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "Время ожидания в миллисекундах. Если `millisecondsTimeOutInterval` параметр равен 0 (ноль), функция проверяет состояние объекта и немедленно возвращается. Если `millisecondsTimeOutInterval` равно -1, ожидания функции никогда не истекает."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы указать, что поток не будет ожидать `waitObject` параметра после вызова делегата; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для указания, что таймер сбрасывается каждый раз при завершении операции ожидания, пока ожидание не зарегистрирован."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> , Можно использовать для отмены зарегистрированной операции ожидания."
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code> Параметр является меньше -1."
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  id: SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Задает количество запросов к пулу потоков, которые могут быть активными одновременно. Все запросы, превышающие это количество, остаются в очереди, пока не станут доступными пула потоков."
  remarks: "Максимальное число рабочих потоков или потоков завершения ввода-вывода в число невозможно задать меньше, чем количество процессоров на компьютере. Чтобы определить, сколько процессоров присутствуют, извлечь значение <xref:System.Environment.ProcessorCount%2A?displayProperty=fullName>Свойства.</xref:System.Environment.ProcessorCount%2A?displayProperty=fullName> Кроме того нельзя задать максимальное число рабочих потоков или потоков завершения ввода-вывода в число меньше, чем соответствующий минимальное количество рабочих потоков или потоков завершения ввода-вывода. Чтобы определить размер пула потоков с минимальным, вызовите <xref:System.Threading.ThreadPool.GetMinThreads%2A>метод.</xref:System.Threading.ThreadPool.GetMinThreads%2A>       Если среда находится, например Internet Information Services (IIS) или SQL Server, узел позволяет ограничить или запретить изменения размера пула потоков.       Соблюдайте осторожность при изменении максимальное число потоков в пуле потоков. Во время может повыситься при использовании кода, изменения могут возникнуть неблагоприятное воздействие на библиотек кода, которые вы используете.       Задание слишком большой размер пула потоков может привести к снижению производительности. Если слишком много потоков выполняются одновременно, расходы на переключение между задачами становится важным фактором."
  syntax:
    content: public static bool SetMaxThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Максимальное число рабочих потоков в пуле потоков."
    - id: completionPortThreads
      type: System.Int32
      description: "Максимальное количество потоков асинхронного ввода-вывода в пуле потоков."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если изменение выполнено успешно; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.SetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  id: SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Задает минимальное количество потоков, которые создаются пулом потоков по требованию по мере поступления новых запросов перед переходом на алгоритм управления созданием и уничтожением потоков."
  remarks: "Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу, пока не достигнет минимум для каждой категории. По достижении минимального пула потоков может создавать дополнительные потоки в этой категории или ожидать завершения некоторых задач. Начиная с версии [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)], пул потоков создает и уничтожает потоки в целях оптимизации пропускной способности, которая определяется как количество задач, завершаемых за единицу времени. Слишком малое количество потоков может препятствовать оптимальному использованию доступных ресурсов, тогда как слишком большое количество потоков может усиливать конкуренцию за ресурсы.       Если потребность низкая, фактическое количество потоков из пула потоков может быть ниже минимальных значений.       Если указано отрицательное число или число, большее, чем максимальное число активных потоков из пула потоков (полученный с использованием <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), возвращает SetMinThreads `false` и не изменяет либо минимальных значений.</xref:System.Threading.ThreadPool.GetMaxThreads%2A>      Настроек [!CAUTION] настроек по умолчанию минимальное количество потоков равно числу процессоров в системе. Метод SetMinThreads увеличить минимальное число ofthreads. Однако необоснованное увеличение этих значений может привести к снижению производительности. Если одновременно запускается слишком много задач, все из них кажется медленным. В большинстве случаев пул потоков работает лучше использует собственный алгоритм выделения потоков. Снижение минимальным меньшего, чем число процессоров, также может вызвать снижение производительности."
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_10_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_10_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_10_1.cpp)]"
  syntax:
    content: public static bool SetMinThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "Минимальное количество рабочих потоков, которые создаются пулом потоков по требованию."
    - id: completionPortThreads
      type: System.Int32
      description: "Минимальное количество потоков асинхронного ввода-вывода, которые создаются пулом потоков по требованию."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если изменение выполнено успешно; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.SetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  id: UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Выполнение операцию перекрывающегося ввода-вывода очереди."
  remarks: "Сведения об использовании собственного Win32 перекрывающегося ввода-вывода, см. в разделе <xref:System.Threading.Overlapped>класса <xref:System.Threading.NativeOverlapped>структуры и `OVERLAPPED` структуры в пакете SDK для платформы Win32.</xref:System.Threading.NativeOverlapped> </xref:System.Threading.Overlapped>      Настроек [!CAUTION] настроек с помощью UnsafeQueueNativeOverlapped метод может случайно открываются брешь в системе безопасности. Управление доступом для кода сформирует его проверки разрешений всех вызывающих объектов разрешений в стеке. При рабочих помещается в очередь в потоке пула потоков с помощью UnsafeQueueNativeOverlapped, стек пула потоков не обладает контекстом вызывающих. Вредоносный код, можно использовать этот параметр, чтобы избежать проверки разрешений."
  syntax:
    content: public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);
    parameters:
    - id: overlapped
      type: System.Threading.NativeOverlapped*
      description: "<xref href=&quot;System.Threading.NativeOverlapped&quot;> </xref> Структуры в очередь."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если операция была успешна помещена в очередь порта завершения ввода-вывода; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Помещает указанный делегат в пул потоков в очередь, но не распространяет вызывающий стек на рабочий поток."
  remarks: "В отличие от <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>метод UnsafeQueueUserWorkItem не распространяет вызывающий стек на рабочий поток.</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.      Настроек [!CAUTION] настроек с помощью UnsafeQueueUserWorkItem может случайно открываются брешь в системе безопасности. Управление доступом для кода сформирует его проверки разрешений всех вызывающих объектов разрешений в стеке. При рабочих помещается в очередь в потоке пула потоков с помощью UnsafeQueueUserWorkItem, стек пула потоков не будет контекста вызывающих. Вредоносный код, можно использовать этот параметр, чтобы избежать проверки разрешений."
  syntax:
    content: public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "Объект <xref href=&quot;System.Threading.WaitCallback&quot;> </xref> , представляющий делегат, который вызывается, когда потоку в пуле потоков назначается рабочий элемент."
    - id: state
      type: System.Object
      description: "Объект, передаваемый делегату при вызове из пула потоков."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если метод выполнен успешно; <xref:System.OutOfMemoryException>создается, если рабочий элемент не может быть назначен.</xref:System.OutOfMemoryException>"
  overload: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "Возникла ситуация нехватки памяти."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Не может быть назначен рабочий элемент."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Регистрирует делегат для ожидания <xref:System.Threading.WaitHandle>, используя 32-разрядное целое число со знаком для тайм-аута в миллисекундах.</xref:System.Threading.WaitHandle> Этот метод не распространяет вызывающий стек на рабочий поток."
  remarks: "В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>метод UnsafeRegisterWaitForSingleObject не распространяет вызывающий стек на рабочий поток.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.      Настроек [!CAUTION] настроек с помощью UnsafeRegisterWaitForSingleObject может случайно открываются брешь в системе безопасности. Управление доступом для кода сформирует его проверки разрешений всех вызывающих объектов разрешений в стеке. При рабочих помещается в очередь в потоке пула потоков с помощью UnsafeRegisterWaitForSingleObject, стек пула потоков не будет контекста вызывающих. Вредоносный код, можно использовать этот параметр, чтобы избежать проверки разрешений.       С помощью <xref:System.Threading.Mutex>для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков.</xref:System.Threading.Mutex>       По окончании с помощью <xref:System.Threading.RegisteredWaitHandle>, возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод для освобождения ссылки на дескриптор ожидания.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод, даже если указать `true` для `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Для регистрации.</xref:System.Threading.WaitHandle> Использовать <xref:System.Threading.WaitHandle>отличный от <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Делегат, который вызывается, когда `waitObject` , указанным параметром."
    - id: state
      type: System.Object
      description: "Объект, переданный делегату."
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "Время ожидания в миллисекундах. Если `millisecondsTimeOutInterval` параметр равен 0 (ноль), функция проверяет состояние объекта и немедленно возвращается. Если `millisecondsTimeOutInterval` равно -1, ожидания функции никогда не истекает."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы указать, что поток не будет ожидать `waitObject` параметра после вызова делегата; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для указания, что таймер сбрасывается каждый раз при завершении операции ожидания, пока ожидание не зарегистрирован."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> Объект, который можно использовать для отмены зарегистрированной операции ожидания."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code> Параметр является меньше -1."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Регистрирует делегат для ожидания <xref:System.Threading.WaitHandle>, задавая 64-разрядное целое число со знаком для тайм-аута в миллисекундах.</xref:System.Threading.WaitHandle> Этот метод не распространяет вызывающий стек на рабочий поток."
  remarks: "В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>метод UnsafeRegisterWaitForSingleObject не распространяет вызывающий стек на рабочий поток.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.      Настроек [!CAUTION] настроек с помощью UnsafeRegisterWaitForSingleObject может случайно открываются брешь в системе безопасности. Управление доступом для кода сформирует его проверки разрешений всех вызывающих объектов разрешений в стеке. При рабочих помещается в очередь в потоке пула потоков с помощью UnsafeRegisterWaitForSingleObject, стек пула потоков не будет контекста вызывающих. Вредоносный код, можно использовать этот параметр, чтобы избежать проверки разрешений.       С помощью <xref:System.Threading.Mutex>для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков.</xref:System.Threading.Mutex>       По окончании с помощью <xref:System.Threading.RegisteredWaitHandle>, возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод для освобождения ссылки на дескриптор ожидания.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод, даже если указать `true` для `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Для регистрации.</xref:System.Threading.WaitHandle> Использовать <xref:System.Threading.WaitHandle>отличный от <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Делегат, который вызывается, когда `waitObject` , указанным параметром."
    - id: state
      type: System.Object
      description: "Объект, переданный делегату."
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "Время ожидания в миллисекундах. Если `millisecondsTimeOutInterval` параметр равен 0 (ноль), функция проверяет состояние объекта и немедленно возвращается. Если `millisecondsTimeOutInterval` равно -1, ожидания функции никогда не истекает."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы указать, что поток не будет ожидать `waitObject` параметра после вызова делегата; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для указания, что таймер сбрасывается каждый раз при завершении операции ожидания, пока ожидание не зарегистрирован."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> Объект, который можно использовать для отмены зарегистрированной операции ожидания."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code> Параметр является меньше -1."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Регистрирует делегат для ожидания <xref:System.Threading.WaitHandle>, указав <xref:System.TimeSpan>для времени ожидания.</xref:System.TimeSpan> </xref:System.Threading.WaitHandle> Этот метод не распространяет вызывающий стек на рабочий поток."
  remarks: "В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>метод UnsafeRegisterWaitForSingleObject не распространяет вызывающий стек на рабочий поток.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.      Настроек [!CAUTION] настроек с помощью UnsafeRegisterWaitForSingleObject может случайно открываются брешь в системе безопасности. Управление доступом для кода сформирует его проверки разрешений всех вызывающих объектов разрешений в стеке. При рабочих помещается в очередь в потоке пула потоков с помощью UnsafeRegisterWaitForSingleObject, стек пула потоков не будет контекста вызывающих. Вредоносный код, можно использовать этот параметр, чтобы избежать проверки разрешений.       С помощью <xref:System.Threading.Mutex>для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков.</xref:System.Threading.Mutex>       По окончании с помощью <xref:System.Threading.RegisteredWaitHandle>, возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод для освобождения ссылки на дескриптор ожидания.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод, даже если указать `true` для `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Для регистрации.</xref:System.Threading.WaitHandle> Использовать <xref:System.Threading.WaitHandle>отличный от <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Делегат, который вызывается, когда `waitObject` , указанным параметром."
    - id: state
      type: System.Object
      description: "Объект, переданный делегату."
    - id: timeout
      type: System.TimeSpan
      description: "Время ожидания, представленное <xref:System.TimeSpan>.</xref:System.TimeSpan> Если `timeout` равно 0 (ноль), функция проверяет состояние объекта и немедленно возвращается. Если `timeout` равно -1, ожидания функции никогда не истекает."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы указать, что поток не будет ожидать `waitObject` параметра после вызова делегата; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для указания, что таймер сбрасывается каждый раз при завершении операции ожидания, пока ожидание не зарегистрирован."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> Объект, который можно использовать для отмены зарегистрированной операции ожидания."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> timeout </code> Параметр является меньше -1."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code> timeout </code> Параметра больше &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Регистрирует делегат для ожидания <xref:System.Threading.WaitHandle>, указывая 32-разрядное целое число без знака для тайм-аута в миллисекундах.</xref:System.Threading.WaitHandle> Этот метод не распространяет вызывающий стек на рабочий поток."
  remarks: "В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>метод UnsafeRegisterWaitForSingleObject не распространяет вызывающий стек на рабочий поток.</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.      Настроек [!CAUTION] настроек с помощью UnsafeRegisterWaitForSingleObject может случайно открываются брешь в системе безопасности. Управление доступом для кода сформирует его проверки разрешений всех вызывающих объектов разрешений в стеке. При рабочих помещается в очередь в потоке пула потоков с помощью UnsafeRegisterWaitForSingleObject, стек пула потоков не будет контекста вызывающих. Вредоносный код, можно использовать этот параметр, чтобы избежать проверки разрешений.       С помощью <xref:System.Threading.Mutex>для `waitObject` не дает взаимное исключение для обратных вызовов, поскольку базовый интерфейс Win32 API использует значение по умолчанию `WT_EXECUTEDEFAULT` флаг, чтобы каждый обратный вызов назначается в отдельном потоке пула потоков.</xref:System.Threading.Mutex>       По окончании с помощью <xref:System.Threading.RegisteredWaitHandle>, возвращаемый этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод для освобождения ссылки на дескриптор ожидания.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>метод, даже если указать `true` для `executeOnlyOnce`.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> Сборщик мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>вместо метода в зависимости от зарегистрированного ожидающего дескриптора метода завершения.</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>Для регистрации.</xref:System.Threading.WaitHandle> Использовать <xref:System.Threading.WaitHandle>отличный от <xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "Делегат, который вызывается, когда `waitObject` , указанным параметром."
    - id: state
      type: System.Object
      description: "Объект, переданный делегату."
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "Время ожидания в миллисекундах. Если `millisecondsTimeOutInterval` параметр равен 0 (ноль), функция проверяет состояние объекта и немедленно возвращается. Если `millisecondsTimeOutInterval` равно -1, ожидания функции никогда не истекает."
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы указать, что поток не будет ожидать `waitObject` параметра после вызова делегата; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для указания, что таймер сбрасывается каждый раз при завершении операции ожидания, пока ожидание не зарегистрирован."
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> Объект, который можно использовать для отмены зарегистрированной операции ожидания."
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
- uid: System.Runtime.InteropServices.SafeHandle
  parent: System.Runtime.InteropServices
  isExternal: true
  name: SafeHandle
  nameWithType: SafeHandle
  fullName: System.Runtime.InteropServices.SafeHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
- uid: System.Threading.WaitCallback
  parent: System.Threading
  isExternal: false
  name: WaitCallback
  nameWithType: WaitCallback
  fullName: System.Threading.WaitCallback
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.RegisteredWaitHandle
  parent: System.Threading
  isExternal: false
  name: RegisteredWaitHandle
  nameWithType: RegisteredWaitHandle
  fullName: System.Threading.RegisteredWaitHandle
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: true
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.Threading.WaitOrTimerCallback
  parent: System.Threading
  isExternal: false
  name: WaitOrTimerCallback
  nameWithType: WaitOrTimerCallback
  fullName: System.Threading.WaitOrTimerCallback
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.Threading.ThreadPool.BindHandle*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle
  nameWithType: ThreadPool.BindHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads
  nameWithType: ThreadPool.GetAvailableThreads
- uid: System.Threading.ThreadPool.GetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads
  nameWithType: ThreadPool.GetMaxThreads
- uid: System.Threading.ThreadPool.GetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads
  nameWithType: ThreadPool.GetMinThreads
- uid: System.Threading.ThreadPool.QueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem
  nameWithType: ThreadPool.QueueUserWorkItem
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject
  nameWithType: ThreadPool.RegisterWaitForSingleObject
- uid: System.Threading.ThreadPool.SetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads
  nameWithType: ThreadPool.SetMaxThreads
- uid: System.Threading.ThreadPool.SetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads
  nameWithType: ThreadPool.SetMinThreads
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject
