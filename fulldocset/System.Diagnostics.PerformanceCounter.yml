### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.PerformanceCounter
  id: PerformanceCounter
  children:
  - System.Diagnostics.PerformanceCounter.#ctor
  - System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String)
  - System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.Boolean)
  - System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String)
  - System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.Boolean)
  - System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.String)
  - System.Diagnostics.PerformanceCounter.BeginInit
  - System.Diagnostics.PerformanceCounter.CategoryName
  - System.Diagnostics.PerformanceCounter.Close
  - System.Diagnostics.PerformanceCounter.CloseSharedResources
  - System.Diagnostics.PerformanceCounter.CounterHelp
  - System.Diagnostics.PerformanceCounter.CounterName
  - System.Diagnostics.PerformanceCounter.CounterType
  - System.Diagnostics.PerformanceCounter.Decrement
  - System.Diagnostics.PerformanceCounter.DefaultFileMappingSize
  - System.Diagnostics.PerformanceCounter.Dispose(System.Boolean)
  - System.Diagnostics.PerformanceCounter.EndInit
  - System.Diagnostics.PerformanceCounter.Increment
  - System.Diagnostics.PerformanceCounter.IncrementBy(System.Int64)
  - System.Diagnostics.PerformanceCounter.InstanceLifetime
  - System.Diagnostics.PerformanceCounter.InstanceName
  - System.Diagnostics.PerformanceCounter.MachineName
  - System.Diagnostics.PerformanceCounter.NextSample
  - System.Diagnostics.PerformanceCounter.NextValue
  - System.Diagnostics.PerformanceCounter.RawValue
  - System.Diagnostics.PerformanceCounter.ReadOnly
  - System.Diagnostics.PerformanceCounter.RemoveInstance
  langs:
  - csharp
  name: PerformanceCounter
  nameWithType: PerformanceCounter
  fullName: System.Diagnostics.PerformanceCounter
  type: Class
  summary: "Представляет компонент счетчика производительности Windows NT."
  remarks: "The PerformanceCounter component can be used for both reading existing predefined or custom counters and publishing (writing) performance data to custom counters.  \n  \n There are numerous predefined counters listed in the Windows Performance Monitor's [Add Counters dialog box](http://go.microsoft.com/fwlink/p/?LinkId=257854). To learn about the .NET Framework performance counters, see [Performance Counters](~/add/includes/ajax-current-ext-md.md).  \n  \n This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n> [!IMPORTANT]\n>  In versions 1.0 and 1.1 of the .NET Framework, this class requires immediate callers to be fully trusted. Starting with the .NET Framework version 2.0, this class requires <xref:System.Diagnostics.PerformanceCounterPermission> for specific actions. It is strongly recommended that <xref:System.Diagnostics.PerformanceCounterPermission> not be granted to semi-trusted code.  The ability to read and write performance counters allows code to perform actions such as enumerating executing processes and obtaining information about them.  \n>   \n>  In addition, passing a PerformanceCounter object to less-trusted code can create a security issue. Never pass performance counter objects, such as a <xref:System.Diagnostics.PerformanceCounterCategory> or PerformanceCounter, to less trusted code.  \n  \n To read from a performance counter, create an instance of the PerformanceCounter class, set the <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, and, optionally, the <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> or <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> properties, and then call the <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> method to take a performance counter reading.  \n  \n To publish performance counter data, create one or more custom counters using the <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=fullName> method, create an instance of the PerformanceCounter class, set the <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> and, optionally, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> or <xref:System.Diagnostics.PerformanceCounter.MachineName%2A> properties, and then call the <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, or <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> methods, or set the <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> property to change the value of your custom counter.  \n  \n> [!NOTE]\n>  The <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, and <xref:System.Diagnostics.PerformanceCounter.Decrement%2A> methods use interlocks to update the counter value. This helps keep the counter value accurate in multithreaded or multiprocess scenarios, but also results in a performance penalty. If you do not need the accuracy that interlocked operations provide, you can update the <xref:System.Diagnostics.PerformanceCounter.RawValue%2A> property directly for up to a 5 times performance improvement.  However, in multithreaded scenarios, some updates to the counter value might be ignored, resulting in inaccurate data.  \n  \n The counter is the mechanism by which performance data is collected. The registry stores the names of all the counters, each of which is related to a specific area of system functionality. Examples include a processor's busy time, memory usage, or the number of bytes received over a network connection.  \n  \n Each counter is uniquely identified through its name and its location. In the same way that a file path includes a drive, a directory, one or more subdirectories, and a file name, counter information consists of four elements: the computer, the category, the category instance, and the counter name.  \n  \n The counter information must include the category, or performance object, that the counter measures data for. A computer's categories include physical components, such as processors, disks, and memory. There are also system categories, such as processes and threads. Each category is related to a functional element within the computer and has a set of standard counters assigned to it. These objects are listed in the Performance object drop-down list of the Add Counters dialog box within the Windows 2000 System Monitor, and you must include them in the counter path. Performance data is grouped by the category to which is it related.  \n  \n In certain cases, several copies of the same category can exist. For example, several processes and threads run simultaneously, and some computers contain more than one processor. The category copies are called category instances, and each instance has a set of standard counters assigned to it. If a category can have more than one instance, an instance specification must be included in the counter information.  \n  \n To obtain performance data for counters that required an initial or previous value for performing the necessary calculation, call the <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> method twice and use the information returned as your application requires.  \n  \n> [!NOTE]\n>  Performance counter categories installed with the [!INCLUDE[dnprdnlong](~/add/includes/dnprdnlong-md.md)] use separate shared memory, with each performance counter category having its own memory. You can specify the size of separate shared memory by creating a DWORD named FileMappingSize in the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\\\*\\<category name>*\\Performance. The FileMappingSize value is set to the shared memory size of the category. The default size is 131072 decimal. If the FileMappingSize value is not present, the `fileMappingSize` attribute value for the `performanceCounters` element specified in the Machine.config file is used, causing additional overhead for configuration file processing. You can realize a performance improvement for application startup by setting the file mapping size in the registry. For more information about the file mapping size, see [\\&lt;performanceCounters\\&gt;](../Topic/%3CperformanceCounters%3E%20Element.md)."
  example:
  - "The following code example demonstrates the use of the PerformanceCounter class to create and use an <xref:System.Diagnostics.PerformanceCounterType> counter type. The example creates categories, sets up counters, collects data from the counters, and calls the <xref:System.Diagnostics.CounterSampleCalculator> class to interpret the performance counter data. The intermediate and final results are displayed in the console window. For additional examples of other performance counter types, see the <xref:System.Diagnostics.PerformanceCounterType> enumeration.  \n  \n [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/add/codesnippet/cpp/t-system.diagnostics.per_0_1.cpp)]\n [!code-cs[PerformanceCounterType.AverageCounter64#1](~/add/codesnippet/csharp/t-system.diagnostics.per_0_1.cs)]\n [!code-vb[PerformanceCounterType.AverageCounter64#1](~/add/codesnippet/visualbasic/t-system.diagnostics.per_0_1.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      public sealed class PerformanceCounter : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.#ctor
  id: '#ctor'
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: PerformanceCounter()
  nameWithType: PerformanceCounter.PerformanceCounter()
  fullName: System.Diagnostics.PerformanceCounter.PerformanceCounter()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Инициализирует новый, доступный только для чтения экземпляр <xref href=&quot;System.Diagnostics.PerformanceCounter&quot;> </xref> класса, не связывая этот экземпляр с любой системой или пользовательский счетчик производительности."
  remarks: "Эта перегрузка конструктора задает <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>Свойства пустые строки (&quot;») и задает <xref:System.Diagnostics.PerformanceCounter.MachineName%2A>Свойства на локальном компьютере (».»).</xref:System.Diagnostics.PerformanceCounter.MachineName%2A> </xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> </xref:System.Diagnostics.PerformanceCounter.CounterName%2A> </xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>       Этот конструктор не инициализирует счетчик производительности, поэтому связывает экземпляр с существующим счетчиком на локальном компьютере. Чтобы указать конкретный счетчик производительности, задайте <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>и, возможно, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>и <xref:System.Diagnostics.PerformanceCounter.MachineName%2A>свойства перед считыванием других свойств или при попытке чтения из счетчика.</xref:System.Diagnostics.PerformanceCounter.MachineName%2A> </xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> </xref:System.Diagnostics.PerformanceCounter.CounterName%2A> </xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> Чтобы записать в счетчик производительности, задайте <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A>Свойства `false`.</xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A>      Настроек [!NOTE] настроек <xref:System.Security.Permissions.HostProtectionAttribute>атрибут, примененный к данному члену имеет следующее значение свойства <xref:System.Security.Permissions.HostProtectionAttribute.Resources%2A>: <xref:System.Security.Permissions.HostProtectionResource>| <xref:System.Security.Permissions.HostProtectionResource>.</xref:System.Security.Permissions.HostProtectionResource></xref:System.Security.Permissions.HostProtectionResource></xref:System.Security.Permissions.HostProtectionAttribute.Resources%2A></xref:System.Security.Permissions.HostProtectionAttribute> <xref:System.Security.Permissions.HostProtectionAttribute>Не влияет на настольные приложения (обычно запускаемые двойным щелчком значка, вводом команды или URL-адрес в браузере).</xref:System.Security.Permissions.HostProtectionAttribute> Дополнительные сведения см. в разделе <xref:System.Security.Permissions.HostProtectionAttribute>класса или [программирование SQL Server и атрибуты защиты основного приложения](~/add/includes/ajax-current-ext-md.md).</xref:System.Security.Permissions.HostProtectionAttribute>"
  example:
  - "The following code example creates a default instance of the <xref:System.Diagnostics.PerformanceCounter> class. After the instance is created, the <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, and <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> property values are set, and the results of a call to the <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> method are displayed.  \n  \n [!code-cs[PerfCounter#1](~/add/codesnippet/csharp/m-system.diagnostics.per_15_1.cs)]\n [!code-cpp[PerfCounter#1](~/add/codesnippet/cpp/m-system.diagnostics.per_15_1.cpp)]\n [!code-vb[PerfCounter#1](~/add/codesnippet/visualbasic/m-system.diagnostics.per_15_1.vb)]"
  syntax:
    content: public PerformanceCounter ();
    parameters: []
  overload: System.Diagnostics.PerformanceCounter.#ctor*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: PerformanceCounter(String,String)
  nameWithType: PerformanceCounter.PerformanceCounter(String,String)
  fullName: System.Diagnostics.PerformanceCounter.PerformanceCounter(String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Инициализирует новый, доступный только для чтения экземпляр <xref href=&quot;System.Diagnostics.PerformanceCounter&quot;> </xref> класса и связывает его с указанной системы или пользовательский счетчик производительности на локальном компьютере. Этот конструктор требует наличия одного экземпляра категории."
  remarks: "В строках параметров регистр не учитывается.       Используйте эту перегрузку для доступа к счетчику на локальном компьютере, к которому относится к категории, содержащей единственный экземпляр счетчика производительности категории. При попытке использовать этот конструктор для указания <xref:System.Diagnostics.PerformanceCounter>экземпляра или категорию, содержащую несколько экземпляров, конструктор выдаст исключение.</xref:System.Diagnostics.PerformanceCounter> Эта перегрузка может получить доступ к любой доступный только для чтения или чтения и записи счетчик, но делает это в режиме только для чтения. Объект <xref:System.Diagnostics.PerformanceCounter>экземпляром, созданным с помощью этой перегрузки не удается записать в счетчик, даже если этот счетчик доступен для чтения и записи.</xref:System.Diagnostics.PerformanceCounter>       Эта перегрузка конструктора задает <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>и <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>значения для свойств, передайте, задает <xref:System.Diagnostics.PerformanceCounter.MachineName%2A>Свойства на локальном компьютере».» и задает <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>свойства равным пустой строке (»»).</xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> </xref:System.Diagnostics.PerformanceCounter.MachineName%2A> </xref:System.Diagnostics.PerformanceCounter.CounterName%2A> </xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>       Этот конструктор инициализирует счетчик производительности и связывает экземпляр с существующим счетчиком (системным или пользовательским счетчиком) на локальном компьютере. Значения, переданные <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>и <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>свойства должен указывать на существующий счетчик производительности на локальном компьютере.</xref:System.Diagnostics.PerformanceCounter.CounterName%2A> </xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>      Настроек [!NOTE] настроек для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или иметь права администратора.   >> Во избежание необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.   >> В Windows Vista привилегии пользователя определяются управления учетных записей (UAC). Если вы являетесь членом группы администраторов, вы присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора."
  syntax:
    content: public PerformanceCounter (string categoryName, string counterName);
    parameters:
    - id: categoryName
      type: System.String
      description: "Имя категории счетчика производительности (объект производительности), с которым связан этот счетчик производительности."
    - id: counterName
      type: System.String
      description: "Имя счетчика производительности."
  overload: System.Diagnostics.PerformanceCounter.#ctor*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>categoryName</code>является пустой строкой (»»).       - или - <code>counterName</code> — пустая строка (»»).       - или - указанная категория не существует.       - или - категории, указанной помечается как нескольких экземпляров и требует создаваться с помощью имени экземпляра счетчика производительности.       - или - <code>categoryName</code> и <code>counterName</code> локализованные на разные языки."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>categoryName</code>or <code>counterName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при доступе к API-Интерфейсу системы."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Код, который выполняется без прав администратора попытка считывания значения счетчика производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.Boolean)
  id: '#ctor(System.String,System.String,System.Boolean)'
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: PerformanceCounter(String,String,Boolean)
  nameWithType: PerformanceCounter.PerformanceCounter(String,String,Boolean)
  fullName: System.Diagnostics.PerformanceCounter.PerformanceCounter(String,String,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Инициализирует новый, доступный только для чтения или чтения и записи экземпляра <xref href=&quot;System.Diagnostics.PerformanceCounter&quot;> </xref> класса и связывает его с указанной системы или пользовательский счетчик производительности на локальном компьютере. Этот конструктор требует наличия одного экземпляра категории."
  remarks: "В строках параметров регистр не учитывается.       Используйте этот перегруженный метод для доступа только для чтения или чтения и записи счетчиков на локальном компьютере, к которому относится к категории, содержащей единственный экземпляр счетчика производительности категории. При попытке использовать этот конструктор для указания <xref:System.Diagnostics.PerformanceCounter>экземпляра или категорию, содержащую несколько экземпляров, конструктор выдаст исключение.</xref:System.Diagnostics.PerformanceCounter>       Эта перегрузка конструктора задает <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, и <xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A>значения для свойств, передайте, задает <xref:System.Diagnostics.PerformanceCounter.MachineName%2A>Свойства на локальном компьютере».» и задает <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>свойства равным пустой строке (»»).</xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> </xref:System.Diagnostics.PerformanceCounter.MachineName%2A> </xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A> </xref:System.Diagnostics.PerformanceCounter.CounterName%2A> </xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>       Этот конструктор инициализирует счетчик производительности и связывает экземпляр с существующим счетчиком (системным или пользовательским счетчиком) на локальном компьютере. Значения, переданные <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>и <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>свойства должен указывать на существующий счетчик производительности на локальном компьютере.</xref:System.Diagnostics.PerformanceCounter.CounterName%2A> </xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> Если экземпляр счетчика производительности, указывающие на недопустим, вызов конструктора возникло исключение.      Настроек [!NOTE] настроек можно использовать эту перегрузку для подключения к системным счетчиком, но нельзя записывать в системный счетчик. Таким образом, задание `readOnly` для `false` при связи с системным счетчиком вызовет конструктор для создания исключения.      Настроек [!NOTE] настроек для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или иметь права администратора.   >> Во избежание необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.   >> В Windows Vista привилегии пользователя определяются управления учетных записей (UAC). Если вы являетесь членом группы администраторов, вы присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора."
  example:
  - "The following code example creates an instance of the <xref:System.Diagnostics.PerformanceCounter> class. The example passes in category names, counter names, and a flag value indicating that the counter is not read-only. This code example is part of a larger example for the <xref:System.Diagnostics.PerformanceCounter> class.  \n  \n [!code-cpp[PerformanceCounterType.AverageCounter64#2](~/add/codesnippet/cpp/edd71a17-4ee7-4e9f-af30-_1.cpp)]\n [!code-cs[PerformanceCounterType.AverageCounter64#2](~/add/codesnippet/csharp/edd71a17-4ee7-4e9f-af30-_1.cs)]\n [!code-vb[PerformanceCounterType.AverageCounter64#2](~/add/codesnippet/visualbasic/edd71a17-4ee7-4e9f-af30-_1.vb)]"
  syntax:
    content: public PerformanceCounter (string categoryName, string counterName, bool readOnly);
    parameters:
    - id: categoryName
      type: System.String
      description: "Имя категории счетчика производительности (объект производительности), с которым связан этот счетчик производительности."
    - id: counterName
      type: System.String
      description: "Имя счетчика производительности."
    - id: readOnly
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>для доступа к счетчику в режиме только для чтения (хотя сам счетчик может быть чтение и запись); <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для доступа к счетчику в режиме чтения и записи."
  overload: System.Diagnostics.PerformanceCounter.#ctor*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code> categoryName </code> — Пустая строка (»»).       - или - <code> counterName </code> — пустая строка (»»).       - или - указанная категория не существует. (if <code>readOnly</code> is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>).       Указанная категория не является пользовательской категории .NET Framework - или - (если <code> readOnly </code> — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>).       - или - категории, указанной помечается как нескольких экземпляров и требует создаваться с помощью имени экземпляра счетчика производительности.       - или - <code> categoryName </code> и <code> counterName </code> локализованные на разные языки."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>categoryName</code>or <code>counterName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при доступе к API-Интерфейсу системы."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Код, который выполняется без прав администратора попытка считывания значения счетчика производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String)
  id: '#ctor(System.String,System.String,System.String)'
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: PerformanceCounter(String,String,String)
  nameWithType: PerformanceCounter.PerformanceCounter(String,String,String)
  fullName: System.Diagnostics.PerformanceCounter.PerformanceCounter(String,String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Инициализирует новый, доступный только для чтения экземпляр <xref href=&quot;System.Diagnostics.PerformanceCounter&quot;> </xref> класса и связывает его с указанной системы или экземпляр счетчиком производительности на локальном компьютере."
  remarks: "В строках параметров регистр не учитывается.       Эта перегрузка конструктора задает <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>значения для свойств передачи и задает <xref:System.Diagnostics.PerformanceCounter.MachineName%2A>Свойства на локальный компьютер «.».</xref:System.Diagnostics.PerformanceCounter.MachineName%2A> </xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> </xref:System.Diagnostics.PerformanceCounter.CounterName%2A> </xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>       Этот конструктор инициализирует счетчик производительности и связывает экземпляр с существующим счетчиком (системным или пользовательским счетчиком) на локальном компьютере. Значения, переданные <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>свойства должен указывать на существующий счетчик производительности на локальном компьютере.</xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> </xref:System.Diagnostics.PerformanceCounter.CounterName%2A> </xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> Если экземпляр счетчика производительности, которые указывают на недопустим, вызов конструктора возникло исключение.       Эта перегрузка может получить доступ к любой доступный только для чтения или чтения и записи счетчик, но делает это в режиме только для чтения. Объект <xref:System.Diagnostics.PerformanceCounter>экземпляром, созданным с помощью этой перегрузки не удается записать в счетчик, даже если этот счетчик доступен для чтения и записи.</xref:System.Diagnostics.PerformanceCounter>       Чтобы создать экземпляр категории производительности, укажите `instanceName` на <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>конструктор.</xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> Если экземпляр категории, заданный параметром `instanceName` уже существует новый объект будет ссылаться на существующий экземпляр категории.      Настроек [!NOTE] настроек для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или иметь права администратора.   >> Во избежание необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.   >> В Windows Vista привилегии пользователя определяются управления учетных записей (UAC). Если вы являетесь членом группы администраторов, вы присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора."
  syntax:
    content: public PerformanceCounter (string categoryName, string counterName, string instanceName);
    parameters:
    - id: categoryName
      type: System.String
      description: "Имя категории счетчика производительности (объект производительности), с которым связан этот счетчик производительности."
    - id: counterName
      type: System.String
      description: "Имя счетчика производительности."
    - id: instanceName
      type: System.String
      description: "Имя экземпляра категории счетчика производительности или пустая строка (&quot;»), если категория содержит единственный экземпляр."
  overload: System.Diagnostics.PerformanceCounter.#ctor*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>categoryName</code>является пустой строкой (»»).       - или - <code>counterName</code> — пустая строка (»»).       - или - указанная категория не является допустимым.       - или - категории, указанной помечается как нескольких экземпляров и требует создаваться с помощью имени экземпляра счетчика производительности.       - или - <code>instanceName</code> длиннее 127 символов.       - или - <code>categoryName</code> и <code>counterName</code> локализованные на разные языки."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>categoryName</code>or <code>counterName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при доступе к API-Интерфейсу системы."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Код, который выполняется без прав администратора попытка считывания значения счетчика производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.Boolean)
  id: '#ctor(System.String,System.String,System.String,System.Boolean)'
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: PerformanceCounter(String,String,String,Boolean)
  nameWithType: PerformanceCounter.PerformanceCounter(String,String,String,Boolean)
  fullName: System.Diagnostics.PerformanceCounter.PerformanceCounter(String,String,String,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Инициализирует новый, доступный только для чтения или чтения и записи экземпляра <xref href=&quot;System.Diagnostics.PerformanceCounter&quot;> </xref> класса и связывает его с указанной системы или экземпляр счетчиком производительности на локальном компьютере."
  remarks: "В строках параметров регистр не учитывается.       Используйте этот перегруженный метод для доступа к счетчику производительности в режиме только для чтения или в режиме чтения и записи.       Эта перегрузка конструктора задает <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>значения для свойств, передаваемому в его и наборы <xref:System.Diagnostics.PerformanceCounter.MachineName%2A>свойство на локальный компьютер «.».</xref:System.Diagnostics.PerformanceCounter.MachineName%2A> </xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> </xref:System.Diagnostics.PerformanceCounter.CounterName%2A> </xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>       Этот конструктор инициализирует счетчик производительности и связывает экземпляр с существующим счетчиком (системным или пользовательским счетчиком) на локальном компьютере. Значения, переданные <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, и <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>свойства должен указывать на существующий счетчик производительности на локальном компьютере.</xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> </xref:System.Diagnostics.PerformanceCounter.CounterName%2A> </xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> Если экземпляр счетчика производительности, указывающие на недопустим, вызов конструктора возникло исключение.      Настроек [!NOTE] настроек можно использовать эту перегрузку для подключения к системным счетчиком, но нельзя записывать в системный счетчик. Таким образом, задание `readOnly` для `false` при связи с системным счетчиком вызовет конструктор для создания исключения.       Чтобы создать экземпляр категории производительности, укажите `instanceName` на <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>конструктор.</xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> Если экземпляр категории, заданный параметром `instanceName` уже существует новый объект будет ссылаться на существующий экземпляр категории.      Настроек [!NOTE] настроек для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или иметь права администратора.   >> Во избежание необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.   >> В Windows Vista привилегии пользователя определяются управления учетных записей (UAC). Если вы являетесь членом группы администраторов, вы присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора."
  syntax:
    content: public PerformanceCounter (string categoryName, string counterName, string instanceName, bool readOnly);
    parameters:
    - id: categoryName
      type: System.String
      description: "Имя категории счетчика производительности (объект производительности), с которым связан этот счетчик производительности."
    - id: counterName
      type: System.String
      description: "Имя счетчика производительности."
    - id: instanceName
      type: System.String
      description: "Имя экземпляра категории счетчика производительности или пустая строка (&quot;»), если категория содержит единственный экземпляр."
    - id: readOnly
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>для доступа к счетчику в режиме только для чтения. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для доступа к счетчику в режиме чтения и записи."
  overload: System.Diagnostics.PerformanceCounter.#ctor*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>categoryName</code>является пустой строкой (»»).       - или - <code>counterName</code> — пустая строка (»»).       - или - запрошенные параметры настройки разрешения чтения и записи является недопустимым для этого счетчика.       Указанная категория не существует - или - (если <code>readOnly</code> — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>).       Указанная категория не является пользовательской категории .NET Framework - или - (если <code>readOnly</code> — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>).       - или - категории, указанной помечается как нескольких экземпляров и требует создаваться с помощью имени экземпляра счетчика производительности.       - или - <code>instanceName</code> длиннее 127 символов.       - или - <code>categoryName</code> и <code>counterName</code> локализованные на разные языки."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>categoryName</code>or <code>counterName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при доступе к API-Интерфейсу системы."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Код, который выполняется без прав администратора попытка считывания значения счетчика производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.String)
  id: '#ctor(System.String,System.String,System.String,System.String)'
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: PerformanceCounter(String,String,String,String)
  nameWithType: PerformanceCounter.PerformanceCounter(String,String,String,String)
  fullName: System.Diagnostics.PerformanceCounter.PerformanceCounter(String,String,String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Инициализирует новый, доступный только для чтения экземпляр <xref href=&quot;System.Diagnostics.PerformanceCounter&quot;> </xref> класса и связывает его с указанной системы или счетчиком экземпляр настраиваемого счетчика производительности, на указанном компьютере."
  remarks: "В строках параметров регистр не учитывается.       Эта перегрузка конструктора задает <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>и <xref:System.Diagnostics.PerformanceCounter.MachineName%2A>значения для свойств передать in.</xref:System.Diagnostics.PerformanceCounter.MachineName%2A> </xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> </xref:System.Diagnostics.PerformanceCounter.CounterName%2A> </xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>       Этот конструктор инициализирует счетчик производительности и связывает экземпляр с существующим счетчиком (системным или пользовательским счетчиком) на указанном компьютере. Значения, переданные <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>и <xref:System.Diagnostics.PerformanceCounter.MachineName%2A>свойства должен указывать на существующий счетчик производительности.</xref:System.Diagnostics.PerformanceCounter.MachineName%2A> </xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> </xref:System.Diagnostics.PerformanceCounter.CounterName%2A> </xref:System.Diagnostics.PerformanceCounter.CategoryName%2A> Если экземпляр счетчика производительности, которые указывают на недопустим, вызов конструктора возникло исключение. Эта перегрузка может получить доступ к любой доступный только для чтения или чтения и записи счетчик, но делает это в режиме только для чтения. Объект <xref:System.Diagnostics.PerformanceCounter>экземпляром, созданным с помощью этой перегрузки не удается записать в счетчик, даже если этот счетчик доступен для чтения и записи.</xref:System.Diagnostics.PerformanceCounter>      Настроек [!NOTE] настроек не удается записать в удаленные счетчики производительности. Нет ни одна перегрузка, которая позволяет указать экземпляр чтение и запись <xref:System.Diagnostics.PerformanceCounter>класс, который подключается к удаленному компьютеру.</xref:System.Diagnostics.PerformanceCounter>       Чтобы создать экземпляр категории производительности, укажите `instanceName` на <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>конструктор.</xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> Если экземпляр категории, заданный параметром `instanceName` уже существует новый объект будет ссылаться на существующий экземпляр категории.      Настроек [!NOTE] настроек для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или иметь права администратора.   >> Во избежание необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.   >> В Windows Vista привилегии пользователя определяются управления учетных записей (UAC). Если вы являетесь членом группы администраторов, вы присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора.      Настроек [!NOTE] настроек в Windows Vista, если удаленный компьютер является членом рабочей группы, может потребоваться отключить контроль учетных Записей, чтобы учетная запись локального пользователя не фильтруется и может быть повышена до учетной записи администратора. По соображениям безопасности Отключение контроля учетных Записей должно быть крайней необходимости. Сведения об отключении контроля учетных Записей см. в разделе [контроль учетных записей пользователей и WMI](http://go.microsoft.com/fwlink/?LinkId=91617)."
  syntax:
    content: public PerformanceCounter (string categoryName, string counterName, string instanceName, string machineName);
    parameters:
    - id: categoryName
      type: System.String
      description: "Имя категории счетчика производительности (объект производительности), с которым связан этот счетчик производительности."
    - id: counterName
      type: System.String
      description: "Имя счетчика производительности."
    - id: instanceName
      type: System.String
      description: "Имя экземпляра категории счетчика производительности или пустая строка (&quot;»), если категория содержит единственный экземпляр."
    - id: machineName
      type: System.String
      description: "Компьютер, на котором существует счетчик производительности и связанная с ним категория."
  overload: System.Diagnostics.PerformanceCounter.#ctor*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>categoryName</code>является пустой строкой (»»).       - или - <code>counterName</code> — пустая строка (»»).       - или - запрошенные параметры настройки разрешения чтения и записи является недопустимым для этого счетчика.       - или - счетчика не существует на указанном компьютере.       - или - категории, указанной помечается как нескольких экземпляров и требует создаваться с помощью имени экземпляра счетчика производительности.       - или - <code>instanceName</code> длиннее 127 символов.       - или - <code>categoryName</code> и <code>counterName</code> локализованные на разные языки."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code> Указан недопустимый параметр."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>categoryName</code>or <code>counterName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при доступе к API-Интерфейсу системы."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Код, который выполняется без прав администратора попытка считывания значения счетчика производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.BeginInit
  id: BeginInit
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: BeginInit()
  nameWithType: PerformanceCounter.BeginInit()
  fullName: System.Diagnostics.PerformanceCounter.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Начинает инициализацию <xref href=&quot;System.Diagnostics.PerformanceCounter&quot;> </xref> экземпляра, используемого в форме или другим компонентом. Инициализация происходит во время выполнения."
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] Разработки, этот метод применяется в среде для запуска инициализации компонента, используемого в форме или другим компонентом. <xref:System.Diagnostics.PerformanceCounter.EndInit%2A>Метод завершает инициализацию.</xref:System.Diagnostics.PerformanceCounter.EndInit%2A> С помощью BeginInit и <xref:System.Diagnostics.PerformanceCounter.EndInit%2A>методы предотвращает использование до полной инициализации компонента.</xref:System.Diagnostics.PerformanceCounter.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Diagnostics.PerformanceCounter.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.CategoryName
  id: CategoryName
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: CategoryName
  nameWithType: PerformanceCounter.CategoryName
  fullName: System.Diagnostics.PerformanceCounter.CategoryName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает имя категории счетчика производительности для счетчика производительности."
  remarks: "«Категория» отображается в `Performance Object` поле закладки диспетчера счетчиков производительности в `Add Counter` диалоговое окно.       Счетчик производительности следит за поведением категории, или объект производительности, на компьютере. Категории включают физические компоненты (такие как процессоры, диски и память) и системные объекты (например, процессы и потоки). Системные счетчики, которые относятся к тому же объекту производительности группируются в категорию, показывающую их общие цели. При создании экземпляра <xref:System.Diagnostics.PerformanceCounter>класса, сначала указывается категория, с которой данный компонент будет взаимодействовать и затем выбрать счетчик из этой категории.</xref:System.Diagnostics.PerformanceCounter>       Например одна категория счетчиков Windows является категория памяти. Системные счетчики в этой категории отслеживают памяти данные, такие как число доступных байтов и число байтов в кэше. Если требуется работать с байтами, кэшируются в приложении, необходимо создать экземпляр <xref:System.Diagnostics.PerformanceCounter>компонента, подключите его к категории памяти, а затем выбрать соответствующий счетчик (в данном случае кэшированных байтов) из этой категории.</xref:System.Diagnostics.PerformanceCounter>       Несмотря на то, что в системе доступно множество дополнительных категорий счетчиков, категории, которые будет осуществляться взаимодействие с наиболее часто являются категории кэша, памяти, объекты, физический диск, процесс, процессор, сервера, системы и потока."
  example:
  - "The following code example creates a default instance of the <xref:System.Diagnostics.PerformanceCounter> class. After the instance is created, the CategoryName, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, and <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A> property values are set, and the results of a call to the <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> method are displayed.  \n  \n [!code-cs[PerfCounter#1](~/add/codesnippet/csharp/p-system.diagnostics.per_6_1.cs)]\n [!code-cpp[PerfCounter#1](~/add/codesnippet/cpp/p-system.diagnostics.per_6_1.cpp)]\n [!code-vb[PerfCounter#1](~/add/codesnippet/visualbasic/p-system.diagnostics.per_6_1.vb)]"
  syntax:
    content: public string CategoryName { get; set; }
    return:
      type: System.String
      description: "Имя категории счетчика производительности (объект производительности), с которым связан этот счетчик производительности."
  overload: System.Diagnostics.PerformanceCounter.CategoryName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "«Категория» является <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.Close
  id: Close
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: Close()
  nameWithType: PerformanceCounter.Close()
  fullName: System.Diagnostics.PerformanceCounter.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Закрывает счетчик производительности и освобождает все ресурсы, выделенные под этот экземпляр счетчика производительности."
  remarks: "Если связать <xref:System.Diagnostics.PerformanceCounter>экземпляр счетчика производительности, который находится на сервере, система инициализирует экземпляр и выделяет память для хранения информации об образце счетчика.</xref:System.Diagnostics.PerformanceCounter> Метод Close освобождает ресурсы, выделенные объектом."
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.PerformanceCounter.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.CloseSharedResources
  id: CloseSharedResources
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: CloseSharedResources()
  nameWithType: PerformanceCounter.CloseSharedResources()
  fullName: System.Diagnostics.PerformanceCounter.CloseSharedResources()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Освобождает библиотеки общих состояние счетчика производительности, распределенное под счетчики."
  syntax:
    content: public static void CloseSharedResources ();
    parameters: []
  overload: System.Diagnostics.PerformanceCounter.CloseSharedResources*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.CounterHelp
  id: CounterHelp
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: CounterHelp
  nameWithType: PerformanceCounter.CounterHelp
  fullName: System.Diagnostics.PerformanceCounter.CounterHelp
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает описание для этого счетчика производительности."
  remarks: "Привязать диалоговое окно «Добавить счетчики» консоли MMC диспетчера счетчика производительности при отображении текста CounterHelp, когда пользователь выбирает счетчик из списка счетчиков и нажатии кнопки объяснить.       При создании нового счетчика, используйте CounterHelp текст для описания счетчика, чтобы пользователь мог определить, следует ли добавить счетчик системного монитора.      Настроек [!NOTE] настроек Если значение <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException>возникает исключение.</xref:System.InvalidOperationException> </xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>.</xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию.      Настроек [!NOTE] настроек для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или иметь права администратора.   >> Во избежание необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.   >> В Windows Vista привилегии пользователя определяются управления учетных записей (UAC). Если вы являетесь членом группы администраторов, вы присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора."
  syntax:
    content: public string CounterHelp { get; }
    return:
      type: System.String
      description: "Описание элемента или количества, которое измеряет этот счетчик производительности."
  overload: System.Diagnostics.PerformanceCounter.CounterHelp*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Diagnostics.PerformanceCounter&quot;> </xref> Экземпляра не связан со счетчиком производительности.       - или - <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>свойству <xref href=&quot;System.Diagnostics.PerformanceCounterInstanceLifetime&quot;> </xref> при использование глобальной общей памяти.</xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Код, который выполняется без прав администратора попытка считывания значения счетчика производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.CounterName
  id: CounterName
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: CounterName
  nameWithType: PerformanceCounter.CounterName
  fullName: System.Diagnostics.PerformanceCounter.CounterName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает имя объекта счетчика производительности, связанный с этим <xref href=&quot;System.Diagnostics.PerformanceCounter&quot;> </xref> экземпляра."
  remarks: "Список доступных готовых счетчиков можно получить из Windows производительности руководителя [диалоговое окно «Добавить счетчики»](http://go.microsoft.com/fwlink/p/?LinkId=257854)."
  example:
  - "The following code example shows how to set the CounterName property to a typical counter name.  \n  \n [!code-cs[PerfCounter#1](~/add/codesnippet/csharp/p-system.diagnostics.per_4_1.cs)]\n [!code-cpp[PerfCounter#1](~/add/codesnippet/cpp/p-system.diagnostics.per_4_1.cpp)]\n [!code-vb[PerfCounter#1](~/add/codesnippet/visualbasic/p-system.diagnostics.per_4_1.vb)]"
  syntax:
    content: public string CounterName { get; set; }
    return:
      type: System.String
      description: "Имя счетчика, который описывает подсчета количества. Это имя будет отображаться в списке счетчиков диспетчера счетчиков производительности MMC оснастку, диалоговое окно «Добавить счетчики»."
  overload: System.Diagnostics.PerformanceCounter.CounterName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "— CounterName <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.CounterType
  id: CounterType
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: CounterType
  nameWithType: PerformanceCounter.CounterType
  fullName: System.Diagnostics.PerformanceCounter.CounterType
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает тип счетчика связанного счетчика производительности."
  remarks: "<xref:System.Diagnostics.PerformanceCounterType>Перечисление содержит видов счетчиков производительности, которые вы можете взаимодействовать с.</xref:System.Diagnostics.PerformanceCounterType> Некоторые типы счетчиков представляют вычисляемые значения, например среднее из измерений счетчика, взятых системой. Другие типы представляют начальное или не рассчитанное значения. В следующей таблице показаны типы счетчиков, которые будут взаимодействовать с наиболее часто.      | Ответственность счетчика | Значение типа счетчика производительности | Пример |   |------------------------------|----------------------------------|-------------|   | Подсчет элементов или операций. | `NumberOfItems32`| Отслеживание числа полученных заказов в виде 32-разрядное целое число. |   | Подсчет пропускную способность. | `NumberOfItems64`| Отслеживать количество заказов на узел с высокой нагрузкой, хранятся в виде 64-разрядное целое число. |   | Отслеживать количество элементов или операций в секунду. | `RateOfCountsPerSecond32`| Отслеживание заказов, получаемых в секунду на сайте. |   | Отслеживать пропускную способность количество элементов или операций в секунду. | `RateOfCountsPerSecond64`| Отслеживание заказов, получаемых в секунду на узел с высокой нагрузкой. |   | Подсчитывать среднее время для выполнения процесса или для обработки элемента | `AverageTimer32`| Вычислить среднее время заказа должен быть обработан. |       При создании счетчика, тип которого требует использования соответствующего базового счетчика, необходимо объявить счетчик и базу в <xref:System.Diagnostics.CounterCreationDataCollection>передачи в <xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=fullName>метод.</xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=fullName> </xref:System.Diagnostics.CounterCreationDataCollection>      Настроек [!NOTE] настроек Если значение <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException>возникает исключение.</xref:System.InvalidOperationException> </xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>.</xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию.      Настроек [!NOTE] настроек для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или иметь права администратора.   >> Во избежание необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.   >> В Windows Vista привилегии пользователя определяются управления учетных записей (UAC). Если вы являетесь членом группы администраторов, вы присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора."
  syntax:
    content: public System.Diagnostics.PerformanceCounterType CounterType { get; }
    return:
      type: System.Diagnostics.PerformanceCounterType
      description: "Объект <xref href=&quot;System.Diagnostics.PerformanceCounterType&quot;> </xref> , описывающий, как взаимодействие с наблюдение за приложением и характер содержащихся в нем значений счетчика (например, подсчитано или не подсчитано)."
  overload: System.Diagnostics.PerformanceCounter.CounterType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Экземпляр не был правильно связан со счетчиком производительности.       - или - <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>свойству <xref href=&quot;System.Diagnostics.PerformanceCounterInstanceLifetime&quot;> </xref> при использование глобальной общей памяти.</xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Код, который выполняется без прав администратора попытка считывания значения счетчика производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.Decrement
  id: Decrement
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: Decrement()
  nameWithType: PerformanceCounter.Decrement()
  fullName: System.Diagnostics.PerformanceCounter.Decrement()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Уменьшает значение счетчика производительности на единицу посредством эффективной атомарной операции."
  remarks: "Можно записать только в пользовательские счетчики. Все системные счетчики доступны только для чтения.      Настроек [!NOTE] настроек <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, и методы декремента используйте блокировка для обновления значения счетчика.</xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> </xref:System.Diagnostics.PerformanceCounter.Increment%2A> Это помогает сохранять значение счетчика точным во многопоточных или многопроцессных скриптах, но приводит также к снижению производительности. Если не требуется точность, заблокированную операций предоставления, можно обновить <xref:System.Diagnostics.PerformanceCounter.RawValue%2A>свойство непосредственно до 5 раз улучшение производительности.</xref:System.Diagnostics.PerformanceCounter.RawValue%2A>  Однако в сценариях с несколькими потоками, некоторые обновления значения счетчика могут игнорироваться, приводя к неточным данным.      Настроек [!NOTE] настроек Если значение <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException>возникает исключение.</xref:System.InvalidOperationException> </xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>.</xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию."
  syntax:
    content: public long Decrement ();
    parameters: []
    return:
      type: System.Int64
      description: "Значение счетчика уменьшается на единицу."
  overload: System.Diagnostics.PerformanceCounter.Decrement*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Счетчик доступен только для чтения, поэтому приложение не может уменьшить его.       - или - экземпляр не был правильно связан со счетчиком производительности.       - или - <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>свойству <xref href=&quot;System.Diagnostics.PerformanceCounterInstanceLifetime&quot;> </xref> при использование глобальной общей памяти.</xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при доступе к API-Интерфейсу системы."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.DefaultFileMappingSize
  id: DefaultFileMappingSize
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: DefaultFileMappingSize
  nameWithType: PerformanceCounter.DefaultFileMappingSize
  fullName: System.Diagnostics.PerformanceCounter.DefaultFileMappingSize
  type: Field
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Размер в байтах глобальной памяти, совместно используемой счетчиками производительности. Значение по умолчанию-524 288 байт."
  syntax:
    content: public static int DefaultFileMappingSize;
    return:
      type: System.Int32
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: PerformanceCounter.Dispose(Boolean)
  fullName: System.Diagnostics.PerformanceCounter.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "Для добавления."
  overload: System.Diagnostics.PerformanceCounter.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.EndInit
  id: EndInit
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: EndInit()
  nameWithType: PerformanceCounter.EndInit()
  fullName: System.Diagnostics.PerformanceCounter.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Завершает инициализацию <xref href=&quot;System.Diagnostics.PerformanceCounter&quot;> </xref> экземпляра, используемого в форме или другим компонентом. Инициализация происходит во время выполнения."
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] Разработки, среда использует этот метод для завершения инициализации компонента, используемого в форме или другим компонентом. <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A>Метод начинает инициализацию.</xref:System.Diagnostics.PerformanceCounter.BeginInit%2A> С помощью <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A>и методы EndInit предотвращает использование до полной инициализации компонента.</xref:System.Diagnostics.PerformanceCounter.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Diagnostics.PerformanceCounter.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.Increment
  id: Increment
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: Increment()
  nameWithType: PerformanceCounter.Increment()
  fullName: System.Diagnostics.PerformanceCounter.Increment()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Увеличивает значение связанного счетчика производительности на единицу посредством эффективной атомарной операции."
  remarks: "Можно записать только в пользовательские счетчики. Все системные счетчики доступны только для чтения.      Настроек [!NOTE] настроек приращения <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, и <xref:System.Diagnostics.PerformanceCounter.Decrement%2A>методы используют блокировка для обновления значения счетчика.</xref:System.Diagnostics.PerformanceCounter.Decrement%2A> </xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> Это помогает сохранять значение счетчика точным во многопоточных или многопроцессных скриптах, но приводит также к снижению производительности. Если не требуется точность, заблокированную операций предоставления, можно обновить <xref:System.Diagnostics.PerformanceCounter.RawValue%2A>свойство непосредственно до 5 раз улучшение производительности.</xref:System.Diagnostics.PerformanceCounter.RawValue%2A>  Однако в сценариях с несколькими потоками, некоторые обновления значения счетчика могут игнорироваться, приводя к неточным данным.      Настроек [!NOTE] настроек Если значение <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException>возникает исключение.</xref:System.InvalidOperationException> </xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>.</xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию."
  syntax:
    content: public long Increment ();
    parameters: []
    return:
      type: System.Int64
      description: "Увеличенное значение счетчика."
  overload: System.Diagnostics.PerformanceCounter.Increment*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Счетчик доступен только для чтения, поэтому приложение не может увеличить его.       - или - экземпляр не был правильно связан со счетчиком производительности.       - или - <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>свойству <xref href=&quot;System.Diagnostics.PerformanceCounterInstanceLifetime&quot;> </xref> при использование глобальной общей памяти.</xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при доступе к API-Интерфейсу системы."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.IncrementBy(System.Int64)
  id: IncrementBy(System.Int64)
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: IncrementBy(Int64)
  nameWithType: PerformanceCounter.IncrementBy(Int64)
  fullName: System.Diagnostics.PerformanceCounter.IncrementBy(Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Увеличивает или уменьшает значение счетчика производительности на заданную величину посредством эффективной атомарной операции."
  remarks: "Можно записать только в пользовательские счетчики. Все системные счетчики доступны только для чтения.      Настроек [!NOTE] настроек <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, IncrementBy, и <xref:System.Diagnostics.PerformanceCounter.Decrement%2A>методы используют блокировка для обновления значения счетчика.</xref:System.Diagnostics.PerformanceCounter.Decrement%2A> </xref:System.Diagnostics.PerformanceCounter.Increment%2A> Это помогает сохранять значение счетчика точным во многопоточных или многопроцессных скриптах, но приводит также к снижению производительности. Если не требуется точность, заблокированную операций предоставления, можно обновить <xref:System.Diagnostics.PerformanceCounter.RawValue%2A>свойство непосредственно до 5 раз улучшение производительности.</xref:System.Diagnostics.PerformanceCounter.RawValue%2A>  Однако в сценариях с несколькими потоками, некоторые обновления значения счетчика могут игнорироваться, приводя к неточным данным.      Настроек [!NOTE] настроек Если значение <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException>возникает исключение.</xref:System.InvalidOperationException> </xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>.</xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию."
  example:
  - "The following code example demonstrates how to use the IncrementBy method to add increments to a counter. This code example is part of a larger example for the <xref:System.Diagnostics.PerformanceCounter> class.  \n  \n [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/add/codesnippet/cpp/m-system.diagnostics.per_2_1.cpp)]\n [!code-cs[PerformanceCounterType.AverageCounter64#3](~/add/codesnippet/csharp/m-system.diagnostics.per_2_1.cs)]\n [!code-vb[PerformanceCounterType.AverageCounter64#3](~/add/codesnippet/visualbasic/m-system.diagnostics.per_2_1.vb)]"
  syntax:
    content: public long IncrementBy (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "Увеличиваемое значение. (Отрицательное значение уменьшает счетчик.)"
    return:
      type: System.Int64
      description: "Новое значение счетчика."
  overload: System.Diagnostics.PerformanceCounter.IncrementBy*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Счетчик доступен только для чтения, поэтому приложение не может увеличить его.       - или - экземпляр не был правильно связан со счетчиком производительности.       - или - <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>свойству <xref href=&quot;System.Diagnostics.PerformanceCounterInstanceLifetime&quot;> </xref> при использование глобальной общей памяти.</xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при доступе к API-Интерфейсу системы."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.InstanceLifetime
  id: InstanceLifetime
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: InstanceLifetime
  nameWithType: PerformanceCounter.InstanceLifetime
  fullName: System.Diagnostics.PerformanceCounter.InstanceLifetime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает время существования процесса."
  remarks: "Если категория счетчиков производительности создается с платформой .NET Framework версии 1.0 или 1.1, она использует глобальную общую память, а значение свойством InstanceLifetime должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>.</xref:System.Diagnostics.PerformanceCounterInstanceLifetime> Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию.      Настроек [!NOTE] настроек Если значение <xref:System.Diagnostics.PerformanceCounter.CounterType%2A>задано <xref:System.Diagnostics.PerformanceCounterCategoryType>, значение счетчика производительности свойством InstanceLifetime должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>.</xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounterCategoryType> </xref:System.Diagnostics.PerformanceCounter.CounterType%2A>"
  syntax:
    content: public System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime { get; set; }
    return:
      type: System.Diagnostics.PerformanceCounterInstanceLifetime
      description: "Один из <xref href=&quot;System.Diagnostics.PerformanceCounterInstanceLifetime&quot;> </xref> значения. Значение по умолчанию — <xref href=&quot;System.Diagnostics.PerformanceCounterInstanceLifetime&quot;> </xref>."
  overload: System.Diagnostics.PerformanceCounter.InstanceLifetime*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Заданное значение не является членом <xref href=&quot;System.Diagnostics.PerformanceCounterInstanceLifetime&quot;> </xref> перечисления."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "После задается свойством InstanceLifetime <xref href=&quot;System.Diagnostics.PerformanceCounter&quot;> </xref> был инициализирован."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.InstanceName
  id: InstanceName
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: InstanceName
  nameWithType: PerformanceCounter.InstanceName
  fullName: System.Diagnostics.PerformanceCounter.InstanceName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает имя экземпляра для этого счетчика производительности."
  remarks: "> [!NOTE]\n>  Instance names must be shorter than 128 characters in length.  \n  \n In some situations, categories are subdivided into instances, which track data about multiple occurrences of the object that a category relates to. Instances apply to the category as whole, rather than to individual counters. Every counter within a category has each instance defined for the category. For example, the Process category contains instances named Idle and System. Every counter within the Process category thus contains data for each instance, showing information about either idle processes or system processes.  \n  \n Many categories do not contain multiple instances, so you can leave this property empty to indicate that no instance is associated with the category.  \n  \n If this <xref:System.Diagnostics.PerformanceCounter> instance points to a noncustom category, you can choose from only the existing category instances. You can create new category instances only in custom categories, which allow you to define as many counters and category instances as you need.  \n  \n To create a performance category instance, specify an `instanceName` on the <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> constructor. If the category instance specified by `instanceName` already exists the new object will reference the existing category instance.  \n  \n> [!NOTE]\n>  Do not use the characters \"(\", \")\", \"#\", \"\\\\\", or \"/\" in the instance name. If any of these characters are used, the Performance Console (see [Runtime Profiling](~/add/includes/ajax-current-ext-md.md)) may not correctly display the instance values.  \n  \n If the instance name is automatically generated and might contain the characters \"(\", \")\", \"#\", \"\\\\\", or \"/\", use the character mapping in the following table.  \n  \n|Character|Mapped character|  \n|---------------|----------------------|  \n|(|[|  \n|)|]|  \n|#|_|  \n|\\|_|  \n|/|_|  \n  \n The <xref:System.AppDomain.FriendlyName%2A> property of the <xref:System.AppDomain> object obtained from the <xref:System.AppDomain.CurrentDomain%2A?displayProperty=fullName> property is a common source of instance names that can contain invalid characters."
  example:
  - "The following code example creates a default instance of the <xref:System.Diagnostics.PerformanceCounter> class. After the instance is created, the <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>, <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>, and InstanceName property values are set, and the results of a call to the <xref:System.Diagnostics.PerformanceCounter.NextValue%2A> method are displayed.  \n  \n [!code-cs[PerfCounter#1](~/add/codesnippet/csharp/p-system.diagnostics.per_0_1.cs)]\n [!code-cpp[PerfCounter#1](~/add/codesnippet/cpp/p-system.diagnostics.per_0_1.cpp)]\n [!code-vb[PerfCounter#1](~/add/codesnippet/visualbasic/p-system.diagnostics.per_0_1.vb)]"
  syntax:
    content: public string InstanceName { get; set; }
    return:
      type: System.String
      description: "Имя экземпляра категории счетчика производительности или пустая строка (&quot;»), если счетчик экземпляра счетчика."
  overload: System.Diagnostics.PerformanceCounter.InstanceName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.MachineName
  id: MachineName
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: MachineName
  nameWithType: PerformanceCounter.MachineName
  fullName: System.Diagnostics.PerformanceCounter.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает имя компьютера для этого счетчика производительности."
  remarks: "Можно записывать значения только в те счетчики, которые находятся на локальном компьютере. Тем не менее можно считывать значения счетчиков, с любого компьютера, на предприятии, для которого имеются права доступа.       При установке свойства MachineName, чтобы он указывал на удаленный компьютер <xref:System.Diagnostics.PerformanceCounter>экземпляр пытается открыть счетчика на этом компьютере.</xref:System.Diagnostics.PerformanceCounter> Если значение счетчика не существует, задание этого свойства создает исключение."
  syntax:
    content: public string MachineName { get; set; }
    return:
      type: System.String
      description: "Сервер, на котором находятся счетчик производительности и связанная с ним категория."
  overload: System.Diagnostics.PerformanceCounter.MachineName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Недопустимый формат MachineName."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.NextSample
  id: NextSample
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: NextSample()
  nameWithType: PerformanceCounter.NextSample()
  fullName: System.Diagnostics.PerformanceCounter.NextSample()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает образец счетчика и возвращает начальное или не рассчитанное значение для него."
  remarks: "Этот метод обычно используется для счетчиков, содержащих невычисляемые значения.      Настроек [!NOTE] настроек Если значение <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException>возникает исключение.</xref:System.InvalidOperationException> </xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>.</xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию.      Настроек [!NOTE] настроек для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или иметь права администратора.   >> Во избежание необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.   >> В Windows Vista привилегии пользователя определяются управления учетных записей (UAC). Если вы являетесь членом группы администраторов, вы присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора."
  example:
  - "The following code example demonstrates how to use the NextSample method to obtain the next uncalculated value of a counter. This code example is part of a larger example for the <xref:System.Diagnostics.PerformanceCounter> class.  \n  \n [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/add/codesnippet/cpp/m-system.diagnostics.per_13_1.cpp)]\n [!code-cs[PerformanceCounterType.AverageCounter64#3](~/add/codesnippet/csharp/m-system.diagnostics.per_13_1.cs)]\n [!code-vb[PerformanceCounterType.AverageCounter64#3](~/add/codesnippet/visualbasic/m-system.diagnostics.per_13_1.vb)]"
  syntax:
    content: public System.Diagnostics.CounterSample NextSample ();
    parameters: []
    return:
      type: System.Diagnostics.CounterSample
      description: "Объект <xref href=&quot;System.Diagnostics.CounterSample&quot;> </xref> , представляющий следующее необработанное значение, которое система получает для этого счетчика."
  overload: System.Diagnostics.PerformanceCounter.NextSample*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Экземпляр не был правильно связан со счетчиком производительности.       - или - <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>свойству <xref href=&quot;System.Diagnostics.PerformanceCounterInstanceLifetime&quot;> </xref> при использование глобальной общей памяти.</xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при доступе к API-Интерфейсу системы."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Код, который выполняется без прав администратора попытка считывания значения счетчика производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.NextValue
  id: NextValue
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: NextValue()
  nameWithType: PerformanceCounter.NextValue()
  fullName: System.Diagnostics.PerformanceCounter.NextValue()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает образец счетчика и возвращает значение, вычисленное для него."
  remarks: "> [!NOTE]Настроек Если вычисленное значение счетчика зависит от двух операций считывания, первая операция чтения возвращает 0,0. Сброс свойств счетчика производительности для указания другого счетчика равнозначен созданию нового счетчика производительности, и первая операция считывания с помощью новых свойств возвращает 0,0. Рекомендуемые задержка между вызовами метода NextValue составляет одну секунду, чтобы разрешить счетчик для выполнения следующего добавочного чтения.      Настроек [!NOTE] настроек для чтения данных счетчиков производительности, необходимо иметь права администратора. В Windows Vista привилегии пользователя определяются управления учетных записей (UAC). Если вы являетесь членом группы администраторов, вы присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора."
  example:
  - "The following code example creates an <xref:System.Diagnostics.PerformanceCounterType> counter and uses the NextValue method to display the counter's values over a time period.  \n  \n [!code-cs[PerformanceCounterType.ElapsedTime#2](~/add/codesnippet/csharp/m-system.diagnostics.per_12_1.cs)]\n [!code-cpp[PerformanceCounterType.ElapsedTime#2](~/add/codesnippet/cpp/m-system.diagnostics.per_12_1.cpp)]\n [!code-vb[PerformanceCounterType.ElapsedTime#2](~/add/codesnippet/visualbasic/m-system.diagnostics.per_12_1.vb)]"
  syntax:
    content: public float NextValue ();
    parameters: []
    return:
      type: System.Single
      description: "Далее вычисленное значение, которое система получает для этого счетчика."
  overload: System.Diagnostics.PerformanceCounter.NextValue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Экземпляр не был правильно связан со счетчиком производительности."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при доступе к API-Интерфейсу системы."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Код, который выполняется без прав администратора попытка считывания значения счетчика производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.RawValue
  id: RawValue
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: RawValue
  nameWithType: PerformanceCounter.RawValue
  fullName: System.Diagnostics.PerformanceCounter.RawValue
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает начальное или не рассчитанное значение этого счетчика."
  remarks: "Если тип счетчика является 32-битным, произведена попытка задать этому свойству значение, слишком велик для свойства усекает значение до 32 бит. При чтении счетчиков на локальном компьютере, с помощью RawValue свойства, а не значение, вычисленное может привести к значительно более высокую производительность в сценариях, где необработанное значение является достаточным.       Если счетчик, который вы читаете доступна только для чтения, при получении свойства RawValue выборку счетчика во время вызова свойства. Это действие эквивалентно начальному вызову <xref:System.Diagnostics.PerformanceCounter.NextSample%2A>метод.</xref:System.Diagnostics.PerformanceCounter.NextSample%2A> Если впоследствии вызвать <xref:System.Diagnostics.PerformanceCounter.NextSample%2A>, можно производить вычисления над значениями, которые возвращены оба вызова.</xref:System.Diagnostics.PerformanceCounter.NextSample%2A>       Поскольку системные счетчики доступны только для чтения, можно получить, но не устанавливать их начальных значений.      Настроек [!NOTE] настроек <xref:System.Diagnostics.PerformanceCounter.Increment%2A>, <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>, и <xref:System.Diagnostics.PerformanceCounter.Decrement%2A>методы используют блокировка для обновления значения счетчика.</xref:System.Diagnostics.PerformanceCounter.Decrement%2A> </xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A> </xref:System.Diagnostics.PerformanceCounter.Increment%2A> Это помогает сохранять значение счетчика точным во многопоточных или многопроцессных скриптах, но приводит также к снижению производительности. Если не требуется точность, заблокированную операции дают, можно обновить свойства RawValue непосредственно для не более 5 раз улучшения производительности.  Однако в сценариях с несколькими потоками, некоторые обновления значения счетчика могут игнорироваться, приводя к неточным данным.      Настроек [!NOTE] настроек Если значение <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException>возникает исключение.</xref:System.InvalidOperationException> </xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>.</xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию.      Настроек [!NOTE] настроек для чтения данных счетчиков производительности в Windows Vista, Windows XP Professional x64 Edition или Windows Server 2003, необходимо быть членом группы пользователей системного монитора или иметь права администратора.   >> Во избежание необходимости повысить права доступа для доступа к счетчикам производительности в Windows Vista, добавьте себя в группу пользователей монитора производительности.   >> В Windows Vista привилегии пользователя определяются управления учетных записей (UAC). Если вы являетесь членом группы администраторов, вы присваивается два маркера доступа на время выполнения: маркер доступа обычного пользователя и маркер доступа администратора. По умолчанию назначена роль обычного пользователя. Для выполнения кода, который обращается к счетчикам производительности, необходимо сначала повысить права доступа со стандартного пользователя до администратора. Это можно сделать при запуске приложения, щелкнув значок приложения правой кнопкой мыши и указав, что приложение должно запускаться от имени администратора."
  example:
  - "The following example uses the <xref:System.Diagnostics.CounterSample> class to display the value of the RawValue property for a counter.  \n  \n [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/add/codesnippet/cpp/p-system.diagnostics.per_2_1.cpp)]\n [!code-cs[PerformanceCounterType.AverageCounter64#1](~/add/codesnippet/csharp/p-system.diagnostics.per_2_1.cs)]\n [!code-vb[PerformanceCounterType.AverageCounter64#1](~/add/codesnippet/visualbasic/p-system.diagnostics.per_2_1.vb)]"
  syntax:
    content: public long RawValue { get; set; }
    return:
      type: System.Int64
      description: "Необработанное значение счетчика."
  overload: System.Diagnostics.PerformanceCounter.RawValue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Вы пытаетесь установить начальное значение счетчика, но счетчик доступен только для чтения.       - или - экземпляр не был правильно связан со счетчиком производительности.       - или - <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>свойству <xref href=&quot;System.Diagnostics.PerformanceCounterInstanceLifetime&quot;> </xref> при использование глобальной общей памяти.</xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при доступе к API-Интерфейсу системы."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "Код, который выполняется без прав администратора попытка считывания значения счетчика производительности."
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.ReadOnly
  id: ReadOnly
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: ReadOnly
  nameWithType: PerformanceCounter.ReadOnly
  fullName: System.Diagnostics.PerformanceCounter.ReadOnly
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает значение, указывающее, является ли это <xref href=&quot;System.Diagnostics.PerformanceCounter&quot;> </xref> экземпляр находится в режиме только для чтения."
  remarks: "Для системного счетчика всегда должна ReadOnly `true`. Не удалось записать системные счетчики."
  syntax:
    content: public bool ReadOnly { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>, если <xref href=&quot;System.Diagnostics.PerformanceCounter&quot;> </xref> экземпляр находится в режиме только для чтения (даже если сам счетчик является счетчиком .NET Framework); <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> если он находится в режиме чтения и записи. Значение по умолчанию является значение, заданное конструктором."
  overload: System.Diagnostics.PerformanceCounter.ReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.PerformanceCounter.RemoveInstance
  id: RemoveInstance
  parent: System.Diagnostics.PerformanceCounter
  langs:
  - csharp
  name: RemoveInstance()
  nameWithType: PerformanceCounter.RemoveInstance()
  fullName: System.Diagnostics.PerformanceCounter.RemoveInstance()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Удаляет экземпляр категории, указанной по <xref href=&quot;System.Diagnostics.PerformanceCounter&quot;> </xref> объекта <xref:System.Diagnostics.PerformanceCounter.InstanceName*>свойство.</xref:System.Diagnostics.PerformanceCounter.InstanceName*>"
  remarks: "Можно удалить экземпляр только для пользовательских счетчиков. Все системные счетчики доступны только для чтения, поэтому попытка удалить один из них вызовет исключение.      Настроек [!NOTE] настроек во избежание возникновения состояния гонки при освобождении памяти общий счетчик производительности, рекомендуется, что вызвать метод RemoveInstance из <xref:System.AppDomain.DomainUnload>обработчика событий.</xref:System.AppDomain.DomainUnload>       Чтобы создать экземпляр категории производительности, укажите `instanceName` на <xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>конструктор.</xref:System.Diagnostics.PerformanceCounter.%23ctor%2A> Если экземпляр категории, заданный параметром `instanceName` уже существует новый объект будет ссылаться на существующий экземпляр категории.      Настроек [!NOTE] настроек Если значение <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>свойство <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>и была создана категория счетчиков производительности с .NET Framework версии 1.0 или 1.1, <xref:System.InvalidOperationException>возникает исключение.</xref:System.InvalidOperationException> </xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Категории счетчиков производительности, созданных с помощью более ранних версий использовать глобальную общую память, а значение для <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>должен быть <xref:System.Diagnostics.PerformanceCounterInstanceLifetime>.</xref:System.Diagnostics.PerformanceCounterInstanceLifetime> </xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A> Если категории не используется приложениями, выполняемыми в версиях 1.0 и 1.1 платформы .NET Framework, удалите и заново создать категорию."
  syntax:
    content: public void RemoveInstance ();
    parameters: []
  overload: System.Diagnostics.PerformanceCounter.RemoveInstance*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Этот счетчик доступен только для чтения, поэтому невозможно удалить все экземпляры, связанные с категорией.       - или - экземпляр не был правильно связан со счетчиком производительности.       - или - <xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>свойству <xref href=&quot;System.Diagnostics.PerformanceCounterInstanceLifetime&quot;> </xref> при использование глобальной общей памяти.</xref:System.Diagnostics.PerformanceCounter.InstanceLifetime*>"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Произошла ошибка при доступе к API-Интерфейсу системы."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition (Me), которая не поддерживает счетчики производительности."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Diagnostics.PerformanceCounter.#ctor
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: PerformanceCounter()
  nameWithType: PerformanceCounter.PerformanceCounter()
  fullName: System.Diagnostics.PerformanceCounter.PerformanceCounter()
- uid: System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String)
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: PerformanceCounter(String,String)
  nameWithType: PerformanceCounter.PerformanceCounter(String,String)
  fullName: System.Diagnostics.PerformanceCounter.PerformanceCounter(String,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.Boolean)
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: PerformanceCounter(String,String,Boolean)
  nameWithType: PerformanceCounter.PerformanceCounter(String,String,Boolean)
  fullName: System.Diagnostics.PerformanceCounter.PerformanceCounter(String,String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String)
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: PerformanceCounter(String,String,String)
  nameWithType: PerformanceCounter.PerformanceCounter(String,String,String)
  fullName: System.Diagnostics.PerformanceCounter.PerformanceCounter(String,String,String)
- uid: System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.Boolean)
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: PerformanceCounter(String,String,String,Boolean)
  nameWithType: PerformanceCounter.PerformanceCounter(String,String,String,Boolean)
  fullName: System.Diagnostics.PerformanceCounter.PerformanceCounter(String,String,String,Boolean)
- uid: System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.String)
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: PerformanceCounter(String,String,String,String)
  nameWithType: PerformanceCounter.PerformanceCounter(String,String,String,String)
  fullName: System.Diagnostics.PerformanceCounter.PerformanceCounter(String,String,String,String)
- uid: System.Diagnostics.PerformanceCounter.BeginInit
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: BeginInit()
  nameWithType: PerformanceCounter.BeginInit()
  fullName: System.Diagnostics.PerformanceCounter.BeginInit()
- uid: System.Diagnostics.PerformanceCounter.CategoryName
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: CategoryName
  nameWithType: PerformanceCounter.CategoryName
  fullName: System.Diagnostics.PerformanceCounter.CategoryName
- uid: System.Diagnostics.PerformanceCounter.Close
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: Close()
  nameWithType: PerformanceCounter.Close()
  fullName: System.Diagnostics.PerformanceCounter.Close()
- uid: System.Diagnostics.PerformanceCounter.CloseSharedResources
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: CloseSharedResources()
  nameWithType: PerformanceCounter.CloseSharedResources()
  fullName: System.Diagnostics.PerformanceCounter.CloseSharedResources()
- uid: System.Diagnostics.PerformanceCounter.CounterHelp
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: CounterHelp
  nameWithType: PerformanceCounter.CounterHelp
  fullName: System.Diagnostics.PerformanceCounter.CounterHelp
- uid: System.Diagnostics.PerformanceCounter.CounterName
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: CounterName
  nameWithType: PerformanceCounter.CounterName
  fullName: System.Diagnostics.PerformanceCounter.CounterName
- uid: System.Diagnostics.PerformanceCounter.CounterType
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: CounterType
  nameWithType: PerformanceCounter.CounterType
  fullName: System.Diagnostics.PerformanceCounter.CounterType
- uid: System.Diagnostics.PerformanceCounterType
  parent: System.Diagnostics
  isExternal: false
  name: PerformanceCounterType
  nameWithType: PerformanceCounterType
  fullName: System.Diagnostics.PerformanceCounterType
- uid: System.Diagnostics.PerformanceCounter.Decrement
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: Decrement()
  nameWithType: PerformanceCounter.Decrement()
  fullName: System.Diagnostics.PerformanceCounter.Decrement()
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.PerformanceCounter.DefaultFileMappingSize
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: DefaultFileMappingSize
  nameWithType: PerformanceCounter.DefaultFileMappingSize
  fullName: System.Diagnostics.PerformanceCounter.DefaultFileMappingSize
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.PerformanceCounter.Dispose(System.Boolean)
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: PerformanceCounter.Dispose(Boolean)
  fullName: System.Diagnostics.PerformanceCounter.Dispose(Boolean)
- uid: System.Diagnostics.PerformanceCounter.EndInit
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: EndInit()
  nameWithType: PerformanceCounter.EndInit()
  fullName: System.Diagnostics.PerformanceCounter.EndInit()
- uid: System.Diagnostics.PerformanceCounter.Increment
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: Increment()
  nameWithType: PerformanceCounter.Increment()
  fullName: System.Diagnostics.PerformanceCounter.Increment()
- uid: System.Diagnostics.PerformanceCounter.IncrementBy(System.Int64)
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: IncrementBy(Int64)
  nameWithType: PerformanceCounter.IncrementBy(Int64)
  fullName: System.Diagnostics.PerformanceCounter.IncrementBy(Int64)
- uid: System.Diagnostics.PerformanceCounter.InstanceLifetime
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: InstanceLifetime
  nameWithType: PerformanceCounter.InstanceLifetime
  fullName: System.Diagnostics.PerformanceCounter.InstanceLifetime
- uid: System.Diagnostics.PerformanceCounterInstanceLifetime
  parent: System.Diagnostics
  isExternal: false
  name: PerformanceCounterInstanceLifetime
  nameWithType: PerformanceCounterInstanceLifetime
  fullName: System.Diagnostics.PerformanceCounterInstanceLifetime
- uid: System.Diagnostics.PerformanceCounter.InstanceName
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: InstanceName
  nameWithType: PerformanceCounter.InstanceName
  fullName: System.Diagnostics.PerformanceCounter.InstanceName
- uid: System.Diagnostics.PerformanceCounter.MachineName
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: MachineName
  nameWithType: PerformanceCounter.MachineName
  fullName: System.Diagnostics.PerformanceCounter.MachineName
- uid: System.Diagnostics.PerformanceCounter.NextSample
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: NextSample()
  nameWithType: PerformanceCounter.NextSample()
  fullName: System.Diagnostics.PerformanceCounter.NextSample()
- uid: System.Diagnostics.CounterSample
  parent: System.Diagnostics
  isExternal: false
  name: CounterSample
  nameWithType: CounterSample
  fullName: System.Diagnostics.CounterSample
- uid: System.Diagnostics.PerformanceCounter.NextValue
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: NextValue()
  nameWithType: PerformanceCounter.NextValue()
  fullName: System.Diagnostics.PerformanceCounter.NextValue()
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Diagnostics.PerformanceCounter.RawValue
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: RawValue
  nameWithType: PerformanceCounter.RawValue
  fullName: System.Diagnostics.PerformanceCounter.RawValue
- uid: System.Diagnostics.PerformanceCounter.ReadOnly
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: ReadOnly
  nameWithType: PerformanceCounter.ReadOnly
  fullName: System.Diagnostics.PerformanceCounter.ReadOnly
- uid: System.Diagnostics.PerformanceCounter.RemoveInstance
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: RemoveInstance()
  nameWithType: PerformanceCounter.RemoveInstance()
  fullName: System.Diagnostics.PerformanceCounter.RemoveInstance()
- uid: System.Diagnostics.PerformanceCounter.#ctor*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: PerformanceCounter
  nameWithType: PerformanceCounter.PerformanceCounter
- uid: System.Diagnostics.PerformanceCounter.BeginInit*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: BeginInit
  nameWithType: PerformanceCounter.BeginInit
- uid: System.Diagnostics.PerformanceCounter.CategoryName*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: CategoryName
  nameWithType: PerformanceCounter.CategoryName
- uid: System.Diagnostics.PerformanceCounter.Close*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: Close
  nameWithType: PerformanceCounter.Close
- uid: System.Diagnostics.PerformanceCounter.CloseSharedResources*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: CloseSharedResources
  nameWithType: PerformanceCounter.CloseSharedResources
- uid: System.Diagnostics.PerformanceCounter.CounterHelp*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: CounterHelp
  nameWithType: PerformanceCounter.CounterHelp
- uid: System.Diagnostics.PerformanceCounter.CounterName*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: CounterName
  nameWithType: PerformanceCounter.CounterName
- uid: System.Diagnostics.PerformanceCounter.CounterType*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: CounterType
  nameWithType: PerformanceCounter.CounterType
- uid: System.Diagnostics.PerformanceCounter.Decrement*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: Decrement
  nameWithType: PerformanceCounter.Decrement
- uid: System.Diagnostics.PerformanceCounter.Dispose*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: Dispose
  nameWithType: PerformanceCounter.Dispose
- uid: System.Diagnostics.PerformanceCounter.EndInit*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: EndInit
  nameWithType: PerformanceCounter.EndInit
- uid: System.Diagnostics.PerformanceCounter.Increment*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: Increment
  nameWithType: PerformanceCounter.Increment
- uid: System.Diagnostics.PerformanceCounter.IncrementBy*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: IncrementBy
  nameWithType: PerformanceCounter.IncrementBy
- uid: System.Diagnostics.PerformanceCounter.InstanceLifetime*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: InstanceLifetime
  nameWithType: PerformanceCounter.InstanceLifetime
- uid: System.Diagnostics.PerformanceCounter.InstanceName*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: InstanceName
  nameWithType: PerformanceCounter.InstanceName
- uid: System.Diagnostics.PerformanceCounter.MachineName*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: MachineName
  nameWithType: PerformanceCounter.MachineName
- uid: System.Diagnostics.PerformanceCounter.NextSample*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: NextSample
  nameWithType: PerformanceCounter.NextSample
- uid: System.Diagnostics.PerformanceCounter.NextValue*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: NextValue
  nameWithType: PerformanceCounter.NextValue
- uid: System.Diagnostics.PerformanceCounter.RawValue*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: RawValue
  nameWithType: PerformanceCounter.RawValue
- uid: System.Diagnostics.PerformanceCounter.ReadOnly*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: ReadOnly
  nameWithType: PerformanceCounter.ReadOnly
- uid: System.Diagnostics.PerformanceCounter.RemoveInstance*
  parent: System.Diagnostics.PerformanceCounter
  isExternal: false
  name: RemoveInstance
  nameWithType: PerformanceCounter.RemoveInstance
