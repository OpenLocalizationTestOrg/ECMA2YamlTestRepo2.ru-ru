### YamlMime:ManagedReference
items:
- uid: System.Windows.DependencyProperty
  id: DependencyProperty
  children:
  - System.Windows.DependencyProperty.AddOwner(System.Type)
  - System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.DefaultMetadata
  - System.Windows.DependencyProperty.GetHashCode
  - System.Windows.DependencyProperty.GetMetadata(System.Type)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  - System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  - System.Windows.DependencyProperty.GlobalIndex
  - System.Windows.DependencyProperty.IsValidType(System.Object)
  - System.Windows.DependencyProperty.IsValidValue(System.Object)
  - System.Windows.DependencyProperty.Name
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyProperty.OwnerType
  - System.Windows.DependencyProperty.PropertyType
  - System.Windows.DependencyProperty.ReadOnly
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  - System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  - System.Windows.DependencyProperty.ToString
  - System.Windows.DependencyProperty.UnsetValue
  - System.Windows.DependencyProperty.ValidateValueCallback
  langs:
  - csharp
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
  type: Class
  summary: "Представляет свойство, которое можно задать с помощью методов таких как, стили, привязки данных, анимации и наследование."
  remarks: "DependencyProperty поддерживает следующие возможности в [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]:-это свойство можно задать в style. Дополнительные сведения см. в разделе [Стилизация и использование шаблонов](~/add/includes/ajax-current-ext-md.md).      -Свойства можно задать с помощью привязки данных. Дополнительные сведения о привязке данных свойств зависимостей см. в разделе [как: привязки свойства из двух элементов управления](~/add/includes/ajax-current-ext-md.md).      -Свойство можно задать со ссылкой на динамический ресурс. Дополнительные сведения см. в разделе [ресурсов XAML](~/add/includes/ajax-current-ext-md.md).      -Свойство может наследовать его значение автоматически от родительского элемента в дереве элементов. Дополнительные сведения см. в разделе [наследование значения свойства](~/add/includes/ajax-current-ext-md.md).      -Свойства могут быть анимированы. Дополнительные сведения см. в разделе [Обзор анимации](~/add/includes/ajax-current-ext-md.md).      -Свойство может сообщать, когда предыдущее значение свойства было изменено и можно выполнить приведение значения свойства. Дополнительные сведения см. в разделе [обратных вызовах свойства зависимости и проверки](~/add/includes/ajax-current-ext-md.md).      -Свойство сообщает информацию для [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], такие как ли изменение значения свойства требуется системе макета, чтобы представлять визуализации элемента.      -Свойство получает поддержку в [!INCLUDE[wpfdesigner_current_long](~/add/includes/wpfdesigner-current-long-md.md)].  Например, можно изменить свойство в **свойства** окна.       Дополнительные сведения о свойствах зависимостей см. в разделе [Общие сведения о свойствах зависимостей](~/add/includes/ajax-current-ext-md.md). Если требуется свойства на пользовательских типов для поддержки возможностей в предыдущем списке, следует создать свойство зависимостей.  Описание способов создания пользовательских свойств зависимостей, в разделе [пользовательских свойств зависимостей](~/add/includes/ajax-current-ext-md.md).       Вложенное свойство является свойством, позволяющий любого объекта, для передачи сведений типа, который определяет вложенное свойство. В [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], любой тип, наследующий от <xref:System.Windows.DependencyObject>можно использовать вложенное свойство независимо от того, является ли тип наследует от типа, определяющего свойство.</xref:System.Windows.DependencyObject> Вложенное свойство — это функция [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] языка.  Чтобы задать присоединенное свойство в [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], используйте *ownerType*.* propertyName* синтаксиса. Является примером вложенное свойство <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName>свойство.</xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName> Если вы хотите создать свойство, которое может использоваться для всех <xref:System.Windows.DependencyObject>типов, следует создать вложенное свойство.</xref:System.Windows.DependencyObject> Дополнительные сведения о вложенных свойств, включая создание, в разделе [зависимостей](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_DependencyProperty&quot;></a>## Использование атрибута XAML ```   <object property=&quot;dependencyPropertyName&quot;/>   - or -   <object property=&quot;ownerType.dependencyPropertyName&quot;/>   - or -   <object property=&quot;attachedPropertyOwnerType.attachedPropertyName&quot;/>   ``` <a name=&quot;xamlValues_DependencyProperty&quot;> </a> ## значений XAML `dependencyPropertyName` строка, указывающая <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>Свойства требуемой зависимостей.</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>       Это может предшествовать префикс пространства имен XML, если свойство не существует в пространстве имен XML по умолчанию (Дополнительные сведения см. в разделе [пространства имен XAML и сопоставление пространства имен WPF XAML](~/add/includes/ajax-current-ext-md.md).)       `ownerType`.`dependencyPropertyName`    Строка, указывающая тип владельца свойства зависимостей, точки (.), а затем <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName>.</xref:System.Windows.DependencyProperty.Name%2A?displayProperty=fullName> `ownerType`Можно также предшествовать префикс пространства имен XML. Для позднего связывания стили и шаблоны, где необходимо указать владельца свойства зависимостей для синтаксического анализа контекста, так как такое использование `TargetType` еще не известна. Дополнительные сведения см. в разделе [Стилизация и использование шаблонов](../Topic/Styling%20and%20Templating.md).       `attachedPropertyOwnerType` *.* `attachedPropertyName`Строка, задающая владельца вложенного свойства, точка (.), а затем имя вложенного свойства. `attachedPropertyOwnerType`Можно также предшествовать префикс пространства имен XML."
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]

      [System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))]

      public sealed class DependencyProperty
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  id: AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Добавляет другой тип в качестве владельца свойства зависимостей, который уже был зарегистрирован."
  remarks: "Этот метод позволяет распознавать свойства зависимостей для типа, который изначально не зарегистрировала это конкретное свойство зависимостей в системе свойств.       Как правило, AddOwner используется для добавления свойств зависимостей к классам, которые еще не предоставляют это свойство зависимостей через наследование управляемого класса (наследование класса вызовет свойства программы-оболочки, чтобы он наследуется производным классом и таким образом обеспечится доступ общей таблицы элементов к свойству зависимостей уже). AddOwner позволяет распознавать свойства зависимостей для типа, который изначально не зарегистрировала это свойство зависимостей в системе свойств.       Эта подпись не позволяет указывать метаданные.  При использовании этого метода метаданные автоматически создается для нового <xref:System.Windows.DependencyProperty>и ее типа владельца.</xref:System.Windows.DependencyProperty> Метаданные автоматически созданный является результатом объединения метаданных из всех базовых типов, для которых определено это свойство. Если нет объединенных метаданных нет, то используется метаданных по умолчанию для свойства. Если оно регистрируется с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A>метод, то метаданные по умолчанию является таким же, как метаданные, создаваемой при <xref:System.Windows.DependencyProperty.RegisterAttached%2A>был вызван.</xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> В противном случае <xref:System.Windows.PropertyMetadata>создан объект с <xref:System.Windows.PropertyMetadata.DefaultValue%2A>Свойства, значение по умолчанию тип свойства, а все остальные свойства <xref:System.Windows.PropertyMetadata>равно `null`.</xref:System.Windows.PropertyMetadata> </xref:System.Windows.PropertyMetadata.DefaultValue%2A> </xref:System.Windows.PropertyMetadata> Используйте <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>подпись, чтобы предоставлять метаданные для версии свойства зависимостей, по мере добавления к предоставленному типу.</xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>       Возвращаемое значение этого метода обычно используется для объявления и предоставления свойства зависимостей, сохраняя идентификатор свойства зависимостей. Идентификатор предоставляет доступ к свойству зависимостей, если вы хотите вызвать системы свойств [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] к свойству зависимостей, особенно, когда существует на добавляемом классе владельца. Одно и то же имя свойства для первоначального владельца и добавленного владельцев следует использовать, чтобы указать на схожую функциональность. Следует использовать <xref:System.Windows.DependencyProperty>возвращаемое значение метода AddOwner для определения идентификатора свойства зависимости, а также для объявления [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] оболочки свойства для свойства зависимостей, которые добавляются типов с помощью AddOwner.</xref:System.Windows.DependencyProperty>       Рекомендуется выше методологии AddOwner используется при создании свойств зависимостей, которые объявлены в [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]. Например, оба <xref:System.Windows.Controls.Border>и <xref:System.Windows.Controls.Control>определяют `BorderBrush` свойства зависимостей, имеющих аналогичные функциональные возможности.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>определяет его `BorderBrush` свойства в системе свойств путем вызова AddOwner зависимости от первоначального владельца <xref:System.Windows.Controls.Border>и его зарегистрированные <xref:System.Windows.Controls.Border.BorderBrushProperty>идентификатор свойства зависимостей.</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border></xref:System.Windows.Controls.Control> AddOwner возвращают значение затем используется для установления новый статический <xref:System.Windows.DependencyProperty>поля (<xref:System.Windows.Controls.Control.BorderBrushProperty>) для этого свойства для добавленного владельцев и `BorderBrush` также объявляется свойство программы-оболочки.</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty>"
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType);
    parameters:
    - id: ownerType
      type: System.Type
      description: "Тип для добавления в качестве владельца данного свойства зависимостей."
    return:
      type: System.Windows.DependencyProperty
      description: "Ссылка на исходный <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> идентификатор, который идентифицирует свойство зависимостей. Этот идентификатор должен быть открыт путем добавления класса в качестве <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> поля."
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  id: AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Добавляет другой тип в качестве владельца свойства зависимостей, который уже был зарегистрирован, предоставляя метаданные свойства зависимости для свойства зависимостей, как оно будет существовать в предоставленном типе владельца."
  remarks: "Этот метод позволяет распознавать свойства зависимостей для типа, который изначально не зарегистрировала это конкретное свойство зависимостей в системе свойств.       Возвращаемое значение этого метода используется для объявления и предоставления свойству зависимостей, особенно в том случае, как оно существует в добавляемом классе владельца. Как правило то же имя свойства для первоначального владельца и добавленного владельцев следует использовать для указания на схожую функциональность. Рекомендуется предоставлять идентификаторы, а также новые [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] оболочки свойства для свойства зависимостей, которые добавляются с помощью <xref:System.Windows.DependencyProperty.AddOwner%2A>.</xref:System.Windows.DependencyProperty.AddOwner%2A> типы       <xref:System.Windows.DependencyProperty.AddOwner%2A>Методологии рекомендуется выше используется при создании [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] объявленная внутри [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)].</xref:System.Windows.DependencyProperty.AddOwner%2A> Например, оба <xref:System.Windows.Controls.Border>и <xref:System.Windows.Controls.Control>определяют `BorderBrush` свойства зависимостей, имеющих аналогичные функциональные возможности.</xref:System.Windows.Controls.Control> </xref:System.Windows.Controls.Border> <xref:System.Windows.Controls.Control>определяет его `BorderBrush` свойства в системе свойств путем вызова <xref:System.Windows.DependencyProperty.AddOwner%2A>на исходный владелец <xref:System.Windows.Controls.Border>и его зарегистрированные <xref:System.Windows.Controls.Border.BorderBrushProperty>идентификатор свойства зависимостей.</xref:System.Windows.Controls.Border.BorderBrushProperty> </xref:System.Windows.Controls.Border> </xref:System.Windows.DependencyProperty.AddOwner%2A></xref:System.Windows.Controls.Control> <xref:System.Windows.DependencyProperty.AddOwner%2A>Возвращают значение затем используется для установления статический <xref:System.Windows.DependencyProperty>поля (<xref:System.Windows.Controls.Control.BorderBrushProperty>) для этого свойства для добавленного владельцев и `BorderBrush` также объявляется свойство программы-оболочки.</xref:System.Windows.Controls.Control.BorderBrushProperty> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.AddOwner%2A>       Идентификатор для свойства зависимостей добавленного владельцев следует использовать для операций, например <xref:System.Windows.DependencyObject.GetValue%2A>.</xref:System.Windows.DependencyObject.GetValue%2A> Однако конкретного типа операций, включающих типов или экземпляров класса, который был добавлен как владелец с различные метаданные будут по-прежнему возвращать даже если ожидаемые результаты исходного (не добавлены владельца) указан идентификатор свойства зависимостей в вызовах методов, например <xref:System.Windows.DependencyObject.GetValue%2A>или <xref:System.Windows.DependencyProperty.GetMetadata%2A>.</xref:System.Windows.DependencyProperty.GetMetadata%2A> </xref:System.Windows.DependencyObject.GetValue%2A> Метаданные для добавленного владельцев сохраняются по AddOwner вызывает самого ссылается не обязательно исключительно поле идентификатора класса Добавление владельца. Тем не менее, рекомендуется для предоставления идентификатора, а также новые [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] оболочки свойства для свойства зависимостей, которые добавляются типов с помощью AddOwner, поскольку Несоблюдение этого создает различие между [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] и [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] представления свойств.       Предоставленных метаданных объединяется с метаданными для свойства зависимостей, которое существует в базовом владельце. Характеристики, которые были указаны в исходных базовых метаданных, сохранятся. Только характеристики, специально измененные в новых метаданных, переопределят характеристики базовых метаданных. Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, заменяются в случае, если они указаны в новых метаданных.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Другие, такие как <xref:System.Windows.PropertyChangedCallback>, объединяются.</xref:System.Windows.PropertyChangedCallback> В конечном счете, поведение при объединении зависит от типа метаданных свойства используется для переопределения, поэтому для существующих классов метаданных свойств, используемых поведения, описанного здесь [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] свойств зависимостей. Дополнительные сведения см. в разделе [метаданные свойства зависимостей](~/add/includes/ajax-current-ext-md.md) и [метаданных свойств среды](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: ownerType
      type: System.Type
      description: "Тип для добавления в качестве владельца данного свойства зависимостей."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Метаданные, квалифицирующие свойство зависимостей, которое существовало в указанном типе."
    return:
      type: System.Windows.DependencyProperty
      description: "Ссылка на исходный <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> идентификатор, который идентифицирует свойство зависимостей. Этот идентификатор должен быть открыт путем добавления класса в качестве <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> поля."
  overload: System.Windows.DependencyProperty.AddOwner*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.DefaultMetadata
  id: DefaultMetadata
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Возвращает метаданные свойства зависимостей по умолчанию."
  remarks: "По умолчанию метаданные, метаданные свойства, доступные для конкретного объекта или объекта производного типа, где альтернативные метаданные не был предоставлен явный <xref:System.Windows.DependencyProperty.Register%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>вызовите.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.Register%2A>       Если владелец исходного метаданных применяется к первому <xref:System.Windows.DependencyProperty.Register%2A>вызов, установить свойству зависимостей, а затем эти метаданные возвращаются в виде DefaultMetadata.</xref:System.Windows.DependencyProperty.Register%2A>       Если метаданные не было применено в исходной коллекции <xref:System.Windows.DependencyProperty.Register%2A>вызвать, формируется с помощью метаданных по умолчанию <xref:System.Windows.DependencyProperty.Register%2A>вызова и это значение возвращается в виде DefaultMetadata.</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.Register%2A>       Основным назначением которых по умолчанию метаданные, связанные с <xref:System.Windows.DependencyProperty>— предоставить значение по умолчанию для этого свойства для какого-либо <xref:System.Windows.DependencyObject>или производный тип.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyProperty>       Для невложенных свойств тип метаданных, возвращенный этим свойством нельзя привести к производные типы <xref:System.Windows.PropertyMetadata>тип, даже если свойство было изначально зарегистрировано с производным типом метаданных.</xref:System.Windows.PropertyMetadata> Изначально зарегистрированных метаданных, включая его исходным типом возможно производные метаданные вызвать <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>вместо этого, передача исходной регистрации типу как параметр.</xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>       Для вложенных свойств тип метаданных, возвращенный этим свойством будет соответствовать типу, заданному в исходной <xref:System.Windows.DependencyProperty.RegisterAttached%2A>метод регистрации.</xref:System.Windows.DependencyProperty.RegisterAttached%2A>"
  example:
  - "[!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]\n[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]"
  syntax:
    content: public System.Windows.PropertyMetadata DefaultMetadata { get; }
    return:
      type: System.Windows.PropertyMetadata
      description: "По умолчанию метаданные свойства зависимостей."
  overload: System.Windows.DependencyProperty.DefaultMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetHashCode
  id: GetHashCode
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Возвращает хэш-код для данного <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>."
  remarks: "В системе свойств использует свой собственный уникальный идентификатор <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, и значение этого свойства, возвращенный GetHashCode.</xref:System.Windows.DependencyProperty.GlobalIndex%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "Хэш-код для данного <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref>."
  overload: System.Windows.DependencyProperty.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  id: GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Возвращает метаданные для этого свойства зависимостей, которое существует в указанном существующем типе."
  remarks: "Указание типа или ссылкой на объект для использования в качестве типа является обязательным, поскольку метаданные могут отличаться от исходной регистрации ввиду <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>вызовы, изменять метаданные свойства зависимостей, как оно существует в типе.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its type. The type is obtained by using a `typeof` operator.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatatype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (Type forType);
    parameters:
    - id: forType
      type: System.Type
      description: "Конкретный тип, из которого требуется извлечь метаданные свойства зависимостей."
    return:
      type: System.Windows.PropertyMetadata
      description: "Объект метаданных свойств."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  id: GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Возвращает метаданные для этого свойства зависимостей, которое существует в указанном экземпляре объекта."
  remarks: "Указание типа или ссылкой на объект является необходимым, поскольку метаданные любое заданное свойство зависимостей может изменяться от исходной регистрации ввиду <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>вызовы, которые можно уточнить метаданные свойства, как оно существует в типе.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>       При запросе метаданных свойства на основе экземпляра это просто передачи экземпляра, его тип может вычисляться внутренним образом. Метаданные свойства зависимостей не зависит от конкретного экземпляра. всегда является согласованным для любой комбинации типа и свойства."
  example:
  - "The following example gets metadata for a dependency property based on a specific <xref:System.Windows.DependencyObject> instance.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);
    parameters:
    - id: dependencyObject
      type: System.Windows.DependencyObject
      description: "Объект зависимости, проверяемый на наличие типа, чтобы определить, какие версии конкретного типа свойства зависимостей необходимо получать метаданные из."
    return:
      type: System.Windows.PropertyMetadata
      description: "Объект метаданных свойств."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  id: GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Возвращает метаданные для этого свойства зависимостей, которое существовало в указанном типе."
  remarks: "Указание типа или ссылкой на объект является необходимым, поскольку метаданные любое заданное свойство зависимостей может изменяться от исходной регистрации ввиду <xref:System.Windows.DependencyProperty.AddOwner%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>вызовы, которые можно уточнить метаданные свойства, как оно существует в типе.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A>"
  example:
  - "The following example gets metadata for a dependency property based on its <xref:System.Windows.DependencyObjectType>.  \n  \n [!code-cs[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/default.xaml.cs#getmetadatadotype)]\n [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/add/codesnippet/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]"
  syntax:
    content: public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);
    parameters:
    - id: dependencyObjectType
      type: System.Windows.DependencyObjectType
      description: "Конкретный объект, тип объекта зависимостей, из которого запрашиваются метаданные свойства зависимостей."
    return:
      type: System.Windows.PropertyMetadata
      description: "Объект метаданных свойств."
  overload: System.Windows.DependencyProperty.GetMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.GlobalIndex
  id: GlobalIndex
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Возвращает внутри созданного значения, которое однозначно идентифицирует свойство зависимостей."
  remarks: "Это значение не является целым числом, [!INCLUDE[TLA#tla_guid](~/add/includes/ajax-current-ext-md.md)]. Как правило это значение индекса не требуется и нет индекса доступа к таблицам всех свойств зависимостей. Свойства зависимостей вместо этого следует ссылаться их идентификатор поля.       GlobalIndex используется внутренне для более быстрого доступа к структурам данных, использующих GlobalIndex как массив, начинающийся с нуля индекс. Подобное использование может применяться для конструкторов или инструментов."
  syntax:
    content: public int GlobalIndex { get; }
    return:
      type: System.Int32
      description: "Уникальный числовой идентификатор."
  overload: System.Windows.DependencyProperty.GlobalIndex*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  id: IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Определяет, является ли указанное значение допустимым для типа этого свойства зависимостей, проверяются согласно типу свойства, указанного в исходной регистрации свойства зависимостей."
  remarks: "Значение `null` является допустимым типом для свойств зависимостей ссылочного типа или <xref:System.Nullable%601>свойства зависимостей и будет возвращать `true` для таких случаев.</xref:System.Nullable%601> В случаях, когда свойство зависимостей ни ссылку и не является <xref:System.Nullable%601>типа, вернет IsValidType `false` значение null, а не создавать исключение.</xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidType as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvalue)]\n [!code-vb[PropertySystemEsoterics#TrySetValue](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]"
  syntax:
    content: public bool IsValidType (object value);
    parameters:
    - id: value
      type: System.Object
      description: "Проверяемое значение."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если указанное значение является типом зарегистрированного свойства или приемлемому производному типу; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.IsValidType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  id: IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Определяет, принимается ли указанное значение для типа свойства с помощью базовой проверки типа и, возможно также, если он находится в пределах диапазона допустимых значений для данного типа."
  remarks: "Для свойства зависимостей, можно указать разрешенный диапазон значений для этого типа с помощью <xref:System.Windows.ValidateValueCallback>, предоставляется при регистрации свойства зависимостей.</xref:System.Windows.ValidateValueCallback>       Этот метод вызывает метод <xref:System.Windows.DependencyProperty.IsValidType%2A>внутренне.</xref:System.Windows.DependencyProperty.IsValidType%2A> Если свойство зависимостей в вопросе нет <xref:System.Windows.ValidateValueCallback>вызов этого метода эквивалентен фактически вызов <xref:System.Windows.DependencyProperty.IsValidType%2A>.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Windows.ValidateValueCallback> Если свойство зависимости имеет <xref:System.Windows.ValidateValueCallback>и если <xref:System.Windows.DependencyProperty.IsValidType%2A>возвращала бы `true`, то возвращаемое значение будет иметь реализации обратного вызова.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Windows.ValidateValueCallback>       Значение null является допустимым значением для свойства зависимостей типа ссылки или <xref:System.Nullable%601>свойства зависимостей и будет возвращать `true` для таких случаев.</xref:System.Nullable%601> В случаях, когда свойство зависимостей ни ссылку и не является <xref:System.Nullable%601>типа, <xref:System.Windows.DependencyProperty.IsValidType%2A>вернет `false` значение null, а не создавать исключение.</xref:System.Windows.DependencyProperty.IsValidType%2A> </xref:System.Nullable%601>"
  example:
  - "The following example uses IsValidValue as a check before calling <xref:System.Windows.DependencyObject.SetValue%2A> on the dependency property.  \n  \n [!code-cs[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]\n [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]"
  syntax:
    content: public bool IsValidValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "Проверяемое значение."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если значение является допустимым и имеет неправильный тип или производному типу; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.IsValidValue*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Name
  id: Name
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Возвращает имя свойства зависимостей."
  remarks: "Это свойство получает имя, указанное как `name` параметр во время регистрации свойства зависимостей. Это имя является постоянным и не может быть `null` или является пустой строкой. Повторяющееся имя регистрации на том же типе владельца не разрешены и возникает исключение при попытке зарегистрировать дубликат.      Настроек [!IMPORTANT] настроек имя свойства зависимостей, должны соответствовать соглашению совпадающих имя его идентификатор для свойства зависимостей минус суффикс «Свойство». Дополнительные сведения см. в разделе [свойств зависимостей](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the Name.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "Имя свойства."
  overload: System.Windows.DependencyProperty.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Задает альтернативные метаданные для этого свойства зависимостей, когда оно присутствует в экземплярах указанного типа, переопределяя метаданные, которые существовали для свойства зависимостей, как оно было унаследовано от базовых типов."
  remarks: "В системе свойств использует свойства зависимостей, следует переопределить метаданные свойства зависимостей. Это соответствует времени, определенные экземпляры создаются с помощью класса, регистрирующего свойство зависимостей. Вызовы OverrideMetadata следует выполнять только в статическом конструкторе типа, предоставляющего себя в качестве `forType` параметр этого метода, или с помощью аналогичные при создании экземпляра. Попытка изменить метаданные после экземпляров типа-владельца не возникнет исключения, но приведет к несогласованному поведению в системе свойств.       После установки с помощью этого метода метаданные для определенного производного класса переопределения последующие попытки переопределения метаданных на этом же производном классе вызывает исключение.       Предоставленных метаданных объединяется с метаданными для свойства зависимостей, которое существует в базовом владельце. Характеристики, которые были указаны в исходных базовых метаданных будет сохранено; только характеристики, специально измененные в новых метаданных, переопределят характеристики базовых метаданных. Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A>заменяются, если он указан в новые метаданные.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Другие, такие как <xref:System.Windows.PropertyChangedCallback>, объединяются.</xref:System.Windows.PropertyChangedCallback> В конечном счете, поведение при объединении зависит от типа метаданных свойства используется для переопределения, поэтому для существующих классов метаданных свойств, используемых поведения, описанного здесь [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] свойств зависимостей. Дополнительные сведения см. в разделе [метаданные свойства зависимостей](~/add/includes/ajax-current-ext-md.md) и [метаданных свойств среды](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: forType
      type: System.Type
      description: "Тип, где это свойство зависимостей наследуется и где будут применены указанные альтернативные метаданные."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Метаданные для применения к свойству зависимостей в переопределяемом типе."
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Была предпринята попытка переопределения метаданных для свойства зависимостей только для чтения (операция не может быть выполнена с помощью данной сигнатуры)."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Метаданные уже были установлены для свойства зависимостей, которое существовало в указанном типе."
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  id: OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Предоставляет альтернативные метаданные для свойства зависимостей только для чтения, когда оно присутствует в экземплярах указанного типа, переопределяя метаданные, указанные при первоначальной регистрации свойства зависимостей. Необходимо передать <xref href=&quot;System.Windows.DependencyPropertyKey&quot;> </xref> для свойства зависимостей только для чтения избежать возникновения исключения."
  remarks: "Эта подпись предоставляет базовую реализацию для идентификатора свойства зависимости только для чтения (<xref:System.Windows.DependencyPropertyKey>) метод.</xref:System.Windows.DependencyPropertyKey> Для переопределения метаданных для свойства зависимостей для чтения и записи, используйте <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>       В системе свойств использует свойства зависимостей, следует переопределить метаданные свойства зависимостей. Это равно времени создания конкретных объектов для класса, который регистрирует свойство зависимости. Вызовы <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>следует выполнять только в статическом конструкторе типа, предоставляющего себя в качестве `forType` параметр этого метода, или с помощью аналогичные при создании экземпляра.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> Попытка изменить метаданные после экземпляров типа-владельца не возникнет исключения, но приведет к несогласованному поведению в системе свойств.       После установки с помощью этого метода метаданные для определенного производного класса переопределения последующие попытки переопределения метаданных на этом же производном классе вызывает исключение.       Предоставленных метаданных объединяется с метаданными для свойства зависимостей, которое существует в базовом владельце. Характеристики, которые были указаны в исходных базовых метаданных будет сохранено; только характеристики, специально измененные в новых метаданных, переопределят характеристики базовых метаданных. Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A>заменяются, если он указан в новые метаданные.</xref:System.Windows.PropertyMetadata.DefaultValue%2A> Другие, такие как <xref:System.Windows.PropertyChangedCallback>, объединяются.</xref:System.Windows.PropertyChangedCallback> Поведение при объединении зависит от используемого для переопределения типа метаданных свойства. Дополнительные сведения см. в разделе [метаданные свойства зависимостей](~/add/includes/ajax-current-ext-md.md) и [метаданных свойств среды](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);
    parameters:
    - id: forType
      type: System.Type
      description: "Тип, где это свойство зависимостей наследуется и где будут применены указанные альтернативные метаданные."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Метаданные для применения к свойству зависимостей в переопределяемом типе."
    - id: key
      type: System.Windows.DependencyPropertyKey
      description: "Ключ доступа для свойства зависимостей только для чтения."
  overload: System.Windows.DependencyProperty.OverrideMetadata*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.OwnerType
  id: OwnerType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Возвращает тип объекта, зарегистрировавшего свойство зависимостей в системе свойств или добавившего себя в качестве владельца свойства."
  remarks: "Данное значение было указано во время регистрации свойства. Владельцем будет либо исходного регистрации типа в случае использования <xref:System.Windows.DependencyProperty>идентификатор, созданный из <xref:System.Windows.DependencyProperty.Register%2A>вызова или тип, добавившего себя в качестве владельца, в случае использования <xref:System.Windows.DependencyProperty>идентификатор, созданный из <xref:System.Windows.DependencyProperty.AddOwner%2A>вызовите.</xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty>       OwnerType с заданным <xref:System.Windows.DependencyProperty>является постоянным и не может быть `null` в допустимый <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty>"
  example:
  - "The following example gets the owner type based on a dependency property identifier `dp`, and then gets metadata on the owner type for that same identifier. This operation is actually equivalent to getting <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> on `dp`.  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]"
  syntax:
    content: public Type OwnerType { get; }
    return:
      type: System.Type
      description: "Тип объекта, зарегистрировавшего свойство или добавившего себя в качестве владельца свойства."
  overload: System.Windows.DependencyProperty.OwnerType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.PropertyType
  id: PropertyType
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Возвращает тип, который использует свойства зависимостей для его значения."
  remarks: "Это свойство сообщает тип значения свойства, объявленные в исходной регистрации свойства через `propertyType` параметра. Аналогично <xref:System.Windows.DependencyProperty.Name%2A>, тип свойства для свойства зависимостей нельзя изменить после регистрации.</xref:System.Windows.DependencyProperty.Name%2A>"
  example:
  - "The following example queries various characteristics of a dependency property identifier, including the PropertyType. The type name string of the PropertyType is obtained from the returned <xref:System.Type>.  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public Type PropertyType { get; }
    return:
      type: System.Type
      description: "<xref:System.Type>Значения свойства.</xref:System.Type>"
  overload: System.Windows.DependencyProperty.PropertyType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ReadOnly
  id: ReadOnly
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Возвращает значение, указывающее, является ли свойство зависимостей, соответствующая <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> экземпляр — это свойство зависимостей только для чтения."
  remarks: "Свойства зависимости только для чтения зарегистрированного в системе свойств путем вызова метода <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>метода, в отличие от <xref:System.Windows.DependencyProperty.Register%2A>метод.</xref:System.Windows.DependencyProperty.Register%2A> </xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> Вложенные свойства также можно зарегистрировать только для чтения; в разделе <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.</xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>       Свойства зависимости только для чтения требуют <xref:System.Windows.DependencyPropertyKey>идентификатор, а не <xref:System.Windows.DependencyProperty>идентификатор для выполнения операций с метаданными, например переопределения метаданных или установка значения.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey> Если вы приобрели коллекцию <xref:System.Windows.DependencyProperty>идентификаторы посредством вызова <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>или другой [!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)] , предоставляющий идентификаторов, проверьте значение только для чтения, прежде чем пытаться вызвать <xref:System.Windows.DependencyObject.SetValue%2A>или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>используют идентификатор для свойства зависимостей в качестве входного параметра, убедитесь, что свойством зависимостей, которое представляет идентификатор не только для чтения.</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyObject.SetValue%2A> </xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> </xref:System.Windows.DependencyProperty> Если имеет значение только для чтения `true` для свойства зависимостей, нет возможности для получения ссылки на программный <xref:System.Windows.DependencyPropertyKey>идентификатора этого свойства зависимостей, из метаданных или <xref:System.Windows.DependencyProperty>идентификатор; идентификатор должен быть доступен как статическое поле для вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>для свойства зависимостей только для чтения.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> </xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyPropertyKey>       При создании пользовательского свойства зависимостей и зарегистрируйте его только для чтения, следует определить только метод доступа get для [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] свойство программы-оболочки. В противном случае ваш класс будет иметь несогласованную объектную модель для обертки свойства, по сравнению с доступом к базовому свойству зависимостей. Дополнительные сведения см. в разделе [свойств зависимостей](~/add/includes/ajax-current-ext-md.md) или [свойства зависимости только для чтения](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPProps](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpprops)]\n [!code-vb[PropertySystemEsoterics#DPProps](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpprops)]"
  syntax:
    content: public bool ReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если свойство зависимостей только для чтения. в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.DependencyProperty.ReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  id: Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Регистрирует свойство зависимостей с указанным именем, типом свойства и типа владельца."
  remarks: "Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - >-
    [!code-cs[WPFAquariumSln#Register3Param](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#register3param)]
     [!code-vb[WPFAquariumSln#Register3Param](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#register3param)]
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "Имя регистрируемого свойства зависимостей. Имя должно быть уникальным в пределах пространства имен регистрации для типа владельца."
    - id: propertyType
      type: System.Type
      description: "Тип свойства."
    - id: ownerType
      type: System.Type
      description: "Тип владельца, регистрирующего свойство зависимостей."
    return:
      type: System.Windows.DependencyProperty
      description: "Идентификатор для свойства зависимостей, который должен использоваться для задания значения <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей, для операций, таких как Программная установка значения или получение метаданных."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Регистрирует свойство зависимостей с указанное имя свойства, тип свойства, типом владельца и метаданными свойства."
  remarks: "Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "Имя регистрируемого свойства зависимостей."
    - id: propertyType
      type: System.Type
      description: "Тип свойства."
    - id: ownerType
      type: System.Type
      description: "Тип владельца, регистрирующего свойство зависимостей."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Метаданные свойства зависимостей."
    return:
      type: System.Windows.DependencyProperty
      description: "Идентификатор для свойства зависимостей, который должен использоваться для задания значения <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей, для операций, таких как Программная установка значения или получение метаданных."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Регистрирует свойство зависимостей с указанное имя свойства, типом свойства, типом владельца, метаданными свойства и обратным вызовом проверки значения для свойства."
  remarks: "Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <xref:System.Windows.ValidateValueCallback>).  \n  \n [!code-cs[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/csharp/DPCallbackOverride/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]\n [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/add/codesnippet/visualbasic/DPCallbackOverride.sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]"
  syntax:
    content: public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "Имя регистрируемого свойства зависимостей."
    - id: propertyType
      type: System.Type
      description: "Тип свойства."
    - id: ownerType
      type: System.Type
      description: "Тип владельца, регистрирующего свойство зависимостей."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Метаданные свойства зависимостей."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Ссылка на обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа."
    return:
      type: System.Windows.DependencyProperty
      description: "Идентификатор для свойства зависимостей, который должен использоваться для задания значения <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей, для операций, таких как Программная установка значения или получение метаданных."
  overload: System.Windows.DependencyProperty.Register*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  id: RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Регистрирует присоединенное свойство с указанным именем, типом свойства и типа владельца."
  remarks: "Вложенное свойство является свойством понятием [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]реализует вложенные свойства как свойства зависимости. Поскольку [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] вложенные свойства являются свойствами зависимости, они могут быть применены метаданные, который может использоваться для операции, такие как сообщение о характеристиках структуры системой общих свойств. Дополнительные сведения см. в разделе [зависимостей](~/add/includes/ajax-current-ext-md.md).       Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);
    parameters:
    - id: name
      type: System.String
      description: "Имя регистрируемого свойства зависимостей."
    - id: propertyType
      type: System.Type
      description: "Тип свойства."
    - id: ownerType
      type: System.Type
      description: "Тип владельца, регистрирующего свойство зависимостей."
    return:
      type: System.Windows.DependencyProperty
      description: "Идентификатор для свойства зависимостей, который должен использоваться для задания значения <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей, для операций, таких как Программная установка значения или получение метаданных."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Регистрирует присоединенное свойство с указанное имя свойства, тип свойства, типом владельца и метаданными свойства."
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with RegisterAttached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with RegisterAttached even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use RegisterAttached to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "Имя регистрируемого свойства зависимостей."
    - id: propertyType
      type: System.Type
      description: "Тип свойства."
    - id: ownerType
      type: System.Type
      description: "Тип владельца, регистрирующего свойство зависимостей."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Метаданные свойства зависимостей. Это может включать значение по умолчанию, а также другие характеристики."
    return:
      type: System.Windows.DependencyProperty
      description: "Идентификатор для свойства зависимостей, который должен использоваться для задания значения <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей, для операций, таких как Программная установка значения или получение метаданных."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Регистрирует присоединенное свойство с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом проверки значения свойства."
  remarks: "An attached property is a property concept defined by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] implements attached properties as dependency properties. Because the [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics. For more information, see [Attached Properties Overview](~/add/includes/ajax-current-ext-md.md).  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example registers an attached property on an abstract class using this RegisterAttached signature. This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.  \n  \n [!code-cs[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]\n [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]"
  syntax:
    content: public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "Имя регистрируемого свойства зависимостей."
    - id: propertyType
      type: System.Type
      description: "Тип свойства."
    - id: ownerType
      type: System.Type
      description: "Тип владельца, регистрирующего свойство зависимостей."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Метаданные свойства зависимостей. Это может включать значение по умолчанию, а также другие характеристики."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Ссылка на обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа."
    return:
      type: System.Windows.DependencyProperty
      description: "Идентификатор для свойства зависимостей, который должен использоваться для задания значения <xref uid=&quot;langword_csharp_public static readonly&quot; name=&quot;public static readonly&quot; href=&quot;&quot;> </xref> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей, для операций, таких как Программная установка значения или получение метаданных."
  overload: System.Windows.DependencyProperty.RegisterAttached*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Регистрирует доступное только для чтения присоединенное свойство с указанным типом свойства, типом владельца и метаданными свойства."
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);
    parameters:
    - id: name
      type: System.String
      description: "Имя регистрируемого свойства зависимостей."
    - id: propertyType
      type: System.Type
      description: "Тип свойства."
    - id: ownerType
      type: System.Type
      description: "Тип владельца, регистрирующего свойство зависимостей."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Метаданные свойства зависимостей."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Ключ свойства зависимостей, который должен использоваться для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей."
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Регистрирует доступное только для чтения присоединенное свойство с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки."
  remarks: "This method returns the type <xref:System.Windows.DependencyPropertyKey>, whereas <xref:System.Windows.DependencyProperty.RegisterAttached%2A> returns the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent the type <xref:System.Windows.DependencyProperty>. Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <xref:System.Windows.DependencyPropertyKey> to only those parts of your code that are necessary to set that dependency property as part of class or application logic. It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName> as a `public static readonly` field on your class.  \n  \n Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]. Without a public setter, an attached property cannot be set in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] syntax.  \n  \n For more information on dependency property registration, see <xref:System.Windows.DependencyProperty>.  \n  \n## Use RegisterAttached for Value-inheriting Dependency Properties  \n One particular scenario for registering a dependency property as attached instead of <xref:System.Windows.DependencyProperty.Register%2A> is to support property value inheritance. You should register value-inheriting dependency properties with <xref:System.Windows.DependencyProperty.RegisterAttached%2A> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set\\* static methods to provide true attached property support accessors.   Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined. Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree. Always use <xref:System.Windows.DependencyProperty.RegisterAttached%2A> to register properties where you specify <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> in the metadata. For more information, see [Property Value Inheritance](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "Имя регистрируемого свойства зависимостей."
    - id: propertyType
      type: System.Type
      description: "Тип свойства."
    - id: ownerType
      type: System.Type
      description: "Тип владельца, регистрирующего свойство зависимостей."
    - id: defaultMetadata
      type: System.Windows.PropertyMetadata
      description: "Метаданные свойства зависимостей."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Ссылка на созданные пользователем обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Ключ свойства зависимостей, который должен использоваться для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей."
  overload: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Регистрирует свойство зависимости только для чтения, с указанным типом свойства, типом владельца и метаданными свойства."
  remarks: "Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, а <xref:System.Windows.DependencyProperty.RegisterAttached%2A>возвращает тип <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> Как правило ключи, представляющие свойства только для чтения не становятся открытым, поскольку ключи можно использовать для задания значения свойства зависимостей, вызвав <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> Структура класса повлияет вашим требованиям, но обычно рекомендуется ограничить доступ и видимость любого <xref:System.Windows.DependencyPropertyKey>для только те части кода, которые необходимы для установки этого свойства зависимостей как часть логики класса или приложения.</xref:System.Windows.DependencyPropertyKey> Кроме того, рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей только для чтения, обеспечивая значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>как `public static readonly` на ваш класс.</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       Свойства зависимости только для чтения, это весьма распространенный сценарий как в существующем [!INCLUDE[TLA2#tla_api](~/add/includes/tla2sharptla-api-md.md)] и сценарии настройки, так как другие [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] функциям может требоваться свойство зависимостей, даже если этого не планируется сделать доступным для установки вызывающими объектами. Значение свойства зависимости только для чтения можно использовать как основу для других операций системы свойств, принимающих свойство зависимостей, например основан <xref:System.Windows.Trigger>для свойства зависимостей в стиле.</xref:System.Windows.Trigger>       Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>"
  example:
  - "The following example registers an `AquariumSize` dependency property as read-only. The example defines `AquariumSizeKey` as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as `AquariumSizeProperty`. Also, a wrapper is created for `AquariumSize`, with only a get accessor.  \n  \n [!code-cs[WPFAquariumSln#RODP](~/add/codesnippet/csharp/WPFAquariumSln/WPFAquariumObjects/Class1.cs#rodp)]\n [!code-vb[WPFAquariumSln#RODP](~/add/codesnippet/visualbasic/wpfaquariumobjects/class1.vb#rodp)]"
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);
    parameters:
    - id: name
      type: System.String
      description: "Имя регистрируемого свойства зависимостей."
    - id: propertyType
      type: System.Type
      description: "Тип свойства."
    - id: ownerType
      type: System.Type
      description: "Тип владельца, регистрирующего свойство зависимостей."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Метаданные свойства зависимостей."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Ключ свойства зависимостей, который должен использоваться для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей."
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  id: RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Регистрирует свойство зависимостей только для чтения, с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки."
  remarks: "Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, а <xref:System.Windows.DependencyProperty.RegisterAttached%2A>возвращает тип <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty> </xref:System.Windows.DependencyProperty.RegisterAttached%2A> </xref:System.Windows.DependencyPropertyKey> Как правило ключи, представляющие свойства только для чтения не становятся открытым, поскольку ключи можно использовать для задания значения свойства зависимостей, вызвав <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>.</xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> Структура класса повлияет вашим требованиям, но обычно рекомендуется ограничить доступ и видимость любого <xref:System.Windows.DependencyPropertyKey>для только те части кода, которые необходимы для установки этого свойства зависимостей как часть логики класса или приложения.</xref:System.Windows.DependencyPropertyKey> Кроме того, рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей только для чтения, обеспечивая значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>как `public static readonly` на ваш класс.</xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=fullName>       Свойства зависимости только для чтения — это весьма распространенный сценарий. Значение свойства зависимости только для чтения можно использовать как основу для других операций системы свойств, принимающих свойство зависимостей, например основан <xref:System.Windows.Trigger>для свойства зависимостей в стиле.</xref:System.Windows.Trigger>       Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.</xref:System.Windows.DependencyProperty>       Проверка на доступное только для чтения свойство зависимостей может быть менее важна. Уровень доступа к закрытым, заданный для ключа снижает вероятность произвольного недопустимого ввода."
  syntax:
    content: public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);
    parameters:
    - id: name
      type: System.String
      description: "Имя регистрируемого свойства зависимостей."
    - id: propertyType
      type: System.Type
      description: "Тип свойства."
    - id: ownerType
      type: System.Type
      description: "Тип владельца, регистрирующего свойство зависимостей."
    - id: typeMetadata
      type: System.Windows.PropertyMetadata
      description: "Метаданные свойства зависимостей."
    - id: validateValueCallback
      type: System.Windows.ValidateValueCallback
      description: "Ссылка на созданные пользователем обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа."
    return:
      type: System.Windows.DependencyPropertyKey
      description: "Ключ свойства зависимостей, который должен использоваться для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей."
  overload: System.Windows.DependencyProperty.RegisterReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ToString
  id: ToString
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Возвращает строковое представление свойства зависимостей."
  remarks: "Эта реализация возвращает <xref:System.Windows.DependencyProperty.Name%2A>значение свойства.</xref:System.Windows.DependencyProperty.Name%2A>"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "Строковое представление свойства зависимостей."
  overload: System.Windows.DependencyProperty.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.UnsetValue
  id: UnsetValue
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
  type: Field
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Указывает статическое значение, которое используется [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] системы свойств вместо <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> для указания, что свойство существует, но не имеет его значение, установленное в системе свойств."
  remarks: "UnsetValue является контрольного значения, который используется для сценариев, где [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] системы свойств не может определить запрошенный <xref:System.Windows.DependencyProperty>значение.</xref:System.Windows.DependencyProperty> Используется UnsetValue вместо `null`, так как `null` может быть является допустимым значением свойства, а также является допустимым (и часто используемые) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       UnsetValue никогда не возвращается из <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>.</xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> При вызове <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName>для свойства зависимостей на <xref:System.Windows.DependencyObject>применяется экземпляр, одно из следующих: - свойство зависимости имеет значение по умолчанию, установленное в метаданных, и возвращается это значение.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=fullName> Это значение может быть получено из <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.</xref:System.Windows.DependencyProperty.DefaultMetadata%2A>      -Любое другое значение было установлено в системе свойств и значение по умолчанию больше не нужны. Дополнительные сведения см. в разделе [приоритет значения свойства зависимости](~/add/includes/ajax-current-ext-md.md).       Параметр <xref:System.Windows.PropertyMetadata.DefaultValue%2A>из UnsetValue специально запрещено.</xref:System.Windows.PropertyMetadata.DefaultValue%2A>       <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>Возвращает UnsetValue, если запрошенное свойство локально не задано.</xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=fullName>       UnsetValue имеет особое значение при использовании в качестве возвращаемого значения <xref:System.Windows.CoerceValueCallback>.</xref:System.Windows.CoerceValueCallback> Дополнительные сведения см. в разделе [обратных вызовах свойства зависимости и проверки](~/add/includes/ajax-current-ext-md.md).       При привязке к базе данных, обратите внимание, что UnsetValue не эквивалентен <xref:System.DBNull.Value>, аналогично тому, как <xref:System.DBNull.Value>не равно значению true null.</xref:System.DBNull.Value> </xref:System.DBNull.Value>"
  syntax:
    content: public static readonly object UnsetValue;
    return:
      type: System.Object
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  id: ValidateValueCallback
  parent: System.Windows.DependencyProperty
  langs:
  - csharp
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "Возвращает значение обратный вызов проверки для свойства зависимостей."
  remarks: "Это свойство будет содержать `null` для любого свойства зависимостей без зарегистрированного обратного вызова проверки.       Проверить значение обратные вызовы должны действовать статически: проверка, применяемая через <xref:System.Windows.ValidateValueCallback>не может определить, является ли указанное значение допустимым для какой-либо экземпляр.</xref:System.Windows.ValidateValueCallback> Обратный вызов может только определить, следует ли все объекты, которые обладают свойством зависимостей, или не должен принимать указанное значение как допустимое. Если необходимо выполнять проверку, полагаясь на знание значений других свойств зависимостей в определенном экземпляре, используйте <xref:System.Windows.CoerceValueCallback>вместо.</xref:System.Windows.CoerceValueCallback> <xref:System.Windows.CoerceValueCallback>Зарегистрирован как часть метаданных свойства зависимостей, а не непосредственно в идентификатор свойства зависимостей.</xref:System.Windows.CoerceValueCallback> Дополнительные сведения см. в разделе [обратных вызовах свойства зависимости и проверки](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public System.Windows.ValidateValueCallback ValidateValueCallback { get; }
    return:
      type: System.Windows.ValidateValueCallback
      description: "Обратный вызов проверки значение для этого свойства зависимостей, как указано для <code> validateValueCallback </code> параметр в исходной регистрации свойства зависимостей."
  overload: System.Windows.DependencyProperty.ValidateValueCallback*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.DependencyProperty.AddOwner(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type)
  nameWithType: DependencyProperty.AddOwner(Type)
  fullName: System.Windows.DependencyProperty.AddOwner(Type)
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner(Type,PropertyMetadata)
  nameWithType: DependencyProperty.AddOwner(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.AddOwner(Type,PropertyMetadata)
- uid: System.Windows.PropertyMetadata
  parent: System.Windows
  isExternal: false
  name: PropertyMetadata
  nameWithType: PropertyMetadata
  fullName: System.Windows.PropertyMetadata
- uid: System.Windows.DependencyProperty.DefaultMetadata
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
  fullName: System.Windows.DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode()
  nameWithType: DependencyProperty.GetHashCode()
  fullName: System.Windows.DependencyProperty.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.DependencyProperty.GetMetadata(System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(Type)
  nameWithType: DependencyProperty.GetMetadata(Type)
  fullName: System.Windows.DependencyProperty.GetMetadata(Type)
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObject)
  nameWithType: DependencyProperty.GetMetadata(DependencyObject)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata(DependencyObjectType)
  nameWithType: DependencyProperty.GetMetadata(DependencyObjectType)
  fullName: System.Windows.DependencyProperty.GetMetadata(DependencyObjectType)
- uid: System.Windows.DependencyObjectType
  parent: System.Windows
  isExternal: false
  name: DependencyObjectType
  nameWithType: DependencyObjectType
  fullName: System.Windows.DependencyObjectType
- uid: System.Windows.DependencyProperty.GlobalIndex
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
  fullName: System.Windows.DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType(Object)
  nameWithType: DependencyProperty.IsValidType(Object)
  fullName: System.Windows.DependencyProperty.IsValidType(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.DependencyProperty.IsValidValue(System.Object)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue(Object)
  nameWithType: DependencyProperty.IsValidValue(Object)
  fullName: System.Windows.DependencyProperty.IsValidValue(Object)
- uid: System.Windows.DependencyProperty.Name
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
  fullName: System.Windows.DependencyProperty.Name
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  nameWithType: DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
  fullName: System.Windows.DependencyProperty.OverrideMetadata(Type,PropertyMetadata,DependencyPropertyKey)
- uid: System.Windows.DependencyPropertyKey
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyKey
  nameWithType: DependencyPropertyKey
  fullName: System.Windows.DependencyPropertyKey
- uid: System.Windows.DependencyProperty.OwnerType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
  fullName: System.Windows.DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
  fullName: System.Windows.DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
  fullName: System.Windows.DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type)
  nameWithType: DependencyProperty.Register(String,Type,Type)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.Register(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.ValidateValueCallback
  parent: System.Windows
  isExternal: false
  name: ValidateValueCallback
  nameWithType: ValidateValueCallback
  fullName: System.Windows.ValidateValueCallback
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttached(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterAttachedReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata)
- uid: System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  nameWithType: DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
  fullName: System.Windows.DependencyProperty.RegisterReadOnly(String,Type,Type,PropertyMetadata,ValidateValueCallback)
- uid: System.Windows.DependencyProperty.ToString
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString()
  nameWithType: DependencyProperty.ToString()
  fullName: System.Windows.DependencyProperty.ToString()
- uid: System.Windows.DependencyProperty.UnsetValue
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: UnsetValue
  nameWithType: DependencyProperty.UnsetValue
  fullName: System.Windows.DependencyProperty.UnsetValue
- uid: System.Windows.DependencyProperty.ValidateValueCallback
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
  fullName: System.Windows.DependencyProperty.ValidateValueCallback
- uid: System.Windows.DependencyProperty.AddOwner*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: AddOwner
  nameWithType: DependencyProperty.AddOwner
- uid: System.Windows.DependencyProperty.DefaultMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: DefaultMetadata
  nameWithType: DependencyProperty.DefaultMetadata
- uid: System.Windows.DependencyProperty.GetHashCode*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetHashCode
  nameWithType: DependencyProperty.GetHashCode
- uid: System.Windows.DependencyProperty.GetMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GetMetadata
  nameWithType: DependencyProperty.GetMetadata
- uid: System.Windows.DependencyProperty.GlobalIndex*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: GlobalIndex
  nameWithType: DependencyProperty.GlobalIndex
- uid: System.Windows.DependencyProperty.IsValidType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidType
  nameWithType: DependencyProperty.IsValidType
- uid: System.Windows.DependencyProperty.IsValidValue*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: IsValidValue
  nameWithType: DependencyProperty.IsValidValue
- uid: System.Windows.DependencyProperty.Name*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Name
  nameWithType: DependencyProperty.Name
- uid: System.Windows.DependencyProperty.OverrideMetadata*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OverrideMetadata
  nameWithType: DependencyProperty.OverrideMetadata
- uid: System.Windows.DependencyProperty.OwnerType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: OwnerType
  nameWithType: DependencyProperty.OwnerType
- uid: System.Windows.DependencyProperty.PropertyType*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: PropertyType
  nameWithType: DependencyProperty.PropertyType
- uid: System.Windows.DependencyProperty.ReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ReadOnly
  nameWithType: DependencyProperty.ReadOnly
- uid: System.Windows.DependencyProperty.Register*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: Register
  nameWithType: DependencyProperty.Register
- uid: System.Windows.DependencyProperty.RegisterAttached*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttached
  nameWithType: DependencyProperty.RegisterAttached
- uid: System.Windows.DependencyProperty.RegisterAttachedReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterAttachedReadOnly
  nameWithType: DependencyProperty.RegisterAttachedReadOnly
- uid: System.Windows.DependencyProperty.RegisterReadOnly*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: RegisterReadOnly
  nameWithType: DependencyProperty.RegisterReadOnly
- uid: System.Windows.DependencyProperty.ToString*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ToString
  nameWithType: DependencyProperty.ToString
- uid: System.Windows.DependencyProperty.ValidateValueCallback*
  parent: System.Windows.DependencyProperty
  isExternal: false
  name: ValidateValueCallback
  nameWithType: DependencyProperty.ValidateValueCallback
