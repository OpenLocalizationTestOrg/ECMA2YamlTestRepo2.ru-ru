### YamlMime:ManagedReference
items:
- uid: System.Net.HttpListener
  id: HttpListener
  children:
  - System.Net.HttpListener.#ctor
  - System.Net.HttpListener.Abort
  - System.Net.HttpListener.AuthenticationSchemes
  - System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  - System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)
  - System.Net.HttpListener.Close
  - System.Net.HttpListener.DefaultServiceNames
  - System.Net.HttpListener.EndGetContext(System.IAsyncResult)
  - System.Net.HttpListener.ExtendedProtectionPolicy
  - System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  - System.Net.HttpListener.GetContext
  - System.Net.HttpListener.GetContextAsync
  - System.Net.HttpListener.IgnoreWriteExceptions
  - System.Net.HttpListener.IsListening
  - System.Net.HttpListener.IsSupported
  - System.Net.HttpListener.Prefixes
  - System.Net.HttpListener.Realm
  - System.Net.HttpListener.Start
  - System.Net.HttpListener.Stop
  - System.Net.HttpListener.System#IDisposable#Dispose
  - System.Net.HttpListener.TimeoutManager
  - System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  langs:
  - csharp
  name: HttpListener
  nameWithType: HttpListener
  fullName: System.Net.HttpListener
  type: Class
  summary: "Предоставляет простой программно управляемый прослушиватель протокола HTTP. Этот класс не наследуется."
  remarks: "Using the HttpListener class, you can create a simple HTTP protocol listener that responds to HTTP requests. The listener is active for the lifetime of the HttpListener object and runs within your application with its permissions.  \n  \n> [!NOTE]\n>  This class is available only on computers running the Windows XP SP2 or Windows Server 2003 operating systems. If you attempt to create an HttpListener object on a computer that is running an earlier operating system, the constructor throws a <xref:System.PlatformNotSupportedException> exception.  \n  \n To use HttpListener, create a new instance of the class using the HttpListener constructor and use the <xref:System.Net.HttpListener.Prefixes%2A> property to gain access to the collection that holds the strings that specify which Uniform Resource Identifier (URI) prefixes the HttpListener should process.  \n  \n A URI prefix string is composed of a scheme (http or https), a host, an optional port, and an optional path. An example of a complete prefix string is \"`http://www.contoso.com:8080/customerData``/`\". Prefixes must end in a forward slash (\"/\"). The HttpListener object with the prefix that most closely matches a requested URI responds to the request. Multiple HttpListener objects cannot add the same prefix; a <xref:System.ComponentModel.Win32Exception> exception is thrown if a HttpListener adds a prefix that is already in use.  \n  \n When a port is specified, the host element can be replaced with \"*\" to indicate that the HttpListener accepts requests sent to the port if the requested URI does not match any other prefix. For example, to receive all requests sent to port 8080 when the requested URI is not handled by any HttpListener, the prefix is \"`http://*:8080``/`\". Similarly, to specify that the HttpListener accepts all requests sent to a port, replace the host element with the \"+\" character, \"`https://+:8080`\". The \"\\*\" and \"+\" characters can be present in prefixes that include paths.  \n  \n Starting with .NET 4.5.3 and Windows 10, wildcard subdomains are supported in URI prefixes that are managed by an HttpListener object. To specify a wildcard subdomain, use the \"*\" character as part of the hostname in a URI prefix: for example, `http://*.foo.com/`, and pass this as the argument to the HttpListenerPrefixCollection.Add method. This will work on .NET 4.5.3 and Windows 10; in earlier versions, this would generate an <xref:System.Net.HttpListenerException>  \n  \n To begin listening for requests from clients, add the URI prefixes to the collection and call the <xref:System.Net.HttpListener.Start%2A> method. HttpListener offers both synchronous and asynchronous models for processing client requests. Requests and their associated responses are accessed using the <xref:System.Net.HttpListenerContext> object returned by the <xref:System.Net.HttpListener.GetContext%2A> method or its asynchronous counterparts, the <xref:System.Net.HttpListener.BeginGetContext%2A> and <xref:System.Net.HttpListener.EndGetContext%2A> methods.  \n  \n The synchronous model is appropriate if your application should block while waiting for a client request and if you want to process only one request at a time. Using the synchronous model, call the <xref:System.Net.HttpListener.GetContext%2A> method, which waits for a client to send a request. The method returns an <xref:System.Net.HttpListenerContext> object to you for processing when one occurs.  \n  \n In the more complex asynchronous model, your application does not block while waiting for requests and each request is processed in its own execution thread. Use the <xref:System.Net.HttpListener.BeginGetContext%2A> method to specify an application-defined method to be called for each incoming request. Within that method, call the <xref:System.Net.HttpListener.EndGetContext%2A> method to obtain the request, process it, and respond.  \n  \n In either model, incoming requests are accessed using the <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=fullName> property and are represented by <xref:System.Net.HttpListenerRequest> objects. Similarly, responses are accessed using the <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=fullName> property and are represented by <xref:System.Net.HttpListenerResponse> objects. These objects share some functionality with the <xref:System.Net.HttpWebRequest> and <xref:System.Net.HttpWebResponse> objects, but the latter objects cannot be used in conjunction with HttpListener because they implement client, not server, behaviors.  \n  \n An HttpListener can require client authentication. You can either specify a particular scheme to use for authentication, or you can specify a delegate that determines the scheme to use. You must require some form of authentication to obtain information about the client's identity. For additional information, see the <xref:System.Net.HttpListenerContext.User%2A>, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>, and <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> properties.  \n  \n> [!NOTE]\n>  If you create an HttpListener using https, you must select a Server Certificate for that listener. Otherwise, an <xref:System.Net.HttpWebRequest> query of this HttpListener will fail with an unexpected close of the connection.  \n  \n> [!NOTE]\n>  You can configure Server Certificates and other listener options by using HttpCfg.exe. See [http://msdn.microsoft.com/library/default.asp?url=/library/en-us/http/http/httpcfg_exe.asp](http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) for more details. The executable is shipped with Windows Server 2003, or can be built from source code available in the Platform SDK.  \n  \n> [!NOTE]\n>  If you specify multiple authentication schemes for the HttpListener, the listener will challenge clients in the following order: `Negotiate`, `NTLM`, `Digest`, and then `Basic`."
  example:
  - "The following code example demonstrates using a HttpListener.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/t-system.net.httplistener_1.cs)]"
  syntax:
    content: 'public sealed class HttpListener : IDisposable'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.HttpListener.#ctor
  id: '#ctor'
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: HttpListener()
  nameWithType: HttpListener.HttpListener()
  fullName: System.Net.HttpListener.HttpListener()
  type: Constructor
  assemblies:
  - System
  namespace: System.Net
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Net.HttpListener&quot;> </xref> класса."
  remarks: "Перед использованием этого экземпляра, возвращаемая этим конструктором, необходимо вызвать его <xref:System.Net.HttpListener.Start%2A>метод.</xref:System.Net.HttpListener.Start%2A>"
  example:
  - "The following code example demonstrates using the <xref:System.Net.HttpListener> constructor to create a new <xref:System.Net.HttpListener> object. For the complete example, see the <xref:System.Net.HttpListener> class topic.  \n  \n [!code-cs[Net_listener_Basic#9](~/add/codesnippet/csharp/m-system.net.httplistene_20_1.cs)]"
  syntax:
    content: public HttpListener ();
    parameters: []
  overload: System.Net.HttpListener.#ctor*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Этот класс не может использоваться в текущей операционной системе. Для использования экземпляров этого класса требуется Windows Server 2003 или Windows XP SP2."
  platform:
  - net462
- uid: System.Net.HttpListener.Abort
  id: Abort
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Abort()
  nameWithType: HttpListener.Abort()
  fullName: System.Net.HttpListener.Abort()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Завершает работу <xref href=&quot;System.Net.HttpListener&quot;> </xref> немедленно, объекта, отменяя все текущие запросы в очереди."
  remarks: "Этот метод освобождает все ресурсы, удерживаемые данным прослушивателем. Все отложенные запросы не удается выполнить.       После вызова этого метода, может возникнуть <xref:System.ObjectDisposedException>при попытке использовать <xref:System.Net.HttpListener>.</xref:System.Net.HttpListener> </xref:System.ObjectDisposedException>"
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[Net_Listener_Basic#11](~/add/codesnippet/csharp/m-system.net.httplistene_4_1.cs)]"
  syntax:
    content: public void Abort ();
    parameters: []
  overload: System.Net.HttpListener.Abort*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.AuthenticationSchemes
  id: AuthenticationSchemes
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: AuthenticationSchemes
  nameWithType: HttpListener.AuthenticationSchemes
  fullName: System.Net.HttpListener.AuthenticationSchemes
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Возвращает или задает схему, используемую для проверки подлинности клиентов."
  remarks: "<xref:System.Net.HttpListener>Использует указанную схему для проверки подлинности всех входящих запросов.</xref:System.Net.HttpListener> <xref:System.Net.HttpListener.GetContext%2A>И <xref:System.Net.HttpListener.EndGetContext%2A>методы возвращают входящего клиентского запроса только в том случае, если <xref:System.Net.HttpListener>успешно проходит проверку подлинности запроса.</xref:System.Net.HttpListener> </xref:System.Net.HttpListener.EndGetContext%2A> </xref:System.Net.HttpListener.GetContext%2A>       Можно запрашивать удостоверение успешно прошедшего проверку подлинности клиента с помощью <xref:System.Net.HttpListenerContext.User%2A?displayProperty=fullName>свойство.</xref:System.Net.HttpListenerContext.User%2A?displayProperty=fullName>       Если требуется <xref:System.Net.HttpListener>объект для использования в различных механизмов проверки подлинности на основе характеристик запросов, он получает (например, в запросе <xref:System.Net.HttpListenerRequest.Url%2A>или <xref:System.Net.HttpListenerRequest.UserHostName%2A>Свойства), необходимо реализовать метод, который выбирает схему проверки подлинности.</xref:System.Net.HttpListenerRequest.UserHostName%2A> </xref:System.Net.HttpListenerRequest.Url%2A> </xref:System.Net.HttpListener> Инструкции о том, как это сделать в разделе <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>документации свойства.</xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>      Настроек [!NOTE] настроек задать это свойство, чтобы включить дайджест, Negotiate или NTLM требует <xref:System.Security.Permissions.SecurityPermission> <xref:System.Security.Permissions.SecurityPermissionFlag>.</xref:System.Security.Permissions.SecurityPermissionFlag> </xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "The following code example demonstrates using the AuthenticationSchemes property to specify an authentication scheme.  \n  \n [!code-cs[Net_listener_Basic#14](~/add/codesnippet/csharp/p-system.net.httplistene_0_1.cs)]"
  syntax:
    content: public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }
    return:
      type: System.Net.AuthenticationSchemes
      description: "Побитовое сочетание <xref:System.Net.AuthenticationSchemes>значений перечисления, указывающее, как клиенты должны пройти проверку подлинности.</xref:System.Net.AuthenticationSchemes> Значение по умолчанию — <xref:System.Net.AuthenticationSchemes>.</xref:System.Net.AuthenticationSchemes>"
  overload: System.Net.HttpListener.AuthenticationSchemes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Этот объект был закрыт."
  platform:
  - net462
- uid: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  id: AuthenticationSchemeSelectorDelegate
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: AuthenticationSchemeSelectorDelegate
  nameWithType: HttpListener.AuthenticationSchemeSelectorDelegate
  fullName: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Возвращает или задает делегат, вызываемый для определения протокола, используемого для проверки подлинности клиентов."
  remarks: "> [!NOTE]Настроек Если требуется, чтобы один и тот же протокол проверки подлинности, используемый для всех запросов, обрабатываемых определенным экземпляром <xref:System.Net.HttpListener>, необходимо задать это свойство.</xref:System.Net.HttpListener> Чтобы указать протокол, используемый для всех запросов клиентов, используйте <xref:System.Net.HttpListener.AuthenticationSchemes%2A>свойство.</xref:System.Net.HttpListener.AuthenticationSchemes%2A>       Если клиент не указал сведения для проверки подлинности в заголовке, <xref:System.Net.HttpListener>вызывает указанный делегат для каждого не прошедших проверку подлинности входящего запроса определить, какой протокол использовать для проверки подлинности клиента.</xref:System.Net.HttpListener> <xref:System.Net.HttpListener.GetContext%2A>И <xref:System.Net.HttpListener.EndGetContext%2A>входящий запрос только тогда, когда они возвращают <xref:System.Net.HttpListener>успешно прошел проверку подлинности запроса.</xref:System.Net.HttpListener> </xref:System.Net.HttpListener.EndGetContext%2A> </xref:System.Net.HttpListener.GetContext%2A> Если запрос не может пройти проверку подлинности, <xref:System.Net.HttpListener>автоматически отправляет обратно ответ 401.</xref:System.Net.HttpListener> Можно получить удостоверение успешно прошедшего проверку подлинности клиента с помощью <xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=fullName>свойство.</xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=fullName>       Возможность делегирования Выбор протокола проверки подлинности в приложении метод полезно использовать экземпляр <xref:System.Net.HttpListener>для использования различных протоколов проверки подлинности в зависимости от характеристик, он получает запросы (например, в запросе <xref:System.Net.HttpListenerRequest.Url%2A>или <xref:System.Net.HttpListenerRequest.UserHostAddress%2A>свойство).</xref:System.Net.HttpListenerRequest.UserHostAddress%2A> </xref:System.Net.HttpListenerRequest.Url%2A> </xref:System.Net.HttpListener>      Настроек [!NOTE] настроек задать это свойство, чтобы включить дайджест, Negotiate или NTLM требует <xref:System.Security.Permissions.SecurityPermission> <xref:System.Security.Permissions.SecurityPermissionFlag>.</xref:System.Security.Permissions.SecurityPermissionFlag> </xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "The following code example sets the value of this property.  \n  \n [!code-vb[NclListener#2](~/add/codesnippet/visualbasic/p-system.net.httplistene_2_1.vb)]\n [!code-cs[NclListener#2](~/add/codesnippet/csharp/p-system.net.httplistene_2_1.cs)]  \n  \n The following code example provides an implementation of a method invoked by an <xref:System.Net.AuthenticationSchemeSelector> delegate.  \n  \n [!code-vb[NclListener#1](~/add/codesnippet/visualbasic/p-system.net.httplistene_2_2.vb)]\n [!code-cs[NclListener#1](~/add/codesnippet/csharp/p-system.net.httplistene_2_2.cs)]"
  syntax:
    content: public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }
    return:
      type: System.Net.AuthenticationSchemeSelector
      description: "<xref href=&quot;System.Net.AuthenticationSchemeSelector&quot;> </xref> Делегат, вызывающий метод, используемый для выбора протокола аутентификации. Значение по умолчанию — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Этот объект был закрыт."
  platform:
  - net462
- uid: System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)
  id: BeginGetContext(System.AsyncCallback,System.Object)
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: BeginGetContext(AsyncCallback,Object)
  nameWithType: HttpListener.BeginGetContext(AsyncCallback,Object)
  fullName: System.Net.HttpListener.BeginGetContext(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Начинает асинхронное получение входящего запроса."
  remarks: "Метод BeginGetContext начинает асинхронный вызов для получения входящих клиентских запросов (без блокировки). Перед вызовом этого метода необходимо вызвать <xref:System.Net.HttpListener.Start%2A>метода и добавьте по крайней мере один префикс универсальный код ресурса (URI) для прослушивания путем добавления строки URI для <xref:System.Net.HttpListenerPrefixCollection>возвращенных <xref:System.Net.HttpListener.Prefixes%2A>свойство.</xref:System.Net.HttpListener.Prefixes%2A> </xref:System.Net.HttpListenerPrefixCollection> </xref:System.Net.HttpListener.Start%2A>       Асинхронная операция необходимо завершить путем вызова <xref:System.Net.HttpListener.EndGetContext%2A>метод.</xref:System.Net.HttpListener.EndGetContext%2A> Как правило, вызывается метод `callback` делегата.       Этот метод блокируется до завершения операции. Чтобы получить входящего запроса и блок до завершения операции, вызовите <xref:System.Net.HttpListener.GetContext%2A>метод.</xref:System.Net.HttpListener.GetContext%2A>       Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/add/includes/ajax-current-ext-md.md)"
  example:
  - "The following code example demonstrates using the BeginGetContext method to specify a callback method that will handle incoming client requests.  \n  \n [!code-cs[Net_Listener_Basic#12](~/add/codesnippet/csharp/m-system.net.httplistene_13_1.cs)]  \n  \n The following code example implements a callback method.  \n  \n [!code-cs[Net_Listener_Basic#13](~/add/codesnippet/csharp/m-system.net.httplistene_13_2.cs)]"
  syntax:
    content: public IAsyncResult BeginGetContext (AsyncCallback callback, object state);
    parameters:
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>Делегат, который ссылается на метод, вызываемый после клиентского запроса.</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "Определенный пользователем объект, который содержит сведения об операции. Этот объект передается `callback` делегировать после завершения операции."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Объект, указывающий состояние асинхронной операции.</xref:System.IAsyncResult>"
  overload: System.Net.HttpListener.BeginGetContext*
  exceptions:
  - type: System.Net.HttpListenerException
    commentId: T:System.Net.HttpListenerException
    description: "Сбой вызова функции Win32. Проверьте свойство исключения <xref:System.Net.HttpListenerException.ErrorCode*>Свойства, чтобы определить причину исключения.</xref:System.Net.HttpListenerException.ErrorCode*>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Этот объект не был запущен или остановлен."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Этот объект был закрыт."
  platform:
  - net462
- uid: System.Net.HttpListener.Close
  id: Close
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Close()
  nameWithType: HttpListener.Close()
  fullName: System.Net.HttpListener.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Завершает работу <xref href=&quot;System.Net.HttpListener&quot;> </xref>."
  remarks: "После вызова этого метода, больше не может использовать <xref:System.Net.HttpListener>объекта.</xref:System.Net.HttpListener> Чтобы временно приостановить <xref:System.Net.HttpListener>, используйте <xref:System.Net.HttpListener.Stop%2A>метод.</xref:System.Net.HttpListener.Stop%2A> </xref:System.Net.HttpListener>       Этот метод завершает пребывания <xref:System.Net.HttpListener>объекта без обработки запросов в очереди.</xref:System.Net.HttpListener> Все отложенные запросы не удается выполнить."
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/m-system.net.httplistene_10_1.cs)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Net.HttpListener.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.DefaultServiceNames
  id: DefaultServiceNames
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: DefaultServiceNames
  nameWithType: HttpListener.DefaultServiceNames
  fullName: System.Net.HttpListener.DefaultServiceNames
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Получает список имен поставщиков услуг (SPN) по умолчанию, в соответствии с зарегистрированными префиксами."
  remarks: "The DefaultServiceNames property is used with integrated Windows authentication to provide extended protection. The list of SPNs is initialized from the <xref:System.Net.HttpListener.Prefixes%2A> property when accessed and cleared when new prefixes are added to the <xref:System.Net.HttpListener.Prefixes%2A> property.  \n  \n The DefaultServiceNames property is used if an application doesn't set the <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> property on its extended protection policy.  \n  \n The <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection> that is retrieved with the DefaultServiceNames property is built from the <xref:System.Net.HttpListener.Prefixes%2A> property according to the following rules:  \n  \n1.  If the hostname is \"+\", \"*\", or an IPv4 or IPv6 literal (equivalent to \"\\*\" but restricted to a specific local interface), the following SPN is added:  \n  \n `\"HTTP/\"` plus the fully qualified domain name of the computer.  \n  \n1.  If the hostname contains no dots (no domains or subdomains), an attempt is made to resolve the fully-qualified domain name using DNS (the same behavior used by <xref:System.Net.HttpWebRequest>). If the fully-qualified domain name can be resolved, the following SPNs are added:  \n  \n `\"HTTP/\"` plus the hostname (the short name).  \n  \n `\"HTTP/\"` plus the fully qualified domain name for the hostname.  \n  \n1.  If the hostname contains not dots (no domains or subdomains) and a fully-qualified domain name can't be resolved, the following SPN is added:  \n  \n `\"HTTP/\"` plus the hostname.  \n  \n1.  If the hostname contains dots (domains or subdomains), the following SPN is added:  \n  \n `\"HTTP/\"` plus the hostname.  \n  \n The DefaultServiceNames property can be used by an application to review the list of default SPNs which will be used for authentication if no custom list is supplied. If other SPNs are needed, an application can add them using one of the <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> methods.  \n  \n It is not safe when using extended protection to make policy decisions based on the requested URL, since this can be spoofed. Rather, applications should rely on the <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> or <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> properties to make such policy decisions."
  syntax:
    content: public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }
    return:
      type: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
      description: "Объект <xref href=&quot;System.Security.Authentication.ExtendedProtection.ServiceNameCollection&quot;> </xref> , содержащая список имен участников-служб."
  overload: System.Net.HttpListener.DefaultServiceNames*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.EndGetContext(System.IAsyncResult)
  id: EndGetContext(System.IAsyncResult)
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: EndGetContext(IAsyncResult)
  nameWithType: HttpListener.EndGetContext(IAsyncResult)
  fullName: System.Net.HttpListener.EndGetContext(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Завершает асинхронную операцию получения входящего клиентского запроса."
  remarks: "Вызывается метод EndGetContext, обычно в методе обратного вызова, определяемые приложением, ни делегатом, чтобы получить <xref:System.Net.HttpListenerContext>, содержащий входящего клиентского запроса и его связанного ответа.</xref:System.Net.HttpListenerContext> Этот метод завершает операцию, запущенную ранее вызовом <xref:System.Net.HttpListener.BeginGetContext%2A>метод.</xref:System.Net.HttpListener.BeginGetContext%2A> Если операция не завершена, этот метод блокируется до завершения удаления.       Поскольку вызов метода EndGetContext требует <xref:System.Net.HttpListener>объекта, этот объект обычно передается в метод обратного вызова, используя объект состояния, переданные в <xref:System.Net.HttpListener.BeginGetContext%2A>метод.</xref:System.Net.HttpListener.BeginGetContext%2A> </xref:System.Net.HttpListener> Этот объект состояния можно получить с помощью <xref:System.IAsyncResult.AsyncState%2A>свойство `asyncResult` объекта.</xref:System.IAsyncResult.AsyncState%2A>       Подробные сведения об использовании модели асинхронного программирования см. в разделе [асинхронный вызов синхронных методов](~/add/includes/ajax-current-ext-md.md)"
  example:
  - "The following code example shows the implementation of a callback method that calls the EndGetContext method.  \n  \n [!code-cs[Net_Listener_Basic#13](~/add/codesnippet/csharp/m-system.net.httplistene_1_1.cs)]"
  syntax:
    content: public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Объект, который был получен при запуске асинхронной операции.</xref:System.IAsyncResult>"
    return:
      type: System.Net.HttpListenerContext
      description: "<xref href=&quot;System.Net.HttpListenerContext&quot;> </xref> , Представляющий запрос клиента."
  overload: System.Net.HttpListener.EndGetContext*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>asyncResult</code>не был получен путем вызова <xref:System.Net.HttpListener.BeginGetContext*> метод."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Метод EndGetContext уже был вызван для указанного <code> asyncResult </code> объекта."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Этот объект был закрыт."
  platform:
  - net462
- uid: System.Net.HttpListener.ExtendedProtectionPolicy
  id: ExtendedProtectionPolicy
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: ExtendedProtectionPolicy
  nameWithType: HttpListener.ExtendedProtectionPolicy
  fullName: System.Net.HttpListener.ExtendedProtectionPolicy
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Возвращает или задает <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> для расширенной защиты сеанса."
  remarks: "Свойство ExtendedProtectionPolicy используется со встроенной проверкой подлинности Windows для обеспечения расширенной защиты. Свойство ExtendedProtectionPolicy позволяет настраивать расширенную политику защиты для всего <xref:System.Net.HttpListener>сеанса.</xref:System.Net.HttpListener> <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A>Свойство позволяет настраивать расширенную политику защиты для каждого отдельного запроса.</xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A>       <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A>Свойство должно быть `null`.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> <xref:System.Net.HttpListener>Экземпляр получает маркера привязки канала (CBT) непосредственно из сеанса TLS, если таковой имеется.</xref:System.Net.HttpListener>"
  syntax:
    content: public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }
    return:
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "Объект <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> , задает политику для расширенной защиты."
  overload: System.Net.HttpListener.ExtendedProtectionPolicy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Была предпринята попытка задать свойство ExtendedProtectionPolicy, но <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>свойство не было <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Была предпринята попытка установить свойства ExtendedProtectionPolicy <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Была предпринята попытка задать свойство ExtendedProtectionPolicy после <xref:System.Net.HttpListener.Start*>метод уже был вызван.</xref:System.Net.HttpListener.Start*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Этот объект был закрыт."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement*>Было задано значение <xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;> </xref> на платформу, которая не поддерживает расширенную защиту.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement*>"
  platform:
  - net462
- uid: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  id: ExtendedProtectionSelectorDelegate
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: ExtendedProtectionSelectorDelegate
  nameWithType: HttpListener.ExtendedProtectionSelectorDelegate
  fullName: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Возвращает или задает делегат, вызываемый для определения <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> для каждого запроса."
  remarks: "<xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A>Свойство используется со встроенной проверкой подлинности Windows для обеспечения расширенной защиты.</xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A>Свойство позволяет настраивать расширенную политику защиты для всего <xref:System.Net.HttpListener>сеанса.</xref:System.Net.HttpListener> </xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> Свойство ExtendedProtectionSelectorDelegate позволяет настраивать расширенную политику защиты каждого отдельного запроса.       <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A>Свойство должно быть `null`.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> <xref:System.Net.HttpListener>Экземпляр получает маркера привязки канала (CBT) непосредственно из сеанса TLS, если таковой имеется.</xref:System.Net.HttpListener>       Для каждого запроса делегат может выбрать параметры, <xref:System.Net.HttpListener>экземпляр будет использовать для обеспечения расширенной защиты.</xref:System.Net.HttpListener>       Если делегат возвращает `null` для этого свойства представляет <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>которой <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>присвоено <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>.</xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement> </xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> </xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>"
  syntax:
    content: public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }
    return:
      type: System.Net.HttpListener.ExtendedProtectionSelector
      description: "Объект <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> , задает политику для расширенной защиты."
  overload: System.Net.HttpListener.ExtendedProtectionSelectorDelegate*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Была предпринята попытка задать свойство ExtendedProtectionSelectorDelegate, но <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>свойство должно быть <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>.</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Была предпринята попытка установить свойства ExtendedProtectionSelectorDelegate <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Была предпринята попытка задать свойство ExtendedProtectionSelectorDelegate после <xref:System.Net.HttpListener.Start*>метод уже был вызван.</xref:System.Net.HttpListener.Start*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Этот объект был закрыт."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Была предпринята попытка задать свойство ExtendedProtectionSelectorDelegate на платформу, которая не поддерживает расширенную защиту."
  platform:
  - net462
- uid: System.Net.HttpListener.GetContext
  id: GetContext
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: GetContext()
  nameWithType: HttpListener.GetContext()
  fullName: System.Net.HttpListener.GetContext()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Ожидает входящий запрос и возвращает при его получении."
  remarks: "Перед вызовом этого метода необходимо вызвать <xref:System.Net.HttpListener.Start%2A>метода и добавьте по крайней мере один префикс URI для прослушивания путем добавления строки URI для <xref:System.Net.HttpListenerPrefixCollection>возвращенных <xref:System.Net.HttpListener.Prefixes%2A>свойство.</xref:System.Net.HttpListener.Prefixes%2A> </xref:System.Net.HttpListenerPrefixCollection> </xref:System.Net.HttpListener.Start%2A> Подробное описание префиксов см. в разделе <xref:System.Net.HttpListener>Общие сведения о классе.</xref:System.Net.HttpListener>       Этот метод блокируется во время ожидания для входящего запроса. Входящие запросы обрабатываются асинхронно (отдельных потоков), чтобы приложение не блокирует используйте <xref:System.Net.HttpListener.BeginGetContext%2A>метод.</xref:System.Net.HttpListener.BeginGetContext%2A>"
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/m-system.net.httplistene_19_1.cs)]"
  syntax:
    content: public System.Net.HttpListenerContext GetContext ();
    parameters: []
    return:
      type: System.Net.HttpListenerContext
      description: "<xref href=&quot;System.Net.HttpListenerContext&quot;> </xref> Объекта, представляющего собой клиентский запрос."
  overload: System.Net.HttpListener.GetContext*
  exceptions:
  - type: System.Net.HttpListenerException
    commentId: T:System.Net.HttpListenerException
    description: "Сбой вызова функции Win32. Проверьте свойство исключения <xref:System.Net.HttpListenerException.ErrorCode*>Свойства, чтобы определить причину исключения.</xref:System.Net.HttpListenerException.ErrorCode*>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Этот объект не был запущен или остановлен.       - или - <xref href=&quot;System.Net.HttpListener&quot;> </xref> имеет префиксы универсальный код ресурса (URI), ответ на. См. заметки."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Этот объект был закрыт."
  platform:
  - net462
- uid: System.Net.HttpListener.GetContextAsync
  id: GetContextAsync
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: GetContextAsync()
  nameWithType: HttpListener.GetContextAsync()
  fullName: System.Net.HttpListener.GetContextAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Ожидает входящий запрос как асинхронную операцию."
  remarks: "Эта операция не будет блокирована. Возвращенный <xref:System.Threading.Tasks.Task%601>объекта будет выполнена при получении входящего запроса.</xref:System.Threading.Tasks.Task%601>       Перед вызовом этого метода необходимо вызвать <xref:System.Net.HttpListener.Start%2A>метода и добавьте по крайней мере один префикс URI для прослушивания путем добавления строки URI для <xref:System.Net.HttpListenerPrefixCollection>возвращенных <xref:System.Net.HttpListener.Prefixes%2A>свойство.</xref:System.Net.HttpListener.Prefixes%2A> </xref:System.Net.HttpListenerPrefixCollection> </xref:System.Net.HttpListener.Start%2A> Подробное описание префиксов см. в разделе <xref:System.Net.HttpListener>Общие сведения о классе.</xref:System.Net.HttpListener>"
  syntax:
    content: public System.Threading.Tasks.Task<System.Net.HttpListenerContext> GetContextAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task{System.Net.HttpListenerContext}
      description: "Возвращает &lt;xref:System.Threading.Tasks.Task%601&gt;.       Объект задачи, представляющий асинхронную операцию. &lt;Xref:System.Threading.Tasks.Task%601.Result%2A&gt; свойство объекта задачи возвращает <xref href=&quot;System.Net.HttpListenerContext&quot;> </xref> объекта, представляющего собой клиентский запрос."
  overload: System.Net.HttpListener.GetContextAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.IgnoreWriteExceptions
  id: IgnoreWriteExceptions
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: IgnoreWriteExceptions
  nameWithType: HttpListener.IgnoreWriteExceptions
  fullName: System.Net.HttpListener.IgnoreWriteExceptions
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Возвращает или задает <xref:System.Boolean>значение, указывающее, получает ли приложение исключения, возникающие при <xref href=&quot;System.Net.HttpListener&quot;> </xref> отправляет ответ клиенту.</xref:System.Boolean>"
  remarks: "Присвойте этому свойству значение `true` Если приложение не требует успешной отправки ответа каждому клиенту."
  example:
  - "The following code example demonstrates setting this property.  \n  \n [!code-cs[Net_Listener_Basic#14](~/add/codesnippet/csharp/p-system.net.httplistene_31_1.cs)]"
  syntax:
    content: public bool IgnoreWriteExceptions { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если этот <xref href=&quot;System.Net.HttpListener&quot;> </xref> не должен возвращать исключения, возникающие при отправке ответа клиенту; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.IgnoreWriteExceptions*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Этот объект был закрыт."
  platform:
  - net462
- uid: System.Net.HttpListener.IsListening
  id: IsListening
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: IsListening
  nameWithType: HttpListener.IsListening
  fullName: System.Net.HttpListener.IsListening
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Возвращает значение, указывающее, является ли <xref href=&quot;System.Net.HttpListener&quot;> </xref> запущена."
  remarks: "Чтобы запустить <xref:System.Net.HttpListener>, вызовите <xref:System.Net.HttpListener.Start%2A>метод.</xref:System.Net.HttpListener.Start%2A> </xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates using this property to determine the listening state of an instance.  \n  \n [!code-cs[Net_Listener_Basic#1](~/add/codesnippet/csharp/p-system.net.httplistene_41_1.cs)]"
  syntax:
    content: public bool IsListening { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref href=&quot;System.Net.HttpListener&quot;> </xref> был запущен; в противном случае — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.IsListening*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.IsSupported
  id: IsSupported
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: IsSupported
  nameWithType: HttpListener.IsSupported
  fullName: System.Net.HttpListener.IsSupported
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Возвращает значение, указывающее, является ли <xref href=&quot;System.Net.HttpListener&quot;> </xref> может использоваться с текущей операционной системой."
  remarks: "Этот класс доступен только на компьютерах, работающих под управлением ОС Windows XP SP2 или Windows Server 2003."
  example:
  - "The following code example demonstrates the use of the IsSupported property to detect whether an <xref:System.Net.HttpListener> object can be used with the current operating system.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/p-system.net.httplistene_21_1.cs)]"
  syntax:
    content: public static bool IsSupported { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref href=&quot;System.Net.HttpListener&quot;> </xref> поддерживается; в противном случае — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.IsSupported*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.Prefixes
  id: Prefixes
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Prefixes
  nameWithType: HttpListener.Prefixes
  fullName: System.Net.HttpListener.Prefixes
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Возвращает универсальный код ресурса (URI) префиксы, обрабатываемые этим <xref href=&quot;System.Net.HttpListener&quot;> </xref> объекта."
  remarks: "Префиксы указаны в канонической форме. Подробное описание префиксов см. в разделе <xref:System.Net.HttpListener>Общие сведения о классе.</xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates using the Prefixes property to obtain and print the URI prefixes that are handled.  \n  \n [!code-cs[Net_Listener_Basic#1](~/add/codesnippet/csharp/p-system.net.httplistene_24_1.cs)]"
  syntax:
    content: public System.Net.HttpListenerPrefixCollection Prefixes { get; }
    return:
      type: System.Net.HttpListenerPrefixCollection
      description: "<xref href=&quot;System.Net.HttpListenerPrefixCollection&quot;> </xref> , Содержащий URI префиксов этим <xref href=&quot;System.Net.HttpListener&quot;> </xref> объект настроен для обработки."
  overload: System.Net.HttpListener.Prefixes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Этот объект был закрыт."
  platform:
  - net462
- uid: System.Net.HttpListener.Realm
  id: Realm
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Realm
  nameWithType: HttpListener.Realm
  fullName: System.Net.HttpListener.Realm
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Возвращает или задает область или раздел ресурса, связанный с этим <xref href=&quot;System.Net.HttpListener&quot;> </xref> объекта."
  remarks: "Серверы используют области для разделения защищенных ресурсов; Каждая секция может иметь свою собственную схему и базу данных проверки подлинности. Области используются только для обычной и дайджест-проверки подлинности. После успешного прохождения клиентом проверки подлинности является действительным для всех ресурсов в данной области. Подробное описание областей см в документе RFC 2617 по [http://www.ietf.org](http://www.ietf.org).       Экземпляр <xref:System.Net.HttpListener>имеет только один связанный сферы.</xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates setting the Realm property.  \n  \n [!code-cs[Net_Listener_Basic#10](~/add/codesnippet/csharp/p-system.net.httplistene_26_1.cs)]"
  syntax:
    content: public string Realm { get; set; }
    return:
      type: System.String
      description: "Объект <xref:System.String>значение, содержащее имя области, связанной с <xref href=&quot;System.Net.HttpListener&quot;> </xref> объекта.</xref:System.String>"
  overload: System.Net.HttpListener.Realm*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Этот объект был закрыт."
  platform:
  - net462
- uid: System.Net.HttpListener.Start
  id: Start
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Start()
  nameWithType: HttpListener.Start()
  fullName: System.Net.HttpListener.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Позволяет этому экземпляру получать входящие запросы."
  remarks: "Этот метод должен вызываться перед вызовом метода <xref:System.Net.HttpListener.GetContext%2A>или <xref:System.Net.HttpListener.BeginGetContext%2A>метод.</xref:System.Net.HttpListener.BeginGetContext%2A> </xref:System.Net.HttpListener.GetContext%2A>       После вы запустили <xref:System.Net.HttpListener>объекта, можно использовать <xref:System.Net.HttpListener.Stop%2A>метод, чтобы остановить его.</xref:System.Net.HttpListener.Stop%2A> </xref:System.Net.HttpListener>      Настроек [!NOTE] настроек этот экземпляр прослушивателя использует протокол https, необходимо установить и выбрать сертификат сервера. В противном случае <xref:System.Net.HttpWebRequest>запрос этого <xref:System.Net.HttpListener>, будут завершаться неожиданный запрос закрытия соединения.</xref:System.Net.HttpListener> </xref:System.Net.HttpWebRequest> Сертификаты сервера и другие параметры прослушивателя можно настроить с помощью HttpCfg.exe. В разделе [http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp](http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) для получения дополнительных сведений."
  example:
  - "The following code example demonstrates using the Start method to begin processing incoming requests.  \n  \n [!code-cs[Net_Listener_Basic#12](~/add/codesnippet/csharp/m-system.net.httplistene_12_1.cs)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Net.HttpListener.Start*
  exceptions:
  - type: System.Net.HttpListenerException
    commentId: T:System.Net.HttpListenerException
    description: "Сбой вызова функции Win32. Проверьте свойство исключения <xref:System.Net.HttpListenerException.ErrorCode*>Свойства, чтобы определить причину исключения.</xref:System.Net.HttpListenerException.ErrorCode*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Этот объект был закрыт."
  platform:
  - net462
- uid: System.Net.HttpListener.Stop
  id: Stop
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Stop()
  nameWithType: HttpListener.Stop()
  fullName: System.Net.HttpListener.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Заставляет этот экземпляр прекратить получать входящие запросы."
  remarks: "Если этот экземпляр уже был остановлен, вызов этого метода не оказывает влияния.       После Вы остановили <xref:System.Net.HttpListener>объекта, можно использовать <xref:System.Net.HttpListener.Start%2A>метод на ее перезапуск.</xref:System.Net.HttpListener.Start%2A> </xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates using the Stop method to stop processing incoming requests.  \n  \n [!code-cs[Net_Listener_Basic#12](~/add/codesnippet/csharp/m-system.net.httplistene_5_1.cs)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Net.HttpListener.Stop*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Этот объект был закрыт."
  platform:
  - net462
- uid: System.Net.HttpListener.System#IDisposable#Dispose
  id: System#IDisposable#Dispose
  isEii: true
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: System.IDisposable.Dispose()
  nameWithType: HttpListener.System.IDisposable.Dispose()
  fullName: System.Net.HttpListener.System.IDisposable.Dispose()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "Освобождает ресурсы, удерживаемые этим <xref href=&quot;System.Net.HttpListener&quot;> </xref> объекта."
  remarks: "Приложения должны использовать <xref:System.Net.HttpListener.Close%2A>метод вместо вызова данного метода.</xref:System.Net.HttpListener.Close%2A>"
  syntax:
    content: void IDisposable.Dispose ();
    parameters: []
  overload: System.Net.HttpListener.System#IDisposable#Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.TimeoutManager
  id: TimeoutManager
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: TimeoutManager
  nameWithType: HttpListener.TimeoutManager
  fullName: System.Net.HttpListener.TimeoutManager
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Диспетчер времени ожидания для этого <xref href=&quot;System.Net.HttpListener&quot;> </xref> экземпляра."
  remarks: "Диспетчер времени ожидания определяет ограничения на время ожидания подключения для этого <xref:System.Net.HttpListener>экземпляра.</xref:System.Net.HttpListener>"
  syntax:
    content: public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }
    return:
      type: System.Net.HttpListenerTimeoutManager
      description: "Returns <xref href=&quot;System.Net.HttpListenerTimeoutManager&quot;></xref>.       Диспетчер времени ожидания для этого <xref href=&quot;System.Net.HttpListener&quot;> </xref> экземпляра."
  overload: System.Net.HttpListener.TimeoutManager*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  id: UnsafeConnectionNtlmAuthentication
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: UnsafeConnectionNtlmAuthentication
  nameWithType: HttpListener.UnsafeConnectionNtlmAuthentication
  fullName: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "Возвращает или задает <xref:System.Boolean>значение, которое определяет, должны ли, когда используется протокол NTLM, дополнительные запросы, использующие то же подключение протокола управления передачей (TCP), необходимо пройти проверку подлинности.</xref:System.Boolean>"
  remarks: "Если значение этого свойства `true` и первый запрос по определенному TCP-подключению проходит проверку подлинности с помощью NTLM, последующие запросы через TCP-подключению обрабатываются с использованием проверки подлинности (<xref:System.Security.Principal.IIdentity>) исходного запроса.</xref:System.Security.Principal.IIdentity>       Это свойство имеет смысл, если NTLM не является протоколом проверки подлинности. Если указано как протокол проверки подлинности Negotiate, это свойство действует только если для проверки подлинности используется протокол NTLM.      Настроек [!NOTE] настроек при задании этого свойства `true` повышает производительность, поскольку <xref:System.Net.HttpListener>не отправлять дополнительные проверки подлинности NTLM, существует риск для безопасности в запросы, чтобы предоставить сведения для проверки подлинности.</xref:System.Net.HttpListener> Необходимо определить, стоит ли увеличение производительности этот риск."
  example:
  - "The following code example demonstrates setting this property.  \n  \n [!code-cs[Net_Listener_Basic#14](~/add/codesnippet/csharp/p-system.net.httplistene_34_1.cs)]"
  syntax:
    content: public bool UnsafeConnectionNtlmAuthentication { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref:System.Security.Principal.IIdentity>первого запроса будут использоваться для последующих запросов по тому же подключению; в противном случае — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Security.Principal.IIdentity> Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Этот объект был закрыт."
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Net.HttpListenerException
  parent: System.Net
  isExternal: false
  name: HttpListenerException
  nameWithType: HttpListenerException
  fullName: System.Net.HttpListenerException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Net.HttpListener.#ctor
  parent: System.Net.HttpListener
  isExternal: false
  name: HttpListener()
  nameWithType: HttpListener.HttpListener()
  fullName: System.Net.HttpListener.HttpListener()
- uid: System.Net.HttpListener.Abort
  parent: System.Net.HttpListener
  isExternal: false
  name: Abort()
  nameWithType: HttpListener.Abort()
  fullName: System.Net.HttpListener.Abort()
- uid: System.Net.HttpListener.AuthenticationSchemes
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemes
  nameWithType: HttpListener.AuthenticationSchemes
  fullName: System.Net.HttpListener.AuthenticationSchemes
- uid: System.Net.AuthenticationSchemes
  parent: System.Net
  isExternal: true
  name: AuthenticationSchemes
  nameWithType: AuthenticationSchemes
  fullName: System.Net.AuthenticationSchemes
- uid: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemeSelectorDelegate
  nameWithType: HttpListener.AuthenticationSchemeSelectorDelegate
  fullName: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
- uid: System.Net.AuthenticationSchemeSelector
  parent: System.Net
  isExternal: false
  name: AuthenticationSchemeSelector
  nameWithType: AuthenticationSchemeSelector
  fullName: System.Net.AuthenticationSchemeSelector
- uid: System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)
  parent: System.Net.HttpListener
  isExternal: false
  name: BeginGetContext(AsyncCallback,Object)
  nameWithType: HttpListener.BeginGetContext(AsyncCallback,Object)
  fullName: System.Net.HttpListener.BeginGetContext(AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Net.HttpListener.Close
  parent: System.Net.HttpListener
  isExternal: false
  name: Close()
  nameWithType: HttpListener.Close()
  fullName: System.Net.HttpListener.Close()
- uid: System.Net.HttpListener.DefaultServiceNames
  parent: System.Net.HttpListener
  isExternal: false
  name: DefaultServiceNames
  nameWithType: HttpListener.DefaultServiceNames
  fullName: System.Net.HttpListener.DefaultServiceNames
- uid: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: false
  name: ServiceNameCollection
  nameWithType: ServiceNameCollection
  fullName: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
- uid: System.Net.HttpListener.EndGetContext(System.IAsyncResult)
  parent: System.Net.HttpListener
  isExternal: false
  name: EndGetContext(IAsyncResult)
  nameWithType: HttpListener.EndGetContext(IAsyncResult)
  fullName: System.Net.HttpListener.EndGetContext(IAsyncResult)
- uid: System.Net.HttpListenerContext
  parent: System.Net
  isExternal: false
  name: HttpListenerContext
  nameWithType: HttpListenerContext
  fullName: System.Net.HttpListenerContext
- uid: System.Net.HttpListener.ExtendedProtectionPolicy
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: HttpListener.ExtendedProtectionPolicy
  fullName: System.Net.HttpListener.ExtendedProtectionPolicy
- uid: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: ExtendedProtectionPolicy
  fullName: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
- uid: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionSelectorDelegate
  nameWithType: HttpListener.ExtendedProtectionSelectorDelegate
  fullName: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
- uid: System.Net.HttpListener.ExtendedProtectionSelector
  parent: System.Net
  isExternal: false
  name: HttpListener+ExtendedProtectionSelector
  nameWithType: HttpListener+ExtendedProtectionSelector
  fullName: System.Net.HttpListener+ExtendedProtectionSelector
- uid: System.Net.HttpListener.GetContext
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContext()
  nameWithType: HttpListener.GetContext()
  fullName: System.Net.HttpListener.GetContext()
- uid: System.Net.HttpListener.GetContextAsync
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContextAsync()
  nameWithType: HttpListener.GetContextAsync()
  fullName: System.Net.HttpListener.GetContextAsync()
- uid: System.Threading.Tasks.Task{System.Net.HttpListenerContext}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<HttpListenerContext>
  nameWithType: Task<HttpListenerContext>
  fullName: System.Threading.Tasks.Task<System.Net.HttpListenerContext>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Net.HttpListenerContext>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Net.HttpListenerContext
    name: HttpListenerContext
    nameWithType: HttpListenerContext
    fullName: HttpListenerContext
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Net.HttpListener.IgnoreWriteExceptions
  parent: System.Net.HttpListener
  isExternal: false
  name: IgnoreWriteExceptions
  nameWithType: HttpListener.IgnoreWriteExceptions
  fullName: System.Net.HttpListener.IgnoreWriteExceptions
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.HttpListener.IsListening
  parent: System.Net.HttpListener
  isExternal: false
  name: IsListening
  nameWithType: HttpListener.IsListening
  fullName: System.Net.HttpListener.IsListening
- uid: System.Net.HttpListener.IsSupported
  parent: System.Net.HttpListener
  isExternal: false
  name: IsSupported
  nameWithType: HttpListener.IsSupported
  fullName: System.Net.HttpListener.IsSupported
- uid: System.Net.HttpListener.Prefixes
  parent: System.Net.HttpListener
  isExternal: false
  name: Prefixes
  nameWithType: HttpListener.Prefixes
  fullName: System.Net.HttpListener.Prefixes
- uid: System.Net.HttpListenerPrefixCollection
  parent: System.Net
  isExternal: false
  name: HttpListenerPrefixCollection
  nameWithType: HttpListenerPrefixCollection
  fullName: System.Net.HttpListenerPrefixCollection
- uid: System.Net.HttpListener.Realm
  parent: System.Net.HttpListener
  isExternal: false
  name: Realm
  nameWithType: HttpListener.Realm
  fullName: System.Net.HttpListener.Realm
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Net.HttpListener.Start
  parent: System.Net.HttpListener
  isExternal: false
  name: Start()
  nameWithType: HttpListener.Start()
  fullName: System.Net.HttpListener.Start()
- uid: System.Net.HttpListener.Stop
  parent: System.Net.HttpListener
  isExternal: false
  name: Stop()
  nameWithType: HttpListener.Stop()
  fullName: System.Net.HttpListener.Stop()
- uid: System.Net.HttpListener.System#IDisposable#Dispose
  parent: System.Net.HttpListener
  isExternal: false
  name: System.IDisposable.Dispose()
  nameWithType: HttpListener.System.IDisposable.Dispose()
  fullName: System.Net.HttpListener.System.IDisposable.Dispose()
- uid: System.Net.HttpListener.TimeoutManager
  parent: System.Net.HttpListener
  isExternal: false
  name: TimeoutManager
  nameWithType: HttpListener.TimeoutManager
  fullName: System.Net.HttpListener.TimeoutManager
- uid: System.Net.HttpListenerTimeoutManager
  parent: System.Net
  isExternal: false
  name: HttpListenerTimeoutManager
  nameWithType: HttpListenerTimeoutManager
  fullName: System.Net.HttpListenerTimeoutManager
- uid: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  parent: System.Net.HttpListener
  isExternal: false
  name: UnsafeConnectionNtlmAuthentication
  nameWithType: HttpListener.UnsafeConnectionNtlmAuthentication
  fullName: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
- uid: System.Net.HttpListener.#ctor*
  parent: System.Net.HttpListener
  isExternal: false
  name: HttpListener
  nameWithType: HttpListener.HttpListener
- uid: System.Net.HttpListener.Abort*
  parent: System.Net.HttpListener
  isExternal: false
  name: Abort
  nameWithType: HttpListener.Abort
- uid: System.Net.HttpListener.AuthenticationSchemes*
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemes
  nameWithType: HttpListener.AuthenticationSchemes
- uid: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate*
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemeSelectorDelegate
  nameWithType: HttpListener.AuthenticationSchemeSelectorDelegate
- uid: System.Net.HttpListener.BeginGetContext*
  parent: System.Net.HttpListener
  isExternal: false
  name: BeginGetContext
  nameWithType: HttpListener.BeginGetContext
- uid: System.Net.HttpListener.Close*
  parent: System.Net.HttpListener
  isExternal: false
  name: Close
  nameWithType: HttpListener.Close
- uid: System.Net.HttpListener.DefaultServiceNames*
  parent: System.Net.HttpListener
  isExternal: false
  name: DefaultServiceNames
  nameWithType: HttpListener.DefaultServiceNames
- uid: System.Net.HttpListener.EndGetContext*
  parent: System.Net.HttpListener
  isExternal: false
  name: EndGetContext
  nameWithType: HttpListener.EndGetContext
- uid: System.Net.HttpListener.ExtendedProtectionPolicy*
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: HttpListener.ExtendedProtectionPolicy
- uid: System.Net.HttpListener.ExtendedProtectionSelectorDelegate*
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionSelectorDelegate
  nameWithType: HttpListener.ExtendedProtectionSelectorDelegate
- uid: System.Net.HttpListener.GetContext*
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContext
  nameWithType: HttpListener.GetContext
- uid: System.Net.HttpListener.GetContextAsync*
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContextAsync
  nameWithType: HttpListener.GetContextAsync
- uid: System.Net.HttpListener.IgnoreWriteExceptions*
  parent: System.Net.HttpListener
  isExternal: false
  name: IgnoreWriteExceptions
  nameWithType: HttpListener.IgnoreWriteExceptions
- uid: System.Net.HttpListener.IsListening*
  parent: System.Net.HttpListener
  isExternal: false
  name: IsListening
  nameWithType: HttpListener.IsListening
- uid: System.Net.HttpListener.IsSupported*
  parent: System.Net.HttpListener
  isExternal: false
  name: IsSupported
  nameWithType: HttpListener.IsSupported
- uid: System.Net.HttpListener.Prefixes*
  parent: System.Net.HttpListener
  isExternal: false
  name: Prefixes
  nameWithType: HttpListener.Prefixes
- uid: System.Net.HttpListener.Realm*
  parent: System.Net.HttpListener
  isExternal: false
  name: Realm
  nameWithType: HttpListener.Realm
- uid: System.Net.HttpListener.Start*
  parent: System.Net.HttpListener
  isExternal: false
  name: Start
  nameWithType: HttpListener.Start
- uid: System.Net.HttpListener.Stop*
  parent: System.Net.HttpListener
  isExternal: false
  name: Stop
  nameWithType: HttpListener.Stop
- uid: System.Net.HttpListener.System#IDisposable#Dispose*
  parent: System.Net.HttpListener
  isExternal: false
  name: System.IDisposable.Dispose
  nameWithType: HttpListener.System.IDisposable.Dispose
- uid: System.Net.HttpListener.TimeoutManager*
  parent: System.Net.HttpListener
  isExternal: false
  name: TimeoutManager
  nameWithType: HttpListener.TimeoutManager
- uid: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication*
  parent: System.Net.HttpListener
  isExternal: false
  name: UnsafeConnectionNtlmAuthentication
  nameWithType: HttpListener.UnsafeConnectionNtlmAuthentication
