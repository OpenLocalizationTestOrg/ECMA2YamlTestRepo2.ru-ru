### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.ProcessThread
  id: ProcessThread
  children:
  - System.Diagnostics.ProcessThread.BasePriority
  - System.Diagnostics.ProcessThread.CurrentPriority
  - System.Diagnostics.ProcessThread.Id
  - System.Diagnostics.ProcessThread.IdealProcessor
  - System.Diagnostics.ProcessThread.PriorityBoostEnabled
  - System.Diagnostics.ProcessThread.PriorityLevel
  - System.Diagnostics.ProcessThread.PrivilegedProcessorTime
  - System.Diagnostics.ProcessThread.ProcessorAffinity
  - System.Diagnostics.ProcessThread.ResetIdealProcessor
  - System.Diagnostics.ProcessThread.StartAddress
  - System.Diagnostics.ProcessThread.StartTime
  - System.Diagnostics.ProcessThread.ThreadState
  - System.Diagnostics.ProcessThread.TotalProcessorTime
  - System.Diagnostics.ProcessThread.UserProcessorTime
  - System.Diagnostics.ProcessThread.WaitReason
  langs:
  - csharp
  name: ProcessThread
  nameWithType: ProcessThread
  fullName: System.Diagnostics.ProcessThread
  type: Class
  summary: "Представляет поток процесса операционной системы."
  remarks: "Используйте ProcessThread для получения сведений о потоке, на котором выполняется в настоящее время в системе. Это позволит вам, например, для наблюдения за характеристиками производительности.      Настроек [!IMPORTANT] настроек этот тип реализует <xref:System.IDisposable>интерфейса.</xref:System.IDisposable> После завершения с помощью типа следует освободить его прямо или косвенно. Для удаления типа непосредственно вызвать его <xref:System.IDisposable.Dispose%2A>метод в `try` / `catch` блока.</xref:System.IDisposable.Dispose%2A> Чтобы удалить ее косвенно, использовать языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <xref:System.IDisposable>разделе интерфейса.</xref:System.IDisposable>       Поток представляет путь выполнения в программе. Это наименьшая единица выполнения, планируемая в Win32. Он состоит из стека, состояния регистров ЦП и записи в списке выполнения системного планировщика.       Процесс состоит из одного или нескольких потоков и код, данных и других ресурсов программы в памяти. Типичными ресурсами программы являются открытые файлы, семафоры и динамически выделяемую память. Каждый ресурс процесса совместно используется всеми потоками процесса.       Программа выполняется, когда системный планировщик передает управление выполнением одному из потоков программы. Планировщик определяет, какой поток и когда. Поток с более низким приоритетом может быть вынужден, подождите, пока потоки с более высоким приоритетом выполнения их задач. На многопроцессорных компьютерах планировщик может перемещать отдельные потоки на разные процессоры, таким образом балансировки нагрузки на ЦП.       Каждый процесс начинается с одного потока, который называется основным потоком. Любой поток может создавать дополнительные потоки. Все потоки процесса разделяют адресное пространство этого процесса.       Основной поток не обязательно находятся по первому индексу в коллекции.      Настроек [!NOTE] настроек начиная с .NET Framework версии 2.0, возможность счетчика производительности ссылка была исключена данные на других компьютерах для многих методов .NET Framework и свойств. Для повышения производительности и позволяющие без прав администратора, использование класса ProcessThread этого изменения. В результате некоторые приложения, которые не получили исключения в более ранних версиях платформы .NET Framework теперь может получить <xref:System.NotSupportedException>.</xref:System.NotSupportedException> Методы и свойства, слишком много, чтобы перечислять их здесь, но сведения об исключении будет добавлен в разделы затронутых элементов.       Потоки процесса выполняются отдельно и независимо друг от друга, если только сделать их видимыми друг с другом. Тем не менее, потоки, разделяющие общие ресурсы, должны координировать свою работу с помощью семафоров и других методов межпроцессного взаимодействия.       Для получения коллекции всех объектов ProcessThread, связанный с текущим процессом, получить <xref:System.Diagnostics.Process.Threads%2A>свойство <xref:System.Diagnostics.Process>экземпляра.</xref:System.Diagnostics.Process> </xref:System.Diagnostics.Process.Threads%2A>"
  syntax:
    content: >-
      [System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      public class ProcessThread : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Dispose(System.Boolean)
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.BasePriority
  id: BasePriority
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: BasePriority
  nameWithType: ProcessThread.BasePriority
  fullName: System.Diagnostics.ProcessThread.BasePriority
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Получает базовый приоритет потока."
  remarks: "BasePriority является стартовым приоритетом для потока данного процесса. Можно просмотреть сведения о базовом приоритете через базовый приоритет счетчик системного монитора.       Операционная система вычисляет базовый приоритет потока, объединяя диапазон уровня приоритета потока с классом приоритета процесса. Можно задать процесс <xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=fullName>в одно из значений в <xref:System.Diagnostics.ProcessPriorityClass>перечисления, которые являются <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, или <xref:System.Diagnostics.ProcessPriorityClass>.</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=fullName> Можно задать потока <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A>Свойства диапазон значений, ограничивающий базовый приоритет потока.</xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> Win32 использует четыре класса приоритетов с семью основными уровнями приоритета каждого класса.       Текущий приоритет потока может отклоняться от базового приоритета. Например, операционная система может изменить <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A>затраченное свойство, основанное на времени или других показателях, когда процесс необходимо поместить впереди других для доступа к обработчику.</xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> Кроме того, можно задать <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>Свойства, чтобы система временно увеличить приоритет потока всякий раз, когда процесс выбирается из состояния ожидания.</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Приоритет сбрасывается при возвращении процесса в состояние ожидания."
  syntax:
    content: public int BasePriority { get; }
    return:
      type: System.Int32
      description: "Базовый приоритет потока, который операционная система вычисляет путем объединения класса приоритета процесса с уровнем приоритета соответствующего потока."
  overload: System.Diagnostics.ProcessThread.BasePriority*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.CurrentPriority
  id: CurrentPriority
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: CurrentPriority
  nameWithType: ProcessThread.CurrentPriority
  fullName: System.Diagnostics.ProcessThread.CurrentPriority
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает текущий приоритет потока."
  remarks: "Текущий приоритет потока может отклоняться от базового приоритета. Например операционной системы можно изменить CurrentPriority, свойство, основанное на момент времени или других показателях, когда процесса необходимо поместить впереди других для доступа к обработчику. Кроме того, можно задать <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>Свойства, чтобы система временно увеличить приоритет потока всякий раз, когда процесс выбирается из состояния ожидания.</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> Приоритет сбрасывается при возвращении процесса в состояние ожидания."
  syntax:
    content: public int CurrentPriority { get; }
    return:
      type: System.Int32
      description: "Текущий приоритет потока, который может отклоняться от базового приоритета, основываясь на способ планирования потока операционной системы. Приоритет может быть временно увеличен для активного потока."
  overload: System.Diagnostics.ProcessThread.CurrentPriority*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.Id
  id: Id
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: Id
  nameWithType: ProcessThread.Id
  fullName: System.Diagnostics.ProcessThread.Id
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает уникальный идентификатор потока."
  remarks: "Операционная система повторно использует идентификационные номера потоков, которые определяют потоки только во время их жизни."
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "Уникальный идентификатор, связанный с конкретным потоком."
  overload: System.Diagnostics.ProcessThread.Id*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.IdealProcessor
  id: IdealProcessor
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: IdealProcessor
  nameWithType: ProcessThread.IdealProcessor
  fullName: System.Diagnostics.ProcessThread.IdealProcessor
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Задает предпочтительный процессор для данного потока к выполнению."
  remarks: "Значение IdealProcessor начинается с нуля.  Другими словами, чтобы задать сходство потока для первого процессора, это свойство равно нулю.       Система планирует потоки по предпочтительным процессорам по возможности.       Поток процесса может перемещаться с процессора на процессор, с каждым перемещением обновление кэша процессора. Задавая процессор для потока может повысить производительность при больших системных нагрузках, уменьшение числа перезагрузок кэша процессора."
  example:
  - "The following example demonstrates how to set the IdealProcessor property for an instance of Notepad to the first processor.  \n  \n [!code-vb[ProcessThreadIdealProcessor#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_25_1.vb)]\n [!code-cs[ProcessThreadIdealProcessor#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_25_1.cs)]"
  syntax:
    content: public int IdealProcessor { set; }
    return:
      type: System.Int32
      description: "Предпочтительный процессор для потока, используемый при планировании потоков, чтобы определить, какой обработчик следует выполняться поток системой."
  overload: System.Diagnostics.ProcessThread.IdealProcessor*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Системе не удалось задать поток для запуска на указанном процессоре."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Данный процесс выполняется на удаленном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.PriorityBoostEnabled
  id: PriorityBoostEnabled
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: PriorityBoostEnabled
  nameWithType: ProcessThread.PriorityBoostEnabled
  fullName: System.Diagnostics.ProcessThread.PriorityBoostEnabled
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает значение, указывающее, должна ли операционная система временно увеличивать приоритет соответствующего потока всякий раз, когда основное окно процесса данный поток получает фокус."
  remarks: "При PriorityBoostEnabled `true`, система временно увеличивает приоритет потока всякий раз, когда соответствующий процесс выбирается из состояния ожидания. Это действие предотвращает прерывание выполнения текущего потока другими процессами. Установка PriorityBoostEnabled затрагивает все существующие потоки, а также каких-либо потоков, создаваемых в последующем процессом. Чтобы восстановить нормальное поведение, задайте <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>Свойства `false`.</xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>       PriorityBoostEnabled действует только в том случае, если поток выполняется в процессе, который имеет <xref:System.Diagnostics.Process.PriorityClass%2A>присвоено одно из значений перечисления динамического приоритета (<xref:System.Diagnostics.ProcessPriorityClass>, <xref:System.Diagnostics.ProcessPriorityClass>, или <xref:System.Diagnostics.ProcessPriorityClass>).</xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.ProcessPriorityClass> </xref:System.Diagnostics.Process.PriorityClass%2A>      Настроек [!NOTE] настроек повышение приоритета слишком высокого приоритета может лишить ресурсов может вызвать операционную систему и сетевые функции. Это может вызвать проблемы с другими задачами операционной системы."
  syntax:
    content: public bool PriorityBoostEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы повысить приоритет потока, когда пользователь взаимодействует с процессом интерфейс; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Diagnostics.ProcessThread.PriorityBoostEnabled*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Не удалось получить информацию о повышении приоритета.       - или - не удалось задать информацию о повышении приоритета."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Данный процесс выполняется на удаленном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.PriorityLevel
  id: PriorityLevel
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: PriorityLevel
  nameWithType: ProcessThread.PriorityLevel
  fullName: System.Diagnostics.ProcessThread.PriorityLevel
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает или задает уровень приоритета потока."
  remarks: "Уровень приоритета — это не одно значение, а целый диапазон значений. Операционная система вычисляет базовый приоритет потока с помощью процесса <xref:System.Diagnostics.Process.PriorityClass%2A>для выбора значения из диапазона, указанного в свойстве PriorityLevel.</xref:System.Diagnostics.Process.PriorityClass%2A>"
  syntax:
    content: public System.Diagnostics.ThreadPriorityLevel PriorityLevel { get; set; }
    return:
      type: System.Diagnostics.ThreadPriorityLevel
      description: "Один из <xref href=&quot;System.Diagnostics.ThreadPriorityLevel&quot;> </xref> значений, определяющее диапазон, который ограничивает приоритет потока."
  overload: System.Diagnostics.ProcessThread.PriorityLevel*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Не удалось получить информацию об уровне приоритета потока.       - или - не удалось задать уровень приоритета потока."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Данный процесс выполняется на удаленном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.PrivilegedProcessorTime
  id: PrivilegedProcessorTime
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: PrivilegedProcessorTime
  nameWithType: ProcessThread.PrivilegedProcessorTime
  fullName: System.Diagnostics.ProcessThread.PrivilegedProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает количество времени, которое поток потратил на выполнение кода внутри ядра операционной системы."
  remarks: "Windows использует несколько разных механизмов защиты и в основе их всех лежит разграничение пользовательского и привилегированного режимов. PrivilegedProcessorTime соответствует количество времени, затраченного на приложение в привилегированном режиме внутри ядра операционной системы. <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A>Свойство указывает количество времени, которое приложение потратил на выполнение кода в пользовательском режиме, вне ядра системы.</xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A>       Пользовательский режим ограничивает приложение в двух важных аспектах. Во-первых приложение не может напрямую обращаться к периферийным устройствам, но вместо этого необходимо вызвать метод ядра операционной системы для получения или задания данных. Таким образом, операционная система может гарантировать, что одно приложение не уничтожит данные, необходимые другому. Во-вторых приложение не может читать или изменять данные, которые хранит сама операционная система. Это ограничение предотвращает приложений случайно или преднамеренно повреждения ядра. Если приложению необходима операционная система для выполнения операции, оно вызывает одну из системных процедур. Многие из них переходят в привилегированный режим, выполните операцию и спокойно возвращаются в пользовательском режиме."
  syntax:
    content: public TimeSpan PrivilegedProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Объект <xref:System.TimeSpan>, указывающий количество времени, которое поток потратил на выполнение кода внутри ядра операционной системы.</xref:System.TimeSpan>"
  overload: System.Diagnostics.ProcessThread.PrivilegedProcessorTime*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Не удалось получить время потока."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Данный процесс выполняется на удаленном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.ProcessorAffinity
  id: ProcessorAffinity
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: ProcessorAffinity
  nameWithType: ProcessThread.ProcessorAffinity
  fullName: System.Diagnostics.ProcessThread.ProcessorAffinity
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Задает процессоры, на которых может запускаться соответствующего потока."
  remarks: "Сходство процессоров потока — набор процессоров, к которым он связан. Другими словами элементы которых он может быть запланировано на.       ProcessorAffinity как битовое представляет каждого процессора. Бит 0 представляет первый процессор, 1-й бит представляет второй процессор и т. д. В следующей таблице показаны подмножество возможных ProcessorAffinity для четырех процессоров системы.      | Значение свойства (в шестнадцатеричном формате) | Допустимые процессоры |   |---------------------------------------|----------------------|   | 0x0001 | 1 |   | 0x0002 | 2 |   | 0x0003 | 1 или 2 |   | 0x0004 | 3 |   | 0x0005 | 1 или 3 |   | 0x0007 | 1, 2 или 3 |   | 0x000F | 1, 2, 3 или 4 |       Можно также указать один предпочтительный процессор для потока, задав <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A>свойство.</xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> Поток процесса может перемещаться с процессора на процессор, с каждым перемещением обновление кэша процессора. Задавая процессор для потока может повысить производительность при больших системных нагрузках, уменьшение числа перезагрузок кэша процессора."
  example:
  - "The following example shows how to set the ProcessorAffinity property for an instance of Notepad to the first processor.  \n  \n [!code-vb[ProcessThreadIdealProcessor#1](~/add/codesnippet/visualbasic/p-system.diagnostics.pro_22_1.vb)]\n [!code-cs[ProcessThreadIdealProcessor#1](~/add/codesnippet/csharp/p-system.diagnostics.pro_22_1.cs)]"
  syntax:
    content: public IntPtr ProcessorAffinity { set; }
    return:
      type: System.IntPtr
      description: "<xref:System.IntPtr>, Указывающий на набор битов, каждый из которых представляет процессор, который может выполняться поток.</xref:System.IntPtr>"
  overload: System.Diagnostics.ProcessThread.ProcessorAffinity*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Не удалось установить соответствие процессоров."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Данный процесс выполняется на удаленном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.ResetIdealProcessor
  id: ResetIdealProcessor
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: ResetIdealProcessor()
  nameWithType: ProcessThread.ResetIdealProcessor()
  fullName: System.Diagnostics.ProcessThread.ResetIdealProcessor()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Отменяет идеальный процессор для потока, чтобы показать, что имеется не один идеальный процессор. Другими словами любой процессор идеален."
  syntax:
    content: public void ResetIdealProcessor ();
    parameters: []
  overload: System.Diagnostics.ProcessThread.ResetIdealProcessor*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Не удается сбросить идеальный процессор."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Данный процесс выполняется на удаленном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.StartAddress
  id: StartAddress
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: StartAddress
  nameWithType: ProcessThread.StartAddress
  fullName: System.Diagnostics.ProcessThread.StartAddress
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает адрес в памяти, функции, вызванных операционной системы, которая запустила этот поток."
  remarks: "Каждый процесс начинается с одного потока, который называется основным потоком. Любой поток может создавать дополнительные потоки.       Процесс имеет виртуальное адресное пространство, исполняемый код, данные, дескрипторы объектов, переменные среды, базовый приоритет и минимальное и максимальное размеры рабочего множества. Все потоки процесса разделяют его виртуальное адресное пространство и системные ресурсы. Кроме того каждый поток поддерживает обработчики исключений, планируемый приоритет и набор структур, в которых система сохраняет контекст потока во время ожидания потока для планирования. Контекст потока включает набор регистров компьютера, стек ядра, блок потоков среды и пользовательский стек в адресном пространстве процесса потока.       Каждый поток Windows фактически начинает свое выполнение в функции, предоставляемое системой, а не приложения. Начальный адрес для основного потока одинаково, поэтому (так как он представляет адрес функции, предоставляемой системой) для всех процессов Windows в системе. Однако свойство StartAddress позволяет получить начальный адрес функции, относящиеся к приложению."
  syntax:
    content: public IntPtr StartAddress { get; }
    return:
      type: System.IntPtr
      description: "Начальный адрес потока, которое указывает определяемую приложением функцию, которую выполняет поток."
  overload: System.Diagnostics.ProcessThread.StartAddress*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Данный процесс выполняется на удаленном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.StartTime
  id: StartTime
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: StartTime
  nameWithType: ProcessThread.StartTime
  fullName: System.Diagnostics.ProcessThread.StartTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает время запуска потока операционной системы."
  syntax:
    content: public DateTime StartTime { get; }
    return:
      type: System.DateTime
      description: "Объект <xref:System.DateTime>представляет время, которое было в системе при запуске потока.</xref:System.DateTime>"
  overload: System.Diagnostics.ProcessThread.StartTime*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Не удалось получить время потока."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Данный процесс выполняется на удаленном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.ThreadState
  id: ThreadState
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: ThreadState
  nameWithType: ProcessThread.ThreadState
  fullName: System.Diagnostics.ProcessThread.ThreadState
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает текущее состояние данного потока."
  remarks: "<xref:System.Diagnostics.ProcessThread.WaitReason%2A>Значение свойства является допустимым, только если значение ThreadState <xref:System.Diagnostics.ThreadState>.</xref:System.Diagnostics.ThreadState> </xref:System.Diagnostics.ProcessThread.WaitReason%2A> Таким образом, проверьте значение ThreadState до перехода <xref:System.Diagnostics.ProcessThread.WaitReason%2A>свойство.</xref:System.Diagnostics.ProcessThread.WaitReason%2A>"
  syntax:
    content: public System.Diagnostics.ThreadState ThreadState { get; }
    return:
      type: System.Diagnostics.ThreadState
      description: "Объект <xref href=&quot;System.Diagnostics.ThreadState&quot;> </xref> , указывающее, выполнением потоков, к примеру, запущен, ожидает или прекращен."
  overload: System.Diagnostics.ProcessThread.ThreadState*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Данный процесс выполняется на удаленном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.TotalProcessorTime
  id: TotalProcessorTime
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: TotalProcessorTime
  nameWithType: ProcessThread.TotalProcessorTime
  fullName: System.Diagnostics.ProcessThread.TotalProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает общее количество времени, затраченного на этот поток с использованием обработчика."
  remarks: "Свойство TotalProcessorTime указывает общее количество времени, что система вывести поток из состояния ожидания и предоставить ему приоритет на любом процессоре. В системе с несколькими процессорами это значение будет включать время, затраченное на каждый процессор, если поток использовал более одного процессора.       Свойство TotalProcessorTime является суммой <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A>и <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A>Свойства.</xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> </xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A>"
  syntax:
    content: public TimeSpan TotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Объект <xref:System.TimeSpan>, указывающее количество времени, что поток контролировал процессор.</xref:System.TimeSpan>"
  overload: System.Diagnostics.ProcessThread.TotalProcessorTime*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Не удалось получить время потока."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Данный процесс выполняется на удаленном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.UserProcessorTime
  id: UserProcessorTime
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: UserProcessorTime
  nameWithType: ProcessThread.UserProcessorTime
  fullName: System.Diagnostics.ProcessThread.UserProcessorTime
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает количество времени, которое поток потратил на выполнение кода внутри приложения."
  remarks: "Windows NT использует несколько разных механизмов защиты и в основе их всех лежит разграничение пользовательского и привилегированного режимов. UserProcessorTime соответствует количество времени, которое приложение потратило на выполнение в пользовательском режиме, вне ядра операционной системы. <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A>Соответствует количество времени, которое приложение потратил на выполнение кода в привилегированном режиме внутри ядра системы.</xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A>       Пользовательский режим ограничивает приложение в двух важных аспектах. Во-первых приложение не может напрямую обращаться к периферийным устройствам, но вместо этого необходимо вызвать метод ядра операционной системы для получения или задания данных. Таким образом, операционная система может гарантировать, что одно приложение не уничтожит данные, необходимые другому. Во-вторых приложение не может читать или изменять данные, которые хранит сама операционная система. Это ограничение предотвращает приложений случайно или преднамеренно повреждения ядра. Если приложению необходима операционная система для выполнения операции, оно вызывает одну из системных процедур. Многие из них переходят в привилегированный режим, выполните операцию и спокойно возвращаются в пользовательском режиме."
  syntax:
    content: public TimeSpan UserProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "Объект <xref:System.TimeSpan>, указывающий количество времени, которое поток потратил на выполнение кода внутри приложения, в отличие от внутри ядра операционной системы.</xref:System.TimeSpan>"
  overload: System.Diagnostics.ProcessThread.UserProcessorTime*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "Не удалось получить время потока."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Данный процесс выполняется на удаленном компьютере."
  platform:
  - net462
- uid: System.Diagnostics.ProcessThread.WaitReason
  id: WaitReason
  parent: System.Diagnostics.ProcessThread
  langs:
  - csharp
  name: WaitReason
  nameWithType: ProcessThread.WaitReason
  fullName: System.Diagnostics.ProcessThread.WaitReason
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "Возвращает причину, по которой поток находится в состоянии ожидания."
  remarks: "Свойство WaitReason доступен, только если <xref:System.Diagnostics.ProcessThread.ThreadState%2A> <xref:System.Diagnostics.ThreadState>.</xref:System.Diagnostics.ThreadState> </xref:System.Diagnostics.ProcessThread.ThreadState%2A> Таким образом, проверить <xref:System.Diagnostics.ProcessThread.ThreadState%2A>значение, прежде чем получить свойство WaitReason.</xref:System.Diagnostics.ProcessThread.ThreadState%2A>"
  syntax:
    content: public System.Diagnostics.ThreadWaitReason WaitReason { get; }
    return:
      type: System.Diagnostics.ThreadWaitReason
      description: "Объект <xref href=&quot;System.Diagnostics.ThreadWaitReason&quot;> </xref> представляет причину, по которой поток находится в состоянии ожидания."
  overload: System.Diagnostics.ProcessThread.WaitReason*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Поток не находится в состоянии ожидания."
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "Платформа является Windows 98 или Windows Millennium Edition."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "Данный процесс выполняется на удаленном компьютере."
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Diagnostics.ProcessThread.BasePriority
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: BasePriority
  nameWithType: ProcessThread.BasePriority
  fullName: System.Diagnostics.ProcessThread.BasePriority
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.ProcessThread.CurrentPriority
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: CurrentPriority
  nameWithType: ProcessThread.CurrentPriority
  fullName: System.Diagnostics.ProcessThread.CurrentPriority
- uid: System.Diagnostics.ProcessThread.Id
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: Id
  nameWithType: ProcessThread.Id
  fullName: System.Diagnostics.ProcessThread.Id
- uid: System.Diagnostics.ProcessThread.IdealProcessor
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: IdealProcessor
  nameWithType: ProcessThread.IdealProcessor
  fullName: System.Diagnostics.ProcessThread.IdealProcessor
- uid: System.Diagnostics.ProcessThread.PriorityBoostEnabled
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: ProcessThread.PriorityBoostEnabled
  fullName: System.Diagnostics.ProcessThread.PriorityBoostEnabled
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.ProcessThread.PriorityLevel
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: PriorityLevel
  nameWithType: ProcessThread.PriorityLevel
  fullName: System.Diagnostics.ProcessThread.PriorityLevel
- uid: System.Diagnostics.ThreadPriorityLevel
  parent: System.Diagnostics
  isExternal: false
  name: ThreadPriorityLevel
  nameWithType: ThreadPriorityLevel
  fullName: System.Diagnostics.ThreadPriorityLevel
- uid: System.Diagnostics.ProcessThread.PrivilegedProcessorTime
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: ProcessThread.PrivilegedProcessorTime
  fullName: System.Diagnostics.ProcessThread.PrivilegedProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Diagnostics.ProcessThread.ProcessorAffinity
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: ProcessorAffinity
  nameWithType: ProcessThread.ProcessorAffinity
  fullName: System.Diagnostics.ProcessThread.ProcessorAffinity
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.ProcessThread.ResetIdealProcessor
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: ResetIdealProcessor()
  nameWithType: ProcessThread.ResetIdealProcessor()
  fullName: System.Diagnostics.ProcessThread.ResetIdealProcessor()
- uid: System.Diagnostics.ProcessThread.StartAddress
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: StartAddress
  nameWithType: ProcessThread.StartAddress
  fullName: System.Diagnostics.ProcessThread.StartAddress
- uid: System.Diagnostics.ProcessThread.StartTime
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: StartTime
  nameWithType: ProcessThread.StartTime
  fullName: System.Diagnostics.ProcessThread.StartTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Diagnostics.ProcessThread.ThreadState
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: ThreadState
  nameWithType: ProcessThread.ThreadState
  fullName: System.Diagnostics.ProcessThread.ThreadState
- uid: System.Diagnostics.ThreadState
  parent: System.Diagnostics
  isExternal: false
  name: ThreadState
  nameWithType: ThreadState
  fullName: System.Diagnostics.ThreadState
- uid: System.Diagnostics.ProcessThread.TotalProcessorTime
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: TotalProcessorTime
  nameWithType: ProcessThread.TotalProcessorTime
  fullName: System.Diagnostics.ProcessThread.TotalProcessorTime
- uid: System.Diagnostics.ProcessThread.UserProcessorTime
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: UserProcessorTime
  nameWithType: ProcessThread.UserProcessorTime
  fullName: System.Diagnostics.ProcessThread.UserProcessorTime
- uid: System.Diagnostics.ProcessThread.WaitReason
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: WaitReason
  nameWithType: ProcessThread.WaitReason
  fullName: System.Diagnostics.ProcessThread.WaitReason
- uid: System.Diagnostics.ThreadWaitReason
  parent: System.Diagnostics
  isExternal: false
  name: ThreadWaitReason
  nameWithType: ThreadWaitReason
  fullName: System.Diagnostics.ThreadWaitReason
- uid: System.Diagnostics.ProcessThread.BasePriority*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: BasePriority
  nameWithType: ProcessThread.BasePriority
- uid: System.Diagnostics.ProcessThread.CurrentPriority*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: CurrentPriority
  nameWithType: ProcessThread.CurrentPriority
- uid: System.Diagnostics.ProcessThread.Id*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: Id
  nameWithType: ProcessThread.Id
- uid: System.Diagnostics.ProcessThread.IdealProcessor*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: IdealProcessor
  nameWithType: ProcessThread.IdealProcessor
- uid: System.Diagnostics.ProcessThread.PriorityBoostEnabled*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: PriorityBoostEnabled
  nameWithType: ProcessThread.PriorityBoostEnabled
- uid: System.Diagnostics.ProcessThread.PriorityLevel*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: PriorityLevel
  nameWithType: ProcessThread.PriorityLevel
- uid: System.Diagnostics.ProcessThread.PrivilegedProcessorTime*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: PrivilegedProcessorTime
  nameWithType: ProcessThread.PrivilegedProcessorTime
- uid: System.Diagnostics.ProcessThread.ProcessorAffinity*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: ProcessorAffinity
  nameWithType: ProcessThread.ProcessorAffinity
- uid: System.Diagnostics.ProcessThread.ResetIdealProcessor*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: ResetIdealProcessor
  nameWithType: ProcessThread.ResetIdealProcessor
- uid: System.Diagnostics.ProcessThread.StartAddress*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: StartAddress
  nameWithType: ProcessThread.StartAddress
- uid: System.Diagnostics.ProcessThread.StartTime*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: StartTime
  nameWithType: ProcessThread.StartTime
- uid: System.Diagnostics.ProcessThread.ThreadState*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: ThreadState
  nameWithType: ProcessThread.ThreadState
- uid: System.Diagnostics.ProcessThread.TotalProcessorTime*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: TotalProcessorTime
  nameWithType: ProcessThread.TotalProcessorTime
- uid: System.Diagnostics.ProcessThread.UserProcessorTime*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: UserProcessorTime
  nameWithType: ProcessThread.UserProcessorTime
- uid: System.Diagnostics.ProcessThread.WaitReason*
  parent: System.Diagnostics.ProcessThread
  isExternal: false
  name: WaitReason
  nameWithType: ProcessThread.WaitReason
