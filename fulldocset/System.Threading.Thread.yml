### YamlMime:ManagedReference
items:
- uid: System.Threading.Thread
  id: Thread
  children:
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  - System.Threading.Thread.Abort
  - System.Threading.Thread.Abort(System.Object)
  - System.Threading.Thread.AllocateDataSlot
  - System.Threading.Thread.AllocateNamedDataSlot(System.String)
  - System.Threading.Thread.ApartmentState
  - System.Threading.Thread.BeginCriticalRegion
  - System.Threading.Thread.BeginThreadAffinity
  - System.Threading.Thread.CurrentContext
  - System.Threading.Thread.CurrentCulture
  - System.Threading.Thread.CurrentPrincipal
  - System.Threading.Thread.CurrentThread
  - System.Threading.Thread.CurrentUICulture
  - System.Threading.Thread.DisableComObjectEagerCleanup
  - System.Threading.Thread.EndCriticalRegion
  - System.Threading.Thread.EndThreadAffinity
  - System.Threading.Thread.ExecutionContext
  - System.Threading.Thread.Finalize
  - System.Threading.Thread.FreeNamedDataSlot(System.String)
  - System.Threading.Thread.GetApartmentState
  - System.Threading.Thread.GetCompressedStack
  - System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  - System.Threading.Thread.GetDomain
  - System.Threading.Thread.GetDomainID
  - System.Threading.Thread.GetHashCode
  - System.Threading.Thread.GetNamedDataSlot(System.String)
  - System.Threading.Thread.Interrupt
  - System.Threading.Thread.IsAlive
  - System.Threading.Thread.IsBackground
  - System.Threading.Thread.IsThreadPoolThread
  - System.Threading.Thread.Join
  - System.Threading.Thread.Join(System.Int32)
  - System.Threading.Thread.Join(System.TimeSpan)
  - System.Threading.Thread.ManagedThreadId
  - System.Threading.Thread.MemoryBarrier
  - System.Threading.Thread.Name
  - System.Threading.Thread.Priority
  - System.Threading.Thread.ResetAbort
  - System.Threading.Thread.Resume
  - System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  - System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  - System.Threading.Thread.Sleep(System.Int32)
  - System.Threading.Thread.Sleep(System.TimeSpan)
  - System.Threading.Thread.SpinWait(System.Int32)
  - System.Threading.Thread.Start
  - System.Threading.Thread.Start(System.Object)
  - System.Threading.Thread.Suspend
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.Threading.Thread.ThreadState
  - System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.VolatileRead(System.Byte@)
  - System.Threading.Thread.VolatileRead(System.Double@)
  - System.Threading.Thread.VolatileRead(System.Int16@)
  - System.Threading.Thread.VolatileRead(System.Int32@)
  - System.Threading.Thread.VolatileRead(System.Int64@)
  - System.Threading.Thread.VolatileRead(System.IntPtr@)
  - System.Threading.Thread.VolatileRead(System.Object@)
  - System.Threading.Thread.VolatileRead(System.SByte@)
  - System.Threading.Thread.VolatileRead(System.Single@)
  - System.Threading.Thread.VolatileRead(System.UInt16@)
  - System.Threading.Thread.VolatileRead(System.UInt32@)
  - System.Threading.Thread.VolatileRead(System.UInt64@)
  - System.Threading.Thread.VolatileRead(System.UIntPtr@)
  - System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  - System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  - System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  - System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  - System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  - System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  - System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  - System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  - System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  - System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  - System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  - System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  - System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  - System.Threading.Thread.Yield
  langs:
  - csharp
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
  type: Class
  summary: "Создает и контролирует поток, задает приоритет и возвращает статус."
  remarks: "При запуске процесса, общеязыковая среда выполнения автоматически создает один основной поток для выполнения кода приложения. Вместе с этой главной основного потока процесса можно создать один или несколько потоков для выполнения частей программного кода, связанные с процессом. Эти потоки могут выполнять на переднем плане или в фоновом режиме. Кроме того, можно использовать <xref:System.Threading.ThreadPool>класса для выполнения кода на рабочих потоков, которые управляются среда.</xref:System.Threading.ThreadPool>       В этом разделе [запуска потока](#Starting)[объектов Получение потока](#Retrieving)[потоки переднего плана и фона](#Foreground)[языка и региональных параметров и потоки](#Culture)[получение сведений об и управление потоками](#Properties)[доступа к коду источника потока](#Source) <a name=&quot;Starting&quot;> </a> ## запуск потока запуска потока, указав делегат, который представляет метод, поток будет выполнена в конструкторе класса.                                Затем вызовите <xref:System.Threading.Thread.Start%2A>метод, чтобы начать выполнение.</xref:System.Threading.Thread.Start%2A>       Конструкторы потоков можно использовать один из типов два делегата, в зависимости от того, можно ли передать аргумент метода для выполнения:-Если метод не имеет аргументов, то можно передать <xref:System.Threading.ThreadStart>делегат в конструктор.</xref:System.Threading.ThreadStart> Он имеет сигнатуру: ```c#       public delegate void ThreadStart()       ``` ```vb       Public Delegate Sub ThreadStart()       ``` следующий пример создает и запускает поток, который выполняет `ExecuteInForeground` метод.           Метод отображает сведения о некоторых свойств потока, а затем выполняет цикл, в котором он приостанавливает полсекунды и отображает затраченное время в секундах. При выполнении потока по крайней мере пять секунд, цикл завершается и поток завершает выполнение.           [!code-cs[System.Threading.Thread#1](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)][!code-vb[System.Threading.Thread#1](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb) ] -Если метод имеет аргумент, передайте <xref:System.Threading.ParameterizedThreadStart>делегат в конструктор.</xref:System.Threading.ParameterizedThreadStart>       Он имеет сигнатуру: ```c#       public delegate void ParameterizedThreadStart(object obj)       ``` ```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ``` метод, выполняемый по делегату можно затем приведите (в C#) или преобразуйте (в Visual Basic) параметр к соответствующему типу.                     Следующий пример идентичен предыдущему, за исключением того, он вызывает <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>конструктор.</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Эта версия `ExecuteInForeground` метод принимает один параметр, который представляет приблизительное число миллисекунд, является выполнение цикла.           [!code-cs[System.Threading.Thread#2](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)][!code-vb[System.Threading.Thread#2](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb) ] нет необходимости сохранять ссылку на объект потока, после запуска потока.       Поток продолжает выполняться, пока не выполнена процедура потока.      <a name=&quot;Retrieving&quot;></a>## Получение потока объектов, которые можно использовать статический (`Shared` в Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A>свойство, чтобы получить ссылку на текущий выполняемый поток из кода, который выполняется поток.</xref:System.Threading.Thread.CurrentThread%2A> В следующем примере используется <xref:System.Threading.Thread.CurrentThread%2A>свойство для отображения сведений о основного потока приложения, другой поток переднего плана, в фоновом потоке и поток из пула потоков.</xref:System.Threading.Thread.CurrentThread%2A>       [!code-cs[System.Threading.Thread#4](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)][!code-vb[System.Threading.Thread#4](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb) ] <a name=&quot;Foreground&quot;> </a> ## переднего плана и фона потоков экземпляры класса потока представляют основные потоки или фоновые потоки.         Фоновые потоки идентичны основные потоки с одним исключением: в фоновом потоке не сохраняется процесс, выполняемый, если все основные потоки завершились. После были остановлены все основные потоки, среда выполнения останавливает все фоновые потоки и завершает работу.       По умолчанию, перечисленных ниже потоков выполняются на переднем плане:-основного потока приложения.      -Все потоки, созданные путем вызова конструктора класса потока.       По умолчанию в фоновом режиме выполняются следующие потоков:-потоков из пула потоков, которые являются пула рабочих потоков, которые поддерживаются средой выполнения.  Работа потоков пула и расписание можно настроить в потоках из пула потоков с помощью <xref:System.Threading.ThreadPool>класса.</xref:System.Threading.ThreadPool>          Настроек [!NOTE] настроек автоматическое выполнение асинхронной операции на основе задачи в потоках из пула потоков. Использование асинхронных операций на основе задач <xref:System.Threading.Tasks.Task>и <xref:System.Threading.Tasks.Task%601>классов для реализации [асинхронная модель на основе задач](~/add/includes/ajax-current-ext-md.md).</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      -Все потоки, которые входят в управляемую среду выполнения из неуправляемого кода.       Вы можете изменить поток для выполнения в фоновом режиме, путем установки <xref:System.Threading.Thread.IsBackground%2A>в любой момент.</xref:System.Threading.Thread.IsBackground%2A>  Фоновые потоки полезны для любой операции, следует продолжить до тех пор, пока приложение выполняется, но не предотвращения завершения работы, таких как мониторинг изменений в файловой системе или входящие подключения к сокетам приложения.       В следующем примере показано различие между потоками переднего плана и фона. Как и в первом примере, это [запуска потока](#Starting) статьи, за исключением того, он задает выполнение в фоновом режиме, перед его началом потока. Как показывает вывод, цикл прерывается до его выполнения в течение пяти секунд.       [!code-cs[System.Threading.Thread#3](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)][!code-vb[System.Threading.Thread#3](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb) ] <a name=&quot;Culture&quot;> </a> ## языка и региональных параметров и потоки каждый поток имеет языка и региональных параметров, представленных <xref:System.Threading.Thread.CurrentCulture%2A>свойство и языка и региональных параметров пользовательского интерфейса, представленного <xref:System.Threading.Thread.CurrentUICulture%2A>свойство.</xref:System.Threading.Thread.CurrentUICulture%2A> </xref:System.Threading.Thread.CurrentCulture%2A>          Текущий язык и региональные параметры поддерживает такие операции, зависящие от культуры как синтаксического анализа и форматирования, сравнение и сортировка строк и также определяет систему письма и календарь, используемый в потоке. Текущий язык и региональные параметры пользовательского интерфейса предоставляет язык и региональные параметры извлечения ресурсов в файлах ресурсов.       При создании нового потока его язык и региональные параметры пользовательского интерфейса определяются текущей культурой и языком и региональными параметрами пользовательского интерфейса, а не язык и региональные параметры пользовательского интерфейса потока, из которого создается новый поток. Это означает, например, что если текущую культуру системы является английский (США) и текущий язык и региональные параметры потока основного приложения — французский (Франция) языка и региональных параметров, созданных вызывающими нового потока <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>конструктор из основного потока является английский (США) и французского (Франция).</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Дополнительные сведения см. в разделе «Язык и региональные параметры и потоки» из <xref:System.Globalization.CultureInfo>разделе, посвященном классу.</xref:System.Globalization.CultureInfo>      Настроек [!IMPORTANT] настроек это неверно потоков, выполняющих асинхронных операций для приложений, ориентированных на [!INCLUDE[net_v46](~/add/includes/net-v46-md.md)] и более поздних версиях, в данном случае, язык и региональные параметры пользовательского интерфейса является частью контекста асинхронных операций, поток, на котором выполняет асинхронную операцию по умолчанию наследует язык и региональные параметры пользовательского интерфейса потока, из которого была запущена асинхронной операции. Дополнительные сведения см в разделе «Язык и региональные параметры и асинхронные операции на основе задач» <xref:System.Globalization.CultureInfo>разделе, посвященном классу.</xref:System.Globalization.CultureInfo>       Можно выполнить одно из следующих действий, чтобы гарантировать, что все потоки выполнение в приложении совместного использования одного языка и региональных:-можно передать <xref:System.Globalization.CultureInfo>объект, представляющий этот язык для <xref:System.Threading.ParameterizedThreadStart>делегата или <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName>метод.</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName> </xref:System.Threading.ParameterizedThreadStart> </xref:System.Globalization.CultureInfo>      — Для приложений, выполняющихся [!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)] и более поздних версиях можно определить язык и региональные параметры пользовательского интерфейса, необходимо назначить для всех потоков, созданных в домене приложения, задав значение <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName>и <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName>Свойства.</xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName> </xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName> Обратите внимание, что это параметр на уровне домена приложения.       Дополнительные сведения и примеры см. раздел «Язык и региональные параметры и потоки» <xref:System.Globalization.CultureInfo>разделе, посвященном классу.</xref:System.Globalization.CultureInfo>      <a name=&quot;Properties&quot;></a>## Получение сведений о и управление потоками могут получать число значений свойств, которые предоставляют сведения о потоке. В некоторых случаях можно также задать значения этих свойств для управления ее работой потока. Эти свойства потока включают:-имя. <xref:System.Threading.Thread.Name%2A>выполняет запись — один раз свойство, которое можно использовать для идентификации потока.</xref:System.Threading.Thread.Name%2A>  Значением по умолчанию является `null`.      -Хэш-код, который можно получить, вызвав <xref:System.Threading.Thread.GetHashCode%2A>метод.</xref:System.Threading.Thread.GetHashCode%2A> Хэш-код можно использовать для уникальной идентификации поток; в течение времени существования вашего потока ее хэш-код не будет конфликтовать со значением из любого другого потока независимо от домена приложения, из которого получается значение.      Идентификатор потока. Значение только для чтения <xref:System.Threading.Thread.ManagedThreadId%2A>свойство назначается средой выполнения и однозначно определяет поток внутри своего процесса.</xref:System.Threading.Thread.ManagedThreadId%2A>          Настроек [!NOTE] настроек операционной системы [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) не имеет фиксированного отношения с управляемым потоком, так как неуправляемый узел может управлять отношением между управляемым и неуправляемым потоками. В частности, более сложный узел может использовать [API размещения среды CLR](https://msdn.microsoft.com/library/ms404385.aspx) спланировать нескольких управляемых потоков для одного потока операционной системы или перемещать управляемый поток между различными потоками операционной системы.      -Текущее состояние потока. В течение своего существования поток всегда находится в один или несколько состояний, которые определены по <xref:System.Threading.ThreadState>свойство.</xref:System.Threading.ThreadState>      -Планирование уровня приоритета, который определяется с <xref:System.Threading.ThreadPriority>свойство.</xref:System.Threading.ThreadPriority> Несмотря на то, что это значение для запроса приоритет потока, не гарантируется соблюдаться операционной системой.      — Только для чтения <xref:System.Threading.Thread.IsThreadPoolThread%2A>свойство, которое указывает, является ли поток в поток из пула потоков.</xref:System.Threading.Thread.IsThreadPoolThread%2A>      - <xref:System.Threading.Thread.IsBackground%2A>Свойство.</xref:System.Threading.Thread.IsBackground%2A> Дополнительные сведения см. в разделе [потоки переднего плана и фона](#Foreground) раздела.      <a name=&quot;Source&quot;></a>## Доступ к исходный код для класса потока для просмотра исходного кода .NET Framework для класса потока, в разделе [ссылки на источник](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96). Выполнять поиск исходного кода в Интернете, справочник для автономной работы и пошагово источники (включая исправления и обновления) во время отладки; в разделе [инструкции](http://referencesource.microsoft.com/)."
  example:
  - "The following example demonstrates simple threading functionality.  \n  \n [!code-cpp[Classic Thread Example#1](~/add/codesnippet/cpp/t-system.threading.thread_5.cpp)]\n [!code-vb[Classic Thread Example#1](~/add/codesnippet/visualbasic/t-system.threading.thread_5.vb)]\n [!code-cs[Classic Thread Example#1](~/add/codesnippet/csharp/t-system.threading.thread_5.cs)]  \n  \n This code produces output similar to the following:  \n  \n```  \n[VB, C++, C#]  \nMain thread: Start a second thread.  \nMain thread: Do some work.  \nThreadProc: 0  \nMain thread: Do some work.  \nThreadProc: 1  \nMain thread: Do some work.  \nThreadProc: 2  \nMain thread: Do some work.  \nThreadProc: 3  \nMain thread: Call Join(), to wait until ThreadProc ends.  \nThreadProc: 4  \nThreadProc: 5  \nThreadProc: 6  \nThreadProc: 7  \nThreadProc: 8  \nThreadProc: 9  \nMain thread: ThreadProc.Join has returned.  Press Enter to end program.  \n```"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements:
  - System.Runtime.InteropServices._Thread
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  id: '#ctor(System.Threading.ParameterizedThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Threading.Thread&quot;> </xref> класса, указывается делегат, позволяющий объекту быть переданным в поток при запуске потока."
  remarks: "Поток не запускается при его создании. Чтобы запланировать для выполнения потока, вызовите <xref:System.Threading.Thread.Start%2A>метод.</xref:System.Threading.Thread.Start%2A> Чтобы передать объект данных в поток, используйте <xref:System.Threading.Thread.Start%28System.Object%29>перегрузку.</xref:System.Threading.Thread.Start%28System.Object%29>      Настроек [!NOTE] настроек пользователей Visual Basic можно опустить <xref:System.Threading.ThreadStart>конструктор при создании потока.</xref:System.Threading.ThreadStart> Используйте `AddressOf` оператор при передаче в метод, например `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic автоматически вызывает <xref:System.Threading.ThreadStart>конструктор.</xref:System.Threading.ThreadStart>"
  example:
  - "The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_19_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_19_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_19_1.cs)]"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "Делегат, который представляет методы, которые вызываются при запуске потока."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  id: '#ctor(System.Threading.ThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Threading.Thread&quot;> </xref> класса."
  remarks: "Поток не запускается при его создании. Чтобы запланировать для выполнения потока, вызовите <xref:System.Threading.Thread.Start%2A>метод.</xref:System.Threading.Thread.Start%2A>      Настроек [!NOTE] настроек пользователей Visual Basic можно опустить <xref:System.Threading.ThreadStart>конструктор при создании потока.</xref:System.Threading.ThreadStart> Используйте `AddressOf` оператор при передаче методе, например `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic автоматически вызывает <xref:System.Threading.ThreadStart>конструктор.</xref:System.Threading.ThreadStart>"
  example:
  - "The following code example shows how to create a thread that executes a static method.  \n  \n [!code-cpp[System.Threading.Thread.ctor#1](~/add/codesnippet/cpp/m-system.threading.threa_18_1.cpp)]\n [!code-vb[System.Threading.Thread.ctor#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_1.vb)]\n [!code-cs[System.Threading.Thread.ctor#1](~/add/codesnippet/csharp/m-system.threading.threa_18_1.cs)]  \n  \n The following code example shows how to create a thread that executes an instance method.  \n  \n [!code-cs[System.Threading.Thread.ctor2#1](~/add/codesnippet/csharp/m-system.threading.threa_18_2.cs)]\n [!code-vb[System.Threading.Thread.ctor2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_2.vb)]\n [!code-cpp[System.Threading.Thread.ctor2#1](~/add/codesnippet/cpp/m-system.threading.threa_18_2.cpp)]"
  syntax:
    content: public Thread (System.Threading.ThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "Объект <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> делегат, который представляет методы, которые вызываются при запуске потока."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>start</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  id: '#ctor(System.Threading.ParameterizedThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Threading.Thread&quot;> </xref> класс указывается делегат, позволяющий объекту быть переданным в поток при запуске потока с указанием максимального размера стека для потока."
  remarks: "Старайтесь не использовать эту перегрузку конструктора. Размер стека по умолчанию, используемые <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>перегрузку конструктора — это размер стека, рекомендуемые для потоков.</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> Если поток имеет проблем с памятью, наиболее вероятной причиной является программирования ошибка, например бесконечной рекурсии.      Настроек [!IMPORTANT] настроек начиная с версии [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], только полностью доверенный код может установить `maxStackSize` значение которого больше, чем размер стека по умолчанию (1 МБ). Если указано большее значение для `maxStackSize` при выполнении кода с частичным доверием `maxStackSize` игнорируется и используется размер стека по умолчанию. Исключение не возникает. Код на любом уровне доверия, может установить `maxStackSize` значение которого меньше, чем размер стека по умолчанию.      Настроек [!NOTE] настроек при разработке полностью доверенной библиотеки, который будет использоваться частично доверенным кодом и необходимо запустить поток, который требует большого стека, должно подтвердить полное доверие перед созданием потока или размер стека по умолчанию будет использоваться. Не делайте этого, если вы полностью управления кодом, который выполняется в потоке.       Если `maxStackSize` меньше, чем минимальный размер стека, используется минимальный размер стека. Если `maxStackSize` не кратному размеру страницы, оно округляется до следующего большего кратной размеру страницы. Например при использовании .NET Framework версии 2.0 в Windows Vista 256 КБ (262 144 байт) является минимальным размером стека, а размер страницы равен 64 КБ (65 536 байт).      Настроек [!NOTE] настроек в версиях Microsoft Windows до Windows XP и Windows Server 2003, `maxStackSize` игнорируется, и используется размер стека, указанный в заголовке исполняемого.       При указании очень малого размера стека, может потребоваться отключить проверки на переполнение стека. Если стек строго ограничивается, проверка сама может вызвать переполнение стека. Чтобы отключить проверку переполнения стека, добавьте следующий файл конфигурации приложения.      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "Объект <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref> делегат, который представляет методы, которые вызываются при запуске потока."
    - id: maxStackSize
      type: System.Int32
      description: "Максимальный размер стека в байтах, используемый потоком, или же 0 для использования максимального размера по умолчанию, указанное в заголовке исполняемого файла.       Внимание для частично доверенного кода `maxStackSize` учитывается, если оно превышает размер стека по умолчанию. Исключение не возникает."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>меньше нуля."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  id: '#ctor(System.Threading.ThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Threading.Thread&quot;> </xref> указанием максимального размера стека для потока."
  remarks: "Старайтесь не использовать эту перегрузку конструктора. Размер стека по умолчанию, используемые <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>перегрузку конструктора — это размер стека, рекомендуемые для потоков.</xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> Если поток имеет проблем с памятью, наиболее вероятной причиной является программирования ошибка, например бесконечной рекурсии.      Настроек [!IMPORTANT] настроек начиная с версии [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], только полностью доверенный код может установить `maxStackSize` значение которого больше, чем размер стека по умолчанию (1 МБ). Если указано большее значение для `maxStackSize` при выполнении кода с частичным доверием `maxStackSize` игнорируется и используется размер стека по умолчанию. Исключение не возникает. Код на любом уровне доверия, может установить `maxStackSize` значение которого меньше, чем размер стека по умолчанию.      Настроек [!NOTE] настроек при разработке полностью доверенной библиотеки, который будет использоваться частично доверенным кодом и необходимо запустить поток, который требует большого стека, должно подтвердить полное доверие перед созданием потока или размер стека по умолчанию будет использоваться. Не делайте этого, если вы полностью управления кодом, который выполняется в потоке.       Если `maxStackSize` меньше, чем минимальный размер стека, используется минимальный размер стека. Если `maxStackSize` не кратному размеру страницы, оно округляется до следующего большего кратной размеру страницы. Например при использовании .NET Framework версии 2.0 в Windows Vista 256 КБ (262 144 байт) является минимальным размером стека, а размер страницы равен 64 КБ (65 536 байт).      Настроек [!NOTE] настроек в версиях Microsoft Windows до Windows XP и Windows Server 2003, `maxStackSize` игнорируется, и используется размер стека, указанный в заголовке исполняемого.       При указании очень малого размера стека, может потребоваться отключить проверки на переполнение стека. Если стек строго ограничивается, проверка сама может вызвать переполнение стека. Чтобы отключить проверку переполнения стека, добавьте следующий файл конфигурации приложения.      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "Объект <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> делегат, который представляет методы, которые вызываются при запуске потока."
    - id: maxStackSize
      type: System.Int32
      description: "Максимальный размер стека в байтах, используемый потоком, или же 0 для использования максимального размера по умолчанию, указанное в заголовке исполняемого файла.       Внимание для частично доверенного кода `maxStackSize` учитывается, если оно превышает размер стека по умолчанию. Исключение не возникает."
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>меньше нуля."
  platform:
  - net462
- uid: System.Threading.Thread.Abort
  id: Abort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Вызывает <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref> в потоке, в которой он вызывается, чтобы начать процесс завершения потока. Вызов данного метода обычно завершает поток."
  remarks: "Если этот метод вызывается в потоке, система создает объект <xref:System.Threading.ThreadAbortException>в поток, который необходимо прервать его.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`— специальное исключение, которое может перехватываться кодом приложения, но вызывается повторно в конце `catch` блокируется пока <xref:System.Threading.Thread.ResetAbort%2A>называется.</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`Отменяет запрос на аварийное завершение и предотвращает `ThreadAbortException` от завершения потока. Невыполненные `finally` блоки выполняются перед поток прерван.      Настроек [!NOTE] настроек Если поток вызывает `Abort` для себя, действует аналогично исключение; <xref:System.Threading.ThreadAbortException>произойдет немедленно, и результат является предсказуемым.</xref:System.Threading.ThreadAbortException> Тем не менее если один поток вызывает `Abort` в другом потоке, аварийное завершение прерывает любой выполняющийся код. Имеется также вероятно аварийное завершение статического конструктора. В редких случаях это может препятствовать экземпляры этого класса в данном домене приложения. В .NET Framework версий 1.0 и 1.1, есть вероятность, поток может прервать пока `finally` блок выполняется, в этом случае `finally` блок прерывается.       Не гарантируется, что поток прервется немедленно или вообще. Такая ситуация может возникнуть, если поток выполняет неограниченное количество вычислений в `finally` блоки, которые вызываются как часть процедуры прерывания, откладывая аварийное завершение тем самым неопределенное время. Подождать, пока поток был прерван, можно вызвать <xref:System.Threading.Thread.Join%2A>метод в потоке после вызова метода Abort, но нет никакой гарантии, Ожидание завершится.</xref:System.Threading.Thread.Join%2A>      Настроек [!NOTE] настроек поток, который вызывает прерывание может блокироваться, если поток, который прерывается находится в защищенной области кода, такие как `catch` блока `finally` блока или области ограниченного выполнения. Если поток, который вызывает прерывание удерживает блокировку, требуемую прерванным потоком, может произойти взаимоблокировка.       Если `Abort` вызывается в потоке, который не был запущен, поток будет прервана, когда <xref:System.Threading.Thread.Start%2A>называется.</xref:System.Threading.Thread.Start%2A> Если `Abort` вызывается в потоке, который заблокирован или находится в спящем режиме, поток прерывается и затем прервана.       Если `Abort` вызывается в потоке, который был приостановлен, <xref:System.Threading.ThreadStateException>исключение в потоке, который вызвал <xref:System.Threading.Thread.Abort%2A>, и <xref:System.Threading.ThreadState>добавляется <xref:System.Threading.Thread.ThreadState%2A>свойство аварийно завершающимся потоком.</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> Объект <xref:System.Threading.ThreadAbortException>не вызывается в приостановленном потоке до <xref:System.Threading.Thread.Resume%2A>называется.</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       Если `Abort` вызывается в управляемом потоке при выполнении неуправляемого кода `ThreadAbortException` не выдается до возвращения потока в управляемом коде.       Если два вызова к `Abort` поступать одновременно, возможно, что один вызов для установки сведений о состоянии и вызов на выполнение `Abort`. Однако приложение не может определить ситуацию.       После `Abort` вызывается в потоке, состояние потока включает <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> После завершения потока в результате успешного вызова `Abort`, состояние потока будет изменен на <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> С достаточными разрешениями поток, который является целевым объектом `Abort` можно отменить аварийное завершение, используя `ResetAbort` метод. Пример, демонстрирующий вызов `ResetAbort` метода, в разделе `ThreadAbortException` класса."
  syntax:
    content: public void Abort ();
    parameters: []
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "В настоящее время приостанавливается поток, который прерывается."
  platform:
  - net462
- uid: System.Threading.Thread.Abort(System.Object)
  id: Abort(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Вызывает <xref href=&quot;System.Threading.ThreadAbortException&quot;> </xref> в потоке, в которой он вызывается, чтобы начать процесс завершения потока, в то же время предоставляя информацию о завершение потока исключения. Вызов данного метода обычно завершает поток."
  remarks: "Если этот метод вызывается в потоке, система создает объект <xref:System.Threading.ThreadAbortException>в поток, который необходимо прервать его.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`— специальное исключение, которое может перехватываться кодом приложения, но вызывается повторно в конце `catch` блокируется пока <xref:System.Threading.Thread.ResetAbort%2A>называется.</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`Отменяет запрос на аварийное завершение и предотвращает `ThreadAbortException` от завершения потока. Невыполненные `finally` блоки выполняются перед поток прерван.      Настроек [!NOTE] настроек Если поток вызывает `Abort` для себя, действует аналогично исключение; <xref:System.Threading.ThreadAbortException>произойдет немедленно, и результат является предсказуемым.</xref:System.Threading.ThreadAbortException> Тем не менее если один поток вызывает `Abort` в другом потоке, аварийное завершение прерывает любой выполняющийся код. Есть вероятность, что статический конструктор может прервана. В редких случаях это может препятствовать экземпляры этого класса в данном домене приложения. В .NET Framework версий 1.0 и 1.1, есть вероятность, поток может прервать пока `finally` блок выполняется, в этом случае `finally` блок прерывается.       Не гарантируется, что поток прервется немедленно или вообще. Такая ситуация может возникнуть, если поток выполняет неограниченное количество вычислений в `finally` блоки, которые вызываются как часть процедуры прерывания, откладывая аварийное завершение тем самым неопределенное время. Подождать, пока поток был прерван, можно вызвать <xref:System.Threading.Thread.Join%2A>метод в потоке после вызова метода Abort, но нет никакой гарантии, что время ожидания истекает.</xref:System.Threading.Thread.Join%2A>      Настроек [!NOTE] настроек поток, который вызывает <xref:System.Threading.Thread.Abort%2A>может блокироваться, если поток, который прерывается находится в защищенной области кода, такие как `catch` блока `finally` блока или области ограниченного выполнения.</xref:System.Threading.Thread.Abort%2A> Если поток, вызывающий <xref:System.Threading.Thread.Abort%2A>удерживает блокировку, требуемую прерванным потоком, может произойти взаимоблокировка.</xref:System.Threading.Thread.Abort%2A>       Если `Abort` вызывается в потоке, который не был запущен, поток будет прервана, когда <xref:System.Threading.Thread.Start%2A>называется.</xref:System.Threading.Thread.Start%2A> Если `Abort` вызывается в потоке, который заблокирован или находится в спящем режиме, поток прерывается и затем прервана.       Если `Abort` вызывается в потоке, который был приостановлен, <xref:System.Threading.ThreadStateException>исключение в потоке, который вызвал <xref:System.Threading.Thread.Abort%2A>, и <xref:System.Threading.ThreadState>добавляется <xref:System.Threading.Thread.ThreadState%2A>свойство аварийно завершающимся потоком.</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> Объект <xref:System.Threading.ThreadAbortException>не вызывается в приостановленном потоке до <xref:System.Threading.Thread.Resume%2A>называется.</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       Если `Abort` вызывается в управляемом потоке при выполнении неуправляемого кода `ThreadAbortException` не выдается до возвращения потока в управляемом коде.       Если два вызова к `Abort` поступать одновременно, возможно, что один вызов для установки сведений о состоянии и вызов на выполнение `Abort`. Однако приложение не может определить ситуацию.       После `Abort` вызывается в потоке, состояние потока включает <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> После завершения потока в результате успешного вызова `Abort`, состояние потока будет изменен на <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> С достаточными разрешениями поток, который является целевым объектом `Abort` можно отменить аварийное завершение, используя `ResetAbort` метод. Пример, демонстрирующий вызов `ResetAbort` метода, в разделе `ThreadAbortException` класса."
  example:
  - "The following code example shows how to pass information to a thread that is being aborted.  \n  \n [!code-cs[System.Threading.Thread.Abort2#1](~/add/codesnippet/csharp/m-system.threading.threa_12_1.cs)]\n [!code-cpp[System.Threading.Thread.Abort2#1](~/add/codesnippet/cpp/m-system.threading.threa_12_1.cpp)]\n [!code-vb[System.Threading.Thread.Abort2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_12_1.vb)]"
  syntax:
    content: public void Abort (object stateInfo);
    parameters:
    - id: stateInfo
      type: System.Object
      description: "Объект, содержащий сведения о приложении, например состояние, которое может использоваться аварийно завершающимся потоком."
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "В настоящее время приостанавливается поток, который прерывается."
  platform:
  - net462
- uid: System.Threading.Thread.AllocateDataSlot
  id: AllocateDataSlot
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Выделяет неименованную область данных всем потокам. Для повышения производительности используйте поля, отмеченные <xref:System.ThreadStaticAttribute>атрибутом.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]Настроек платформа .NET Framework предоставляет два механизма для использования локальное хранилище потока (TLS): статические поля потока (то есть поля, отмеченные <xref:System.ThreadStaticAttribute>атрибут) и области данных.</xref:System.ThreadStaticAttribute> Статические поля потока предоставляют гораздо более высокую производительность, чем области данных и включить проверку типов во время компиляции. Дополнительные сведения об использовании TLS см. в разделе [локальное хранилище потока: статические поля потока и области данных](~/add/includes/ajax-current-ext-md.md).       Область данных выделяется во всех потоках.       Потоки используют механизм локального хранилища памяти для хранения данных определенного потока. Общеязыковая среда выполнения выделяет массив хранения данных несколькими разъемами для каждого процесса при его создании. Поток может выделить область данных в хранилище данных, хранилище и получения данных значение в слоте и освободить эту область для повторного использования после истечения срока действия потока. Области данных являются уникальными для каждого потока. Ни один поток (даже дочерний поток) можно получить эти данные."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_16_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_16_1.cpp)]  \n  \n **Second Example**  \n  \n The following code example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_16_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_16_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateDataSlot ();
    parameters: []
    return:
      type: System.LocalDataStoreSlot
      description: "Выделенная Именованная область данных всем потокам."
  overload: System.Threading.Thread.AllocateDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  id: AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Выделяет именованную область данных всем потокам. Для повышения производительности используйте поля, отмеченные <xref:System.ThreadStaticAttribute>атрибутом.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]Настроек платформа .NET Framework предоставляет два механизма для использования локальное хранилище потока (TLS): статические поля потока (то есть поля, отмеченные <xref:System.ThreadStaticAttribute>атрибут) и области данных.</xref:System.ThreadStaticAttribute> Статические поля потока предоставляют гораздо более высокую производительность, чем области данных и включить проверку типов во время компиляции. Дополнительные сведения об использовании TLS см. в разделе [локальное хранилище потока: статические поля потока и области данных](~/add/includes/ajax-current-ext-md.md).       Потоки используют механизм локального хранилища памяти для хранения данных определенного потока. Общеязыковая среда выполнения выделяет массив хранения данных несколькими разъемами для каждого процесса при его создании. Поток может выделить область данных в хранилище данных, хранилище и получения данных значение в слоте и освободить эту область для повторного использования после истечения срока действия потока. Области данных являются уникальными для каждого потока. Ни один поток (даже дочерний поток) можно получить эти данные.       Нет необходимости использовать метод AllocateNamedDataSlot для выделения именованную область данных, так как <xref:System.Threading.Thread.GetNamedDataSlot%2A>метод выделяет область, если он уже не была выделена.</xref:System.Threading.Thread.GetNamedDataSlot%2A>      Настроек [!NOTE] настроек при использовании AllocateNamedDataSlot метод должен вызываться в основном потоке при запуске программы, так как он вызывает исключение, если область с указанным именем уже был выделен. Нет возможности проверить ли уже выделена слот.       Слоты, выделенных с помощью этого метода должны быть освобождены вызовом <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</xref:System.Threading.Thread.FreeNamedDataSlot%2A>"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_7_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_7_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n> [!NOTE]\n>  The example code does not use the AllocateNamedDataSlot method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated. If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_7_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_7_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "Имя выделяемой области данных."
    return:
      type: System.LocalDataStoreSlot
      description: "Выделенная Именованная область данных всем потокам."
  overload: System.Threading.Thread.AllocateNamedDataSlot*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Именованную область данных с указанным именем уже существует."
  platform:
  - net462
- uid: System.Threading.Thread.ApartmentState
  id: ApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает или задает состояние апартамента для данного потока."
  remarks: "**Свойство ApartmentState устарело.**  Альтернативы устаревшему <xref:System.Threading.Thread.GetApartmentState%2A>метод для извлечения состояние апартамента и <xref:System.Threading.Thread.SetApartmentState%2A>метод, чтобы задать состояние апартамента.</xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>       В .NET Framework версий 1.0 и 1.1 `ApartmentState` свойство отмечает поток, чтобы показать, что он будет выполняться в однопотоковый или многопотокового подразделения. Это свойство можно задать, если поток находится в `Unstarted` или `Running` состоянии; тем не менее, оно может быть задано только один раз для потока. Если свойство не было задано, возвращается `Unknown`.       Попытка присвоить состояние подразделения потока состояние подразделения которого уже задано свойство ApartmentState игнорируется. Однако <xref:System.Threading.Thread.SetApartmentState%2A>вызывает исключение <xref:System.InvalidOperationException>в этом случае.</xref:System.InvalidOperationException> </xref:System.Threading.Thread.SetApartmentState%2A>      Настроек [!IMPORTANT] настроек в .NET Framework версии 2.0, новые потоки инициализируются как <xref:System.Threading.ApartmentState?displayProperty=fullName>Если их состояние подразделения не задано до их запуска.</xref:System.Threading.ApartmentState?displayProperty=fullName> Основной поток приложения инициализируется <xref:System.Threading.ApartmentState?displayProperty=fullName>по умолчанию.</xref:System.Threading.ApartmentState?displayProperty=fullName> Основной поток приложения могут больше не устанавливаются в <xref:System.Threading.ApartmentState?displayProperty=fullName>, установив <xref:System.Threading.ApartmentState?displayProperty=fullName>свойство в первой строке кода.</xref:System.Threading.ApartmentState?displayProperty=fullName> </xref:System.Threading.ApartmentState?displayProperty=fullName> Используйте <xref:System.STAThreadAttribute>вместо.</xref:System.STAThreadAttribute>       В .NET Framework версии 2.0, можно указать потоковой моделью COM для приложения C++ с помощью [/CLRTHREADATTRIBUTE (установить атрибут потока среды CLR)](~/add/includes/ajax-current-ext-md.md) компоновщика."
  example:
  - "The following code example demonstrates how to set the apartment state of a thread.  \n  \n [!code-cs[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/csharp/p-system.threading.threa_8_1.cs)]\n [!code-cpp[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/cpp/p-system.threading.threa_8_1.cpp)]\n [!code-vb[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_8_1.vb)]"
  syntax:
    content: public System.Threading.ApartmentState ApartmentState { get; set; }
    return:
      type: System.Threading.ApartmentState
      description: "Один из <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> значения. Начальное значение — <xref uid=&quot;langword_csharp_Unknown&quot; name=&quot;Unknown&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.ApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Предпринята попытка задать это свойство в состояние, не является допустимым состоянием подразделения (состояние, отличное от однопотокового подразделения (<xref uid=&quot;langword_csharp_STA&quot; name=&quot;STA&quot; href=&quot;&quot;></xref>) или многопотокового подразделения (<xref uid=&quot;langword_csharp_MTA&quot; name=&quot;MTA&quot; href=&quot;&quot;></xref>))."
  platform:
  - net462
- uid: System.Threading.Thread.BeginCriticalRegion
  id: BeginCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Уведомляет хост, что выполнение близится ко входу в область кода, в которой эффекты прерывания выполнения или неуправляемого выполнения могут повлиять на другие задачи в домене приложения."
  remarks: "Узлы среды выполнения (CLR), например Microsoft SQL Server 2005, могут устанавливать различные политики для сбоев в критические и некритические областей кода. Критической области — один, в которой эффекты прерывания выполнения или необработанное исключение не могут быть ограничены текущей задачей. Напротив прерывание или сбой в некритической области кода влияет только задачи, в котором произошла ошибка.       Например рассмотрим задачу, которая пытается выделить память при блокировке. Если происходит сбой выделения памяти, прерывания текущей задачи недостаточно для обеспечения стабильности <xref:System.AppDomain>, так как может существовать другие задачи в домене, ожидающих блокировки.</xref:System.AppDomain> При прерывании выполнения текущей задачи, другие задачи могут взаимно блокироваться.       При возникновении сбоя в критической области, узел может потребоваться выгрузить весь <xref:System.AppDomain>, а не рисковать и продолжения выполнения потенциально нестабильно.</xref:System.AppDomain> Для информирования основного, код переходит в критической области, вызовите BeginCriticalRegion. Вызовите <xref:System.Threading.Thread.EndCriticalRegion%2A>Когда выполнение возвращается некритической области кода.</xref:System.Threading.Thread.EndCriticalRegion%2A>       С помощью этого метода в коде, выполняемом в SQL Server 2005 требуется код для выполнения на высоком уровне защиты узла."
  example:
  - "The following example demonstrates the use of the BeginCriticalRegion and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_5_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_5_1.vb)]"
  syntax:
    content: public static void BeginCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.BeginCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.BeginThreadAffinity
  id: BeginThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Уведомляет хост, что управляемый код близок к выполнению инструкций, зависящих от идентификации текущего потока операционной системы."
  remarks: "Некоторые узлы CLR, например Microsoft SQL Server 2005, обеспечивают самостоятельное управление потоками. Узел, который предоставляет собственный поток управления можно переместить выполняющуюся задачу из одного потока операционной системы в другую в любое время. Большинство задач с помощью этого переключения не затрагиваются. Тем не менее некоторые задачи поддерживают сходство потоков: то есть они зависят от идентификатора потока операционной системы. Эти задачи необходимо проинформировать узел выполняемого кода, не будут перенаправлены.       Например, если приложение вызывает API-Интерфейсу блокировки операционной системы, который реализует сходство потоков, например Win32 CRITICAL_SECTION, системы перед необходимо вызвать BeginThreadAffinity запроса на блокировку и <xref:System.Threading.Thread.EndThreadAffinity%2A>после освобождения блокировки.</xref:System.Threading.Thread.EndThreadAffinity%2A>       С помощью этого метода в коде, выполняемом в SQL Server 2005 требуется код для выполнения на высоком уровне защиты узла."
  example:
  - "The following example demonstrates the use of the BeginThreadAffinity and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_0_1.vb)]"
  syntax:
    content: public static void BeginThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.BeginThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentContext
  id: CurrentContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает текущий контекст, в котором выполняется поток."
  syntax:
    content: public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }
    return:
      type: System.Runtime.Remoting.Contexts.Context
      description: "Объект <xref href=&quot;System.Runtime.Remoting.Contexts.Context&quot;> </xref> представляет текущий контекст потока."
  overload: System.Threading.Thread.CurrentContext*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentCulture
  id: CurrentCulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает или задает язык и региональные параметры текущего потока."
  remarks: "<xref:System.Globalization.CultureInfo>Объект, возвращаемый этим свойством, а также связанных с ним объектов, определяют форматом по умолчанию для дат, времени, чисел, денежных значений, текст порядка сортировки, регистр соглашения и операции сравнения строк.</xref:System.Globalization.CultureInfo> В разделе <xref:System.Globalization.CultureInfo>класса для изучения языка и региональных параметров имена и идентификаторы, различия между инвариантным, нейтральные и конкретные языки и региональные параметры, и сведения о культуре способом влияет потоков и доменов приложений.</xref:System.Globalization.CultureInfo> В разделе <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>свойство, чтобы узнать, как определяется язык и региональные параметры потока по умолчанию и как пользователи задать сведения о культуре для их компьютеров.</xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>       Начиная с версии [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], можно задать свойство CurrentCulture для нейтрального языка и региональных параметров. Это, поскольку поведение <xref:System.Globalization.CultureInfo>класс был изменен: когда он представляет нейтральной культуре значения его свойств (в частности, <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, и <xref:System.Globalization.CultureInfo.TextInfo%2A>Свойства) теперь отражают заданных региональных параметров, который связан с нейтральным языком и региональными параметрами.</xref:System.Globalization.CultureInfo.TextInfo%2A> </xref:System.Globalization.CultureInfo.NumberFormat%2A> </xref:System.Globalization.CultureInfo.DateTimeFormat%2A> </xref:System.Globalization.CultureInfo.CompareInfo%2A> </xref:System.Globalization.CultureInfo.Calendar%2A> </xref:System.Globalization.CultureInfo> В более ранних версиях платформы .NET Framework вызвал свойство CurrentCulture <xref:System.NotSupportedException>исключения, когда был назначен нейтрального языка и региональных параметров.</xref:System.NotSupportedException>"
  example:
  - "The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_3_1.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentCulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "Объект, представляющий язык и региональные параметры текущего потока."
  overload: System.Threading.Thread.CurrentCulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Свойство имеет значение <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentPrincipal
  id: CurrentPrincipal
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает или задает текущего участника потока (для безопасности на основе ролей)."
  remarks: ''
  example:
  - "The following code example shows how to set and retrieve the principal of a thread.  \n  \n [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/cpp/p-system.threading.threa_11_1.cpp)]\n [!code-cs[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/csharp/p-system.threading.threa_11_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/visualbasic/p-system.threading.threa_11_1.vb)]"
  syntax:
    content: public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }
    return:
      type: System.Security.Principal.IPrincipal
      description: "<xref:System.Security.Principal.IPrincipal>Значение, представляющее контекст безопасности.</xref:System.Security.Principal.IPrincipal>"
  overload: System.Threading.Thread.CurrentPrincipal*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий не имеет необходимых прав для задания участника."
  platform:
  - net462
- uid: System.Threading.Thread.CurrentThread
  id: CurrentThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает в данный момент поток."
  remarks: ''
  example:
  - "The following example creates a task that in turn creates 20 child tasks. The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the CurrentThread property  to display information about the thread on which it is running.  \n  \n [!code-vb[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_1_1.vb)]\n [!code-cs[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/csharp/p-system.threading.threa_1_1.cs)]  \n  \n Each child task generates 1 million random numbers between 1 and 1 million and returns their mean. The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.  \n  \n Note that while the application runs on a foreground thread, each task runs on a thread pool thread."
  syntax:
    content: public static System.Threading.Thread CurrentThread { get; }
    return:
      type: System.Threading.Thread
      description: "Объект <xref href=&quot;System.Threading.Thread&quot;> </xref> , представляющий собой выполняющийся в данный момент поток."
  overload: System.Threading.Thread.CurrentThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.CurrentUICulture
  id: CurrentUICulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает или задает текущий язык и региональные параметры, используемые диспетчером ресурсов для поиска ресурсов, связанных с языком и региональными параметрами, во время выполнения."
  remarks: "The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture. See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains. See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> property to learn how a thread's default UI culture is determined.  \n  \n The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture. Neutral cultures should not be used with formatting methods such as [String.Format(IFormatProvider, String, Object\\[\\])](assetId:///M:System.String.Format(System.IFormatProvider,System.String,System.Object[])?qualifyHint=True&autoUpgrade=False), <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=fullName>. Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.  \n  \n> [!NOTE]\n>  The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method throws <xref:System.ArgumentException> for the neutral cultures \"zh-Hant\" (\"zh-CHT\") and \"zh-Hans\" (\"zh-CHS\")."
  example:
  - "The following example determines whether the language of the current thread's UI culture is French. If it is not, it sets the UI culture of the current thread to English (United States).  \n  \n [!code-cs[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_1.vb)]  \n  \n The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_2_2.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_2.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_2.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentUICulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "Объект, представляющий текущий язык и региональные параметры."
  overload: System.Threading.Thread.CurrentUICulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "Свойство имеет значение <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Свойству присвоено имя языка и региональных параметров, которое не может использоваться для нахождения файла ресурсов. Имена файлов ресурсов должны содержать только буквы, цифры, дефисы и знаки подчеркивания."
  platform:
  - net462
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  id: DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  langs:
  - csharp
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Отключает автоматическую очистку вызываемых оболочек времени выполнения (RCW) для текущего потока."
  remarks: "По умолчанию общеязыковой среды выполнения (CLR) производит очистку вызываемых оболочек времени выполнения автоматически. Среда CLR передает сообщения во время очистки, что может привести к проблемам повторный вход для нескольких приложений, которые удовлетворяют следующим критериям необычные:-приложение выполняет собственную загрузку сообщения.      -Приложению для управления точно при загрузке сообщения.       Такие приложения могут использовать метод DisableComObjectEagerCleanup, чтобы предотвратить это автоматическое освобождение вызываемых оболочек времени выполнения среды CLR.       При вызове этого метода в потоке автоматической очистки не может быть включена для этого потока. Когда приложение будет готово для очистки вызываемые оболочки времени выполнения, используйте <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName>метод, чтобы заставить среду выполнения, чтобы очистить все вызываемые оболочки времени выполнения в текущем контексте.</xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName> Выдачи сообщений происходит во время выполнения метода."
  syntax:
    content: public void DisableComObjectEagerCleanup ();
    parameters: []
  overload: System.Threading.Thread.DisableComObjectEagerCleanup*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndCriticalRegion
  id: EndCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Уведомляет хост, что выполнение близится ко входу в область кода, в которой эффекты прерывания выполнения или неуправляемой ограничены текущей задачей."
  remarks: "Узлы среды выполнения (CLR), например Microsoft SQL Server 2005, могут устанавливать различные политики для сбоев в критические и некритические областей кода. Критической области — один, в которой эффекты прерывания выполнения или необработанное исключение не могут быть ограничены текущей задачей. Напротив прерывание или сбой в некритической области кода влияет только задачи, в котором произошла ошибка.       Например рассмотрим задачу, которая пытается выделить память при блокировке. Если происходит сбой выделения памяти, прерывания текущей задачи недостаточно для обеспечения стабильности <xref:System.AppDomain>, так как может существовать другие задачи в домене, ожидающих блокировки.</xref:System.AppDomain> При прерывании выполнения текущей задачи, другие задачи могут взаимно блокироваться.       При возникновении сбоя в критической области, узел может потребоваться выгрузить весь <xref:System.AppDomain>, а не рисковать и продолжения выполнения потенциально нестабильно.</xref:System.AppDomain> Для информирования основного, код переходит в критической области, вызовите <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</xref:System.Threading.Thread.BeginCriticalRegion%2A> Вызов EndCriticalRegion выполнение возвращается некритической области кода.       С помощью этого метода в коде, выполняемом в SQL Server 2005 требуется код для выполнения на высоком уровне защиты узла."
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and EndCriticalRegion methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_1_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_1_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_1_1.vb)]"
  syntax:
    content: public static void EndCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.EndCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndThreadAffinity
  id: EndThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Уведомляет хост, что управляемый код завершения выполнения инструкций, зависящих от идентификации текущего потока операционной системы."
  remarks: "Некоторые узлы CLR, например Microsoft SQL Server 2005, обеспечивают самостоятельное управление потоками. Узел, который предоставляет собственный поток управления можно переместить выполняющуюся задачу из одного потока операционной системы в другую в любое время. Большинство задач с помощью этого переключения не затрагиваются. Тем не менее некоторые задачи поддерживают сходство потоков: то есть они зависят от идентификатора потока операционной системы. Эти задачи необходимо проинформировать узел выполняемого кода, не будут перенаправлены.       Например, если приложение вызывает API системы для получения операционной системой блокировки, сходство потоков, например Win32 CRITICAL_SECTION, необходимо вызвать <xref:System.Threading.Thread.BeginThreadAffinity%2A>перед установкой блокировки и EndThreadAffinity после освобождения блокировки.</xref:System.Threading.Thread.BeginThreadAffinity%2A>       С помощью этого метода в коде, выполняемом в SQL Server 2005 требуется код для выполнения на высоком уровне защиты узла."
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and EndThreadAffinity methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_3_1.vb)]"
  syntax:
    content: public static void EndThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.EndThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет необходимых разрешений."
  platform:
  - net462
- uid: System.Threading.Thread.ExecutionContext
  id: ExecutionContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает <xref:System.Threading.ExecutionContext>, содержащий сведения о различных контекстах текущего потока.</xref:System.Threading.ExecutionContext>"
  remarks: "<xref:System.Threading.ExecutionContext>Класс предоставляет один контейнер для все сведения, относящиеся к логический поток выполнения.</xref:System.Threading.ExecutionContext> Это включает в себя контекст безопасности, контекст вызовов, контекст синхронизации, контекст локализации и контекст транзакции."
  syntax:
    content: public System.Threading.ExecutionContext ExecutionContext { get; }
    return:
      type: System.Threading.ExecutionContext
      description: "<xref:System.Threading.ExecutionContext>, Содержащий консолидированную информацию о контекстах текущего потока.</xref:System.Threading.ExecutionContext>"
  overload: System.Threading.Thread.ExecutionContext*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Finalize
  id: Finalize
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Гарантирует, что ресурсы освобождены и выполнены другие операции очистки, когда сборщик мусора восстанавливает <xref href=&quot;System.Threading.Thread&quot;> </xref> объекта."
  remarks: "Сборщик мусора вызывает метод Finalize, когда текущий объект готов к завершению."
  syntax:
    content: ~Thread ();
    parameters: []
  overload: System.Threading.Thread.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  id: FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Удаляет связь между названием и областью для всех потоков в процессе. Для повышения производительности используйте поля, отмеченные <xref:System.ThreadStaticAttribute>атрибутом.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]Настроек платформа .NET Framework предоставляет два механизма для использования локальное хранилище потока (TLS): статические поля потока (то есть поля, отмеченные <xref:System.ThreadStaticAttribute>атрибут) и области данных.</xref:System.ThreadStaticAttribute> Статические поля потока предоставляют гораздо более высокую производительность, чем области данных и включить проверку типов во время компиляции. Дополнительные сведения об использовании TLS см. в разделе [локальное хранилище потока: статические поля потока и области данных](~/add/includes/ajax-current-ext-md.md).       После какой-либо поток вызывает `FreeNamedDataSlot`, поток, который вызывает <xref:System.Threading.Thread.GetNamedDataSlot%2A>с тем же именем приведет к выделению новую ячейку, связанный с именем.</xref:System.Threading.Thread.GetNamedDataSlot%2A> Последующие вызовы `GetNamedDataSlot` любым потоком будут возвращать новую область. Тем не менее, любой поток, по-прежнему содержит <xref:System.LocalDataStoreSlot?displayProperty=fullName>возвращенные предыдущими вызовами метода `GetNamedDataSlot` можно продолжать использовать старый слота.</xref:System.LocalDataStoreSlot?displayProperty=fullName>       Область, связанный с именем, будет освобождена только тогда, когда каждый `LocalDataStoreSlot` , полученные до вызова метода `FreeNamedDataSlot` были освобождены и сбора мусора.       Потоки используют механизм локального хранилища памяти для хранения данных определенного потока. Общеязыковая среда выполнения выделяет массив хранения данных несколькими разъемами для каждого процесса при его создании. Поток может выделить область данных в хранилище данных, хранилище и получения данных значение в слоте и освободить эту область для повторного использования после истечения срока действия потока. Области данных являются уникальными для каждого потока. Ни один поток (даже дочерний поток) можно получить эти данные."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_9_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_9_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_9_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_9_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_2.vb)]"
  syntax:
    content: public static void FreeNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "Имя освобождаемой области данных."
  overload: System.Threading.Thread.FreeNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetApartmentState
  id: GetApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> значение, показывающее состояние апартамента."
  remarks: "Этот метод вместе с <xref:System.Threading.Thread.SetApartmentState%2A>метод и <xref:System.Threading.Thread.TrySetApartmentState%2A>заменяет метод, <xref:System.Threading.Thread.ApartmentState%2A>свойство.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A>"
  example:
  - "The following code example demonstrates the GetApartmentState, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, GetApartmentState displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_11_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_11_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_11_1.cs)]"
  syntax:
    content: public System.Threading.ApartmentState GetApartmentState ();
    parameters: []
    return:
      type: System.Threading.ApartmentState
      description: "Один из <xref href=&quot;System.Threading.ApartmentState&quot;> </xref> значения, указывающие состояние подразделения управляемого потока. Значение по умолчанию — <xref href=&quot;System.Threading.ApartmentState&quot;> </xref>."
  overload: System.Threading.Thread.GetApartmentState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetCompressedStack
  id: GetCompressedStack
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> объекта, который может использоваться для записи стека текущего потока."
  remarks: "Этот метод больше не поддерживается."
  syntax:
    content: public System.Threading.CompressedStack GetCompressedStack ();
    parameters: []
    return:
      type: System.Threading.CompressedStack
      description: "Отсутствует."
  overload: System.Threading.Thread.GetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Во всех случаях."
  platform:
  - net462
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  id: GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Получает значение из заданной области текущего потока, внутри текущей области текущего потока. Для повышения производительности используйте поля, отмеченные <xref:System.ThreadStaticAttribute>атрибутом.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]Настроек платформа .NET Framework предоставляет два механизма для использования локальное хранилище потока (TLS): статические поля потока (то есть поля, отмеченные <xref:System.ThreadStaticAttribute>атрибут) и области данных.</xref:System.ThreadStaticAttribute> Статические поля потока предоставляют гораздо более высокую производительность, чем области данных и включить проверку типов во время компиляции. Дополнительные сведения об использовании TLS см. в разделе [локальное хранилище потока: статические поля потока и области данных](~/add/includes/ajax-current-ext-md.md).       Потоки используют механизм локального хранилища памяти для хранения данных определенного потока. Общеязыковая среда выполнения выделяет массив хранения данных несколькими разъемами для каждого процесса при его создании. Поток может выделить область данных в хранилище данных, хранилище и получения данных значение в слоте и освободить эту область для повторного использования после истечения срока действия потока. Области данных являются уникальными для каждого потока. Ни один поток (даже дочерний поток) можно получить эти данные.      Настроек [!NOTE] настроек GetData — `Shared` метод, который всегда применяется к потоку выполняться в данный момент, даже при вызове с помощью переменной, которая ссылается на другой поток. Чтобы избежать путаницы, используйте имя класса при вызове `Shared` методы: `Dim test As Object = Thread.GetData(testSlot)`."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_27_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_27_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_27_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_27_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_2.vb)]"
  syntax:
    content: public static object GetData (LocalDataStoreSlot slot);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "<xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> Из которого необходимо получить значение."
    return:
      type: System.Object
      description: "Извлекаемое значение."
  overload: System.Threading.Thread.GetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomain
  id: GetDomain
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает текущую область, в которой выполняется текущий поток."
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_29_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_29_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_29_1.cpp)]"
  syntax:
    content: public static AppDomain GetDomain ();
    parameters: []
    return:
      type: System.AppDomain
      description: "<xref href=&quot;System.AppDomain&quot;> </xref> Представляющий собой текущий домен приложения выполняющегося потока."
  overload: System.Threading.Thread.GetDomain*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomainID
  id: GetDomainID
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает уникальный идентификатор домена приложения."
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_17_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_17_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_17_1.cpp)]"
  syntax:
    content: public static int GetDomainID ();
    parameters: []
    return:
      type: System.Int32
      description: "32-разрядное знаковое целое число, однозначно определяющее домен приложения."
  overload: System.Threading.Thread.GetDomainID*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetHashCode
  id: GetHashCode
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает хэш-код для текущего потока."
  remarks: "Хэш-код не гарантированно уникален. Используйте <xref:System.Threading.Thread.ManagedThreadId%2A>свойство, если требуется уникальный идентификатор управляемого потока.</xref:System.Threading.Thread.ManagedThreadId%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "Целочисленное значение хэш-кода."
  overload: System.Threading.Thread.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  id: GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Ищет именованную область данных. Для повышения производительности используйте поля, отмеченные <xref:System.ThreadStaticAttribute>атрибутом.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]Настроек платформа .NET Framework предоставляет два механизма для использования локальное хранилище потока (TLS): статические поля потока (то есть поля, отмеченные <xref:System.ThreadStaticAttribute>атрибут) и области данных.</xref:System.ThreadStaticAttribute> Статические поля потока предоставляют гораздо более высокую производительность, чем области данных и включить проверку типов во время компиляции. Дополнительные сведения об использовании TLS см. в разделе [локальное хранилище потока: статические поля потока и области данных](~/add/includes/ajax-current-ext-md.md).       Потоки используют механизм локального хранилища памяти для хранения данных определенного потока. Общеязыковая среда выполнения выделяет массив хранения данных несколькими разъемами для каждого процесса при его создании. Поток может выделить область данных в хранилище данных, хранилище и получения данных значение в слоте и освободить эту область для повторного использования после истечения срока действия потока. Области данных являются уникальными для каждого потока. Ни один поток (даже дочерний поток) можно получить эти данные.       Если Именованная область не существует, выделяется новая область. Именованные области данных являются открытыми и может использоваться кем."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_13_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_13_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_13_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_13_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot GetNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "Имя локальной области данных."
    return:
      type: System.LocalDataStoreSlot
      description: "Объект <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> выделенный для данного потока."
  overload: System.Threading.Thread.GetNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Interrupt
  id: Interrupt
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Прерывает работу потока, находящегося в <xref uid=&quot;langword_csharp_WaitSleepJoin&quot; name=&quot;WaitSleepJoin&quot; href=&quot;&quot;> </xref> состоянии."
  remarks: "Если этот поток не заблокирован в настоящее время ожидания, спящего режима или состояние соединения, он будет прервана, когда он начнет блокироваться.       <xref:System.Threading.ThreadInterruptedException>возникает в прерванного потока, но только поток блокируется.</xref:System.Threading.ThreadInterruptedException> Если поток никогда не блокируется, исключение никогда не создается, и таким образом, поток может завершить не будучи прерванным."
  example:
  - "The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.  \n  \n [!code-cpp[System.Threading.Thread.Interrupt#1](~/add/codesnippet/cpp/m-system.threading.threa_21_1.cpp)]\n [!code-vb[System.Threading.Thread.Interrupt#1](~/add/codesnippet/visualbasic/m-system.threading.threa_21_1.vb)]\n [!code-cs[System.Threading.Thread.Interrupt#1](~/add/codesnippet/csharp/m-system.threading.threa_21_1.cs)]"
  syntax:
    content: public void Interrupt ();
    parameters: []
  overload: System.Threading.Thread.Interrupt*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет соответствующего <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.IsAlive
  id: IsAlive
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает значение, показывающее статус выполнения текущего потока."
  syntax:
    content: public bool IsAlive { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если этот поток был запущен и не был завершен обычным образом или прерван; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsAlive*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.IsBackground
  id: IsBackground
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает или задает значение, указывающее, является ли поток фоновым потоком."
  remarks: "Поток находится в фоновом потоке или основной поток. Фоновые потоки идентичны основные потоки, за исключением того, что фоновые потоки не предотвращают завершение процесса. Когда все основные потоки, принадлежащие процессу, завершились, общеязыковая среда выполнения завершает процесс. Все оставшиеся фоновые потоки останавливаются и не завершаются.       По умолчанию, перечисленных ниже потоков выполняются на переднем плане (то есть их IsBackground возвращает `false`):-основного потока (или основного потока приложения).      -Все потоки, созданные путем вызова <xref:System.Threading.Thread>конструктора класса.</xref:System.Threading.Thread>       По умолчанию, перечисленных ниже потоков выполняются в фоновом режиме (то есть их IsBackground возвращает `true`):-потоков из пула потоков, которые являются пула рабочих потоков, которые поддерживаются средой выполнения. Работа потоков пула и расписание можно настроить в потоках из пула потоков с помощью <xref:System.Threading.ThreadPool>класса.</xref:System.Threading.ThreadPool>          Настроек [!NOTE] настроек автоматическое выполнение асинхронной операции на основе задачи в потоках из пула потоков.      -Все потоки, которые входят в управляемую среду выполнения из неуправляемого кода."
  example:
  - "The following example contrasts the behavior of foreground and background threads. It creates a foreground thread and a background thread. The foreground thread keeps the process running until completes its `for` loop and terminates. However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.  \n  \n [!code-cs[System.Threading.Thread.IsBackground#1](~/add/codesnippet/csharp/p-system.threading.threa_7_1.cs)]\n [!code-cpp[System.Threading.Thread.IsBackground#1](~/add/codesnippet/cpp/p-system.threading.threa_7_1.cpp)]\n [!code-vb[System.Threading.Thread.IsBackground#1](~/add/codesnippet/visualbasic/p-system.threading.threa_7_1.vb)]"
  syntax:
    content: public bool IsBackground { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если этот поток является или станет фоновым потоком; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsBackground*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Поток не существует."
  platform:
  - net462
- uid: System.Threading.Thread.IsThreadPoolThread
  id: IsThreadPoolThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает значение, указывающее, является ли поток принадлежит группе управляемых потоков."
  remarks: "Дополнительные сведения см. [управляемых потоков пула](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to determine whether a thread is from the thread pool.  \n  \n [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/cpp/p-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/csharp/p-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_0_1.vb)]"
  syntax:
    content: public bool IsThreadPoolThread { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если этот поток принадлежит группе управляемых потоков; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.IsThreadPoolThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Join
  id: Join
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Блокирует вызывающий поток до завершения потока, представленный этим экземпляром, продолжая отправлять стандартные сообщения COM и <xref uid=&quot;langword_csharp_SendMessage&quot; name=&quot;SendMessage&quot; href=&quot;&quot;> </xref> сообщения."
  remarks: "Соединение является метод синхронизации, который блокирует вызывающий поток (поток, вызывающий метод), до которого соединения, вызывается метод завершения потока. Используйте этот метод, чтобы убедиться, что поток завершен. Вызывающий объект будет выполняться бесконечно, если поток не завершился. В следующем примере `Thread1` поток вызывает метод Join `Thread2`, чего `Thread1` блок до `Thread2` завершена.       [!code-cs[System.Threading.Thread.Join#1](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)][!code-vb[System.Threading.Thread.Join#1](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb) ] Если поток завершился уже при <xref:System.Threading.Thread.Join%2A>вызывается метод возвращается немедленно.</xref:System.Threading.Thread.Join%2A>        Настроек [!WARNING] настроек никогда не должен вызывать метод Join <xref:System.Threading.Thread>объект, представляющий текущий поток из текущего потока.</xref:System.Threading.Thread> В результате приложение зависает, так как текущий поток до появления сообщения от самой себя, этот метод изменяет состояние вызывающего потока для включения <xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName> Невозможно вызвать `Join` в потоке, который находится в <xref:System.Threading.ThreadState?displayProperty=fullName>состояние.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public void Join ();
    parameters: []
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Вызывающий объект пытается присоединиться к потоку, который находится в <xref href=&quot;System.Threading.ThreadState&quot;> </xref> состояния."
  - type: System.Threading.ThreadInterruptedException
    commentId: T:System.Threading.ThreadInterruptedException
    description: "Выполнение потока прервано во время ожидания."
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.Int32)
  id: Join(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Блокирует вызывающий поток до завершения потока, представленный этим экземпляром или указанный истечения времени, продолжая отправлять стандартные сообщения COM и SendMessage."
  remarks: "Соединение — это метод синхронизации, который блокирует вызывающий поток (поток, вызывающий метод) до любой поток которого <xref:System.Threading.Thread.Join%2A>вызывается метод завершения или истечения заданного интервала времени ожидания.</xref:System.Threading.Thread.Join%2A> В следующем примере `Thread1` поток вызывает метод <xref:System.Threading.Thread.Join>метод `Thread2`, чего `Thread1` тех пор, пока блокировка `Thread2` завершения или по истечении 2 секунды.</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#2](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)][!code-vb[System.Threading.Thread.Join#2](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb) ] Если <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>указан для `millisecondsTimeout` параметра, этот метод работает идентично <xref:System.Threading.Thread.Join>перегрузка метода, за исключением возвращаемого значения.</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         Если поток завершился уже при <xref:System.Threading.Thread.Join%2A>вызывается метод возвращается немедленно.</xref:System.Threading.Thread.Join%2A>       Этот метод изменяет состояние вызывающего потока для включения <xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName> Невозможно вызвать `Join` в потоке, который находится в <xref:System.Threading.ThreadState?displayProperty=fullName>состояние.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public bool Join (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "Количество миллисекунд для ожидания завершения потока."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если поток завершился; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если поток не завершился по истечении количества времени, заданного параметром <code> millisecondsTimeout </code> параметре."
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Значение <code> millisecondsTimeout </code> является отрицательным и не равно &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; в миллисекундах."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Поток не запущен."
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.TimeSpan)
  id: Join(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Блокирует вызывающий поток до завершения потока, представленный этим экземпляром или указанный истечения времени, продолжая отправлять стандартные сообщения COM и SendMessage."
  remarks: "Соединение — это метод синхронизации, который блокирует вызывающий поток (поток, вызывающий метод) до любой поток которого <xref:System.Threading.Thread.Join%2A>вызывается метод завершения или истечения заданного интервала времени ожидания.</xref:System.Threading.Thread.Join%2A> В следующем примере `Thread1` поток вызывает метод <xref:System.Threading.Thread.Join>метод `Thread2`, чего `Thread1` тех пор, пока блокировка `Thread2` завершения или по истечении 2 секунды.</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#3](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)][!code-vb[System.Threading.Thread.Join#3](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb) ] Если <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>указан для `timeout`, этот метод работает идентично <xref:System.Threading.Thread.Join>перегрузка метода, за исключением возвращаемого значения.</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         Если поток завершился уже при <xref:System.Threading.Thread.Join%2A>вызывается метод возвращается немедленно.</xref:System.Threading.Thread.Join%2A>       Этот метод изменяет состояние текущего потока для включения <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> Невозможно вызвать `Join` в потоке, который находится в <xref:System.Threading.ThreadState?displayProperty=fullName>состояние.</xref:System.Threading.ThreadState?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.  \n  \n [!code-cpp[System.Threading.Thread.Timespan#1](~/add/codesnippet/cpp/m-system.threading.threa_28_2.cpp)]\n [!code-cs[System.Threading.Thread.Timespan#1](~/add/codesnippet/csharp/m-system.threading.threa_28_2.cs)]\n [!code-vb[System.Threading.Thread.Timespan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_28_2.vb)]"
  syntax:
    content: public bool Join (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "Объект <xref:System.TimeSpan>задано время ожидания для завершения процесса.</xref:System.TimeSpan>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если поток завершился; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если поток не завершился по истечении количества времени, заданного параметром <code> timeout </code> параметре."
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Значение <code> timeout </code> является отрицательным и не равно &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; в миллисекундах, или больше, чем &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; миллисекунд."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Вызывающий объект пытается присоединиться к потоку, который находится в <xref href=&quot;System.Threading.ThreadState&quot;> </xref> состояния."
  platform:
  - net462
- uid: System.Threading.Thread.ManagedThreadId
  id: ManagedThreadId
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает уникальный идентификатор текущего управляемого потока."
  remarks: "Значение свойства ManagedThreadId потока служит для уникальной идентификации этого потока, внутри своего процесса.       Значение свойства ManagedThreadId не меняется со временем, даже если неуправляемый код, на котором размещается общеязыковая среда выполнения реализует поток как волокно."
  syntax:
    content: public int ManagedThreadId { get; }
    return:
      type: System.Int32
      description: "Целое число, представляющее уникальный идентификатор для этого управляемого потока."
  overload: System.Threading.Thread.ManagedThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.MemoryBarrier
  id: MemoryBarrier
  parent: System.Threading.Thread
  langs:
  - csharp
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: 'Синхронизирует доступ к памяти следующим образом: процессор, выполняющий текущий поток не способен упорядочить инструкции таким способом, который обращается к памяти до вызова MemoryBarrier выполнялись после обращений к памяти, выполните вызов MemoryBarrier.'
  remarks: "MemoryBarrier требуется только на мультипроцессорных системах со слабой организацией памяти (например, система, использующая несколько процессоров Intel Itanium).       Для большинства целей, C# `lock` оператор, Visual Basic `SyncLock` инструкции или <xref:System.Threading.Monitor>класса предоставляют более простые способы синхронизации данных.</xref:System.Threading.Monitor>"
  syntax:
    content: public static void MemoryBarrier ();
    parameters: []
  overload: System.Threading.Thread.MemoryBarrier*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Name
  id: Name
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает или задает имя потока."
  remarks: "Это свойство доступно для записи — после. Так как значение по умолчанию, имя свойства потока `null`, можно определить, является ли имя уже явно присвоен в поток, сравнивая его с `null`.       Строка, назначается свойству имя может содержать любой символ Юникода."
  example:
  - "The following example shows how to name a thread.  \n  \n [!code-cs[System.Threading.Thread.Name#1](~/add/codesnippet/csharp/p-system.threading.threa_4_1.cs)]\n [!code-cpp[System.Threading.Thread.Name#1](~/add/codesnippet/cpp/p-system.threading.threa_4_1.cpp)]\n [!code-vb[System.Threading.Thread.Name#1](~/add/codesnippet/visualbasic/p-system.threading.threa_4_1.vb)]"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "Строка, содержащая имя потока или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если имя не задано."
  overload: System.Threading.Thread.Name*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Запрошена операция задания, но <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref> свойство уже задано."
  platform:
  - net462
- uid: System.Threading.Thread.Priority
  id: Priority
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает или задает значение, указывающее на планируемый приоритет потока."
  remarks: "Поток можно назначить один из следующих приоритет <xref:System.Threading.ThreadPriority>значения:- `Highest`       -    `AboveNormal`       -    `Normal`       -    `BelowNormal`       -    `Lowest` операционные системы не требуются для предоставления приоритета потока.</xref:System.Threading.ThreadPriority>"
  example:
  - "The following example shows the result of changing the priority of a thread. Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>, and the priority of a second is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>. Each thread increments a variable in a `while` loop and runs for a set time.  \n  \n [!code-cs[System.Threading.ThreadPriority#1](~/add/codesnippet/csharp/p-system.threading.threa_6_1.cs)]\n [!code-vb[System.Threading.ThreadPriority#1](~/add/codesnippet/visualbasic/p-system.threading.threa_6_1.vb)]"
  syntax:
    content: public System.Threading.ThreadPriority Priority { get; set; }
    return:
      type: System.Threading.ThreadPriority
      description: "Один из <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref> значения. Значение по умолчанию — <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref>."
  overload: System.Threading.Thread.Priority*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Поток достиг конечного состояния, такие как <xref href=&quot;System.Threading.ThreadState&quot;> </xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Значение, указанное для операции задания не является допустимым <xref href=&quot;System.Threading.ThreadPriority&quot;> </xref> значение."
  platform:
  - net462
- uid: System.Threading.Thread.ResetAbort
  id: ResetAbort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Отменяет <xref:System.Threading.Thread.Abort*>запрошенный для текущего потока.</xref:System.Threading.Thread.Abort*>"
  remarks: "Этот метод может вызываться только кодом с соответствующими разрешениями.       Когда выполняется вызов для `Abort` завершить поток, система создает <xref:System.Threading.ThreadAbortException>.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`— специальное исключение, которое может быть зафиксировано кодом приложения, но повторно в конце блока catch, если `ResetAbort` вызывается. `ResetAbort`Отменяет запрос на аварийное завершение и предотвращает `ThreadAbortException` от завершения потока.       В разделе <xref:System.Threading.ThreadAbortException>пример, демонстрирующий вызов `ResetAbort` метод.</xref:System.Threading.ThreadAbortException>"
  syntax:
    content: public static void ResetAbort ();
    parameters: []
  overload: System.Threading.Thread.ResetAbort*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "<xref uid=&quot;langword_csharp_Abort&quot; name=&quot;Abort&quot; href=&quot;&quot;></xref>не был вызван для текущего потока."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий не имеет требуемого разрешения безопасности для текущего потока."
  platform:
  - net462
- uid: System.Threading.Thread.Resume
  id: Resume
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возобновляет приостановленную потока."
  remarks: >-
    > [!CAUTION]

    >  Do not use the <xref:System.Threading.Thread.Suspend%2A> and Resume methods to synchronize the activities of threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked. If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked. Deadlocks can occur very easily.
  syntax:
    content: public void Resume ();
    parameters: []
  overload: System.Threading.Thread.Resume*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Поток не был запущен, бездействует или не находится в приостановленном состоянии."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет соответствующего <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  id: SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Задает состояние апартамента потока до его запуска."
  remarks: "Новые потоки инициализируются как <xref:System.Threading.ApartmentState?displayProperty=fullName>Если их состояние подразделения не задано до их запуска.</xref:System.Threading.ApartmentState?displayProperty=fullName> Необходимо задать состояние подразделения, до начала потока.      Настроек [!NOTE] настроек основного потока приложения инициализируется <xref:System.Threading.ApartmentState?displayProperty=fullName>по умолчанию.</xref:System.Threading.ApartmentState?displayProperty=fullName> Единственный способ задать состояние подразделения потока основного приложения для <xref:System.Threading.ApartmentState?displayProperty=fullName>заключается в применении <xref:System.STAThreadAttribute>атрибут к методу точки входа.</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       Метод SetApartmentState вместе с <xref:System.Threading.Thread.GetApartmentState%2A>метод и <xref:System.Threading.Thread.TrySetApartmentState%2A>заменяет метод, <xref:System.Threading.Thread.ApartmentState%2A>свойство.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, SetApartmentState, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and SetApartmentState changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with SetApartmentState, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_6_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_6_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_6_1.cs)]"
  syntax:
    content: public void SetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "Новое состояние апартамента."
  overload: System.Threading.Thread.SetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>не является допустимым состоянием подразделения."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Поток уже запущен."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Состояние подразделения уже инициализировано."
  platform:
  - net462
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  id: SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Применяет записанное <xref href=&quot;System.Threading.CompressedStack&quot;> </xref> к текущему потоку."
  remarks: "Этот метод больше не поддерживается."
  syntax:
    content: public void SetCompressedStack (System.Threading.CompressedStack stack);
    parameters:
    - id: stack
      type: System.Threading.CompressedStack
      description: "<xref href=&quot;System.Threading.CompressedStack&quot;> </xref> Объекта для применения к текущему потоку."
  overload: System.Threading.Thread.SetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Во всех случаях."
  platform:
  - net462
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  id: SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Задает данные в указанной области, на данный момент поток, для текущего домена этого потока. Для повышения производительности используйте поля, отмеченные <xref:System.ThreadStaticAttribute>атрибутом.</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]Настроек платформа .NET Framework предоставляет два механизма для использования локальное хранилище потока (TLS): статические поля потока (то есть поля, отмеченные <xref:System.ThreadStaticAttribute>атрибут) и области данных.</xref:System.ThreadStaticAttribute> Статические поля потока предоставляют гораздо более высокую производительность, чем области данных и включить проверку типов во время компиляции. Дополнительные сведения об использовании TLS см. в разделе [локальное хранилище потока: статические поля потока и области данных](~/add/includes/ajax-current-ext-md.md).       Потоки используют механизм локального хранилища памяти для хранения данных определенного потока. Общеязыковая среда выполнения выделяет массив хранения данных несколькими разъемами для каждого процесса при его создании. Поток может выделить область данных в хранилище данных, хранилище и получения данных значения в слоте и освободить эту область для повторного использования после завершения процедуры потока и <xref:System.Threading.Thread>удален сборщиком мусора объект.</xref:System.Threading.Thread> Области данных являются уникальными для каждого потока. Ни один поток (даже дочерний поток) можно получить эти данные.      Настроек [!NOTE] настроек SetData является `Shared` метод, который всегда применяется к потоку выполняться в данный момент, даже при вызове с помощью переменной, которая ссылается на другой поток. Чтобы избежать путаницы, используйте имя класса при вызове `Shared` методы: `Thread.SetData(testSlot, &quot;test data&quot;)`."
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_4_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_4_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_4_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_4_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_2.vb)]"
  syntax:
    content: public static void SetData (LocalDataStoreSlot slot, object data);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "<xref href=&quot;System.LocalDataStoreSlot&quot;> </xref> Которого задается значение."
    - id: data
      type: System.Object
      description: "Задаваемое значение."
  overload: System.Threading.Thread.SetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.Int32)
  id: Sleep(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Приостанавливает текущий поток для указанного числа миллисекунд."
  remarks: "Поток не планируется для выполнения в операционной системе на указанный период времени. Этот метод изменяет состояние потока для включения <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState>       Можно указать <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>для `millisecondsTimeout` параметра на приостановку потока бесконечно.</xref:System.Threading.Timeout.Infinite?displayProperty=fullName> Тем не менее, рекомендуется использовать другие <xref:System.Threading?displayProperty=fullName>классы, такие как <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, или <xref:System.Threading.Semaphore>вместо синхронизировать потоков или управление ресурсами.</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       Тактов системы с определенной скоростью вызывается разрешение часов. Фактическое время ожидания может быть точно заданное время ожидания, поскольку заданное время ожидания будет впоследствии скорректирована совпадают с тактов. Дополнительные сведения о времени разрешения и время ожидания см. в разделе [спящий режим функция](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) раздела. Этот метод вызывает метод [спящий режим функция](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx) из API системы Windows.       Этот метод не выполняет стандартные COM и SendMessage.      Настроек [!NOTE] настроек необходимо в спящий режим в потоке, который имеет <xref:System.STAThreadAttribute>, но вы хотите выполнять стандартные COM и SendMessage, используйте одну из перегрузок <xref:System.Threading.Thread.Join%2A>метод, который задает интервал времени ожидания.</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method to block the application's main thread.  \n  \n [!code-cs[Thread.Sleep#1](~/add/codesnippet/csharp/m-system.threading.threa_2_1.cs)]\n [!code-vb[Thread.Sleep#1](~/add/codesnippet/visualbasic/m-system.threading.threa_2_1.vb)]\n [!code-cpp[Thread.Sleep#1](~/add/codesnippet/cpp/m-system.threading.threa_2_1.cpp)]"
  syntax:
    content: public static void Sleep (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "Число миллисекунд, на которое приостанавливается поток. Если значение `millisecondsTimeout` аргумент равен нулю, поток освобождает оставшуюся часть своего интервала времени для любого потока с таким же приоритетом, готовым к выполнению. Если нет других потоков с таким же приоритетом, готовым к выполнению, выполнение текущего потока не приостанавливается."
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Значение тайм-аута отрицательно и не равно <xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  id: Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Приостанавливает текущий поток в течение заданного времени."
  remarks: "Поток не планируется для выполнения в операционной системе на указанный период времени. Этот метод изменяет состояние потока для включения <xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState>       Можно указать <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName>для `timeout` параметра на приостановку потока бесконечно.</xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName> Тем не менее, рекомендуется использовать другие <xref:System.Threading?displayProperty=fullName>классы, такие как <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, или <xref:System.Threading.Semaphore>вместо синхронизировать потоков или управление ресурсами.</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       Эта перегрузка <xref:System.Threading.Thread.Sleep%2A>использует общее количество миллисекунд в `timeout`.</xref:System.Threading.Thread.Sleep%2A> Дробное количество миллисекунд, отбрасываются.       Этот метод не выполняет стандартные COM и SendMessage.      Настроек [!NOTE] настроек необходимо в спящий режим в потоке, который имеет <xref:System.STAThreadAttribute>, но вы хотите выполнять стандартные COM и SendMessage, используйте одну из перегрузок <xref:System.Threading.Thread.Join%2A>метод, который задает интервал времени ожидания.</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method overload to block the application's main thread five times, for two seconds each time.  \n  \n [!code-cpp[Thread.Sleep_TimeSpan#1](~/add/codesnippet/cpp/m-system.threading.threa_31_1.cpp)]\n [!code-cs[Thread.Sleep_TimeSpan#1](~/add/codesnippet/csharp/m-system.threading.threa_31_1.cs)]\n [!code-vb[Thread.Sleep_TimeSpan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_31_1.vb)]"
  syntax:
    content: public static void Sleep (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "Количество времени, на которое приостанавливается поток. Если значение `millisecondsTimeout` аргумент &lt;xref:System.TimeSpan?displayProperty=fullName&gt;, поток освобождает оставшуюся часть своего интервала времени для любого потока с таким же приоритетом, готовым к выполнению. Если нет других потоков с таким же приоритетом, готовым к выполнению, выполнение текущего потока не приостанавливается."
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Значение <code> timeout </code> является отрицательным и не равно &lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt; в миллисекундах, или больше, чем &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; миллисекунд."
  platform:
  - net462
- uid: System.Threading.Thread.SpinWait(System.Int32)
  id: SpinWait(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Вынуждает поток ожидать количество времени, определенное параметром <code> iterations </code> параметра."
  remarks: "Метод SpinWait полезна для реализации блокировки. Классы в .NET Framework, такие как <xref:System.Threading.Monitor>и <xref:System.Threading.ReaderWriterLock>, этот метод используется внутренне.</xref:System.Threading.ReaderWriterLock> </xref:System.Threading.Monitor> SpinWait фактически переводит процессор в очень непрерывном цикле со счетчика цикла, заданные `iterations` параметра. Таким образом, длительность ожидания зависит от скорости процессора.       Сравните это с <xref:System.Threading.Thread.Sleep%2A>метод.</xref:System.Threading.Thread.Sleep%2A> Поток, который вызывает <xref:System.Threading.Thread.Sleep%2A>дает остальная часть своего текущего интервала времени процессора, даже если за определенный интервал времени равна нулю.</xref:System.Threading.Thread.Sleep%2A> Указание ненулевой интервал <xref:System.Threading.Thread.Sleep%2A>удаляет поток из рассмотрения планировщиком потоков до истечения интервала времени.</xref:System.Threading.Thread.Sleep%2A>       SpinWait обычно не имеет смысла для обычных приложений. В большинстве случаев следует использовать классы синхронизации, предоставляемые платформой .NET Framework; Например, вызов <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>или инструкцию, которая служит оболочкой для <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>(`lock` в C# или `SyncLock` в Visual Basic).</xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> </xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>      Настроек [!CAUTION] настроек в тех редких случаях, где предпочтительнее избежать переключение контекста, например, если известно, что изменение состояния является неизбежной, вызвать метод SpinWait в цикле. Код, который выполняет SpinWait предназначен для предотвращения проблем, возникающих на компьютерах с несколькими процессорами. Например на компьютерах с несколькими процессорами Intel с применением технологии Hyper-Threading SpinWait предотвращает нехватку ресурсов процессора в определенных ситуациях."
  syntax:
    content: public static void SpinWait (int iterations);
    parameters:
    - id: iterations
      type: System.Int32
      description: "32-разрядное знаковое целое число, определяющий, как долго поток — ожидание."
  overload: System.Threading.Thread.SpinWait*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Start
  id: Start
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Заставляет операционную систему изменить состояние текущего экземпляра на <xref href=&quot;System.Threading.ThreadState&quot;> </xref>."
  remarks: "Когда поток находится в <xref:System.Threading.ThreadState?displayProperty=fullName>состояние операционной системы можно запланировать его выполнение.</xref:System.Threading.ThreadState?displayProperty=fullName> Поток начинает выполнение на первой строке метода, представленного <xref:System.Threading.ThreadStart>или <xref:System.Threading.ParameterizedThreadStart>делегат, переданное в конструктор потока.</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> Обратите внимание, что вызов метода Start не блокирует вызывающий поток.      Настроек [!NOTE] настроек Если эта перегрузка используется с потоком, созданные с помощью <xref:System.Threading.ParameterizedThreadStart>делегировать, `null` передается в метод, выполняемый потоком.</xref:System.Threading.ParameterizedThreadStart>       Если поток завершился, его невозможно перезапустить другим вызовом `Start`."
  example:
  - "The following example creates and starts a thread.  \n  \n [!code-cpp[ThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_25_1.cpp)]\n [!code-cs[ThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_25_1.cs)]\n [!code-vb[ThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_25_1.vb)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Поток уже запущен."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Не хватает памяти для запуска этого потока."
  platform:
  - net462
- uid: System.Threading.Thread.Start(System.Object)
  id: Start(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Заставляет операционную систему изменить состояние текущего экземпляра на <xref href=&quot;System.Threading.ThreadState&quot;> </xref>и (необязательно) передает объект, содержащий данные для использования с помощью метода, который выполняется потоком."
  remarks: "Когда поток находится в <xref:System.Threading.ThreadState?displayProperty=fullName>состояние операционной системы можно запланировать его выполнение.</xref:System.Threading.ThreadState?displayProperty=fullName> Поток начинает выполнение на первой строке метода, представленного <xref:System.Threading.ThreadStart>или <xref:System.Threading.ParameterizedThreadStart>делегат, переданное в конструктор потока.</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> Обратите внимание, что вызов метода Start не блокирует вызывающий поток.       Если поток завершился, его невозможно перезапустить другим вызовом `Start`.       Эта перегрузка и <xref:System.Threading.ParameterizedThreadStart>делегат позволяют легко передать процедуре потока данных, но метод не является типобезопасным, потому что эта перегрузка может передаваться все объекты.</xref:System.Threading.ParameterizedThreadStart> Для размещения процедуры потока и полей данных в рабочий объект является более надежным способом передачи данных в процедуре потока. Дополнительные сведения см. в разделе [создание потоков и передача данных во время запуска](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_15_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_15_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_15_1.cs)]"
  syntax:
    content: public void Start (object parameter);
    parameters:
    - id: parameter
      type: System.Object
      description: "Объект, содержащий данные для использования с помощью метода, который выполняется потоком."
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Поток уже запущен."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "Не хватает памяти для запуска этого потока."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Этот поток был создан с помощью <xref href=&quot;System.Threading.ThreadStart&quot;> </xref> делегировать вместо <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref> делегата."
  platform:
  - net462
- uid: System.Threading.Thread.Suspend
  id: Suspend
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Приостанавливает работу потока, либо если работа потока уже приостановлена, не оказывает влияния."
  remarks: "Если работа потока уже приостановлена, этот метод не оказывает влияния.      Настроек [!CAUTION] настроек не используйте Suspend и <xref:System.Threading.Thread.Resume%2A>методы для синхронизации действий потоков.</xref:System.Threading.Thread.Resume%2A> У вас нет возможности узнать, какой код поток выполняется в том случае, когда он приостановлен. Если поток приостановлен во время удержания блокировок во время оценки разрешений безопасности, другие потоки в <xref:System.AppDomain>может быть заблокирован.</xref:System.AppDomain> Если приостановить поток при выполнении конструктора класса, другие потоки в <xref:System.AppDomain>, попытка использовать, что класс заблокированы.</xref:System.AppDomain> Очень легко может вызвать взаимоблокировку."
  syntax:
    content: public void Suspend ();
    parameters: []
  overload: System.Threading.Thread.Suspend*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Поток не запущен или не существует."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "Вызывающий объект не имеет соответствующего <xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации."
  remarks: "Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetIDsOfNames`, см. в библиотеке MSDN."
  syntax:
    content: void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "Зарезервировано для использования в будущем. Должно быть равным IID_NULL."
    - id: rgszNames
      type: System.IntPtr
      description: "Переданный массив имен для сопоставления."
    - id: cNames
      type: System.UInt32
      description: "Количество сопоставляемых имен."
    - id: lcid
      type: System.UInt32
      description: "Контекст языкового стандарта для интерпретации имен."
    - id: rgDispId
      type: System.IntPtr
      description: "Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Доступ поздним связыванием при помощи COM- `IDispatch` интерфейс не поддерживается."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Извлекает сведения о типе для объекта, которые можно использовать для получения сведений о типе интерфейса."
  remarks: "Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfo`, см. в библиотеке MSDN."
  syntax:
    content: void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "Возвращаемые сведения о типе."
    - id: lcid
      type: System.UInt32
      description: "Идентификатор языкового стандарта для сведений о типе."
    - id: ppTInfo
      type: System.IntPtr
      description: "Получает указатель на объект сведений о запрошенного типа."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Доступ поздним связыванием при помощи COM- `IDispatch` интерфейс не поддерживается."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Возвращает число интерфейсов сведения о типе, предоставляемых объектом (0 или 1)."
  remarks: "Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfoCount`, см. в библиотеке MSDN."
  syntax:
    content: void _Thread.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "Указывает, к которому записывается число предоставляемых объектом интерфейсов сведения о типе."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Доступ поздним связыванием при помощи COM- `IDispatch` интерфейс не поддерживается."
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Предоставляет доступ к свойствам и методам, предоставляемым объекта."
  remarks: "Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::Invoke`, см. в библиотеке MSDN."
  syntax:
    content: void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "Идентифицирует член."
    - id: riid
      type: System.Guid
      description: "Зарезервировано для использования в будущем. Должно быть равным IID_NULL."
    - id: lcid
      type: System.UInt32
      description: "Контекст языкового стандарта, в котором следует интерпретировать аргументы."
    - id: wFlags
      type: System.Int16
      description: "Флаги, описывающие контекст вызова."
    - id: pDispParams
      type: System.IntPtr
      description: "Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах."
    - id: pVarResult
      type: System.IntPtr
      description: "Указатель на расположение, где будет храниться результат."
    - id: pExcepInfo
      type: System.IntPtr
      description: "Указатель на структуру, содержащую сведения об исключении."
    - id: puArgErr
      type: System.IntPtr
      description: "Индекс первого аргумента, вызвавшего ошибку."
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "Доступ поздним связыванием при помощи COM- `IDispatch` интерфейс не поддерживается."
  platform:
  - net462
- uid: System.Threading.Thread.ThreadState
  id: ThreadState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Получает значение, содержащее состояния текущего потока."
  remarks: "Свойство ThreadState предоставляет более подробные сведения, чем <xref:System.Threading.Thread.IsAlive%2A>свойство.</xref:System.Threading.Thread.IsAlive%2A>      Настроек [!IMPORTANT] настроек состояние потока используется только в сценариях отладки. Никогда не используйте в коде состояния потоков для синхронизации действий потоков."
  example:
  - "The following code example demonstrates accessing the `ThreadState` of a thread.  \n  \n [!code-cs[System.Threading.Thread.ThreadState#1](~/add/codesnippet/csharp/p-system.threading.threa_5_1.cs)]\n [!code-vb[System.Threading.Thread.ThreadState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_5_1.vb)]\n [!code-cpp[System.Threading.Thread.ThreadState#1](~/add/codesnippet/cpp/p-system.threading.threa_5_1.cpp)]"
  syntax:
    content: public System.Threading.ThreadState ThreadState { get; }
    return:
      type: System.Threading.ThreadState
      description: "Один из <xref href=&quot;System.Threading.ThreadState&quot;> </xref> значения, указывающие состояние текущего потока. Начальное значение — <xref uid=&quot;langword_csharp_Unstarted&quot; name=&quot;Unstarted&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.ThreadState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  id: TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Задает состояние апартамента потока до его запуска."
  remarks: "Новые потоки инициализируются как <xref:System.Threading.ApartmentState?displayProperty=fullName>Если их состояние подразделения не задано до их запуска.</xref:System.Threading.ApartmentState?displayProperty=fullName> Необходимо задать состояние подразделения, до начала потока.      Настроек [!NOTE] настроек основного потока приложения инициализируется <xref:System.Threading.ApartmentState?displayProperty=fullName>по умолчанию.</xref:System.Threading.ApartmentState?displayProperty=fullName> Единственный способ задать состояние подразделения потока основного приложения для <xref:System.Threading.ApartmentState?displayProperty=fullName>заключается в применении <xref:System.STAThreadAttribute>атрибут к методу точки входа.</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       Метод TrySetApartmentState вместе с <xref:System.Threading.Thread.GetApartmentState%2A>метод и <xref:System.Threading.Thread.SetApartmentState%2A>заменяет метод, <xref:System.Threading.Thread.ApartmentState%2A>свойство.</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and TrySetApartmentState methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The TrySetApartmentState method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the TrySetApartmentState method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_26_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_26_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_26_1.cs)]"
  syntax:
    content: public bool TrySetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "Новое состояние апартамента."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если задано состояние подразделения; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.TrySetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>не является допустимым состоянием подразделения."
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "Поток уже запущен."
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  id: VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Считывает значение поля. Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров."
  remarks: "VolatileRead и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе VolatileRead Получает самое последнее значение, записанное в ячейку памяти любым процессором. Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный VolatileRead и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю, VolatileRead или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует VolatileRead или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A>"
  syntax:
    content: public static byte VolatileRead (ref byte address);
    parameters:
    - id: address
      type: System.Byte
      description: "Поле для чтения."
    return:
      type: System.Byte
      description: "Последнее значение, записанное в поле любым процессором."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  id: VolatileRead(System.Double@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Считывает значение поля. Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A>Получает самое последнее значение, записанное в ячейку памяти любым процессором.</xref:System.Threading.Thread.VolatileRead%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static double VolatileRead (ref double address);
    parameters:
    - id: address
      type: System.Double
      description: "Поле для чтения."
    return:
      type: System.Double
      description: "Последнее значение, записанное в поле любым процессором."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  id: VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Считывает значение поля. Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A>Получает самое последнее значение, записанное в ячейку памяти любым процессором.</xref:System.Threading.Thread.VolatileRead%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static short VolatileRead (ref short address);
    parameters:
    - id: address
      type: System.Int16
      description: "Поле для чтения."
    return:
      type: System.Int16
      description: "Последнее значение, записанное в поле любым процессором."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  id: VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Считывает значение поля. Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A>Получает самое последнее значение, записанное в ячейку памяти любым процессором.</xref:System.Threading.Thread.VolatileRead%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static int VolatileRead (ref int address);
    parameters:
    - id: address
      type: System.Int32
      description: "Поле для чтения."
    return:
      type: System.Int32
      description: "Последнее значение, записанное в поле любым процессором."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  id: VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Считывает значение поля. Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A>Получает самое последнее значение, записанное в ячейку памяти любым процессором.</xref:System.Threading.Thread.VolatileRead%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static long VolatileRead (ref long address);
    parameters:
    - id: address
      type: System.Int64
      description: "Поле для чтения."
    return:
      type: System.Int64
      description: "Последнее значение, записанное в поле любым процессором."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  id: VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Считывает значение поля. Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A>Получает самое последнее значение, записанное в ячейку памяти любым процессором.</xref:System.Threading.Thread.VolatileRead%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static IntPtr VolatileRead (ref IntPtr address);
    parameters:
    - id: address
      type: System.IntPtr
      description: "Поле для чтения."
    return:
      type: System.IntPtr
      description: "Последнее значение, записанное в поле любым процессором."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  id: VolatileRead(System.Object@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Считывает значение поля. Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A>Получает самое последнее значение, записанное в ячейку памяти любым процессором.</xref:System.Threading.Thread.VolatileRead%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static object VolatileRead (ref object address);
    parameters:
    - id: address
      type: System.Object
      description: "Поле для чтения."
    return:
      type: System.Object
      description: "Последнее значение, записанное в поле любым процессором."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  id: VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Считывает значение поля. Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A>Получает самое последнее значение, записанное в ячейку памяти любым процессором.</xref:System.Threading.Thread.VolatileRead%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static sbyte VolatileRead (ref sbyte address);
    parameters:
    - id: address
      type: System.SByte
      description: "Поле для чтения."
    return:
      type: System.SByte
      description: "Последнее значение, записанное в поле любым процессором."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  id: VolatileRead(System.Single@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Считывает значение поля. Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A>Получает самое последнее значение, записанное в ячейку памяти любым процессором.</xref:System.Threading.Thread.VolatileRead%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static float VolatileRead (ref float address);
    parameters:
    - id: address
      type: System.Single
      description: "Поле для чтения."
    return:
      type: System.Single
      description: "Последнее значение, записанное в поле любым процессором."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  id: VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Считывает значение поля. Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A>Получает самое последнее значение, записанное в ячейку памяти любым процессором.</xref:System.Threading.Thread.VolatileRead%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static ushort VolatileRead (ref ushort address);
    parameters:
    - id: address
      type: System.UInt16
      description: "Поле для чтения."
    return:
      type: System.UInt16
      description: "Последнее значение, записанное в поле любым процессором."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  id: VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Считывает значение поля. Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A>Получает самое последнее значение, записанное в ячейку памяти любым процессором.</xref:System.Threading.Thread.VolatileRead%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static uint VolatileRead (ref uint address);
    parameters:
    - id: address
      type: System.UInt32
      description: "Поле для чтения."
    return:
      type: System.UInt32
      description: "Последнее значение, записанное в поле любым процессором."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  id: VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Считывает значение поля. Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A>Получает самое последнее значение, записанное в ячейку памяти любым процессором.</xref:System.Threading.Thread.VolatileRead%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static ulong VolatileRead (ref ulong address);
    parameters:
    - id: address
      type: System.UInt64
      description: "Поле для чтения."
    return:
      type: System.UInt64
      description: "Последнее значение, записанное в поле любым процессором."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  id: VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Считывает значение поля. Значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и состояния кэш-буфера процессоров."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A>Получает самое последнее значение, записанное в ячейку памяти любым процессором.</xref:System.Threading.Thread.VolatileRead%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static UIntPtr VolatileRead (ref UIntPtr address);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "Поле для чтения."
    return:
      type: System.UIntPtr
      description: "Последнее значение, записанное в поле любым процессором."
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  id: VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и VolatileWrite предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе VolatileWrite обеспечивает значение, записанное в ячейку памяти немедленно видимым для всех процессоров. Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и VolatileWrite убедитесь, что значение чтение или записываются в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или VolatileWrite.</xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или VolatileWrite.</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref byte address, byte value);
    parameters:
    - id: address
      type: System.Byte
      description: "Поле, к которому должны быть записаны значения."
    - id: value
      type: System.Byte
      description: "Записываемое значение."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  id: VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A>гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.</xref:System.Threading.Thread.VolatileWrite%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref double address, double value);
    parameters:
    - id: address
      type: System.Double
      description: "Поле, к которому должны быть записаны значения."
    - id: value
      type: System.Double
      description: "Записываемое значение."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  id: VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A>гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.</xref:System.Threading.Thread.VolatileWrite%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref short address, short value);
    parameters:
    - id: address
      type: System.Int16
      description: "Поле, к которому должны быть записаны значения."
    - id: value
      type: System.Int16
      description: "Записываемое значение."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  id: VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A>гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.</xref:System.Threading.Thread.VolatileWrite%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref int address, int value);
    parameters:
    - id: address
      type: System.Int32
      description: "Поле, к которому должны быть записаны значения."
    - id: value
      type: System.Int32
      description: "Записываемое значение."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  id: VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A>гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.</xref:System.Threading.Thread.VolatileWrite%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref long address, long value);
    parameters:
    - id: address
      type: System.Int64
      description: "Поле, к которому должны быть записаны значения."
    - id: value
      type: System.Int64
      description: "Записываемое значение."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  id: VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A>гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.</xref:System.Threading.Thread.VolatileWrite%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref IntPtr address, IntPtr value);
    parameters:
    - id: address
      type: System.IntPtr
      description: "Поле, к которому должны быть записаны значения."
    - id: value
      type: System.IntPtr
      description: "Записываемое значение."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  id: VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A>гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.</xref:System.Threading.Thread.VolatileWrite%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref object address, object value);
    parameters:
    - id: address
      type: System.Object
      description: "Поле, к которому должны быть записаны значения."
    - id: value
      type: System.Object
      description: "Записываемое значение."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  id: VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A>гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.</xref:System.Threading.Thread.VolatileWrite%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref sbyte address, sbyte value);
    parameters:
    - id: address
      type: System.SByte
      description: "Поле, к которому должны быть записаны значения."
    - id: value
      type: System.SByte
      description: "Записываемое значение."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  id: VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A>гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.</xref:System.Threading.Thread.VolatileWrite%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref float address, float value);
    parameters:
    - id: address
      type: System.Single
      description: "Поле, к которому должны быть записаны значения."
    - id: value
      type: System.Single
      description: "Записываемое значение."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  id: VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A>гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.</xref:System.Threading.Thread.VolatileWrite%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref ushort address, ushort value);
    parameters:
    - id: address
      type: System.UInt16
      description: "Поле, к которому должны быть записаны значения."
    - id: value
      type: System.UInt16
      description: "Записываемое значение."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  id: VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A>гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.</xref:System.Threading.Thread.VolatileWrite%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref uint address, uint value);
    parameters:
    - id: address
      type: System.UInt32
      description: "Поле, к которому должны быть записаны значения."
    - id: value
      type: System.UInt32
      description: "Записываемое значение."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  id: VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A>гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.</xref:System.Threading.Thread.VolatileWrite%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref ulong address, ulong value);
    parameters:
    - id: address
      type: System.UInt64
      description: "Поле, к которому должны быть записаны значения."
    - id: value
      type: System.UInt64
      description: "Записываемое значение."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  id: VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Записывает значение в поле непосредственно, так что оно становится видимым для всех процессоров компьютера."
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>предназначены для особых случаев синхронизации.</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> В обычных условиях C# `lock` оператор, Visual Basic `SyncLock` инструкции и <xref:System.Threading.Monitor>класса предоставляют более простые альтернативы.</xref:System.Threading.Monitor>       В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A>гарантирует, что значение, записанное в ячейку памяти будет видимым для всех процессоров.</xref:System.Threading.Thread.VolatileWrite%2A> Для этого может потребоваться сброс кэша процессора.       Даже в системе однопроцессорный <xref:System.Threading.Thread.VolatileRead%2A>и <xref:System.Threading.Thread.VolatileWrite%2A>Убедитесь, что значение чтения или записи в память и не кэшируются (например, в регистре процессора).</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> Таким образом их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком, или оборудования.       Вызов этого метода влияет только однократный доступ к памяти. Для предоставления эффективной синхронизации для поля, необходимо использовать весь доступ к полю <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      Настроек [!NOTE] настроек в C# с помощью `volatile` модификатор поля гарантирует, что весь доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A>или <xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref UIntPtr address, UIntPtr value);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "Поле, к которому должны быть записаны значения."
    - id: value
      type: System.UIntPtr
      description: "Записываемое значение."
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Yield
  id: Yield
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "Позволяет вызвавшему потоку передать выполнение другому потоку, готовому к использованию на текущем процессоре. Операционная система выбирает потоку передается выполнение."
  remarks: "Если этот метод завершается успешно, получением остальная часть потока текущего интервала времени. Операционная система планирует вызывающий поток для другого среза времени в соответствии с его приоритетом и состоянием других потоков, доступных для выполнения.       Выдача ограничена процессором, который выполняет вызывающий поток. Операционная система не переключит выполнение на другой процессор даже в том случае, если процессор простаивает или выполняется поток с более низким приоритетом. Если нет других потоков, которые готовы к выполнению на текущем процессоре, операционная система не дает выполнения, и этот метод возвращает `false`.       Этот метод эквивалентен методу вызове неуправляемого кода для вызова собственного Win32 `SwitchToThread` функции. Следует вызывать Yield, вызвать метод вместо использования платформы, так как неуправляемого кода обходит любое пользовательское потоковое поведение запрошенным узла."
  syntax:
    content: public static bool Yield ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если операционная система переключила выполнение на другой поток; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Threading.Thread.Yield*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Threading.ThreadStateException
  parent: System.Threading
  isExternal: false
  name: ThreadStateException
  nameWithType: ThreadStateException
  fullName: System.Threading.ThreadStateException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Threading.ThreadInterruptedException
  parent: System.Threading
  isExternal: false
  name: ThreadInterruptedException
  nameWithType: ThreadInterruptedException
  fullName: System.Threading.ThreadInterruptedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
- uid: System.Threading.ParameterizedThreadStart
  parent: System.Threading
  isExternal: false
  name: ParameterizedThreadStart
  nameWithType: ParameterizedThreadStart
  fullName: System.Threading.ParameterizedThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
- uid: System.Threading.ThreadStart
  parent: System.Threading
  isExternal: false
  name: ThreadStart
  nameWithType: ThreadStart
  fullName: System.Threading.ThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
- uid: System.Threading.Thread.Abort
  parent: System.Threading.Thread
  isExternal: false
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
- uid: System.Threading.Thread.Abort(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Threading.Thread.AllocateDataSlot
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
- uid: System.LocalDataStoreSlot
  parent: System
  isExternal: false
  name: LocalDataStoreSlot
  nameWithType: LocalDataStoreSlot
  fullName: System.LocalDataStoreSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Threading.Thread.ApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
- uid: System.Threading.ApartmentState
  parent: System.Threading
  isExternal: false
  name: ApartmentState
  nameWithType: ApartmentState
  fullName: System.Threading.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
- uid: System.Threading.Thread.BeginThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
- uid: System.Threading.Thread.CurrentContext
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
- uid: System.Runtime.Remoting.Contexts.Context
  parent: System.Runtime.Remoting.Contexts
  isExternal: false
  name: Context
  nameWithType: Context
  fullName: System.Runtime.Remoting.Contexts.Context
- uid: System.Threading.Thread.CurrentCulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Threading.Thread.CurrentPrincipal
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.Threading.Thread.CurrentThread
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
- uid: System.Threading.Thread.CurrentUICulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
- uid: System.Threading.Thread.EndCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
- uid: System.Threading.Thread.EndThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
- uid: System.Threading.Thread.ExecutionContext
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
- uid: System.Threading.ExecutionContext
  parent: System.Threading
  isExternal: true
  name: ExecutionContext
  nameWithType: ExecutionContext
  fullName: System.Threading.ExecutionContext
- uid: System.Threading.Thread.Finalize
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
- uid: System.Threading.Thread.GetApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
- uid: System.Threading.Thread.GetCompressedStack
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
- uid: System.Threading.CompressedStack
  parent: System.Threading
  isExternal: false
  name: CompressedStack
  nameWithType: CompressedStack
  fullName: System.Threading.CompressedStack
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  isExternal: false
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
- uid: System.Threading.Thread.GetDomain
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.Threading.Thread.GetDomainID
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
- uid: System.Threading.Thread.GetHashCode
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
- uid: System.Threading.Thread.Interrupt
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
- uid: System.Threading.Thread.IsAlive
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.Thread.IsBackground
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join
  parent: System.Threading.Thread
  isExternal: false
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
- uid: System.Threading.Thread.Join(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
- uid: System.Threading.Thread.Join(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.Thread.ManagedThreadId
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
- uid: System.Threading.Thread.Name
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
- uid: System.Threading.Thread.Priority
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
- uid: System.Threading.ThreadPriority
  parent: System.Threading
  isExternal: false
  name: ThreadPriority
  nameWithType: ThreadPriority
  fullName: System.Threading.ThreadPriority
- uid: System.Threading.Thread.ResetAbort
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
- uid: System.Threading.Thread.Resume
  parent: System.Threading.Thread
  isExternal: false
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
- uid: System.Threading.Thread.Sleep(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
- uid: System.Threading.Thread.SpinWait(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
- uid: System.Threading.Thread.Start
  parent: System.Threading.Thread
  isExternal: false
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
- uid: System.Threading.Thread.Start(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
- uid: System.Threading.Thread.Suspend
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Threading.Thread.ThreadState
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
- uid: System.Threading.ThreadState
  parent: System.Threading
  isExternal: false
  name: ThreadState
  nameWithType: ThreadState
  fullName: System.Threading.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
- uid: System.SByte
  parent: System
  isExternal: true
  name: SByte
  nameWithType: SByte
  fullName: System.SByte
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
- uid: System.UInt16
  parent: System
  isExternal: true
  name: UInt16
  nameWithType: UInt16
  fullName: System.UInt16
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
- uid: System.UInt64
  parent: System
  isExternal: true
  name: UInt64
  nameWithType: UInt64
  fullName: System.UInt64
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
- uid: System.UIntPtr
  parent: System
  isExternal: true
  name: UIntPtr
  nameWithType: UIntPtr
  fullName: System.UIntPtr
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
- uid: System.Threading.Thread.Yield
  parent: System.Threading.Thread
  isExternal: false
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
- uid: System.Threading.Thread.#ctor*
  parent: System.Threading.Thread
  isExternal: false
  name: Thread
  nameWithType: Thread.Thread
- uid: System.Threading.Thread.Abort*
  parent: System.Threading.Thread
  isExternal: false
  name: Abort
  nameWithType: Thread.Abort
- uid: System.Threading.Thread.AllocateDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot
  nameWithType: Thread.AllocateDataSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot
  nameWithType: Thread.AllocateNamedDataSlot
- uid: System.Threading.Thread.ApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion
  nameWithType: Thread.BeginCriticalRegion
- uid: System.Threading.Thread.BeginThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity
  nameWithType: Thread.BeginThreadAffinity
- uid: System.Threading.Thread.CurrentContext*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
- uid: System.Threading.Thread.CurrentCulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
- uid: System.Threading.Thread.CurrentPrincipal*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
- uid: System.Threading.Thread.CurrentThread*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
- uid: System.Threading.Thread.CurrentUICulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup*
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup
  nameWithType: Thread.DisableComObjectEagerCleanup
- uid: System.Threading.Thread.EndCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion
  nameWithType: Thread.EndCriticalRegion
- uid: System.Threading.Thread.EndThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity
  nameWithType: Thread.EndThreadAffinity
- uid: System.Threading.Thread.ExecutionContext*
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
- uid: System.Threading.Thread.Finalize*
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize
  nameWithType: Thread.Finalize
- uid: System.Threading.Thread.FreeNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot
  nameWithType: Thread.FreeNamedDataSlot
- uid: System.Threading.Thread.GetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState
  nameWithType: Thread.GetApartmentState
- uid: System.Threading.Thread.GetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack
  nameWithType: Thread.GetCompressedStack
- uid: System.Threading.Thread.GetData*
  parent: System.Threading.Thread
  isExternal: false
  name: GetData
  nameWithType: Thread.GetData
- uid: System.Threading.Thread.GetDomain*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain
  nameWithType: Thread.GetDomain
- uid: System.Threading.Thread.GetDomainID*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID
  nameWithType: Thread.GetDomainID
- uid: System.Threading.Thread.GetHashCode*
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode
  nameWithType: Thread.GetHashCode
- uid: System.Threading.Thread.GetNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot
  nameWithType: Thread.GetNamedDataSlot
- uid: System.Threading.Thread.Interrupt*
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt
  nameWithType: Thread.Interrupt
- uid: System.Threading.Thread.IsAlive*
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
- uid: System.Threading.Thread.IsBackground*
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread*
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join*
  parent: System.Threading.Thread
  isExternal: false
  name: Join
  nameWithType: Thread.Join
- uid: System.Threading.Thread.ManagedThreadId*
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier*
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier
  nameWithType: Thread.MemoryBarrier
- uid: System.Threading.Thread.Name*
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
- uid: System.Threading.Thread.Priority*
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
- uid: System.Threading.Thread.ResetAbort*
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort
  nameWithType: Thread.ResetAbort
- uid: System.Threading.Thread.Resume*
  parent: System.Threading.Thread
  isExternal: false
  name: Resume
  nameWithType: Thread.Resume
- uid: System.Threading.Thread.SetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState
  nameWithType: Thread.SetApartmentState
- uid: System.Threading.Thread.SetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack
  nameWithType: Thread.SetCompressedStack
- uid: System.Threading.Thread.SetData*
  parent: System.Threading.Thread
  isExternal: false
  name: SetData
  nameWithType: Thread.SetData
- uid: System.Threading.Thread.Sleep*
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep
  nameWithType: Thread.Sleep
- uid: System.Threading.Thread.SpinWait*
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait
  nameWithType: Thread.SpinWait
- uid: System.Threading.Thread.Start*
  parent: System.Threading.Thread
  isExternal: false
  name: Start
  nameWithType: Thread.Start
- uid: System.Threading.Thread.Suspend*
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend
  nameWithType: Thread.Suspend
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke
- uid: System.Threading.Thread.ThreadState*
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState
  nameWithType: Thread.TrySetApartmentState
- uid: System.Threading.Thread.VolatileRead*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead
  nameWithType: Thread.VolatileRead
- uid: System.Threading.Thread.VolatileWrite*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite
  nameWithType: Thread.VolatileWrite
- uid: System.Threading.Thread.Yield*
  parent: System.Threading.Thread
  isExternal: false
  name: Yield
  nameWithType: Thread.Yield
