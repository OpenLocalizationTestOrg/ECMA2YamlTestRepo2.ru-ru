### YamlMime:ManagedReference
items:
- uid: System.ServiceProcess.ServiceBase
  id: ServiceBase
  children:
  - System.ServiceProcess.ServiceBase.#ctor
  - System.ServiceProcess.ServiceBase.AutoLog
  - System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  - System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  - System.ServiceProcess.ServiceBase.CanPauseAndContinue
  - System.ServiceProcess.ServiceBase.CanShutdown
  - System.ServiceProcess.ServiceBase.CanStop
  - System.ServiceProcess.ServiceBase.Dispose(System.Boolean)
  - System.ServiceProcess.ServiceBase.EventLog
  - System.ServiceProcess.ServiceBase.ExitCode
  - System.ServiceProcess.ServiceBase.MaxNameLength
  - System.ServiceProcess.ServiceBase.OnContinue
  - System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)
  - System.ServiceProcess.ServiceBase.OnPause
  - System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  - System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  - System.ServiceProcess.ServiceBase.OnShutdown
  - System.ServiceProcess.ServiceBase.OnStart(System.String[])
  - System.ServiceProcess.ServiceBase.OnStop
  - System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)
  - System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)
  - System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])
  - System.ServiceProcess.ServiceBase.ServiceHandle
  - System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)
  - System.ServiceProcess.ServiceBase.ServiceName
  - System.ServiceProcess.ServiceBase.Stop
  langs:
  - csharp
  name: ServiceBase
  nameWithType: ServiceBase
  fullName: System.ServiceProcess.ServiceBase
  type: Class
  summary: "Предоставляет базовый класс для службы, которая будет существовать как часть приложения службы. ServiceBase должен быть производным от при создании нового класса службы."
  remarks: "Derive from ServiceBase when defining your service class in a service application. Any useful service overrides the [OnStart(String\\[\\])](assetId:///M:System.ServiceProcess.ServiceBase.OnStart(System.String[])?qualifyHint=False&autoUpgrade=True) and <xref:System.ServiceProcess.ServiceBase.OnStop%2A> methods. For additional functionality, you can override <xref:System.ServiceProcess.ServiceBase.OnPause%2A> and <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> with specific behavior in response to changes in the service state.  \n  \n A service is a long-running executable that does not support a user interface, and which might not run under the logged-on user account. The service can run without any user being logged on to the computer.  \n  \n By default, services run under the System account, which is not the same as the Administrator account. You cannot change the rights of the System account. Alternatively, you can use a <xref:System.ServiceProcess.ServiceProcessInstaller> to specify a user account under which the service will run.  \n  \n An executable can contain more than one service but must contain a separate <xref:System.ServiceProcess.ServiceInstaller> for each service. The <xref:System.ServiceProcess.ServiceInstaller> instance registers the service with the system. The installer also associates each service with an event log that you can use to record service commands. The `main()` function in the executable defines which services should run. The current working directory of the service is the system directory, not the directory in which the executable is located.  \n  \n When you start a service, the system locates the executable and runs the <xref:System.ServiceProcess.ServiceBase.OnStart%2A> method for that service, contained within the executable. However, running the service is not the same as running the executable. The executable only loads the service. The service is accessed (for example, started and stopped) through the Service Control Manager.  \n  \n The executable calls the ServiceBase derived class's constructor the first time you call Start on the service. The <xref:System.ServiceProcess.ServiceBase.OnStart%2A> command-handling method is called immediately after the constructor executes. The constructor is not executed again after the first time the service has been loaded, so it is necessary to separate the processing performed by the constructor from that performed by <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Any resources that can be released by <xref:System.ServiceProcess.ServiceBase.OnStop%2A> should be created in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Creating resources in the constructor prevents them from being created properly if the service is started again after <xref:System.ServiceProcess.ServiceBase.OnStop%2A> has released the resources.  \n  \n The Service Control Manager (SCM) provides a way to interact with the service. You can use the SCM to pass Start, Stop, Pause, Continue, or custom commands into the service. The SCM uses the values of <xref:System.ServiceProcess.ServiceBase.CanStop%2A> and <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> to determine whether the service accepts Stop, Pause, or Continue commands. Stop, Pause, and Continue are enabled in the SCM's context menus only if the corresponding property <xref:System.ServiceProcess.ServiceBase.CanStop%2A> or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `true` in the service class. If enabled, the command is passed to the service, and <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, or <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> is called. If <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `false`, the corresponding command-handling method (such as <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) will not be processed, even if you have implemented the method.  \n  \n You can use the <xref:System.ServiceProcess.ServiceController> class to do programmatically what the SCM does using a user interface. You can automate the tasks available in the console. If <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, or <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> is `true` but you have not implemented a corresponding command-handling method (such as <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) the system throws an exception and ignores the command.  \n  \n You do not have to implement <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, or any other method in ServiceBase. However, the service's behavior is described in <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, so at minimum, this member should be overridden. The `main()` function of the executable registers the service in the executable with the Service Control Manager by calling the <xref:System.ServiceProcess.ServiceBase.Run%2A> method. The <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> property of the ServiceBase object passed to the <xref:System.ServiceProcess.ServiceBase.Run%2A> method must match the <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> property of the service installer for that service.  \n  \n You can use `InstallUtil.exe` to install services on your system.  \n  \n> [!NOTE]\n>  You can specify a log other than the Application event log to receive notification of service calls, but neither the <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> nor the <xref:System.ServiceProcess.ServiceBase.EventLog%2A> property can write to a custom log. Set <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> to `false` if you do not want to use automatic logging."
  syntax:
    content: >-
      [System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))]

      public class ServiceBase : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.#ctor
  id: '#ctor'
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceBase()
  nameWithType: ServiceBase.ServiceBase()
  fullName: System.ServiceProcess.ServiceBase.ServiceBase()
  type: Constructor
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Создает новый экземпляр <xref href=&quot;System.ServiceProcess.ServiceBase&quot;> </xref> класса."
  remarks: "Не следует создавать экземпляр <xref:System.ServiceProcess.ServiceBase>класса.</xref:System.ServiceProcess.ServiceBase> Вместо этого являются производными от <xref:System.ServiceProcess.ServiceBase>и создание экземпляра вашего производного класса.</xref:System.ServiceProcess.ServiceBase> Минимальное необходимо реализовать конструктор для класса, производного от <xref:System.ServiceProcess.ServiceBase>заключается в задании <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>в компоненте.</xref:System.ServiceProcess.ServiceBase.ServiceName%2A> </xref:System.ServiceProcess.ServiceBase> Никакие другие процессы не является обязательным в конструкторе. Должен обрабатывать большинство инициализации в <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, а не в конструкторе.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> В противном случае нет никакой гарантии, которые объекты будут повторно инициализированы, при повторном запуске службы после ее остановки.       При переопределении в производном классе конструктор, необходимо вызовите конструктор базового класса в коде.       <xref:System.ServiceProcess.ServiceBase>Конструктора задает <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>для `true`.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A> </xref:System.ServiceProcess.ServiceBase> Если вы не хотите автоматически записывать вызовы службы от диспетчера управления службами (SCM), установите <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>для `false`.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>       Если исполняемый файл содержит одну службу, система вызывает конструктор службы при выборе из диспетчера управления Службами Start.       Если исполняемый файл содержит несколько служб, вызов Start для одной службы вызывает конструкторы для всех служб в исполняемом файле, но запускается только указанная служба. Деструкторы служб запускаются вместе после все службы были остановлены, не по отдельности после остановки всех служб.      Настроек [!NOTE] настроек при переопределении конструктор базового класса, то необходимо явно вызвать в конструкторе производного класса."
  syntax:
    content: public ServiceBase ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.AutoLog
  id: AutoLog
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: AutoLog
  nameWithType: ServiceBase.AutoLog
  fullName: System.ServiceProcess.ServiceBase.AutoLog
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Указывает, следует ли в журнал событий команд Start, Stop, Pause и продолжить."
  remarks: "Установите значение AutoLog `true` указывает службе использовать журнал событий приложений, чтобы ошибки команд, а также информацию об изменении состояния для запуска, остановки, приостановки и продолжения события в службе. Имя службы используется в качестве журнала <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>.</xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>       Для передачи сведений пользовательского журнала событий, а не в журнале приложений, равным AutoLog `false` и записать инструкции в пределах методов обработки команд <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, или <xref:System.ServiceProcess.ServiceBase.OnStop%2A>можно записывать в журнал соответствующие</xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A>      Настроек [!NOTE] настроек <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>предоставляет исходная строка для журнала событий, нужно установить, прежде чем служба пытается произвести запись в журнал событий.</xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Исключение при попытке доступа к журналу событий имя источника задано."
  syntax:
    content: public bool AutoLog { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>данные должны записываться в журнал событий; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.AutoLog*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  id: CanHandlePowerEvent
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanHandlePowerEvent
  nameWithType: ServiceBase.CanHandlePowerEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Возвращает или задает значение, указывающее, может ли служба обрабатывать уведомления об изменениях состояния питания компьютера."
  remarks: "При изменениях состояния питания компьютера диспетчера управления службами (SCM) проверяет, является ли служба принимает значение CanHandlePowerEvent по.       Если CanHandlePowerEvent `true`, команда передается в службу и <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>метод вызывается, если определено.</xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> Если <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>не реализован в производном классе SCM обрабатывает события управления питанием с помощью пустой базовый класс <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=fullName>метод.</xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=fullName> </xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>"
  syntax:
    content: public bool CanHandlePowerEvent { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если служба обрабатывает указанные изменения в состоянии питания компьютера <xref href=&quot;System.ServiceProcess.PowerBroadcastStatus&quot;> </xref> класса, в противном случае — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanHandlePowerEvent*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Это свойство изменено после запуска службы."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  id: CanHandleSessionChangeEvent
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanHandleSessionChangeEvent
  nameWithType: ServiceBase.CanHandleSessionChangeEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Возвращает или задает значение, указывающее, может ли служба обрабатывать события изменения сеанса, полученный от сеанса сервера терминалов."
  syntax:
    content: public bool CanHandleSessionChangeEvent { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если служба может обрабатывать события изменения сеанса сервера терминалов; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Это свойство изменено после запуска службы."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanPauseAndContinue
  id: CanPauseAndContinue
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanPauseAndContinue
  nameWithType: ServiceBase.CanPauseAndContinue
  fullName: System.ServiceProcess.ServiceBase.CanPauseAndContinue
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Возвращает или задает значение, указывающее, приостановки или возобновления работы службы."
  remarks: "Задайте значение свойства CanPauseAndContinue в конструкторе для службы.       Если служба приостановлена, он прерывает текущую работу. При продолжении работы службы (или через диспетчер управления службами или программным способом) <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>запускает.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Отправка запроса на приостановку к службе можно экономии ресурсов системы. Приостановка не может освободить все ресурсы системы, но не Stop. <xref:System.ServiceProcess.ServiceBase.OnPause%2A>и <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>часто применяется для выполнения меньше, чем <xref:System.ServiceProcess.ServiceBase.OnStop%2A>и <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> </xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A></xref:System.ServiceProcess.ServiceBase.OnPause%2A>       При CanPauseAndContinue `true`, переопределите <xref:System.ServiceProcess.ServiceBase.OnPause%2A>и <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>задаются действия, которое должно выполняться, когда диспетчер управления службами (SCM) передает запрос на приостановку или остановку службы.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>должен быть реализован для отмены обработки в <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.</xref:System.ServiceProcess.ServiceBase.OnPause%2A></xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Если CanPauseAndContinue `false`, не будут передаваться приостановить или продолжить запросы к службе, поэтому <xref:System.ServiceProcess.ServiceBase.OnPause%2A>и <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>методы не вызываются, даже если их реализации.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> В SCM `Pause` и `Continue` элементы будут отключены при CanPauseAndContinue `false`."
  syntax:
    content: public bool CanPauseAndContinue { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если служба может быть приостановлена; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanPauseAndContinue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Служба уже запущена. Свойства CanPauseAndContinue не может изменяться после запуска службы."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanShutdown
  id: CanShutdown
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanShutdown
  nameWithType: ServiceBase.CanShutdown
  fullName: System.ServiceProcess.ServiceBase.CanShutdown
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Возвращает или задает значение, указывающее, является ли уведомлять службу о завершении работы системы."
  remarks: "Если CanShutdown `true`, уведомлять службу о завершении работы системы. При завершении работы, <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>метод вызывается в том случае, если он был реализован в производном класса.</xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>      Настроек [!NOTE] настроек только система должна вызывать <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>метод для выполнения; служба может вызывать его, но это не рекомендуется.</xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>"
  syntax:
    content: public bool CanShutdown { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если службы должны быть уведомлены, когда система завершает работу; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.  Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.CanShutdown*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Служба уже запущена. Свойство CanShutdown не может изменяться после запуска службы."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.CanStop
  id: CanStop
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: CanStop
  nameWithType: ServiceBase.CanStop
  fullName: System.ServiceProcess.ServiceBase.CanStop
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Возвращает или задает значение, указывающее, возможен ли останов службы после ее запуска."
  remarks: "При вызове службы, диспетчер управления службами (SCM) проверяет, принимает ли службы с помощью значения CanStop команды Stop. Для большинства служб имеет значение CanStop `true`, но некоторые службы операционной системы, например, не разрешает пользователю остановить их.       Если CanStop `true`, команда Stop передается службе и <xref:System.ServiceProcess.ServiceBase.OnStop%2A>метод вызывается в том случае, если он определен.</xref:System.ServiceProcess.ServiceBase.OnStop%2A> Если <xref:System.ServiceProcess.ServiceBase.OnStop%2A>не реализован в производном классе, дескрипторы SCM команды Stop через пустой базовый класс <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=fullName>метод.</xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=fullName> </xref:System.ServiceProcess.ServiceBase.OnStop%2A>"
  syntax:
    content: public bool CanStop { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если служба может быть остановлена и <xref:System.ServiceProcess.ServiceBase.OnStop*>метод с именем; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.ServiceProcess.ServiceBase.OnStop*>"
  overload: System.ServiceProcess.ServiceBase.CanStop*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Служба уже запущена. Свойство CanStop нельзя изменить после запуска службы."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: ServiceBase.Dispose(Boolean)
  fullName: System.ServiceProcess.ServiceBase.Dispose(Boolean)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Уничтожает ресурсы (кроме памяти), используемые <xref href=&quot;System.ServiceProcess.ServiceBase&quot;> </xref>."
  remarks: "Вызов Dispose в производном классе (и с его помощью в <xref:System.ServiceProcess.ServiceBase>класса) после использования производного класса.</xref:System.ServiceProcess.ServiceBase> Метод Dispose оставляет производного класса в нерабочем состоянии. После вызова Dispose, необходимо удалить все ссылки в производный класс и <xref:System.ServiceProcess.ServiceBase>, невозможно освободить память, они занимающих при сборке мусора.</xref:System.ServiceProcess.ServiceBase>      Настроек [!NOTE] настроек всегда вызова Dispose перед освобождением последней ссылки на класс, производный от <xref:System.ServiceProcess.ServiceBase>.</xref:System.ServiceProcess.ServiceBase> В противном случае ресурсы <xref:System.ServiceProcess.ServiceBase>и используете будет производного класса не будут освобождены, пока сборщик мусора не вызовет деструкторы объектов.</xref:System.ServiceProcess.ServiceBase>       <xref:System.ServiceProcess.ServiceBase.OnStop%2A>часто применяется для обработки кода в <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, объединенных с помощью вызова метода Dispose.</xref:System.ServiceProcess.ServiceBase.OnPause%2A></xref:System.ServiceProcess.ServiceBase.OnStop%2A> Если вы решите сделать это в производном классе, обычно реализуют <xref:System.ServiceProcess.ServiceBase.OnStart%2A>Выделить все, что выпущен Dispose.</xref:System.ServiceProcess.ServiceBase.OnStart%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>для освобождения управляемых и неуправляемых ресурсов; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для освобождения только неуправляемых ресурсов."
  overload: System.ServiceProcess.ServiceBase.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.EventLog
  id: EventLog
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: EventLog
  nameWithType: ServiceBase.EventLog
  fullName: System.ServiceProcess.ServiceBase.EventLog
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Получает журнал событий, которые можно использовать для записи уведомлений о вызовах команд службы, такие как запуск или остановка, в журнал событий приложений."
  remarks: "Конструктор инициализирует свойство EventLog к экземпляру с <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>и <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=fullName>набором свойств.</xref:System.Diagnostics.EventLog.Log%2A?displayProperty=fullName> </xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName> Источником является <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>службы, и журнал — журнал приложения на компьютере</xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Эти значения задаются автоматически и не может изменяться для автоматической записи команд службы.       Если <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>является `true`, запуск, остановка, приостановка, продолжить и пользовательские команды автоматически записываются в журнал событий приложений</xref:System.ServiceProcess.ServiceBase.AutoLog%2A> Свойство EventLog записи журнала, а также дополнительных сообщений. Компонент вызывает метод <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=fullName>с помощью этого элемента EventLog.</xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=fullName>       Для передачи сведений пользовательского журнала событий, а не в журнале приложений, задайте <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>для `false` и записать инструкции в пределах методов обработки команд <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, или <xref:System.ServiceProcess.ServiceBase.OnStop%2A>можно записывать в журнал соответствующие</xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: public virtual System.Diagnostics.EventLog EventLog { get; }
    return:
      type: System.Diagnostics.EventLog
      description: "<xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> Экземпляра, источник которого регистрируется в журнале приложений."
  overload: System.ServiceProcess.ServiceBase.EventLog*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ExitCode
  id: ExitCode
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ExitCode
  nameWithType: ServiceBase.ExitCode
  fullName: System.ServiceProcess.ServiceBase.ExitCode
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Возвращает или задает код выхода для службы."
  remarks: "Задайте свойство ExitCode ненулевое значение, перед остановкой службы в случае ошибки диспетчера управления службами."
  syntax:
    content: public int ExitCode { get; set; }
    return:
      type: System.Int32
      description: "Код выхода для службы."
  overload: System.ServiceProcess.ServiceBase.ExitCode*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.MaxNameLength
  id: MaxNameLength
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: MaxNameLength
  nameWithType: ServiceBase.MaxNameLength
  fullName: System.ServiceProcess.ServiceBase.MaxNameLength
  type: Field
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Указывает максимальный размер имени службы."
  remarks: "ServiceName и DisplayName имеют ограничения на размер, должны учитываться при задании свойств для класса службы."
  syntax:
    content: public const int MaxNameLength = 80;
    return:
      type: System.Int32
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnContinue
  id: OnContinue
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnContinue()
  nameWithType: ServiceBase.OnContinue()
  fullName: System.ServiceProcess.ServiceBase.OnContinue()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "При реализации в производном классе OnContinue выполняется, когда команда продолжить отправляется в службу диспетчера управления службами (SCM). Указывает действия, выполняемые при возобновлении работы после ее приостановки службы."
  remarks: "Реализовать OnContinue отражения приложения в ответ на <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.</xref:System.ServiceProcess.ServiceBase.OnPause%2A> При продолжении работы службы (или через консоль служб или программным способом) OnContinue, обработка выполняется и служба снова становится активной.       OnContinue должен быть переопределен при <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>свойство `true`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>       Если <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>является `false`, не будут передаваться приостановить или продолжить запросы к службе, поэтому <xref:System.ServiceProcess.ServiceBase.OnPause%2A>и OnContinue методы не следует вызывать, даже если их реализации.</xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> В SCM `Pause` и `Continue` элементы будут отключены при <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>— `false`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>"
  syntax:
    content: protected virtual void OnContinue ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnContinue*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)
  id: OnCustomCommand(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnCustomCommand(Int32)
  nameWithType: ServiceBase.OnCustomCommand(Int32)
  fullName: System.ServiceProcess.ServiceBase.OnCustomCommand(Int32)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "При реализации в производном классе OnCustomCommand выполняется, когда диспетчер управления службами (SCM) передает службе пользовательскую команду. Указывает действия, выполняемые при возникновении команды с указанным значением параметра."
  remarks: "OnCustomCommand позволяет указать дополнительные функциональные возможности, запуск, остановка, приостановка и возобновление службы.       Диспетчер СЛУЖБ не проверяет пользовательскую команду, чтобы проверить, поддерживает ли служба `command` параметры, переданные в. Он передает пользовательскую команду непосредственно к службе. Если служба не распознает `command` параметра, он не выполняет никаких действий.       Пользовательские команды вызываются <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A>инструкции в <xref:System.ServiceProcess.ServiceController>компонента.</xref:System.ServiceProcess.ServiceController> </xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> Использовать инструкцию switch или, если... Выберите условия для обработки пользовательских команд, определенных в службе.       Только значения для пользовательской команды, которые можно определить в приложении или использовать в OnCustomCommand распространяются от 128 до 255. Целые числа меньше 128 соответствуют значениям резервируемых системой.       Если <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>свойство `true`, пользовательские команды, как и другие команды записи в журнал событий для отчетов, успешно ли выполнено выполнения метода.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: protected virtual void OnCustomCommand (int command);
    parameters:
    - id: command
      type: System.Int32
      description: "Сообщение команды, отправляемые службе."
  overload: System.ServiceProcess.ServiceBase.OnCustomCommand*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnPause
  id: OnPause
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnPause()
  nameWithType: ServiceBase.OnPause()
  fullName: System.ServiceProcess.ServiceBase.OnPause()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "При реализации в производном классе, он выполняется при передаче службе команды приостановки диспетчера управления службами (SCM). Задает действия, выполняемые при приостановке работы службы."
  remarks: "OnPause используется для указания действия, выполняемые при получении службой команды приостановки. OnPause должен быть переопределен при <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>свойство `true`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>       При продолжении приостановленной службы (или через консоль служб или программным способом) <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>обработки запускается, и служба снова становится активным.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Только команда Pause позволяет приложению реагировать на определенное событие. OnPause ничего не к службе, он делать не определен.       Отправка запроса на приостановку к службе сохранения ресурсов системы, так как паузы не требует освобождения всех системных ресурсов. Например если открытых потоков в процессе, приостановка службы, а не ее остановки, потоки остаются открытыми, поэтому не нужно перераспределять их, когда служба продолжает. Если вы определили приостановить, чтобы освободить все ресурсы системы, он ведет себя как команды остановки.       Задать <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>для `true`и переопределите OnPause и <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>задаются действия, которое должно происходить при передаче управления Службами запрос на приостановку или остановку службы.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>Чтобы отменить обработку в OnPause должны быть реализованы.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A>       Если <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>является `false`, не будут передаваться приостановить или продолжить запросов в службу, так что OnPause и <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>методы не вызываются, даже если реализована.</xref:System.ServiceProcess.ServiceBase.OnContinue%2A> </xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> В SCM `Pause` и `Continue` элементы будут отключены при <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>— `false`.</xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>"
  syntax:
    content: protected virtual void OnPause ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnPause*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  id: OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnPowerEvent(PowerBroadcastStatus)
  nameWithType: ServiceBase.OnPowerEvent(PowerBroadcastStatus)
  fullName: System.ServiceProcess.ServiceBase.OnPowerEvent(PowerBroadcastStatus)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "При реализации в производном классе, он выполняется при изменении состояния питания компьютера. Это применимо для переносных компьютеров, когда они переходят в режиме приостановки, который не является таким же, как завершение работы системы."
  remarks: "Позволяет указать действия, выполняемые при системного события, определенного в OnPowerEvent <xref:System.ServiceProcess.PowerBroadcastStatus>происходит перечисления — например, когда компьютер находится в режиме приостановки или разрядке батареи.</xref:System.ServiceProcess.PowerBroadcastStatus>       OnPowerEvent должен быть переопределен при <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>свойство `true`.</xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>"
  syntax:
    content: protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);
    parameters:
    - id: powerStatus
      type: System.ServiceProcess.PowerBroadcastStatus
      description: "Объект <xref href=&quot;System.ServiceProcess.PowerBroadcastStatus&quot;> </xref> указывает уведомления от системы о состоянии питания."
    return:
      type: System.Boolean
      description: "При реализации в производном классе требованиям приложения определить возвращаемое значение. Например если <xref uid=&quot;langword_csharp_QuerySuspend&quot; name=&quot;QuerySuspend&quot; href=&quot;&quot;> </xref> передается состояние вещания, можно заставить приложение отклонять запрос, возвращая <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.ServiceProcess.ServiceBase.OnPowerEvent*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  id: OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnSessionChange(SessionChangeDescription)
  nameWithType: ServiceBase.OnSessionChange(SessionChangeDescription)
  fullName: System.ServiceProcess.ServiceBase.OnSessionChange(SessionChangeDescription)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Выполняется при получении события изменения от сеанса сервера терминалов."
  remarks: "Необходимо задать <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A>Свойства `true` для выполнения этого метода.</xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A>"
  syntax:
    content: protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);
    parameters:
    - id: changeDescription
      type: System.ServiceProcess.SessionChangeDescription
      description: "Структура, определяющая тип изменения."
  overload: System.ServiceProcess.ServiceBase.OnSessionChange*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnShutdown
  id: OnShutdown
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnShutdown()
  nameWithType: ServiceBase.OnShutdown()
  fullName: System.ServiceProcess.ServiceBase.OnShutdown()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "При реализации в производном классе, выполняется, когда система завершает работу. Указывает, что должно произойти непосредственно перед завершением работы системы."
  remarks: "OnShutdown используется для указания действий, выполняемых при завершении работы системы.       Это событие происходит только в том случае, когда операционная система завершает работу, не в том случае, когда компьютер выключен.       OnShutdown должен быть переопределен при <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>свойство `true`.</xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>"
  syntax:
    content: protected virtual void OnShutdown ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnStart(System.String[])
  id: OnStart(System.String[])
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnStart(String[])
  nameWithType: ServiceBase.OnStart(String[])
  fullName: System.ServiceProcess.ServiceBase.OnStart(String[])
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "При реализации в производном классе, выполняет при отправке команды запуска служба диспетчера управления службами (SCM) или при запуске операционной системы (для служб, запускаемых автоматически). Указывает действия, выполняемые при запуске службы."
  remarks: "Use OnStart to specify the processing that occurs when the service receives a Start command. OnStart is the method in which you specify the behavior of the service. OnStart can take arguments as a way to pass data, but this usage is rare.  \n  \n> [!CAUTION]\n>  Do not use the constructor to perform processing that should be in OnStart. Use OnStart to handle all initialization of your service. The constructor is called when the application's executable runs, not when the service runs. The executable runs before OnStart. When you continue, for example, the constructor is not called again because the SCM already holds the object in memory. If <xref:System.ServiceProcess.ServiceBase.OnStop%2A> releases resources allocated in the constructor rather than in OnStart, the needed resources would not be created again the second time the service is called.  \n  \n Services can be set to start automatically when the computer reboots by setting the <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> on the service's installer to <xref:System.ServiceProcess.ServiceStartMode>. In such a situation, OnStart would be called at system startup.  \n  \n OnStart is expected to be overridden in the derived class. For the service to be useful, OnStart and <xref:System.ServiceProcess.ServiceBase.OnStop%2A> should both be implemented in your service class.  \n  \n Process initialization arguments for the service in the OnStart method, not in the Main method. The arguments in the `args` parameter array can be set manually in the properties window for the service in the Services console. The arguments entered in the console are not saved; they are passed to the service on a one-time basis when the service is started from the control panel. Arguments that must be present when the service is automatically started can be placed in the ImagePath string value for the service's registry key (HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\\\*\\<service name>*). You can obtain the arguments from the registry using the <xref:System.Environment.GetCommandLineArgs%2A> method, for example:  `string[] imagePathArgs = Environment.GetCommandLineArgs();`."
  syntax:
    content: protected virtual void OnStart (string[] args);
    parameters:
    - id: args
      type: System.String[]
      description: "Данные, передаваемые командой запуска."
  overload: System.ServiceProcess.ServiceBase.OnStart*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.OnStop
  id: OnStop
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: OnStop()
  nameWithType: ServiceBase.OnStop()
  fullName: System.ServiceProcess.ServiceBase.OnStop()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "При реализации в производном классе, он выполняется при передаче службе команды остановки диспетчера управления службами (SCM). Указывает действия, выполняемые при останове службы."
  remarks: "Позволяет указать действия, выполняемые при получении службой команды остановки OnStop.       Когда диспетчер управления Службами получает команды остановки, она использует значение <xref:System.ServiceProcess.ServiceBase.CanStop%2A>для проверки, является ли служба принимает команды Stop.</xref:System.ServiceProcess.ServiceBase.CanStop%2A> Если <xref:System.ServiceProcess.ServiceBase.CanStop%2A>является `true`, команда Stop передается службе и вызывается метод OnStop, если он определен.</xref:System.ServiceProcess.ServiceBase.CanStop%2A> Если в службе не реализован OnStop, SCM обрабатывает команду остановки.       Если <xref:System.ServiceProcess.ServiceBase.CanStop%2A>является `false`, SCM игнорирует команду Stop.</xref:System.ServiceProcess.ServiceBase.CanStop%2A> Не передается в службу. Возвращает команду остановки и выдает исключение.       OnStop должен переопределяться в производном классе. Для службы были полезны, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>и OnStop следует реализовать в классе вашей службы.</xref:System.ServiceProcess.ServiceBase.OnStart%2A>"
  syntax:
    content: protected virtual void OnStop ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.OnStop*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)
  id: RequestAdditionalTime(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: RequestAdditionalTime(Int32)
  nameWithType: ServiceBase.RequestAdditionalTime(Int32)
  fullName: System.ServiceProcess.ServiceBase.RequestAdditionalTime(Int32)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Запрашивает дополнительное время для отложенной операции."
  remarks: "Метод RequestAdditionalTime предназначен для вызова переопределенным <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, или <xref:System.ServiceProcess.ServiceBase.OnStop%2A>методов, чтобы запросить дополнительное время для отложенной операции, чтобы предотвратить диспетчера управления службами (SCM) пометить службу как не отвечает.</xref:System.ServiceProcess.ServiceBase.OnStop%2A> </xref:System.ServiceProcess.ServiceBase.OnStart%2A> </xref:System.ServiceProcess.ServiceBase.OnPause%2A> </xref:System.ServiceProcess.ServiceBase.OnContinue%2A>  Если отложенная операция не продолжить, приостановка, запуск или остановка и <xref:System.InvalidOperationException>возникает исключение.</xref:System.InvalidOperationException>"
  syntax:
    content: public void RequestAdditionalTime (int milliseconds);
    parameters:
    - id: milliseconds
      type: System.Int32
      description: "Запрошенное время в миллисекундах."
  overload: System.ServiceProcess.ServiceBase.RequestAdditionalTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Служба не находится в состоянии ожидания."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)
  id: Run(System.ServiceProcess.ServiceBase)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Run(ServiceBase)
  nameWithType: ServiceBase.Run(ServiceBase)
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Регистрирует исполняемый файл для службы с помощью диспетчера управления службами (SCM)."
  remarks: "Эта перегрузка вызывается в `main()` функции службы для регистрации службы с помощью диспетчера управления службами. После выполнения вызова, диспетчер управления службами выдает команды запуска, что приводит к вызову <xref:System.ServiceProcess.ServiceBase.OnStart%2A>метод в службе.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> Служба не запущена, пока не будет выполнена команда запуска.       Метод Run называется так же, как <xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>для приложений Windows Forms.</xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>       Если <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>является `true`, записи в журнал событий по указанной службы `service` параметра не запускается.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: public static void Run (System.ServiceProcess.ServiceBase service);
    parameters:
    - id: service
      type: System.ServiceProcess.ServiceBase
      description: "Объект <xref href=&quot;System.ServiceProcess.ServiceBase&quot;> </xref> определяющий службу для запуска."
  overload: System.ServiceProcess.ServiceBase.Run*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>service</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])
  id: Run(System.ServiceProcess.ServiceBase[])
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Run(ServiceBase[])
  nameWithType: ServiceBase.Run(ServiceBase[])
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase[])
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Регистрирует исполняемый файл для нескольких служб с помощью диспетчера управления службами (SCM)."
  remarks: "Эта перегрузка вызывается в `main()` функции службы для регистрации служб с помощью диспетчера управления службами. После выполнения вызова, диспетчер управления службами выдает команды Start, которые приводят в вызовах <xref:System.ServiceProcess.ServiceBase.OnStart%2A>методы в службах.</xref:System.ServiceProcess.ServiceBase.OnStart%2A> Службы не запущены, пока не будут выполнены команды запуска.       Метод Run называется так же, как <xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>метод для приложений Windows Forms.</xref:System.Windows.Forms.Application.Run%2A?displayProperty=fullName>       Если <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>является `true`, запись записывается в журнал событий, если происходит сбой запуска любой службы в массиве.</xref:System.ServiceProcess.ServiceBase.AutoLog%2A>"
  syntax:
    content: public static void Run (System.ServiceProcess.ServiceBase[] services);
    parameters:
    - id: services
      type: System.ServiceProcess.ServiceBase[]
      description: "Массив экземпляров ServiceBase, определяющих службы для запуска."
  overload: System.ServiceProcess.ServiceBase.Run*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Запуск службы не предоставлен. Массив может быть <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> или пустым."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ServiceHandle
  id: ServiceHandle
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceHandle
  nameWithType: ServiceBase.ServiceHandle
  fullName: System.ServiceProcess.ServiceBase.ServiceHandle
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Возвращает дескриптор управления службой для службы."
  remarks: "Дескриптор управления службой используется для взаимодействия с диспетчером управления службами (SCM).  Дескриптор может использоваться для обновления сведений о состоянии диспетчера управления службами для вызова службы, с помощью неуправляемых `SetServiceStatus` функции."
  syntax:
    content: protected IntPtr ServiceHandle { get; }
    return:
      type: System.IntPtr
      description: "<xref:System.IntPtr>Структура, содержащая дескриптор управления службой для службы.</xref:System.IntPtr>"
  overload: System.ServiceProcess.ServiceBase.ServiceHandle*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)
  id: ServiceMainCallback(System.Int32,System.IntPtr)
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceMainCallback(Int32,IntPtr)
  nameWithType: ServiceBase.ServiceMainCallback(Int32,IntPtr)
  fullName: System.ServiceProcess.ServiceBase.ServiceMainCallback(Int32,IntPtr)
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Регистрирует обработчик команд и запускает службу."
  syntax:
    content: public void ServiceMainCallback (int argCount, IntPtr argPointer);
    parameters:
    - id: argCount
      type: System.Int32
      description: "Число аргументов в массиве аргументов."
    - id: argPointer
      type: System.IntPtr
      description: "<xref:System.IntPtr>Структура, которая указывает на массив аргументов.</xref:System.IntPtr>"
  overload: System.ServiceProcess.ServiceBase.ServiceMainCallback*
  exceptions: []
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.ServiceName
  id: ServiceName
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: ServiceName
  nameWithType: ServiceBase.ServiceName
  fullName: System.ServiceProcess.ServiceBase.ServiceName
  type: Property
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Возвращает или задает короткое имя, используемое для идентификации службы в системе."
  remarks: "ServiceName идентифицирует службу к диспетчеру управления службами. Значение этого свойства должно быть идентично имени службы в <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=fullName>свойства соответствующего класса установщика.</xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=fullName> В коде, ServiceName службы обычно задается в `main()` функция исполняемого файла.       ServiceName также используется для указания <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName>связанных с <xref:System.ServiceProcess.ServiceBase.EventLog%2A>свойство.</xref:System.ServiceProcess.ServiceBase.EventLog%2A> </xref:System.Diagnostics.EventLog.Source%2A?displayProperty=fullName> Этот <xref:System.ServiceProcess.ServiceBase.EventLog%2A>экземпляр, который записывает сведения о командах службы в журнал приложения.</xref:System.ServiceProcess.ServiceBase.EventLog%2A>       ServiceName, который является строкой источника для журнала событий, необходимо задать перед началом записи в журнал событий. Попытка доступа к журналу событий имя источника задано приводит к созданию исключения."
  syntax:
    content: public string ServiceName { get; set; }
    return:
      type: System.String
      description: "Имя службы."
  overload: System.ServiceProcess.ServiceBase.ServiceName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Служба уже запущена. Свойство ServiceName не может изменяться после запуска службы."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Указанное имя представляет собой строку нулевой длины или длиннее, чем <xref href=&quot;System.ServiceProcess.ServiceBase.MaxNameLength&quot;> </xref>, или указанное имя содержит символы, косой чертой или обратной косой черты."
  platform:
  - net462
- uid: System.ServiceProcess.ServiceBase.Stop
  id: Stop
  parent: System.ServiceProcess.ServiceBase
  langs:
  - csharp
  name: Stop()
  nameWithType: ServiceBase.Stop()
  fullName: System.ServiceProcess.ServiceBase.Stop()
  type: Method
  assemblies:
  - System.ServiceProcess
  namespace: System.ServiceProcess
  summary: "Останавливает работающую службу."
  remarks: "Метод Stop задает состояние службы, чтобы указать остановки находится в состоянии ожидания и вызовы <xref:System.ServiceProcess.ServiceBase.OnStop%2A>метод.</xref:System.ServiceProcess.ServiceBase.OnStop%2A>  После остановки приложения служба переходит в состояние до остановки. Если приложение является размещенной службы, будет выгружен домен приложения."
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.ServiceProcess.ServiceBase.Stop*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ServiceProcess.ServiceBase.#ctor
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceBase()
  nameWithType: ServiceBase.ServiceBase()
  fullName: System.ServiceProcess.ServiceBase.ServiceBase()
- uid: System.ServiceProcess.ServiceBase.AutoLog
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: AutoLog
  nameWithType: ServiceBase.AutoLog
  fullName: System.ServiceProcess.ServiceBase.AutoLog
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandlePowerEvent
  nameWithType: ServiceBase.CanHandlePowerEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandlePowerEvent
- uid: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandleSessionChangeEvent
  nameWithType: ServiceBase.CanHandleSessionChangeEvent
  fullName: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent
- uid: System.ServiceProcess.ServiceBase.CanPauseAndContinue
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanPauseAndContinue
  nameWithType: ServiceBase.CanPauseAndContinue
  fullName: System.ServiceProcess.ServiceBase.CanPauseAndContinue
- uid: System.ServiceProcess.ServiceBase.CanShutdown
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanShutdown
  nameWithType: ServiceBase.CanShutdown
  fullName: System.ServiceProcess.ServiceBase.CanShutdown
- uid: System.ServiceProcess.ServiceBase.CanStop
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanStop
  nameWithType: ServiceBase.CanStop
  fullName: System.ServiceProcess.ServiceBase.CanStop
- uid: System.ServiceProcess.ServiceBase.Dispose(System.Boolean)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: ServiceBase.Dispose(Boolean)
  fullName: System.ServiceProcess.ServiceBase.Dispose(Boolean)
- uid: System.ServiceProcess.ServiceBase.EventLog
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: EventLog
  nameWithType: ServiceBase.EventLog
  fullName: System.ServiceProcess.ServiceBase.EventLog
- uid: System.Diagnostics.EventLog
  parent: System.Diagnostics
  isExternal: false
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog
- uid: System.ServiceProcess.ServiceBase.ExitCode
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ExitCode
  nameWithType: ServiceBase.ExitCode
  fullName: System.ServiceProcess.ServiceBase.ExitCode
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.ServiceProcess.ServiceBase.MaxNameLength
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: MaxNameLength
  nameWithType: ServiceBase.MaxNameLength
  fullName: System.ServiceProcess.ServiceBase.MaxNameLength
- uid: System.ServiceProcess.ServiceBase.OnContinue
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnContinue()
  nameWithType: ServiceBase.OnContinue()
  fullName: System.ServiceProcess.ServiceBase.OnContinue()
- uid: System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnCustomCommand(Int32)
  nameWithType: ServiceBase.OnCustomCommand(Int32)
  fullName: System.ServiceProcess.ServiceBase.OnCustomCommand(Int32)
- uid: System.ServiceProcess.ServiceBase.OnPause
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPause()
  nameWithType: ServiceBase.OnPause()
  fullName: System.ServiceProcess.ServiceBase.OnPause()
- uid: System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPowerEvent(PowerBroadcastStatus)
  nameWithType: ServiceBase.OnPowerEvent(PowerBroadcastStatus)
  fullName: System.ServiceProcess.ServiceBase.OnPowerEvent(PowerBroadcastStatus)
- uid: System.ServiceProcess.PowerBroadcastStatus
  parent: System.ServiceProcess
  isExternal: false
  name: PowerBroadcastStatus
  nameWithType: PowerBroadcastStatus
  fullName: System.ServiceProcess.PowerBroadcastStatus
- uid: System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnSessionChange(SessionChangeDescription)
  nameWithType: ServiceBase.OnSessionChange(SessionChangeDescription)
  fullName: System.ServiceProcess.ServiceBase.OnSessionChange(SessionChangeDescription)
- uid: System.ServiceProcess.SessionChangeDescription
  parent: System.ServiceProcess
  isExternal: false
  name: SessionChangeDescription
  nameWithType: SessionChangeDescription
  fullName: System.ServiceProcess.SessionChangeDescription
- uid: System.ServiceProcess.ServiceBase.OnShutdown
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnShutdown()
  nameWithType: ServiceBase.OnShutdown()
  fullName: System.ServiceProcess.ServiceBase.OnShutdown()
- uid: System.ServiceProcess.ServiceBase.OnStart(System.String[])
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStart(String[])
  nameWithType: ServiceBase.OnStart(String[])
  fullName: System.ServiceProcess.ServiceBase.OnStart(String[])
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.ServiceProcess.ServiceBase.OnStop
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStop()
  nameWithType: ServiceBase.OnStop()
  fullName: System.ServiceProcess.ServiceBase.OnStop()
- uid: System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: RequestAdditionalTime(Int32)
  nameWithType: ServiceBase.RequestAdditionalTime(Int32)
  fullName: System.ServiceProcess.ServiceBase.RequestAdditionalTime(Int32)
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Run(ServiceBase)
  nameWithType: ServiceBase.Run(ServiceBase)
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase)
- uid: System.ServiceProcess.ServiceBase
  parent: System.ServiceProcess
  isExternal: false
  name: ServiceBase
  nameWithType: ServiceBase
  fullName: System.ServiceProcess.ServiceBase
- uid: System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Run(ServiceBase[])
  nameWithType: ServiceBase.Run(ServiceBase[])
  fullName: System.ServiceProcess.ServiceBase.Run(ServiceBase[])
- uid: System.ServiceProcess.ServiceBase[]
  parent: System.ServiceProcess
  isExternal: false
  name: ServiceBase
  nameWithType: ServiceBase
  fullName: System.ServiceProcess.ServiceBase[]
  spec.csharp:
  - uid: System.ServiceProcess.ServiceBase
    name: ServiceBase
    nameWithType: ServiceBase
    fullName: ServiceBase[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.ServiceProcess.ServiceBase.ServiceHandle
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceHandle
  nameWithType: ServiceBase.ServiceHandle
  fullName: System.ServiceProcess.ServiceBase.ServiceHandle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceMainCallback(Int32,IntPtr)
  nameWithType: ServiceBase.ServiceMainCallback(Int32,IntPtr)
  fullName: System.ServiceProcess.ServiceBase.ServiceMainCallback(Int32,IntPtr)
- uid: System.ServiceProcess.ServiceBase.ServiceName
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceName
  nameWithType: ServiceBase.ServiceName
  fullName: System.ServiceProcess.ServiceBase.ServiceName
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.ServiceProcess.ServiceBase.Stop
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Stop()
  nameWithType: ServiceBase.Stop()
  fullName: System.ServiceProcess.ServiceBase.Stop()
- uid: System.ServiceProcess.ServiceBase.#ctor*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceBase
  nameWithType: ServiceBase.ServiceBase
- uid: System.ServiceProcess.ServiceBase.AutoLog*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: AutoLog
  nameWithType: ServiceBase.AutoLog
- uid: System.ServiceProcess.ServiceBase.CanHandlePowerEvent*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandlePowerEvent
  nameWithType: ServiceBase.CanHandlePowerEvent
- uid: System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanHandleSessionChangeEvent
  nameWithType: ServiceBase.CanHandleSessionChangeEvent
- uid: System.ServiceProcess.ServiceBase.CanPauseAndContinue*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanPauseAndContinue
  nameWithType: ServiceBase.CanPauseAndContinue
- uid: System.ServiceProcess.ServiceBase.CanShutdown*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanShutdown
  nameWithType: ServiceBase.CanShutdown
- uid: System.ServiceProcess.ServiceBase.CanStop*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: CanStop
  nameWithType: ServiceBase.CanStop
- uid: System.ServiceProcess.ServiceBase.Dispose*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Dispose
  nameWithType: ServiceBase.Dispose
- uid: System.ServiceProcess.ServiceBase.EventLog*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: EventLog
  nameWithType: ServiceBase.EventLog
- uid: System.ServiceProcess.ServiceBase.ExitCode*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ExitCode
  nameWithType: ServiceBase.ExitCode
- uid: System.ServiceProcess.ServiceBase.OnContinue*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnContinue
  nameWithType: ServiceBase.OnContinue
- uid: System.ServiceProcess.ServiceBase.OnCustomCommand*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnCustomCommand
  nameWithType: ServiceBase.OnCustomCommand
- uid: System.ServiceProcess.ServiceBase.OnPause*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPause
  nameWithType: ServiceBase.OnPause
- uid: System.ServiceProcess.ServiceBase.OnPowerEvent*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnPowerEvent
  nameWithType: ServiceBase.OnPowerEvent
- uid: System.ServiceProcess.ServiceBase.OnSessionChange*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnSessionChange
  nameWithType: ServiceBase.OnSessionChange
- uid: System.ServiceProcess.ServiceBase.OnShutdown*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnShutdown
  nameWithType: ServiceBase.OnShutdown
- uid: System.ServiceProcess.ServiceBase.OnStart*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStart
  nameWithType: ServiceBase.OnStart
- uid: System.ServiceProcess.ServiceBase.OnStop*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: OnStop
  nameWithType: ServiceBase.OnStop
- uid: System.ServiceProcess.ServiceBase.RequestAdditionalTime*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: RequestAdditionalTime
  nameWithType: ServiceBase.RequestAdditionalTime
- uid: System.ServiceProcess.ServiceBase.Run*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Run
  nameWithType: ServiceBase.Run
- uid: System.ServiceProcess.ServiceBase.ServiceHandle*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceHandle
  nameWithType: ServiceBase.ServiceHandle
- uid: System.ServiceProcess.ServiceBase.ServiceMainCallback*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceMainCallback
  nameWithType: ServiceBase.ServiceMainCallback
- uid: System.ServiceProcess.ServiceBase.ServiceName*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: ServiceName
  nameWithType: ServiceBase.ServiceName
- uid: System.ServiceProcess.ServiceBase.Stop*
  parent: System.ServiceProcess.ServiceBase
  isExternal: false
  name: Stop
  nameWithType: ServiceBase.Stop
