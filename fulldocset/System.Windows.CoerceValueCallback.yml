### YamlMime:ManagedReference
items:
- uid: System.Windows.CoerceValueCallback
  id: CoerceValueCallback
  langs:
  - csharp
  name: CoerceValueCallback
  nameWithType: CoerceValueCallback
  fullName: System.Windows.CoerceValueCallback
  type: Delegate
  summary: "Предоставляет шаблон для метода, вызываемого при оценке значения свойства зависимостей или приведение конкретное требование."
  remarks: "Обратные вызовы, в зависимости от CoerceValueCallback можно назначить свойству зависимостей через несколькими способами. Каждый из этих способов необходимо сначала создать объект метаданных свойств (<xref:System.Windows.PropertyMetadata>, или производного класса, такие как <xref:System.Windows.FrameworkPropertyMetadata>).</xref:System.Windows.FrameworkPropertyMetadata> </xref:System.Windows.PropertyMetadata> Создать объект метаданных, с помощью подписи конструктор, принимающий `coerceValueCallback` параметра и присвоить этому параметру обработчика ответа. Или создать метаданные любого подписями и набор <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>свойство до помещения метаданных используется.</xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>       Если у вас есть эти метаданные, можно:-определить новые свойства зависимостей для нового класса с помощью либо подпись <xref:System.Windows.DependencyProperty.Register%2A>, предоставляя метаданные как `typeMetadata` значение.</xref:System.Windows.DependencyProperty.Register%2A>      -Переопределить метаданные (вызов <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>) для существующего свойства зависимости, при наследовании от класса, которому принадлежит свойство зависимостей.</xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>      -Добавьте существующего свойства зависимостей для нового <xref:System.Windows.DependencyObject>класса, используя новые метаданные, вызвав <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>.</xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> </xref:System.Windows.DependencyObject>       Реализации данного ответа следует проверить значение `baseValue` и определить на основе значения или тип ли это значение, которое необходимо дополнительно привести.       <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>Зависимость свойство вызывается каждый раз, когда в системе свойств или любой вызывающий объект вызывает <xref:System.Windows.DependencyObject.CoerceValue%2A>на <xref:System.Windows.DependencyObject>экземпляра с указанием идентификатора этого свойства как `dp`.</xref:System.Windows.DependencyObject> </xref:System.Windows.DependencyObject.CoerceValue%2A> </xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>       Изменения значения свойства может поступать любого из членов в системе свойств. Это включает стили, изначальную, триггеры, наследование значения свойства и локальное значение параметра.       Обычно следует избегать, указание более одного <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>для любого заданного свойства зависимостей (переопределения или добавления с новыми метаданными для свойства зависимостей, уже <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>).</xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> </xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> Только одна из обратных вызовов будет действовать. Действующим ответом будет тем, которое было применено к наиболее производного класса в наследовании по сравнению с <xref:System.Windows.DependencyObject>вызывающего объекта.</xref:System.Windows.DependencyObject> При переопределении метаданных, заменяются других обратных вызовах, связанные с метаданными для свойства зависимостей, существовавшего выше в иерархии владельцев."
  example:
  - "The following example includes an implementation of this callback to coerce the stored value of a dependency property based on other inputs, such as another property's value. In this case, the callback checks to see whether the `ShirtType` property corresponds to a type of shirt that has buttons; if so it establishes a starting default color for the `ButtonColor`, if the shirt type has no buttons, it coerces the `ButtonColor` value back to a starting value, which causes the [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] (not shown) to remove that dropdown from the effective choices.  \n  \n [!code-cs[DPCustom#CoerceValueCallback](~/add/codesnippet/csharp/DPCustom/default.xaml.cs#coercevaluecallback)]\n [!code-vb[DPCustom#CoerceValueCallback](~/add/codesnippet/visualbasic/dpcustom/default.xaml.vb#coercevaluecallback)]"
  syntax:
    content: public delegate object CoerceValueCallback(DependencyObject d, object baseValue);
  inheritance:
  - System.Delegate
  platform:
  - net462
references:
- uid: System.Delegate
  isExternal: false
  name: System.Delegate
