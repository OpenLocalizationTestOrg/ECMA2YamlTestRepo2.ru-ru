### YamlMime:ManagedReference
items:
- uid: System.Security.Policy.TrustManagerContext
  id: TrustManagerContext
  children:
  - System.Security.Policy.TrustManagerContext.#ctor
  - System.Security.Policy.TrustManagerContext.#ctor(System.Security.Policy.TrustManagerUIContext)
  - System.Security.Policy.TrustManagerContext.IgnorePersistedDecision
  - System.Security.Policy.TrustManagerContext.KeepAlive
  - System.Security.Policy.TrustManagerContext.NoPrompt
  - System.Security.Policy.TrustManagerContext.Persist
  - System.Security.Policy.TrustManagerContext.PreviousApplicationIdentity
  - System.Security.Policy.TrustManagerContext.UIContext
  langs:
  - csharp
  name: TrustManagerContext
  nameWithType: TrustManagerContext
  fullName: System.Security.Policy.TrustManagerContext
  type: Class
  summary: "Представляет контекст для диспетчер доверия, которые следует учитывать при принятии решения для запуска приложения и при установке параметров безопасности на новом <xref href=&quot;System.AppDomain&quot;> </xref> для запуска приложения."
  remarks: "Список начальных значений свойств для экземпляра класса TrustManagerContext см. в разделе <xref:System.Security.Policy.TrustManagerContext.%23ctor>конструктор.</xref:System.Security.Policy.TrustManagerContext.%23ctor>"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class TrustManagerContext
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Security.Policy.TrustManagerContext.#ctor
  id: '#ctor'
  parent: System.Security.Policy.TrustManagerContext
  langs:
  - csharp
  name: TrustManagerContext()
  nameWithType: TrustManagerContext.TrustManagerContext()
  fullName: System.Security.Policy.TrustManagerContext.TrustManagerContext()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Policy
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Security.Policy.TrustManagerContext&quot;> </xref> класса."
  remarks: "В следующей таблице показаны исходные значения свойств для нового экземпляра <xref:System.Security.Policy.TrustManagerContext>класса.</xref:System.Security.Policy.TrustManagerContext>      | Свойство | Начальное значение |   |--------------|-------------------|   | <xref:System.Security.Policy.TrustManagerContext.IgnorePersistedDecision%2A>| `false`|   | <xref:System.Security.Policy.TrustManagerContext.KeepAlive%2A>| `false`|   | <xref:System.Security.Policy.TrustManagerContext.NoPrompt%2A>| `false`|   | <xref:System.Security.Policy.TrustManagerContext.Persist%2A>| `true`|   | <xref:System.Security.Policy.TrustManagerContext.PreviousApplicationIdentity%2A>| `null`|   | <xref:System.Security.Policy.TrustManagerContext.UIContext%2A>| <xref:System.Security.Policy.TrustManagerUIContext>|</xref:System.Security.Policy.TrustManagerUIContext></xref:System.Security.Policy.TrustManagerContext.UIContext%2A></xref:System.Security.Policy.TrustManagerContext.PreviousApplicationIdentity%2A></xref:System.Security.Policy.TrustManagerContext.Persist%2A></xref:System.Security.Policy.TrustManagerContext.NoPrompt%2A></xref:System.Security.Policy.TrustManagerContext.KeepAlive%2A></xref:System.Security.Policy.TrustManagerContext.IgnorePersistedDecision%2A>"
  syntax:
    content: public TrustManagerContext ();
    parameters: []
  overload: System.Security.Policy.TrustManagerContext.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Policy.TrustManagerContext.#ctor(System.Security.Policy.TrustManagerUIContext)
  id: '#ctor(System.Security.Policy.TrustManagerUIContext)'
  parent: System.Security.Policy.TrustManagerContext
  langs:
  - csharp
  name: TrustManagerContext(TrustManagerUIContext)
  nameWithType: TrustManagerContext.TrustManagerContext(TrustManagerUIContext)
  fullName: System.Security.Policy.TrustManagerContext.TrustManagerContext(TrustManagerUIContext)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Policy
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Security.Policy.TrustManagerContext&quot;> </xref> класса с помощью указанного <xref href=&quot;System.Security.Policy.TrustManagerUIContext&quot;> </xref> объекта."
  remarks: "Этот конструктор инициализирует свойства с теми же параметрами, как конструктор по умолчанию, за исключением <xref:System.Security.Policy.TrustManagerContext.UIContext%2A>свойств, который установлен на значение переданного in.</xref:System.Security.Policy.TrustManagerContext.UIContext%2A>"
  syntax:
    content: public TrustManagerContext (System.Security.Policy.TrustManagerUIContext uiContext);
    parameters:
    - id: uiContext
      type: System.Security.Policy.TrustManagerUIContext
      description: "Один из <xref href=&quot;System.Security.Policy.TrustManagerUIContext&quot;> </xref> значения, которое указывает тип доверия диспетчера пользовательского интерфейса для использования."
  overload: System.Security.Policy.TrustManagerContext.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Policy.TrustManagerContext.IgnorePersistedDecision
  id: IgnorePersistedDecision
  parent: System.Security.Policy.TrustManagerContext
  langs:
  - csharp
  name: IgnorePersistedDecision
  nameWithType: TrustManagerContext.IgnorePersistedDecision
  fullName: System.Security.Policy.TrustManagerContext.IgnorePersistedDecision
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Policy
  summary: "Возвращает или задает значение, указывающее, должен ли диспетчер безопасности приложения игнорировать любые сохраненные решения и вызвать диспетчер доверия."
  remarks: "Если `true`, <xref:System.Security.Policy.ApplicationSecurityManager>игнорирует сохраненные решения для приложения и вызывает диспетчер доверительное отношение.</xref:System.Security.Policy.ApplicationSecurityManager> Если `false`, <xref:System.Security.Policy.ApplicationSecurityManager>использует кэшированием принятия решений, если он доступен.</xref:System.Security.Policy.ApplicationSecurityManager>"
  syntax:
    content: public virtual bool IgnorePersistedDecision { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>для вызова доверия manager; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.Policy.TrustManagerContext.IgnorePersistedDecision*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Policy.TrustManagerContext.KeepAlive
  id: KeepAlive
  parent: System.Security.Policy.TrustManagerContext
  langs:
  - csharp
  name: KeepAlive
  nameWithType: TrustManagerContext.KeepAlive
  fullName: System.Security.Policy.TrustManagerContext.KeepAlive
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Policy
  summary: "Возвращает или задает значение, указывающее, является ли диспетчер доверия сохранить в кэше состояние для этого приложения, чтобы упростить будущие запросы, чтобы определить отношение доверия приложения."
  remarks: "Этот флаг установлен в `true` Если узел может вызвать диспетчер доверия несколько раз для решений о доверии для этого приложения. Если `true`, диспетчер доверия следует кэшировать любое состояние, которое может повысить скорость будущие вызовы <xref:System.Security.Policy.IApplicationTrustManager.DetermineApplicationTrust%2A>метод.</xref:System.Security.Policy.IApplicationTrustManager.DetermineApplicationTrust%2A> Это свойство имеет значение `false` Если узел не ожидает вызвать диспетчер доверия снова для текущего <xref:System.AppDomain>.</xref:System.AppDomain>"
  syntax:
    content: public virtual bool KeepAlive { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>для кэширования данных состояния; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.Policy.TrustManagerContext.KeepAlive*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Policy.TrustManagerContext.NoPrompt
  id: NoPrompt
  parent: System.Security.Policy.TrustManagerContext
  langs:
  - csharp
  name: NoPrompt
  nameWithType: TrustManagerContext.NoPrompt
  fullName: System.Security.Policy.TrustManagerContext.NoPrompt
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Policy
  summary: "Возвращает или задает значение, указывающее, должен ли диспетчер доверия запрашивать у пользователя принятие решений о доверии."
  remarks: "Если `false`, диспетчер доверия определяет соответствующий пользовательский диалог, чтобы получить решение о доверии."
  syntax:
    content: public virtual bool NoPrompt { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Чтобы не запрашивать пользователя; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для запроса у пользователя. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.Policy.TrustManagerContext.NoPrompt*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Policy.TrustManagerContext.Persist
  id: Persist
  parent: System.Security.Policy.TrustManagerContext
  langs:
  - csharp
  name: Persist
  nameWithType: TrustManagerContext.Persist
  fullName: System.Security.Policy.TrustManagerContext.Persist
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Policy
  summary: "Возвращает или задает значение, указывающее, следует ли сохранять ответ пользователя в диалоговом окне согласия."
  remarks: "Это свойство является `true` Если ответ пользователя в диалоговом окне согласия необходимо сохранить, чтобы избежать дополнительной запрашивая разрешения пользователя при каждом новом запросе активации. Это свойство является `false` , если не следует сохранять ответ пользователя."
  syntax:
    content: public virtual bool Persist { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>для кэширования данных состояния; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Security.Policy.TrustManagerContext.Persist*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Policy.TrustManagerContext.PreviousApplicationIdentity
  id: PreviousApplicationIdentity
  parent: System.Security.Policy.TrustManagerContext
  langs:
  - csharp
  name: PreviousApplicationIdentity
  nameWithType: TrustManagerContext.PreviousApplicationIdentity
  fullName: System.Security.Policy.TrustManagerContext.PreviousApplicationIdentity
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Policy
  summary: "Возвращает или задает идентификатор предыдущей идентификации приложения."
  syntax:
    content: public virtual ApplicationIdentity PreviousApplicationIdentity { get; set; }
    return:
      type: System.ApplicationIdentity
      description: "<xref href=&quot;System.ApplicationIdentity&quot;> </xref> Объект, представляющий предыдущий <xref href=&quot;System.ApplicationIdentity&quot;> </xref>."
  overload: System.Security.Policy.TrustManagerContext.PreviousApplicationIdentity*
  exceptions: []
  platform:
  - net462
- uid: System.Security.Policy.TrustManagerContext.UIContext
  id: UIContext
  parent: System.Security.Policy.TrustManagerContext
  langs:
  - csharp
  name: UIContext
  nameWithType: TrustManagerContext.UIContext
  fullName: System.Security.Policy.TrustManagerContext.UIContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.Policy
  summary: "Возвращает или задает тип пользовательского интерфейса, который должен отображать диспетчер доверия."
  remarks: "UIContext, свойство предназначен рекомендовать пользовательского интерфейса, диспетчер доверия должен предоставлять решение о доверии. Диспетчер доверия вправе использовать другой интерфейс."
  syntax:
    content: public virtual System.Security.Policy.TrustManagerUIContext UIContext { get; set; }
    return:
      type: System.Security.Policy.TrustManagerUIContext
      description: "Один из <xref href=&quot;System.Security.Policy.TrustManagerUIContext&quot;> </xref> значения. Значение по умолчанию — <xref href=&quot;System.Security.Policy.TrustManagerUIContext&quot;> </xref>."
  overload: System.Security.Policy.TrustManagerContext.UIContext*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.Policy.TrustManagerContext.#ctor
  parent: System.Security.Policy.TrustManagerContext
  isExternal: false
  name: TrustManagerContext()
  nameWithType: TrustManagerContext.TrustManagerContext()
  fullName: System.Security.Policy.TrustManagerContext.TrustManagerContext()
- uid: System.Security.Policy.TrustManagerContext.#ctor(System.Security.Policy.TrustManagerUIContext)
  parent: System.Security.Policy.TrustManagerContext
  isExternal: false
  name: TrustManagerContext(TrustManagerUIContext)
  nameWithType: TrustManagerContext.TrustManagerContext(TrustManagerUIContext)
  fullName: System.Security.Policy.TrustManagerContext.TrustManagerContext(TrustManagerUIContext)
- uid: System.Security.Policy.TrustManagerUIContext
  parent: System.Security.Policy
  isExternal: false
  name: TrustManagerUIContext
  nameWithType: TrustManagerUIContext
  fullName: System.Security.Policy.TrustManagerUIContext
- uid: System.Security.Policy.TrustManagerContext.IgnorePersistedDecision
  parent: System.Security.Policy.TrustManagerContext
  isExternal: false
  name: IgnorePersistedDecision
  nameWithType: TrustManagerContext.IgnorePersistedDecision
  fullName: System.Security.Policy.TrustManagerContext.IgnorePersistedDecision
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.Policy.TrustManagerContext.KeepAlive
  parent: System.Security.Policy.TrustManagerContext
  isExternal: false
  name: KeepAlive
  nameWithType: TrustManagerContext.KeepAlive
  fullName: System.Security.Policy.TrustManagerContext.KeepAlive
- uid: System.Security.Policy.TrustManagerContext.NoPrompt
  parent: System.Security.Policy.TrustManagerContext
  isExternal: false
  name: NoPrompt
  nameWithType: TrustManagerContext.NoPrompt
  fullName: System.Security.Policy.TrustManagerContext.NoPrompt
- uid: System.Security.Policy.TrustManagerContext.Persist
  parent: System.Security.Policy.TrustManagerContext
  isExternal: false
  name: Persist
  nameWithType: TrustManagerContext.Persist
  fullName: System.Security.Policy.TrustManagerContext.Persist
- uid: System.Security.Policy.TrustManagerContext.PreviousApplicationIdentity
  parent: System.Security.Policy.TrustManagerContext
  isExternal: false
  name: PreviousApplicationIdentity
  nameWithType: TrustManagerContext.PreviousApplicationIdentity
  fullName: System.Security.Policy.TrustManagerContext.PreviousApplicationIdentity
- uid: System.ApplicationIdentity
  parent: System
  isExternal: false
  name: ApplicationIdentity
  nameWithType: ApplicationIdentity
  fullName: System.ApplicationIdentity
- uid: System.Security.Policy.TrustManagerContext.UIContext
  parent: System.Security.Policy.TrustManagerContext
  isExternal: false
  name: UIContext
  nameWithType: TrustManagerContext.UIContext
  fullName: System.Security.Policy.TrustManagerContext.UIContext
- uid: System.Security.Policy.TrustManagerContext.#ctor*
  parent: System.Security.Policy.TrustManagerContext
  isExternal: false
  name: TrustManagerContext
  nameWithType: TrustManagerContext.TrustManagerContext
- uid: System.Security.Policy.TrustManagerContext.IgnorePersistedDecision*
  parent: System.Security.Policy.TrustManagerContext
  isExternal: false
  name: IgnorePersistedDecision
  nameWithType: TrustManagerContext.IgnorePersistedDecision
- uid: System.Security.Policy.TrustManagerContext.KeepAlive*
  parent: System.Security.Policy.TrustManagerContext
  isExternal: false
  name: KeepAlive
  nameWithType: TrustManagerContext.KeepAlive
- uid: System.Security.Policy.TrustManagerContext.NoPrompt*
  parent: System.Security.Policy.TrustManagerContext
  isExternal: false
  name: NoPrompt
  nameWithType: TrustManagerContext.NoPrompt
- uid: System.Security.Policy.TrustManagerContext.Persist*
  parent: System.Security.Policy.TrustManagerContext
  isExternal: false
  name: Persist
  nameWithType: TrustManagerContext.Persist
- uid: System.Security.Policy.TrustManagerContext.PreviousApplicationIdentity*
  parent: System.Security.Policy.TrustManagerContext
  isExternal: false
  name: PreviousApplicationIdentity
  nameWithType: TrustManagerContext.PreviousApplicationIdentity
- uid: System.Security.Policy.TrustManagerContext.UIContext*
  parent: System.Security.Policy.TrustManagerContext
  isExternal: false
  name: UIContext
  nameWithType: TrustManagerContext.UIContext
