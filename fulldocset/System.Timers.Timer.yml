### YamlMime:ManagedReference
items:
- uid: System.Timers.Timer
  id: Timer
  children:
  - System.Timers.Timer.#ctor
  - System.Timers.Timer.#ctor(System.Double)
  - System.Timers.Timer.AutoReset
  - System.Timers.Timer.BeginInit
  - System.Timers.Timer.Close
  - System.Timers.Timer.Dispose(System.Boolean)
  - System.Timers.Timer.Elapsed
  - System.Timers.Timer.Enabled
  - System.Timers.Timer.EndInit
  - System.Timers.Timer.Interval
  - System.Timers.Timer.Site
  - System.Timers.Timer.Start
  - System.Timers.Timer.Stop
  - System.Timers.Timer.SynchronizingObject
  langs:
  - csharp
  name: Timer
  nameWithType: Timer
  fullName: System.Timers.Timer
  type: Class
  summary: "Создает событие после заданного интервала, с возможностью создания повторяющихся событий.       Для просмотра исходного кода .NET Framework для этого типа, в разделе [ссылки на источник](http://referencesource.microsoft.com/#System/services/timers/system/timers/Timer.cs#897683f27faba082)."
  remarks: "> [!NOTE]Настроек исходного кода .NET Framework для этого типа см. в разделе [ссылки на источник](http://referencesource.microsoft.com/#System/services/timers/system/timers/Timer.cs#897683f27faba082). Выполнять поиск исходного кода в Интернете, справочник для автономной работы и пошагово источники (включая исправления и обновления) во время отладки; в разделе [инструкции](http://referencesource.microsoft.com/).       Компонент Timer является серверным таймер, который вызывает <xref:System.Timers.Timer.Elapsed>событие в приложении после количество миллисекунд в <xref:System.Timers.Timer.Interval%2A>свойстве.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> Можно настроить объект таймера для инициирования события только один раз или несколько раз с помощью <xref:System.Timers.Timer.AutoReset%2A>свойство.</xref:System.Timers.Timer.AutoReset%2A> Как правило объект таймера объявлен на уровне класса, чтобы оно оставалось в области, при условии, что он необходим. Затем можно обработать его <xref:System.Timers.Timer.Elapsed>событие, чтобы обеспечить обработку.</xref:System.Timers.Timer.Elapsed> Например, предположим, имеется важный сервер, который должен храниться 24 часа в сутки, 7 дней в неделю. Можно создать службу, использующую объект таймера периодически проверять сервер и убедитесь, что система работает. Если система не отвечает, служба может попытаться перезапустить сервер или уведомить администратора.      Настроек [!IMPORTANT] настроек таймера класс доступен в платформе .NET Framework. Он не включен в стандартной библиотеке .NET и не доступен на других платформах, таких как .NET Core или универсальной платформы Windows. На этих платформах, а также для обеспечения переносимости на всех платформах .NET, следует использовать <xref:System.Threading.Timer?displayProperty=fullName>вместо этого класс.</xref:System.Threading.Timer?displayProperty=fullName>       Этот тип реализует <xref:System.IDisposable>интерфейса.</xref:System.IDisposable> После завершения с помощью типа следует освободить его прямо или косвенно. Для удаления типа непосредственно вызвать его <xref:System.IDisposable.Dispose%2A>метод в `try` / `catch` блока.</xref:System.IDisposable.Dispose%2A> Чтобы удалить ее косвенно, использовать языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует интерфейс IDisposable» в <xref:System.IDisposable>разделе интерфейса.</xref:System.IDisposable>       Класс Timer серверных предназначен для использования с рабочими потоками в многопоточной среде. Серверные таймеры могут перемещаться между потоками для обработки возникающих <xref:System.Timers.Timer.Elapsed>события, возникающие в большую точность, чем таймеры Windows в вызове событий по времени.</xref:System.Timers.Timer.Elapsed>       Компонент Timer вызывает <xref:System.Timers.Timer.Elapsed>события, в зависимости от значение (в миллисекундах) <xref:System.Timers.Timer.Interval%2A>свойство.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> Можно обработать это событие для выполнения обработки, что нужно. Например предположим, что имеется приложение электронной коммерции, непрерывно регистрирующее заказов на продажу в базу данных. Служба, составляющая инструкции по доставке обрабатывает пакет заказов, а не по отдельности. Можно использовать таймер для начала пакетной обработки данных каждые 30 минут.      Настроек [!IMPORTANT] настроек System.Timers.Timer класс имеет тем же разрешением, что системных часов. Это означает, что <xref:System.Timers.Timer.Elapsed>с интервалом, заданным путем разрешения системных часов, если активизируется событие <xref:System.Timers.Timer.Interval%2A>свойства меньше, чем разрешения системных часов.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> Дополнительные сведения см. в разделе <xref:System.Timers.Timer.Interval%2A>свойство.</xref:System.Timers.Timer.Interval%2A>       Когда <xref:System.Timers.Timer.AutoReset%2A>имеет значение `false`, вызывает объект таймера <xref:System.Timers.Timer.Elapsed>события только один раз после первого <xref:System.Timers.Timer.Interval%2A>прошло.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.AutoReset%2A> Чтобы поддерживать вызов <xref:System.Timers.Timer.Elapsed>событий регулярно в интервал, заданный <xref:System.Timers.Timer.Interval%2A>, задайте <xref:System.Timers.Timer.AutoReset%2A>для `true`, который является значением по умолчанию.</xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed>       Компонент Timer перехватывает и подавляет все исключения, созданные обработчики событий для <xref:System.Timers.Timer.Elapsed>событий.</xref:System.Timers.Timer.Elapsed> Это поведение может измениться в будущих выпусков платформы .NET Framework. Обратите внимание, что это не относится обработчиков событий, которые выполняются асинхронно и включают `await` оператора (в C#) или `Await` оператора (в Visual Basic). Исключения, создаваемые в эти обработчики событий, распространяются обратно в вызывающий поток, как показано в следующем примере. Дополнительные сведения о исключений в асинхронных методах см. в разделе [обработка исключений](~/add/includes/ajax-current-ext-md.md).       [!code-cs[System.Timers.Timer#3](~/add/codesnippet/csharp/t-system.timers.timer_1.cs)][!code-vb[System.Timers.Timer#3](~/add/codesnippet/visualbasic/t-system.timers.timer_1.vb) ] Если <xref:System.Timers.Timer.SynchronizingObject%2A>свойство `null`, <xref:System.Timers.Timer.Elapsed>событие <xref:System.Threading.ThreadPool>потока.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.SynchronizingObject%2A>   Если обработка <xref:System.Timers.Timer.Elapsed>больше времени, чем время события <xref:System.Timers.Timer.Interval%2A>, может быть снова вызывать событие на другом <xref:System.Threading.ThreadPool>потока.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> В этом случае обработчик событий должен быть реентерабельным.      Настроек [!NOTE] настроек метод обработки событий может выполняться в одном потоке, в то же время, другой поток вызывает <xref:System.Timers.Timer.Stop%2A>метода или наборы <xref:System.Timers.Timer.Enabled%2A>Свойства `false`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> Это может привести к <xref:System.Timers.Timer.Elapsed>события после остановки таймера.</xref:System.Timers.Timer.Elapsed> Пример кода для <xref:System.Timers.Timer.Stop%2A>метод показывает один из способов избежать состояния гонок.</xref:System.Timers.Timer.Stop%2A>       Даже если <xref:System.Timers.Timer.SynchronizingObject%2A>не `null`, <xref:System.Timers.Timer.Elapsed>события могут происходить после <xref:System.Timers.Timer.Dispose%2A>или <xref:System.Timers.Timer.Stop%2A>был вызван метод или после <xref:System.Timers.Timer.Enabled%2A>Свойства `false`, так как сигнал для вызова <xref:System.Timers.Timer.Elapsed>событий всегда помещается в очередь для выполнения в потоке пула потоков.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.SynchronizingObject%2A> Один из способов устранения этой ситуации состязания является задать флаг, который определяет обработчик событий для <xref:System.Timers.Timer.Elapsed>событие, чтобы игнорировать последующие события.</xref:System.Timers.Timer.Elapsed>       Если вы используете класс таймера с элементом пользовательского интерфейса, таких как формы или элемента управления, без помещения таймера этого элемента пользовательского интерфейса, назначить форму или элемент управления, содержащий таймер, чтобы <xref:System.Timers.Timer.SynchronizingObject%2A>Свойства, чтобы события маршалируется в потоке пользовательского интерфейса.</xref:System.Timers.Timer.SynchronizingObject%2A>       Список значений свойства по умолчанию для экземпляра таймера см. в разделе <xref:System.Timers.Timer.%23ctor%2A>конструктор.</xref:System.Timers.Timer.%23ctor%2A>      Настроек [!TIP] настроек Имейте в виду, что библиотека классов .NET Framework включает четыре класса с именем `Timer`, каждый из который предоставляет различные функциональные возможности: >>-таймера (этот раздел): вызывает событие через определенные интервалы. Класс предназначен для использования в качестве сервера под управлением или компонент службы в многопоточной среде; он не имеет пользовательского интерфейса и не отображается во время выполнения.   настроек- <xref:System.Threading.Timer?displayProperty=fullName>: выполняет метод обратного вызова один поток из пула потоков через регулярные интервалы.</xref:System.Threading.Timer?displayProperty=fullName> Метод обратного вызова определяется, когда таймер создается и не может быть изменено. Как и класс Timer этот класс предназначен для использования в качестве сервера под управлением или компонент службы в многопоточной среде; он не имеет пользовательского интерфейса и не отображается во время выполнения.   настроек- <xref:System.Windows.Forms.Timer?displayProperty=fullName>: компонент Windows Forms, который вызывает событие через определенные интервалы.</xref:System.Windows.Forms.Timer?displayProperty=fullName> Компонент не имеет пользовательского интерфейса и предназначены для использования в среде с одним потоком.   настроек- <xref:System.Web.UI.Timer?displayProperty=fullName>: это компонент ASP.NET, который выполняет обратную передачу асинхронный или синхронный веб-страницы через определенные интервалы.</xref:System.Web.UI.Timer?displayProperty=fullName>"
  example:
  - "The following example instantiates a `System.Timers.Timer` object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cs[System.Timers.Timer#2](~/add/codesnippet/csharp/t-system.timers.timer_2.cs)]\n [!code-vb[System.Timers.Timer#2](~/add/codesnippet/visualbasic/t-system.timers.timer_2.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Elapsed")]

      [System.ComponentModel.DefaultProperty("Interval")]

      public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Timers.Timer.#ctor
  id: '#ctor'
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Timer()
  nameWithType: Timer.Timer()
  fullName: System.Timers.Timer.Timer()
  type: Constructor
  assemblies:
  - System
  namespace: System.Timers
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Timers.Timer&quot;> </xref> класса и задает всем свойствам начальные значения."
  remarks: "В следующей таблице показаны исходные значения свойств для экземпляра класса <xref:System.Timers.Timer>.</xref:System.Timers.Timer>      | Свойство | Начальное значение |   |--------------|-------------------|   | <xref:System.Timers.Timer.AutoReset%2A>| `true`|   | <xref:System.Timers.Timer.Enabled%2A>| `false`|   | <xref:System.Timers.Timer.Interval%2A>|&100; миллисекунд |   | <xref:System.Timers.Timer.SynchronizingObject%2A>| Пустая ссылка (`Nothing` в Visual Basic). |</xref:System.Timers.Timer.SynchronizingObject%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.AutoReset%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/m-system.timers.timer.sh_1_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/m-system.timers.timer.sh_1_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/m-system.timers.timer.sh_1_1.vb)]"
  syntax:
    content: public Timer ();
    parameters: []
  overload: System.Timers.Timer.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.#ctor(System.Double)
  id: '#ctor(System.Double)'
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Timer(Double)
  nameWithType: Timer.Timer(Double)
  fullName: System.Timers.Timer.Timer(Double)
  type: Constructor
  assemblies:
  - System
  namespace: System.Timers
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Timers.Timer&quot;> </xref> класса и задает <xref:System.Timers.Timer.Interval*>Свойства для указанного числа миллисекунд.</xref:System.Timers.Timer.Interval*>"
  remarks: "Этот конструктор задает <xref:System.Timers.Timer.Interval%2A>Свойства нового экземпляра таймера, но не включает таймер.</xref:System.Timers.Timer.Interval%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cs[System.Timers.Timer#3](~/add/codesnippet/csharp/m-system.timers.timer.sh_0_1.cs)]\n [!code-vb[System.Timers.Timer#3](~/add/codesnippet/visualbasic/m-system.timers.timer.sh_0_1.vb)]"
  syntax:
    content: public Timer (double interval);
    parameters:
    - id: interval
      type: System.Double
      description: "Время (в миллисекундах) между событиями. Значение должно быть больше нуля и меньше или равно &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  overload: System.Timers.Timer.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Значение <code> interval </code> параметр имеет значение меньше или равно нулю, или больше, чем &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;."
  platform:
  - net462
- uid: System.Timers.Timer.AutoReset
  id: AutoReset
  parent: System.Timers.Timer
  langs:
  - csharp
  name: AutoReset
  nameWithType: Timer.AutoReset
  fullName: System.Timers.Timer.AutoReset
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Возвращает или задает типа Boolean, ли <xref href=&quot;System.Timers.Timer&quot;> </xref> должен вызывать <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> событий только один раз (<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>) или неоднократно (<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>)."
  remarks: "Если <xref:System.Timers.Timer>уже включена при <xref:System.Timers.Timer.Start%2A>вызывается метод, интервал сбрасывается.</xref:System.Timers.Timer.Start%2A> </xref:System.Timers.Timer> Если AutoReset `false`, <xref:System.Timers.Timer.Start%2A>необходимо вызвать метод, чтобы снова запустить счетчик.</xref:System.Timers.Timer.Start%2A>       Интервал сброса влияет при <xref:System.Timers.Timer.Elapsed>события.</xref:System.Timers.Timer.Elapsed> Например, если задать интервал, равный 5 секунд, а затем задать <xref:System.Timers.Timer.Enabled%2A>Свойства `true`, счетчик начнется в момент <xref:System.Timers.Timer.Enabled%2A>задано.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> Если сбросить интервал на 10 секунд, когда прошло 3 секунды <xref:System.Timers.Timer.Elapsed>событие вызывается в первый раз 13 секунд после <xref:System.Timers.Timer.Enabled%2A>было задано значение `true`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed>"
  example:
  - "The following example creates a <xref:System.Timers.Timer> whose <xref:System.Timers.Timer.Elapsed> event fires after 1.5 seconds. Its event handler then displays \"Hello World!\" on the console.  \n  \n [!code-vb[Classic Timer.Timer1 Example#1](~/add/codesnippet/visualbasic/p-system.timers.timer.au_1.vb)]\n [!code-cs[Classic Timer.Timer1 Example#1](~/add/codesnippet/csharp/p-system.timers.timer.au_1.cs)]\n [!code-cpp[Classic Timer.Timer1 Example#1](~/add/codesnippet/cpp/p-system.timers.timer.au_1.cpp)]"
  syntax:
    content: public bool AutoReset { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref href=&quot;System.Timers.Timer&quot;> </xref> должен вызывать <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> событие каждый раз при истечении интервала времени; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> если он должен вызвать <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> событий только один раз, при первом входе истечении интервала времени. Значение по умолчанию — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Timers.Timer.AutoReset*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.BeginInit
  id: BeginInit
  parent: System.Timers.Timer
  langs:
  - csharp
  name: BeginInit()
  nameWithType: Timer.BeginInit()
  fullName: System.Timers.Timer.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Начинает инициализацию времени выполнения <xref href=&quot;System.Timers.Timer&quot;> </xref> , используемого в форме или другим компонентом."
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] Разработки, этот метод применяется в среде для запуска инициализации компонента, используемого в форме или другим компонентом. <xref:System.Timers.Timer.EndInit%2A>Метод завершает инициализацию.</xref:System.Timers.Timer.EndInit%2A> С помощью BeginInit и <xref:System.Timers.Timer.EndInit%2A>методы предотвращает использование до полной инициализации элемента управления.</xref:System.Timers.Timer.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Timers.Timer.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Close
  id: Close
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Close()
  nameWithType: Timer.Close()
  fullName: System.Timers.Timer.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Освобождает ресурсы, используемые <xref href=&quot;System.Timers.Timer&quot;> </xref>."
  remarks: "В свою очередь вызывает метод Close `Dispose` метод."
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Timers.Timer.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Timer.Dispose(Boolean)
  fullName: System.Timers.Timer.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Освобождает все ресурсы, используемые текущим <xref href=&quot;System.Timers.Timer&quot;> </xref>."
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>для освобождения управляемых и неуправляемых ресурсов; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> для освобождения только неуправляемых ресурсов."
  overload: System.Timers.Timer.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Elapsed
  id: Elapsed
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Elapsed
  nameWithType: Timer.Elapsed
  fullName: System.Timers.Timer.Elapsed
  type: Event
  assemblies:
  - System
  namespace: System.Timers
  summary: "Происходит при истечении интервала времени."
  remarks: "События Elapsed возникает в том случае, если <xref:System.Timers.Timer.Enabled%2A>свойство `true` и интервал времени (в миллисекундах), заданный <xref:System.Timers.Timer.Interval%2A>свойство истекает.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Enabled%2A> Если <xref:System.Timers.Timer.AutoReset%2A>свойство `true`, повторно вызывать событие в интервал, заданный <xref:System.Timers.Timer.Interval%2A>свойство; в противном случае это событие возникает только один раз в первый раз <xref:System.Timers.Timer.Interval%2A>значение истечения.</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.AutoReset%2A>       Если <xref:System.Timers.Timer.Interval%2A>задается после <xref:System.Timers.Timer>был запущен, счетчик сбрасывается.</xref:System.Timers.Timer> </xref:System.Timers.Timer.Interval%2A> Например, если задать интервал, равный 5 секунд, а затем задать <xref:System.Timers.Timer.Enabled%2A>для `true`, счетчик начнется в момент <xref:System.Timers.Timer.Enabled%2A>задано.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> Если сбросить интервал на 10 секунд, когда прошло 3 секунды, возникает событие Elapsed в первый раз 13 секунд после <xref:System.Timers.Timer.Enabled%2A>было задано значение `true`.</xref:System.Timers.Timer.Enabled%2A>       Если <xref:System.Timers.Timer.SynchronizingObject%2A>свойство `null`, возникает событие Elapsed на <xref:System.Threading.ThreadPool>потока.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.SynchronizingObject%2A> При обработке события Elapsed длится дольше чем <xref:System.Timers.Timer.Interval%2A>, может быть снова вызывать событие на другом <xref:System.Threading.ThreadPool>потока.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Interval%2A> В этом случае обработчик событий должен быть реентерабельным.      Настроек [!NOTE] настроек метод обработки событий может выполняться в одном потоке, в то же время, другой поток вызывает <xref:System.Timers.Timer.Stop%2A>метода или наборы <xref:System.Timers.Timer.Enabled%2A>Свойства `false`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> Это может привести к затраченное события после остановки таймера. Пример кода для <xref:System.Timers.Timer.Stop%2A>метод показывает один из способов избежать состояния гонок.</xref:System.Timers.Timer.Stop%2A>       Даже если <xref:System.Timers.Timer.SynchronizingObject%2A>не `null`, затраченное события могут происходить после <xref:System.Timers.Timer.Dispose%2A>или <xref:System.Timers.Timer.Stop%2A>был вызван метод или после <xref:System.Timers.Timer.Enabled%2A>свойство значение `false`, так как сигнал для инициирования события Elapsed всегда помещается в очередь для выполнения в потоке пула потоков.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.SynchronizingObject%2A> Чтобы задать флаг, который определяет обработчик событий для события Elapsed игнорировать последующие события является одним из способов устранения этой ситуации состязания.       <xref:System.Timers.Timer>Компонент перехватывает и подавляет все исключения, созданные обработчики событий для события Elapsed.</xref:System.Timers.Timer> Это поведение может измениться в будущих выпусков платформы .NET Framework."
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its Elapsed event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/e-system.timers.timer.el_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/e-system.timers.timer.el_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/e-system.timers.timer.el_1.vb)]"
  syntax:
    content: public event System.Timers.ElapsedEventHandler Elapsed;
    return:
      type: System.Timers.ElapsedEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Enabled
  id: Enabled
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Enabled
  nameWithType: Timer.Enabled
  fullName: System.Timers.Timer.Enabled
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Возвращает или задает значение, указывающее, является ли <xref href=&quot;System.Timers.Timer&quot;> </xref> должен вызывать <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> событий."
  remarks: "Установите значение Enabled `true` совпадает со значением вызова <xref:System.Timers.Timer.Start%2A>, в то время, чтобы включить параметр `false` является таким же, как вызов <xref:System.Timers.Timer.Stop%2A>.</xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Start%2A>      Настроек [!NOTE] настроек сигнала для вызова <xref:System.Timers.Timer.Elapsed>событий всегда очередь для выполнения в <xref:System.Threading.ThreadPool>потока.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> Это может привести к <xref:System.Timers.Timer.Elapsed>события свойство Enabled было присвоено `false`.</xref:System.Timers.Timer.Elapsed> В примере кода для <xref:System.Timers.Timer.Stop%2A>метод показывает один из способов устранения этой ситуации состязания.</xref:System.Timers.Timer.Stop%2A>       Если включено `true` и <xref:System.Timers.Timer.AutoReset%2A>равно `false`, <xref:System.Timers.Timer>вызывает <xref:System.Timers.Timer.Elapsed>события только один раз, при первом запуске интервал истечения.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A>       Если интервал после <xref:System.Timers.Timer>был запущен, счетчик сбрасывается.</xref:System.Timers.Timer> Например, если задать интервал, равный 5 секунд и задайте для свойства Enabled `true`, счетчик начинается со временем, заданным включено. Если сбросить интервал на 10 секунд, когда прошло 3 секунды <xref:System.Timers.Timer.Elapsed>событие вызывается в первый раз 13 секунд после Enabled было задано значение `true`.</xref:System.Timers.Timer.Elapsed>      Настроек [!NOTE] настроек некоторые визуальные конструкторы, например, в Microsoft Visual Studio, значение свойства Enabled `true` при вставке новой <xref:System.Timers.Timer>.</xref:System.Timers.Timer>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/p-system.timers.timer.en_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/p-system.timers.timer.en_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/p-system.timers.timer.en_1.vb)]"
  syntax:
    content: public bool Enabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref href=&quot;System.Timers.Timer&quot;> </xref> должен вызывать <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> события; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Timers.Timer.Enabled*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Невозможно задать это свойство, поскольку таймера был удален."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Timers.Timer.Interval*>Свойство установлено в значение больше, чем &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; до включения таймера.</xref:System.Timers.Timer.Interval*>"
  platform:
  - net462
- uid: System.Timers.Timer.EndInit
  id: EndInit
  parent: System.Timers.Timer
  langs:
  - csharp
  name: EndInit()
  nameWithType: Timer.EndInit()
  fullName: System.Timers.Timer.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Завершает инициализацию среды выполнения <xref href=&quot;System.Timers.Timer&quot;> </xref> , используемого в форме или другим компонентом."
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)] Разработки, среда использует этот метод для завершения инициализации компонента, используемого в форме или другим компонентом. <xref:System.Timers.Timer.BeginInit%2A>Метод начинает инициализацию.</xref:System.Timers.Timer.BeginInit%2A> С помощью <xref:System.Timers.Timer.BeginInit%2A>и методы EndInit предотвращает использование до полной инициализации элемента управления.</xref:System.Timers.Timer.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Timers.Timer.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Interval
  id: Interval
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Interval
  nameWithType: Timer.Interval
  fullName: System.Timers.Timer.Interval
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Возвращает или задает интервал, в миллисекундах, по истечении которого возникает <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> событий."
  remarks: "Используйте свойство Interval для определения частоты, с которой <xref:System.Timers.Timer.Elapsed>событие.</xref:System.Timers.Timer.Elapsed> Поскольку <xref:System.Timers.Timer>класс зависит от системных часов, для них же разрешением, что системные часы.</xref:System.Timers.Timer> Это означает, что <xref:System.Timers.Timer.Elapsed>активизируется событие с интервалом, заданным путем разрешения системных часов, если свойство интервал меньше, чем разрешения системных часов.</xref:System.Timers.Timer.Elapsed> В следующем примере свойства интервала в 5 миллисекунд. При выполнении на [!INCLUDE[win7](~/add/includes/win7-md.md)] системы которого системных часов с разрешением примерно 15 миллисекунд, события примерно каждые 15 миллисекунд, а не каждые 5 миллисекунд.       [!code-cs[System.Timers.Timer.Interval#1](~/add/codesnippet/csharp/p-system.timers.timer.in_1.cs)][!code-vb[System.Timers.Timer.Interval#1](~/add/codesnippet/visualbasic/p-system.timers.timer.in_1.vb) ] можно использовать следующий код для определения разрешения системных часов в текущей системе: [!code-cs [System.Timers.Timer.Interval#2](~/add/codesnippet/csharp/p-system.timers.timer.in_2.cs)][!code-vb[System.Timers.Timer.Interval#2](~/add/codesnippet/visualbasic/p-system.timers.timer.in_2.vb) ] Если вашему приложению требуется больше разрешения, предоставляемые чем <xref:System.Timers.Timer>класса или системных часов, используйте таймеры с высоким разрешением мультимедиа; см. раздел [как: использовать таймер высокого разрешения](http://msdn.microsoft.com/library/aa964692.aspx).</xref:System.Timers.Timer>           Если интервал после <xref:System.Timers.Timer>был запущен, счетчик сбрасывается.</xref:System.Timers.Timer> Например, если задать интервал, равный 5 секунд, а затем задать <xref:System.Timers.Timer.Enabled%2A>Свойства `true`, счетчик начнется в момент <xref:System.Timers.Timer.Enabled%2A>задано.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> Если сбросить интервал на 10 секунд, когда прошло 3 секунды <xref:System.Timers.Timer.Elapsed>событие вызывается в первый раз 13 секунд после <xref:System.Timers.Timer.Enabled%2A>было задано значение `true`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed>       Если <xref:System.Timers.Timer.Enabled%2A>имеет значение `true` и <xref:System.Timers.Timer.AutoReset%2A>равно `false`, <xref:System.Timers.Timer>вызывает <xref:System.Timers.Timer.Elapsed>события только один раз, при первом запуске интервал истечения.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Enabled%2A> <xref:System.Timers.Timer.Enabled%2A>Затем устанавливается `false`.</xref:System.Timers.Timer.Enabled%2A>      Настроек [!NOTE] настроек Если <xref:System.Timers.Timer.Enabled%2A>и <xref:System.Timers.Timer.AutoReset%2A>устанавливаются равными `false`, и таймер ранее была включена, параметр причины свойство интервал <xref:System.Timers.Timer.Elapsed>событие один раз, как если бы <xref:System.Timers.Timer.Enabled%2A>ранее было задано свойство `true`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Enabled%2A> Чтобы задать интервал не порождает событие, можно временно перевести <xref:System.Timers.Timer.Enabled%2A>Свойства `true`, присвойте свойству интервал период времени и немедленно установить <xref:System.Timers.Timer.Enabled%2A>обратно свойство `false`.</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/p-system.timers.timer.in_3.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/p-system.timers.timer.in_3.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/p-system.timers.timer.in_3.vb)]"
  syntax:
    content: public double Interval { get; set; }
    return:
      type: System.Double
      description: "Время в миллисекундах, между <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> события. Значение должно быть больше нуля и меньше или равно &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;. Значение по умолчанию — 100 миллисекунд."
  overload: System.Timers.Timer.Interval*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Интервал меньше или равно нулю.       - или - интервал больше, чем &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;, и что таймер включен в данный момент. (Если таймер в данный момент не включена, исключение не возникает, пока будет включена.)"
  platform:
  - net462
- uid: System.Timers.Timer.Site
  id: Site
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Site
  nameWithType: Timer.Site
  fullName: System.Timers.Timer.Site
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Возвращает или задает узел, который привязывает <xref href=&quot;System.Timers.Timer&quot;> </xref> к его контейнеру в режиме конструктора."
  remarks: "Узлы связывают <xref:System.ComponentModel.Component>для <xref:System.ComponentModel.Container>и разрешить связь между ними, а также предоставляет способ для управления компонентами контейнера.</xref:System.ComponentModel.Container> </xref:System.ComponentModel.Component>"
  syntax:
    content: public override System.ComponentModel.ISite Site { get; set; }
    return:
      type: System.ComponentModel.ISite
      description: "<xref href=&quot;System.ComponentModel.ISite&quot;> </xref> Интерфейс, представляющий сайт, который привязывает <xref href=&quot;System.Timers.Timer&quot;> </xref> объекта к его контейнеру."
  overload: System.Timers.Timer.Site*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Start
  id: Start
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Start()
  nameWithType: Timer.Start()
  fullName: System.Timers.Timer.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Начинает вызывать <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> событий, задав <xref:System.Timers.Timer.Enabled*>для <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Timers.Timer.Enabled*>"
  remarks: "При вызове Start и <xref:System.Timers.Timer.AutoReset%2A>равно `false`, <xref:System.Timers.Timer>вызывает <xref:System.Timers.Timer.Elapsed>события только один раз, при первом запуске интервал истечения.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A> При вызове Start и <xref:System.Timers.Timer.AutoReset%2A>— `true`, <xref:System.Timers.Timer>вызывает <xref:System.Timers.Timer.Elapsed>первого события время окончания интервала и продолжает вызывать события в указанном интервале.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A>       Можно также запустить времени, задав <xref:System.Timers.Timer.Enabled%2A>для `true`.</xref:System.Timers.Timer.Enabled%2A>      Настроек [!NOTE] настроек Если <xref:System.Timers.Timer.AutoReset%2A>является `false`, чтобы снова запустить счетчик должен вызываться метод Start.</xref:System.Timers.Timer.AutoReset%2A>       Вызов метода Start при включении таймера не оказывает влияния."
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Timers.Timer.Start*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<xref href=&quot;System.Timers.Timer&quot;> </xref> Создается с интервалом, равным или больше, чем &lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; + 1, либо задается интервал меньше нуля."
  platform:
  - net462
- uid: System.Timers.Timer.Stop
  id: Stop
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Stop()
  nameWithType: Timer.Stop()
  fullName: System.Timers.Timer.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "Прекращает вызывать <xref href=&quot;System.Timers.Timer.Elapsed&quot;> </xref> событий, задав <xref:System.Timers.Timer.Enabled*>для <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Timers.Timer.Enabled*>"
  remarks: "Также можно остановить времени, задав <xref:System.Timers.Timer.Enabled%2A>для `false`.</xref:System.Timers.Timer.Enabled%2A>      Настроек [!NOTE] настроек сигнала для вызова <xref:System.Timers.Timer.Elapsed>событий всегда очередь для выполнения в <xref:System.Threading.ThreadPool>потоке, поэтому метод обработки событий может выполняться в одном потоке, в то же время, в который выполняется вызов метода Stop в другом потоке.</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> Это может привести к <xref:System.Timers.Timer.Elapsed>события после вызова метода Stop.</xref:System.Timers.Timer.Elapsed> В примере кода ниже показан один из способов устранения этой ситуации состязания."
  example:
  - "The following example instantiates a `System.Timers.Timer` object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised. When the user presses the Enter key, the application calls the  Stop method before terminating the application.  \n  \n [!code-cs[System.Timers.Timer#2](~/add/codesnippet/csharp/m-system.timers.timer.stop_1.cs)]\n [!code-vb[System.Timers.Timer#2](~/add/codesnippet/visualbasic/m-system.timers.timer.stop_1.vb)]  \n  \n The following code example shows one way to prevent the thread that calls the Stop method from continuing until a currently executing <xref:System.Timers.Timer.Elapsed> event ends, and also to prevent two <xref:System.Timers.Timer.Elapsed> events from executing the event handler at the same time (often referred to as reentrancy).  \n  \n The example executes 100 test runs. Each time the test is run, the timer is started with an interval of 150 milliseconds. The event handler uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to simulate a task that randomly varies in length from 50 to 200 milliseconds. The test method also starts a control thread that waits for a second and then stops the timer. If an event is being handled when the control thread stops the timer, the control thread must wait until the event is finished before proceeding.  \n  \n The <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName> method overload is used to avoid reentrancy and to prevent the control thread from continuing until an executing event ends. The event handler uses the <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> method to set a control variable to 1, but only if the value is currently zero. This is an atomic operation. If the return value is zero, the control variable has been set to 1 and the event handler proceeds. If the return value is non-zero, the event is simply discarded to avoid reentrancy. (If it were necessary to execute every event, the <xref:System.Threading.Monitor> class would be a better way to synchronize the events.) When the event handler ends, it sets the control variable back to zero. The example records the total number of events that executed, that were discarded because of reentrancy, and that occurred after the Stop method was called.  \n  \n The control thread uses the <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> method to set the control variable to -1 (minus one), but only if the value is currently zero. If the atomic operation returns non-zero, an event is currently executing. The control thread waits and tries again. The example records the number of times the control thread had to wait for an event to finish.  \n  \n [!code-cs[Timer.Stop#1](~/add/codesnippet/csharp/m-system.timers.timer.stop_2.cs)]\n [!code-vb[Timer.Stop#1](~/add/codesnippet/visualbasic/m-system.timers.timer.stop_2.vb)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Timers.Timer.Stop*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.SynchronizingObject
  id: SynchronizingObject
  parent: System.Timers.Timer
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
  fullName: System.Timers.Timer.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "Возвращает или задает объект, используемый для маршалинга вызовов обработчика событий, осуществленных после истечения интервала времени."
  remarks: "При SynchronizingObject `null`, метод, обрабатывающий <xref:System.Timers.Timer.Elapsed>событие вызывается в поток из пула потоков системы.</xref:System.Timers.Timer.Elapsed> Дополнительные сведения о системном пуле потоков см. в разделе <xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       Если <xref:System.Timers.Timer.Elapsed>событие обрабатывается с помощью визуального компонента Windows Forms, например кнопку, обращение к компоненту через пул потоков системы, результат исключение или просто может работать не будут.</xref:System.Timers.Timer.Elapsed> Избежать подобного эффекта, задав SynchronizingObject компоненту Windows Forms, который вызывает метод, обрабатывающий <xref:System.Timers.Timer.Elapsed>событий для вызова в том же потоке, где компонент был создан.</xref:System.Timers.Timer.Elapsed>      Настроек [!NOTE] настроек даже если свойство SynchronizingObject не `null`, <xref:System.Timers.Timer.Elapsed>события могут происходить после <xref:System.Timers.Timer.Dispose%2A>или <xref:System.Timers.Timer.Stop%2A>был вызван метод или после <xref:System.Timers.Timer.Enabled%2A>присвоено свойству `false`, так как сигнал для вызова <xref:System.Timers.Timer.Elapsed>событий всегда помещается в очередь для выполнения в потоке пула потоков.</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.Elapsed> Один из способов устранения этой ситуации состязания является задать флаг, который определяет обработчик событий для <xref:System.Timers.Timer.Elapsed>событие, чтобы игнорировать последующие события.</xref:System.Timers.Timer.Elapsed>       Если <xref:System.Timers.Timer>— используется в среде Visual Studio в конструктор Windows Forms, SynchronizingObject автоматически присваивается элемент управления, содержащий <xref:System.Timers.Timer>.</xref:System.Timers.Timer> </xref:System.Timers.Timer> Например, если поместить <xref:System.Timers.Timer>в конструктор для `Form1` (который наследуется от <xref:System.Windows.Forms.Form>), свойство SynchronizingObject <xref:System.Timers.Timer>устанавливается на экземпляр `Form1`.</xref:System.Timers.Timer> </xref:System.Windows.Forms.Form> </xref:System.Timers.Timer>"
  example:
  - "The following example is a Windows Forms app that serves as a very simple text file editor. When the text in the text box has not been saved, the app asks the user at one-minute intervals whether he or she wants to save the contents of the text box.  To do this, the <xref:System.Timers.Timer.Interval%2A> property is set to one minute (60,000 milliseconds), and the SynchronizingObject property is set to the <xref:System.Windows.Forms.Form> object.  \n  \n [!code-cs[System.Timers.Timer.SynchronizingObject#1](~/add/codesnippet/csharp/SynchronizingObjectCS1/Form1.cs#1)]\n [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/add/codesnippet/visualbasic/SynchronizingObjectVB1/Form1.vb#1)]  \n  \n The example requires that you add the following controls to the form:  \n  \n-   A <xref:System.Windows.Forms.TextBox> control named `TextBox1` (its default name).  \n  \n-   A <xref:System.Windows.Forms.Button> control named `Button1` (its default name).  \n  \n-   A <xref:System.Windows.Forms.SaveFileDialog> control named `SaveSaveFileDialog1` (its default name) ."
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "<xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref> Представляет объект, используемый для маршалинга вызовов обработчика событий, осуществленных после истечения интервала времени. Значение по умолчанию — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Timers.Timer.SynchronizingObject*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Timers.Timer.#ctor
  parent: System.Timers.Timer
  isExternal: false
  name: Timer()
  nameWithType: Timer.Timer()
  fullName: System.Timers.Timer.Timer()
- uid: System.Timers.Timer.#ctor(System.Double)
  parent: System.Timers.Timer
  isExternal: false
  name: Timer(Double)
  nameWithType: Timer.Timer(Double)
  fullName: System.Timers.Timer.Timer(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Timers.Timer.AutoReset
  parent: System.Timers.Timer
  isExternal: false
  name: AutoReset
  nameWithType: Timer.AutoReset
  fullName: System.Timers.Timer.AutoReset
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Timers.Timer.BeginInit
  parent: System.Timers.Timer
  isExternal: false
  name: BeginInit()
  nameWithType: Timer.BeginInit()
  fullName: System.Timers.Timer.BeginInit()
- uid: System.Timers.Timer.Close
  parent: System.Timers.Timer
  isExternal: false
  name: Close()
  nameWithType: Timer.Close()
  fullName: System.Timers.Timer.Close()
- uid: System.Timers.Timer.Dispose(System.Boolean)
  parent: System.Timers.Timer
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Timer.Dispose(Boolean)
  fullName: System.Timers.Timer.Dispose(Boolean)
- uid: System.Timers.Timer.Elapsed
  parent: System.Timers.Timer
  isExternal: false
  name: Elapsed
  nameWithType: Timer.Elapsed
  fullName: System.Timers.Timer.Elapsed
- uid: System.Timers.ElapsedEventHandler
  parent: System.Timers
  isExternal: false
  name: ElapsedEventHandler
  nameWithType: ElapsedEventHandler
  fullName: System.Timers.ElapsedEventHandler
- uid: System.Timers.Timer.Enabled
  parent: System.Timers.Timer
  isExternal: false
  name: Enabled
  nameWithType: Timer.Enabled
  fullName: System.Timers.Timer.Enabled
- uid: System.Timers.Timer.EndInit
  parent: System.Timers.Timer
  isExternal: false
  name: EndInit()
  nameWithType: Timer.EndInit()
  fullName: System.Timers.Timer.EndInit()
- uid: System.Timers.Timer.Interval
  parent: System.Timers.Timer
  isExternal: false
  name: Interval
  nameWithType: Timer.Interval
  fullName: System.Timers.Timer.Interval
- uid: System.Timers.Timer.Site
  parent: System.Timers.Timer
  isExternal: false
  name: Site
  nameWithType: Timer.Site
  fullName: System.Timers.Timer.Site
- uid: System.ComponentModel.ISite
  parent: System.ComponentModel
  isExternal: false
  name: ISite
  nameWithType: ISite
  fullName: System.ComponentModel.ISite
- uid: System.Timers.Timer.Start
  parent: System.Timers.Timer
  isExternal: false
  name: Start()
  nameWithType: Timer.Start()
  fullName: System.Timers.Timer.Start()
- uid: System.Timers.Timer.Stop
  parent: System.Timers.Timer
  isExternal: false
  name: Stop()
  nameWithType: Timer.Stop()
  fullName: System.Timers.Timer.Stop()
- uid: System.Timers.Timer.SynchronizingObject
  parent: System.Timers.Timer
  isExternal: false
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
  fullName: System.Timers.Timer.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Timers.Timer.#ctor*
  parent: System.Timers.Timer
  isExternal: false
  name: Timer
  nameWithType: Timer.Timer
- uid: System.Timers.Timer.AutoReset*
  parent: System.Timers.Timer
  isExternal: false
  name: AutoReset
  nameWithType: Timer.AutoReset
- uid: System.Timers.Timer.BeginInit*
  parent: System.Timers.Timer
  isExternal: false
  name: BeginInit
  nameWithType: Timer.BeginInit
- uid: System.Timers.Timer.Close*
  parent: System.Timers.Timer
  isExternal: false
  name: Close
  nameWithType: Timer.Close
- uid: System.Timers.Timer.Dispose*
  parent: System.Timers.Timer
  isExternal: false
  name: Dispose
  nameWithType: Timer.Dispose
- uid: System.Timers.Timer.Enabled*
  parent: System.Timers.Timer
  isExternal: false
  name: Enabled
  nameWithType: Timer.Enabled
- uid: System.Timers.Timer.EndInit*
  parent: System.Timers.Timer
  isExternal: false
  name: EndInit
  nameWithType: Timer.EndInit
- uid: System.Timers.Timer.Interval*
  parent: System.Timers.Timer
  isExternal: false
  name: Interval
  nameWithType: Timer.Interval
- uid: System.Timers.Timer.Site*
  parent: System.Timers.Timer
  isExternal: false
  name: Site
  nameWithType: Timer.Site
- uid: System.Timers.Timer.Start*
  parent: System.Timers.Timer
  isExternal: false
  name: Start
  nameWithType: Timer.Start
- uid: System.Timers.Timer.Stop*
  parent: System.Timers.Timer
  isExternal: false
  name: Stop
  nameWithType: Timer.Stop
- uid: System.Timers.Timer.SynchronizingObject*
  parent: System.Timers.Timer
  isExternal: false
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
