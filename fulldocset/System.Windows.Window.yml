### YamlMime:ManagedReference
items:
- uid: System.Windows.Window
  id: Window
  children:
  - System.Windows.Window.#ctor
  - System.Windows.Window.Activate
  - System.Windows.Window.Activated
  - System.Windows.Window.AllowsTransparency
  - System.Windows.Window.AllowsTransparencyProperty
  - System.Windows.Window.ArrangeOverride(System.Windows.Size)
  - System.Windows.Window.Close
  - System.Windows.Window.Closed
  - System.Windows.Window.Closing
  - System.Windows.Window.ContentRendered
  - System.Windows.Window.Deactivated
  - System.Windows.Window.DialogResult
  - System.Windows.Window.DpiChanged
  - System.Windows.Window.DpiChangedEvent
  - System.Windows.Window.DragMove
  - System.Windows.Window.GetWindow(System.Windows.DependencyObject)
  - System.Windows.Window.Hide
  - System.Windows.Window.Icon
  - System.Windows.Window.IconProperty
  - System.Windows.Window.IsActive
  - System.Windows.Window.IsActiveProperty
  - System.Windows.Window.Left
  - System.Windows.Window.LeftProperty
  - System.Windows.Window.LocationChanged
  - System.Windows.Window.LogicalChildren
  - System.Windows.Window.MeasureOverride(System.Windows.Size)
  - System.Windows.Window.OnActivated(System.EventArgs)
  - System.Windows.Window.OnClosed(System.EventArgs)
  - System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)
  - System.Windows.Window.OnContentChanged(System.Object,System.Object)
  - System.Windows.Window.OnContentRendered(System.EventArgs)
  - System.Windows.Window.OnCreateAutomationPeer
  - System.Windows.Window.OnDeactivated(System.EventArgs)
  - System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)
  - System.Windows.Window.OnLocationChanged(System.EventArgs)
  - System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  - System.Windows.Window.OnSourceInitialized(System.EventArgs)
  - System.Windows.Window.OnStateChanged(System.EventArgs)
  - System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)
  - System.Windows.Window.OwnedWindows
  - System.Windows.Window.Owner
  - System.Windows.Window.ResizeMode
  - System.Windows.Window.ResizeModeProperty
  - System.Windows.Window.RestoreBounds
  - System.Windows.Window.Show
  - System.Windows.Window.ShowActivated
  - System.Windows.Window.ShowActivatedProperty
  - System.Windows.Window.ShowDialog
  - System.Windows.Window.ShowInTaskbar
  - System.Windows.Window.ShowInTaskbarProperty
  - System.Windows.Window.SizeToContent
  - System.Windows.Window.SizeToContentProperty
  - System.Windows.Window.SourceInitialized
  - System.Windows.Window.StateChanged
  - System.Windows.Window.TaskbarItemInfo
  - System.Windows.Window.TaskbarItemInfoProperty
  - System.Windows.Window.Title
  - System.Windows.Window.TitleProperty
  - System.Windows.Window.Top
  - System.Windows.Window.Topmost
  - System.Windows.Window.TopmostProperty
  - System.Windows.Window.TopProperty
  - System.Windows.Window.WindowStartupLocation
  - System.Windows.Window.WindowState
  - System.Windows.Window.WindowStateProperty
  - System.Windows.Window.WindowStyle
  - System.Windows.Window.WindowStyleProperty
  langs:
  - csharp
  name: Window
  nameWithType: Window
  fullName: System.Windows.Window
  type: Class
  summary: "Предоставляет возможность создавать, настраивать, показывать и управлять временем жизни и диалоговые окна."
  remarks: "Точка взаимодействия между пользователем и автономное приложение — это окно. Объект [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] окно состоит из двух различных областей:-неклиентскую область, которая содержит элементы оформления окна, включая значок, заголовок, системное меню «свернуть», разверните кнопки, восстановления, кнопку закрытия и границу.      — Клиентская область, в котором размещается содержимое для конкретного приложения.       Стандартное окно показано на следующем рисунке: ![элементов окна](~/add/media/windowoverviewfigure1.PNG &quot;элементов окна&quot;) инкапсулирует возможность создавать, настраивать, показывать и управлять временем жизни окна и диалоговые окна и предоставляет следующие ключевые службы: **управления жизненным циклом**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>( <xref:System.Windows.Window.Close%2A>), <xref:System.Windows.Window.Closed>( <xref:System.Windows.Window.Closing>), <xref:System.Windows.Window.Deactivated>( <xref:System.Windows.Window.Hide%2A>), <xref:System.Windows.Window.IsActive%2A>( <xref:System.Windows.Window.Show%2A>), <xref:System.Windows.Window.SourceInitialized>.</xref:System.Windows.Window.SourceInitialized> </xref:System.Windows.Window.Show%2A> </xref:System.Windows.Window.IsActive%2A> </xref:System.Windows.Window.Hide%2A> </xref:System.Windows.Window.Deactivated> </xref:System.Windows.Window.Closing> </xref:System.Windows.Window.Closed> </xref:System.Windows.Window.Close%2A> </xref:System.Windows.Window.Activated> </xref:System.Windows.Window.Activate%2A>       **Управление окнами**: <xref:System.Windows.Window.GetWindow%2A>( <xref:System.Windows.Window.OwnedWindows%2A>), <xref:System.Windows.Window.Owner%2A>.</xref:System.Windows.Window.Owner%2A> </xref:System.Windows.Window.OwnedWindows%2A> </xref:System.Windows.Window.GetWindow%2A>       **Appearance and Behavior**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>       **Dialog Boxes**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>.</xref:System.Windows.Window.ShowDialog%2A></xref:System.Windows.Window.DialogResult%2A></xref:System.Windows.Window.WindowStyle%2A></xref:System.Windows.Window.WindowState%2A></xref:System.Windows.Window.WindowStartupLocation%2A></xref:System.Windows.Window.Topmost%2A></xref:System.Windows.Window.Top%2A></xref:System.Windows.Window.Title%2A></xref:System.Windows.Window.StateChanged></xref:System.Windows.Window.SizeToContent%2A></xref:System.Windows.Window.ShowInTaskbar%2A></xref:System.Windows.Window.ShowActivated%2A></xref:System.Windows.Window.RestoreBounds%2A></xref:System.Windows.Window.ResizeMode%2A></xref:System.Windows.Window.LocationChanged></xref:System.Windows.Window.Left%2A></xref:System.Windows.Window.Icon%2A></xref:System.Windows.Window.DragMove%2A></xref:System.Windows.Window.ContentRendered></xref:System.Windows.Window.AllowsTransparency%2A>       Кроме того <xref:System.Windows.Application>предоставляет специальную поддержку для управления все окна в приложении:-приложение поддерживает список всех окон, которые в данный момент созданы в приложении.</xref:System.Windows.Application> Этот список предоставляется <xref:System.Windows.Application.Windows%2A>свойство.</xref:System.Windows.Application.Windows%2A>      -По умолчанию <xref:System.Windows.Application.MainWindow%2A>автоматически устанавливается со ссылкой на первое окно, экземпляр которого создается в приложении.</xref:System.Windows.Application.MainWindow%2A> Это делая окна главного окна приложения.       Окно может быть реализован с помощью разметки, разметки и кода или кода.       Окно в основном используется для отображения окна и диалоговые окна для автономных приложений. Однако для приложений, требующих навигации на уровне окна, например мастера, можно использовать <xref:System.Windows.Navigation.NavigationWindow>вместо; <xref:System.Windows.Navigation.NavigationWindow>является производным от окна и расширяет его с поддержкой навигации в стиле браузера.</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.NavigationWindow>      Настроек [!NOTE] настроек Острова содержимого с поддержкой навигации могут включаться в другие содержимое и контейнеры с помощью <xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame>       Окно должно `UnmanagedCode` создания разрешения безопасности. Это приводит к следующим последствиям:- [!INCLUDE[TLA#tla_clickonce](~/add/includes/tlasharptla-clickonce-md.md)]-развернутой отдельные приложения запросят повышения разрешений при запуске из зон Интернета или локальной интрасети.      - [!INCLUDE[TLA2#tla_xbap#plural](~/add/includes/tla2sharptla-xbapsharpplural-md.md)] , запрашивающие меньше, чем полные права доступа не будет иметь возможность создать экземпляр windows или диалоговым окнам.       Сведения о автономное развертывание приложений и рекомендации по безопасности см. в разделе [стратегия безопасности WPF — безопасность платформы](~/add/includes/ajax-current-ext-md.md).       Окно <xref:System.Windows.Controls.ContentControl>, что означает, что он может содержать один объект любого типа (например, строки, изображения или панели).</xref:System.Windows.Controls.ContentControl> Дополнительные сведения см. в разделе <xref:System.Windows.Controls.ContentControl>класса.</xref:System.Windows.Controls.ContentControl> Кроме того окно является корневым элементом и, следовательно, не может быть частью содержимого другого элемента.      Настроек [!NOTE] настроек <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.Window.Top%2A>, и <xref:System.Windows.Window.Left%2A>Свойства, заданные через стиль окна не будут применяться во время выполнения.</xref:System.Windows.Window.Left%2A> </xref:System.Windows.Window.Top%2A> </xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.Height%2A>      ## Настройка окна элемента управления для применения значения свойств для нескольких элементов управления окна, используйте <xref:System.Windows.FrameworkElement.Style%2A>свойство.</xref:System.Windows.FrameworkElement.Style%2A> Можно изменить значение по умолчанию <xref:System.Windows.Controls.ControlTemplate>для предоставления уникального внешнего вида элемента управления.</xref:System.Windows.Controls.ControlTemplate> Дополнительные сведения о создании <xref:System.Windows.Controls.ControlTemplate>, в разделе [Настройка внешнего вида существующего элемента управления путем создания объекта ControlTemplate](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.Controls.ControlTemplate>  Части и состояния, характерные для окна см. в разделе [окна Стили и шаблоны](~/add/includes/ajax-current-ext-md.md).       Свойства зависимостей для этого элемента управления могут быть заданы посредством стиля элемента управления по умолчанию.  Если свойство задано стилем по умолчанию, когда элемент управления появится в приложении свойство может изменять значения по умолчанию. Стиль по умолчанию определяется по какая тема рабочего стола используется при запуске приложения.  Дополнительные сведения см. в разделе [темы по умолчанию WPF](http://go.microsoft.com/fwlink/?LinkID=158252).      Настроек [!NOTE] настроек свойства visual будет действовать только если это свойство более присутствует в шаблоне элемента управления окна по умолчанию и задается с помощью. Список визуальных свойств можно найти в разделе «Изменение Visual структуры управления» в [Настройка внешнего вида существующего элемента управления путем создания объекта ControlTemplate](../Topic/Customizing%20the%20Appearance%20of%20an%20Existing%20Control%20by%20Creating%20a%20ControlTemplate.md)."
  example:
  - "The following example shows how a standard window is defined using only markup:  \n  \n [!code-xml[WindowSnippets#WindowMARKUPONLY](~/add/codesnippet/xaml/WindowSnippets.CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  \n  \n The following example shows how a standard window is defined using only code:  \n  \n [!code-cs[WindowSnippets#WindowCODEONLY](~/add/codesnippet/csharp/WindowSnippets.CSharp/CodeOnlyWindow.cs#windowcodeonly)]\n [!code-vb[WindowSnippets#WindowCODEONLY](~/add/codesnippet/visualbasic/windowsnippets/codeonlywindow.vb#windowcodeonly)]  \n  \n The following example shows how a standard window is defined using a combination of markup and code-behind.  \n  \n [!code-xml[WindowSnippets#WindowXAML](~/add/codesnippet/xaml/WindowSnippets.CSharp/MainWindow.xaml#windowxaml)]  \n  \n [!code-cs[WindowSnippets#WindowCODEBEHIND](~/add/codesnippet/csharp/WindowSnippets.CSharp/MainWindow.xaml.cs#windowcodebehind)]\n [!code-vb[WindowSnippets#WindowCODEBEHIND](~/add/codesnippet/visualbasic/windowsnippets/mainwindow.xaml.vb#windowcodebehind)]"
  syntax:
    content: >-
      [System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)]

      public class Window : System.Windows.Controls.ContentControl
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.Media.Visual
  - System.Windows.UIElement
  - System.Windows.FrameworkElement
  - System.Windows.Controls.Control
  - System.Windows.Controls.ContentControl
  implements: []
  inheritedMembers:
  - System.Windows.Controls.ContentControl.AddChild(System.Object)
  - System.Windows.Controls.ContentControl.AddText(System.String)
  - System.Windows.Controls.ContentControl.Content
  - System.Windows.Controls.ContentControl.ContentProperty
  - System.Windows.Controls.ContentControl.ContentStringFormat
  - System.Windows.Controls.ContentControl.ContentStringFormatProperty
  - System.Windows.Controls.ContentControl.ContentTemplate
  - System.Windows.Controls.ContentControl.ContentTemplateProperty
  - System.Windows.Controls.ContentControl.ContentTemplateSelector
  - System.Windows.Controls.ContentControl.ContentTemplateSelectorProperty
  - System.Windows.Controls.ContentControl.HasContent
  - System.Windows.Controls.ContentControl.HasContentProperty
  - System.Windows.Controls.ContentControl.OnContentStringFormatChanged(System.String,System.String)
  - System.Windows.Controls.ContentControl.OnContentTemplateChanged(System.Windows.DataTemplate,System.Windows.DataTemplate)
  - System.Windows.Controls.ContentControl.OnContentTemplateSelectorChanged(System.Windows.Controls.DataTemplateSelector,System.Windows.Controls.DataTemplateSelector)
  - System.Windows.Controls.ContentControl.ShouldSerializeContent
  - System.Windows.Controls.ContentControl.System#Windows#Markup#IAddChild#AddChild(System.Object)
  - System.Windows.Controls.ContentControl.System#Windows#Markup#IAddChild#AddText(System.String)
  - System.Windows.Controls.Control.Background
  - System.Windows.Controls.Control.BackgroundProperty
  - System.Windows.Controls.Control.BorderBrush
  - System.Windows.Controls.Control.BorderBrushProperty
  - System.Windows.Controls.Control.BorderThickness
  - System.Windows.Controls.Control.BorderThicknessProperty
  - System.Windows.Controls.Control.FontFamily
  - System.Windows.Controls.Control.FontFamilyProperty
  - System.Windows.Controls.Control.FontSize
  - System.Windows.Controls.Control.FontSizeProperty
  - System.Windows.Controls.Control.FontStretch
  - System.Windows.Controls.Control.FontStretchProperty
  - System.Windows.Controls.Control.FontStyle
  - System.Windows.Controls.Control.FontStyleProperty
  - System.Windows.Controls.Control.FontWeight
  - System.Windows.Controls.Control.FontWeightProperty
  - System.Windows.Controls.Control.Foreground
  - System.Windows.Controls.Control.ForegroundProperty
  - System.Windows.Controls.Control.HandlesScrolling
  - System.Windows.Controls.Control.HorizontalContentAlignment
  - System.Windows.Controls.Control.HorizontalContentAlignmentProperty
  - System.Windows.Controls.Control.IsTabStop
  - System.Windows.Controls.Control.IsTabStopProperty
  - System.Windows.Controls.Control.MouseDoubleClick
  - System.Windows.Controls.Control.MouseDoubleClickEvent
  - System.Windows.Controls.Control.OnMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.Controls.Control.OnPreviewMouseDoubleClick(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)
  - System.Windows.Controls.Control.Padding
  - System.Windows.Controls.Control.PaddingProperty
  - System.Windows.Controls.Control.PreviewMouseDoubleClick
  - System.Windows.Controls.Control.PreviewMouseDoubleClickEvent
  - System.Windows.Controls.Control.TabIndex
  - System.Windows.Controls.Control.TabIndexProperty
  - System.Windows.Controls.Control.Template
  - System.Windows.Controls.Control.TemplateProperty
  - System.Windows.Controls.Control.ToString
  - System.Windows.Controls.Control.VerticalContentAlignment
  - System.Windows.Controls.Control.VerticalContentAlignmentProperty
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.FrameworkElement.ActualHeight
  - System.Windows.FrameworkElement.ActualHeightProperty
  - System.Windows.FrameworkElement.ActualWidth
  - System.Windows.FrameworkElement.ActualWidthProperty
  - System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  - System.Windows.FrameworkElement.ApplyTemplate
  - System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  - System.Windows.FrameworkElement.BeginInit
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  - System.Windows.FrameworkElement.BindingGroup
  - System.Windows.FrameworkElement.BindingGroupProperty
  - System.Windows.FrameworkElement.BringIntoView
  - System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  - System.Windows.FrameworkElement.ContextMenu
  - System.Windows.FrameworkElement.ContextMenuClosing
  - System.Windows.FrameworkElement.ContextMenuClosingEvent
  - System.Windows.FrameworkElement.ContextMenuOpening
  - System.Windows.FrameworkElement.ContextMenuOpeningEvent
  - System.Windows.FrameworkElement.ContextMenuProperty
  - System.Windows.FrameworkElement.Cursor
  - System.Windows.FrameworkElement.CursorProperty
  - System.Windows.FrameworkElement.DataContext
  - System.Windows.FrameworkElement.DataContextChanged
  - System.Windows.FrameworkElement.DataContextProperty
  - System.Windows.FrameworkElement.DefaultStyleKey
  - System.Windows.FrameworkElement.DefaultStyleKeyProperty
  - System.Windows.FrameworkElement.EndInit
  - System.Windows.FrameworkElement.FindName(System.String)
  - System.Windows.FrameworkElement.FindResource(System.Object)
  - System.Windows.FrameworkElement.FlowDirection
  - System.Windows.FrameworkElement.FlowDirectionProperty
  - System.Windows.FrameworkElement.FocusVisualStyle
  - System.Windows.FrameworkElement.FocusVisualStyleProperty
  - System.Windows.FrameworkElement.ForceCursor
  - System.Windows.FrameworkElement.ForceCursorProperty
  - System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  - System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  - System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  - System.Windows.FrameworkElement.GetTemplateChild(System.String)
  - System.Windows.FrameworkElement.GetUIParentCore
  - System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  - System.Windows.FrameworkElement.Height
  - System.Windows.FrameworkElement.HeightProperty
  - System.Windows.FrameworkElement.HorizontalAlignment
  - System.Windows.FrameworkElement.HorizontalAlignmentProperty
  - System.Windows.FrameworkElement.InheritanceBehavior
  - System.Windows.FrameworkElement.Initialized
  - System.Windows.FrameworkElement.InputScope
  - System.Windows.FrameworkElement.InputScopeProperty
  - System.Windows.FrameworkElement.IsInitialized
  - System.Windows.FrameworkElement.IsLoaded
  - System.Windows.FrameworkElement.Language
  - System.Windows.FrameworkElement.LanguageProperty
  - System.Windows.FrameworkElement.LayoutTransform
  - System.Windows.FrameworkElement.LayoutTransformProperty
  - System.Windows.FrameworkElement.Loaded
  - System.Windows.FrameworkElement.LoadedEvent
  - System.Windows.FrameworkElement.Margin
  - System.Windows.FrameworkElement.MarginProperty
  - System.Windows.FrameworkElement.MaxHeight
  - System.Windows.FrameworkElement.MaxHeightProperty
  - System.Windows.FrameworkElement.MaxWidth
  - System.Windows.FrameworkElement.MaxWidthProperty
  - System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  - System.Windows.FrameworkElement.MinHeight
  - System.Windows.FrameworkElement.MinHeightProperty
  - System.Windows.FrameworkElement.MinWidth
  - System.Windows.FrameworkElement.MinWidthProperty
  - System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  - System.Windows.FrameworkElement.Name
  - System.Windows.FrameworkElement.NameProperty
  - System.Windows.FrameworkElement.OnApplyTemplate
  - System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  - System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  - System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  - System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  - System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkElement.OverridesDefaultStyle
  - System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  - System.Windows.FrameworkElement.Parent
  - System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  - System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  - System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  - System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  - System.Windows.FrameworkElement.RequestBringIntoView
  - System.Windows.FrameworkElement.RequestBringIntoViewEvent
  - System.Windows.FrameworkElement.Resources
  - System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  - System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  - System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  - System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  - System.Windows.FrameworkElement.ShouldSerializeResources
  - System.Windows.FrameworkElement.ShouldSerializeStyle
  - System.Windows.FrameworkElement.ShouldSerializeTriggers
  - System.Windows.FrameworkElement.SizeChanged
  - System.Windows.FrameworkElement.SizeChangedEvent
  - System.Windows.FrameworkElement.SourceUpdated
  - System.Windows.FrameworkElement.Style
  - System.Windows.FrameworkElement.StyleProperty
  - System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.FrameworkElement.Tag
  - System.Windows.FrameworkElement.TagProperty
  - System.Windows.FrameworkElement.TargetUpdated
  - System.Windows.FrameworkElement.TemplatedParent
  - System.Windows.FrameworkElement.ToolTip
  - System.Windows.FrameworkElement.ToolTipClosing
  - System.Windows.FrameworkElement.ToolTipClosingEvent
  - System.Windows.FrameworkElement.ToolTipOpening
  - System.Windows.FrameworkElement.ToolTipOpeningEvent
  - System.Windows.FrameworkElement.ToolTipProperty
  - System.Windows.FrameworkElement.Triggers
  - System.Windows.FrameworkElement.TryFindResource(System.Object)
  - System.Windows.FrameworkElement.Unloaded
  - System.Windows.FrameworkElement.UnloadedEvent
  - System.Windows.FrameworkElement.UnregisterName(System.String)
  - System.Windows.FrameworkElement.UpdateDefaultStyle
  - System.Windows.FrameworkElement.UseLayoutRounding
  - System.Windows.FrameworkElement.UseLayoutRoundingProperty
  - System.Windows.FrameworkElement.VerticalAlignment
  - System.Windows.FrameworkElement.VerticalAlignmentProperty
  - System.Windows.FrameworkElement.VisualChildrenCount
  - System.Windows.FrameworkElement.Width
  - System.Windows.FrameworkElement.WidthProperty
  - System.Windows.Media.Visual.AddVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.FindCommonVisualAncestor(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.IsAncestorOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.IsDescendantOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)
  - System.Windows.Media.Visual.PointFromScreen(System.Windows.Point)
  - System.Windows.Media.Visual.PointToScreen(System.Windows.Point)
  - System.Windows.Media.Visual.RemoveVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Media3D.Visual3D)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToDescendant(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToVisual(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.VisualBitmapEffect
  - System.Windows.Media.Visual.VisualBitmapEffectInput
  - System.Windows.Media.Visual.VisualBitmapScalingMode
  - System.Windows.Media.Visual.VisualCacheMode
  - System.Windows.Media.Visual.VisualClearTypeHint
  - System.Windows.Media.Visual.VisualClip
  - System.Windows.Media.Visual.VisualEdgeMode
  - System.Windows.Media.Visual.VisualEffect
  - System.Windows.Media.Visual.VisualOffset
  - System.Windows.Media.Visual.VisualOpacity
  - System.Windows.Media.Visual.VisualOpacityMask
  - System.Windows.Media.Visual.VisualParent
  - System.Windows.Media.Visual.VisualScrollableAreaClip
  - System.Windows.Media.Visual.VisualTextHintingMode
  - System.Windows.Media.Visual.VisualTextRenderingMode
  - System.Windows.Media.Visual.VisualTransform
  - System.Windows.Media.Visual.VisualXSnappingGuidelines
  - System.Windows.Media.Visual.VisualYSnappingGuidelines
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  - System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.AllowDrop
  - System.Windows.UIElement.AllowDropProperty
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.AreAnyTouchesCaptured
  - System.Windows.UIElement.AreAnyTouchesCapturedProperty
  - System.Windows.UIElement.AreAnyTouchesCapturedWithin
  - System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty
  - System.Windows.UIElement.AreAnyTouchesDirectlyOver
  - System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty
  - System.Windows.UIElement.AreAnyTouchesOver
  - System.Windows.UIElement.AreAnyTouchesOverProperty
  - System.Windows.UIElement.Arrange(System.Windows.Rect)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.BitmapEffect
  - System.Windows.UIElement.BitmapEffectInput
  - System.Windows.UIElement.BitmapEffectInputProperty
  - System.Windows.UIElement.BitmapEffectProperty
  - System.Windows.UIElement.CacheMode
  - System.Windows.UIElement.CacheModeProperty
  - System.Windows.UIElement.CaptureMouse
  - System.Windows.UIElement.CaptureStylus
  - System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.Clip
  - System.Windows.UIElement.ClipProperty
  - System.Windows.UIElement.ClipToBounds
  - System.Windows.UIElement.ClipToBoundsProperty
  - System.Windows.UIElement.CommandBindings
  - System.Windows.UIElement.DesiredSize
  - System.Windows.UIElement.DragEnter
  - System.Windows.UIElement.DragEnterEvent
  - System.Windows.UIElement.DragLeave
  - System.Windows.UIElement.DragLeaveEvent
  - System.Windows.UIElement.DragOver
  - System.Windows.UIElement.DragOverEvent
  - System.Windows.UIElement.Drop
  - System.Windows.UIElement.DropEvent
  - System.Windows.UIElement.Effect
  - System.Windows.UIElement.EffectProperty
  - System.Windows.UIElement.Focus
  - System.Windows.UIElement.Focusable
  - System.Windows.UIElement.FocusableChanged
  - System.Windows.UIElement.FocusableProperty
  - System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.UIElement.GiveFeedback
  - System.Windows.UIElement.GiveFeedbackEvent
  - System.Windows.UIElement.GotFocus
  - System.Windows.UIElement.GotFocusEvent
  - System.Windows.UIElement.GotKeyboardFocus
  - System.Windows.UIElement.GotKeyboardFocusEvent
  - System.Windows.UIElement.GotMouseCapture
  - System.Windows.UIElement.GotMouseCaptureEvent
  - System.Windows.UIElement.GotStylusCapture
  - System.Windows.UIElement.GotStylusCaptureEvent
  - System.Windows.UIElement.GotTouchCapture
  - System.Windows.UIElement.GotTouchCaptureEvent
  - System.Windows.UIElement.HasAnimatedProperties
  - System.Windows.UIElement.HasEffectiveKeyboardFocus
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)
  - System.Windows.UIElement.InputBindings
  - System.Windows.UIElement.InputHitTest(System.Windows.Point)
  - System.Windows.UIElement.InvalidateArrange
  - System.Windows.UIElement.InvalidateMeasure
  - System.Windows.UIElement.InvalidateVisual
  - System.Windows.UIElement.IsArrangeValid
  - System.Windows.UIElement.IsEnabled
  - System.Windows.UIElement.IsEnabledChanged
  - System.Windows.UIElement.IsEnabledCore
  - System.Windows.UIElement.IsEnabledProperty
  - System.Windows.UIElement.IsFocused
  - System.Windows.UIElement.IsFocusedProperty
  - System.Windows.UIElement.IsHitTestVisible
  - System.Windows.UIElement.IsHitTestVisibleChanged
  - System.Windows.UIElement.IsHitTestVisibleProperty
  - System.Windows.UIElement.IsInputMethodEnabled
  - System.Windows.UIElement.IsKeyboardFocused
  - System.Windows.UIElement.IsKeyboardFocusedChanged
  - System.Windows.UIElement.IsKeyboardFocusedProperty
  - System.Windows.UIElement.IsKeyboardFocusWithin
  - System.Windows.UIElement.IsKeyboardFocusWithinChanged
  - System.Windows.UIElement.IsKeyboardFocusWithinProperty
  - System.Windows.UIElement.IsManipulationEnabled
  - System.Windows.UIElement.IsManipulationEnabledProperty
  - System.Windows.UIElement.IsMeasureValid
  - System.Windows.UIElement.IsMouseCaptured
  - System.Windows.UIElement.IsMouseCapturedChanged
  - System.Windows.UIElement.IsMouseCapturedProperty
  - System.Windows.UIElement.IsMouseCaptureWithin
  - System.Windows.UIElement.IsMouseCaptureWithinChanged
  - System.Windows.UIElement.IsMouseCaptureWithinProperty
  - System.Windows.UIElement.IsMouseDirectlyOver
  - System.Windows.UIElement.IsMouseDirectlyOverChanged
  - System.Windows.UIElement.IsMouseDirectlyOverProperty
  - System.Windows.UIElement.IsMouseOver
  - System.Windows.UIElement.IsMouseOverProperty
  - System.Windows.UIElement.IsStylusCaptured
  - System.Windows.UIElement.IsStylusCapturedChanged
  - System.Windows.UIElement.IsStylusCapturedProperty
  - System.Windows.UIElement.IsStylusCaptureWithin
  - System.Windows.UIElement.IsStylusCaptureWithinChanged
  - System.Windows.UIElement.IsStylusCaptureWithinProperty
  - System.Windows.UIElement.IsStylusDirectlyOver
  - System.Windows.UIElement.IsStylusDirectlyOverChanged
  - System.Windows.UIElement.IsStylusDirectlyOverProperty
  - System.Windows.UIElement.IsStylusOver
  - System.Windows.UIElement.IsStylusOverProperty
  - System.Windows.UIElement.IsVisible
  - System.Windows.UIElement.IsVisibleChanged
  - System.Windows.UIElement.IsVisibleProperty
  - System.Windows.UIElement.KeyDown
  - System.Windows.UIElement.KeyDownEvent
  - System.Windows.UIElement.KeyUp
  - System.Windows.UIElement.KeyUpEvent
  - System.Windows.UIElement.LayoutUpdated
  - System.Windows.UIElement.LostFocus
  - System.Windows.UIElement.LostFocusEvent
  - System.Windows.UIElement.LostKeyboardFocus
  - System.Windows.UIElement.LostKeyboardFocusEvent
  - System.Windows.UIElement.LostMouseCapture
  - System.Windows.UIElement.LostMouseCaptureEvent
  - System.Windows.UIElement.LostStylusCapture
  - System.Windows.UIElement.LostStylusCaptureEvent
  - System.Windows.UIElement.LostTouchCapture
  - System.Windows.UIElement.LostTouchCaptureEvent
  - System.Windows.UIElement.ManipulationBoundaryFeedback
  - System.Windows.UIElement.ManipulationBoundaryFeedbackEvent
  - System.Windows.UIElement.ManipulationCompleted
  - System.Windows.UIElement.ManipulationCompletedEvent
  - System.Windows.UIElement.ManipulationDelta
  - System.Windows.UIElement.ManipulationDeltaEvent
  - System.Windows.UIElement.ManipulationInertiaStarting
  - System.Windows.UIElement.ManipulationInertiaStartingEvent
  - System.Windows.UIElement.ManipulationStarted
  - System.Windows.UIElement.ManipulationStartedEvent
  - System.Windows.UIElement.ManipulationStarting
  - System.Windows.UIElement.ManipulationStartingEvent
  - System.Windows.UIElement.Measure(System.Windows.Size)
  - System.Windows.UIElement.MouseDown
  - System.Windows.UIElement.MouseDownEvent
  - System.Windows.UIElement.MouseEnter
  - System.Windows.UIElement.MouseEnterEvent
  - System.Windows.UIElement.MouseLeave
  - System.Windows.UIElement.MouseLeaveEvent
  - System.Windows.UIElement.MouseLeftButtonDown
  - System.Windows.UIElement.MouseLeftButtonDownEvent
  - System.Windows.UIElement.MouseLeftButtonUp
  - System.Windows.UIElement.MouseLeftButtonUpEvent
  - System.Windows.UIElement.MouseMove
  - System.Windows.UIElement.MouseMoveEvent
  - System.Windows.UIElement.MouseRightButtonDown
  - System.Windows.UIElement.MouseRightButtonDownEvent
  - System.Windows.UIElement.MouseRightButtonUp
  - System.Windows.UIElement.MouseRightButtonUpEvent
  - System.Windows.UIElement.MouseUp
  - System.Windows.UIElement.MouseUpEvent
  - System.Windows.UIElement.MouseWheel
  - System.Windows.UIElement.MouseWheelEvent
  - System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)
  - System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)
  - System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)
  - System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)
  - System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)
  - System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)
  - System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)
  - System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  - System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)
  - System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.Opacity
  - System.Windows.UIElement.OpacityMask
  - System.Windows.UIElement.OpacityMaskProperty
  - System.Windows.UIElement.OpacityProperty
  - System.Windows.UIElement.PersistId
  - System.Windows.UIElement.PreviewDragEnter
  - System.Windows.UIElement.PreviewDragEnterEvent
  - System.Windows.UIElement.PreviewDragLeave
  - System.Windows.UIElement.PreviewDragLeaveEvent
  - System.Windows.UIElement.PreviewDragOver
  - System.Windows.UIElement.PreviewDragOverEvent
  - System.Windows.UIElement.PreviewDrop
  - System.Windows.UIElement.PreviewDropEvent
  - System.Windows.UIElement.PreviewGiveFeedback
  - System.Windows.UIElement.PreviewGiveFeedbackEvent
  - System.Windows.UIElement.PreviewGotKeyboardFocus
  - System.Windows.UIElement.PreviewGotKeyboardFocusEvent
  - System.Windows.UIElement.PreviewKeyDown
  - System.Windows.UIElement.PreviewKeyDownEvent
  - System.Windows.UIElement.PreviewKeyUp
  - System.Windows.UIElement.PreviewKeyUpEvent
  - System.Windows.UIElement.PreviewLostKeyboardFocus
  - System.Windows.UIElement.PreviewLostKeyboardFocusEvent
  - System.Windows.UIElement.PreviewMouseDown
  - System.Windows.UIElement.PreviewMouseDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonDown
  - System.Windows.UIElement.PreviewMouseLeftButtonDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonUp
  - System.Windows.UIElement.PreviewMouseLeftButtonUpEvent
  - System.Windows.UIElement.PreviewMouseMove
  - System.Windows.UIElement.PreviewMouseMoveEvent
  - System.Windows.UIElement.PreviewMouseRightButtonDown
  - System.Windows.UIElement.PreviewMouseRightButtonDownEvent
  - System.Windows.UIElement.PreviewMouseRightButtonUp
  - System.Windows.UIElement.PreviewMouseRightButtonUpEvent
  - System.Windows.UIElement.PreviewMouseUp
  - System.Windows.UIElement.PreviewMouseUpEvent
  - System.Windows.UIElement.PreviewMouseWheel
  - System.Windows.UIElement.PreviewMouseWheelEvent
  - System.Windows.UIElement.PreviewQueryContinueDrag
  - System.Windows.UIElement.PreviewQueryContinueDragEvent
  - System.Windows.UIElement.PreviewStylusButtonDown
  - System.Windows.UIElement.PreviewStylusButtonDownEvent
  - System.Windows.UIElement.PreviewStylusButtonUp
  - System.Windows.UIElement.PreviewStylusButtonUpEvent
  - System.Windows.UIElement.PreviewStylusDown
  - System.Windows.UIElement.PreviewStylusDownEvent
  - System.Windows.UIElement.PreviewStylusInAirMove
  - System.Windows.UIElement.PreviewStylusInAirMoveEvent
  - System.Windows.UIElement.PreviewStylusInRange
  - System.Windows.UIElement.PreviewStylusInRangeEvent
  - System.Windows.UIElement.PreviewStylusMove
  - System.Windows.UIElement.PreviewStylusMoveEvent
  - System.Windows.UIElement.PreviewStylusOutOfRange
  - System.Windows.UIElement.PreviewStylusOutOfRangeEvent
  - System.Windows.UIElement.PreviewStylusSystemGesture
  - System.Windows.UIElement.PreviewStylusSystemGestureEvent
  - System.Windows.UIElement.PreviewStylusUp
  - System.Windows.UIElement.PreviewStylusUpEvent
  - System.Windows.UIElement.PreviewTextInput
  - System.Windows.UIElement.PreviewTextInputEvent
  - System.Windows.UIElement.PreviewTouchDown
  - System.Windows.UIElement.PreviewTouchDownEvent
  - System.Windows.UIElement.PreviewTouchMove
  - System.Windows.UIElement.PreviewTouchMoveEvent
  - System.Windows.UIElement.PreviewTouchUp
  - System.Windows.UIElement.PreviewTouchUpEvent
  - System.Windows.UIElement.QueryContinueDrag
  - System.Windows.UIElement.QueryContinueDragEvent
  - System.Windows.UIElement.QueryCursor
  - System.Windows.UIElement.QueryCursorEvent
  - System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.ReleaseAllTouchCaptures
  - System.Windows.UIElement.ReleaseMouseCapture
  - System.Windows.UIElement.ReleaseStylusCapture
  - System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.RenderSize
  - System.Windows.UIElement.RenderTransform
  - System.Windows.UIElement.RenderTransformOrigin
  - System.Windows.UIElement.RenderTransformOriginProperty
  - System.Windows.UIElement.RenderTransformProperty
  - System.Windows.UIElement.ShouldSerializeCommandBindings
  - System.Windows.UIElement.ShouldSerializeInputBindings
  - System.Windows.UIElement.SnapsToDevicePixels
  - System.Windows.UIElement.SnapsToDevicePixelsProperty
  - System.Windows.UIElement.StylusButtonDown
  - System.Windows.UIElement.StylusButtonDownEvent
  - System.Windows.UIElement.StylusButtonUp
  - System.Windows.UIElement.StylusButtonUpEvent
  - System.Windows.UIElement.StylusDown
  - System.Windows.UIElement.StylusDownEvent
  - System.Windows.UIElement.StylusEnter
  - System.Windows.UIElement.StylusEnterEvent
  - System.Windows.UIElement.StylusInAirMove
  - System.Windows.UIElement.StylusInAirMoveEvent
  - System.Windows.UIElement.StylusInRange
  - System.Windows.UIElement.StylusInRangeEvent
  - System.Windows.UIElement.StylusLeave
  - System.Windows.UIElement.StylusLeaveEvent
  - System.Windows.UIElement.StylusMove
  - System.Windows.UIElement.StylusMoveEvent
  - System.Windows.UIElement.StylusOutOfRange
  - System.Windows.UIElement.StylusOutOfRangeEvent
  - System.Windows.UIElement.StylusPlugIns
  - System.Windows.UIElement.StylusSystemGesture
  - System.Windows.UIElement.StylusSystemGestureEvent
  - System.Windows.UIElement.StylusUp
  - System.Windows.UIElement.StylusUpEvent
  - System.Windows.UIElement.TextInput
  - System.Windows.UIElement.TextInputEvent
  - System.Windows.UIElement.TouchDown
  - System.Windows.UIElement.TouchDownEvent
  - System.Windows.UIElement.TouchEnter
  - System.Windows.UIElement.TouchEnterEvent
  - System.Windows.UIElement.TouchesCaptured
  - System.Windows.UIElement.TouchesCapturedWithin
  - System.Windows.UIElement.TouchesDirectlyOver
  - System.Windows.UIElement.TouchesOver
  - System.Windows.UIElement.TouchLeave
  - System.Windows.UIElement.TouchLeaveEvent
  - System.Windows.UIElement.TouchMove
  - System.Windows.UIElement.TouchMoveEvent
  - System.Windows.UIElement.TouchUp
  - System.Windows.UIElement.TouchUpEvent
  - System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)
  - System.Windows.UIElement.Uid
  - System.Windows.UIElement.UidProperty
  - System.Windows.UIElement.UpdateLayout
  - System.Windows.UIElement.Visibility
  - System.Windows.UIElement.VisibilityProperty
  platform:
  - net462
- uid: System.Windows.Window.#ctor
  id: '#ctor'
  parent: System.Windows.Window
  langs:
  - csharp
  name: Window()
  nameWithType: Window.Window()
  fullName: System.Windows.Window.Window()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Windows.Window&quot;> </xref> класса."
  remarks: "Конструктор инициализирует <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>, и <xref:System.Windows.Window.Left%2A>Свойства по умолчанию <xref:System.Windows.Window>значения.</xref:System.Windows.Window> </xref:System.Windows.Window.Left%2A> </xref:System.Windows.Window.Top%2A> </xref:System.Windows.FrameworkElement.Height%2A> </xref:System.Windows.FrameworkElement.Width%2A>       Если окно создается в пределах <xref:System.AppDomain>с <xref:System.Windows.Application>объекта конструктор добавляет <xref:System.Windows.Window>объекта в набор <xref:System.Windows.Application>-управляемых windows через <xref:System.Windows.Application.Windows%2A>свойство <xref:System.Windows.Application>объекта.</xref:System.Windows.Application> </xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Application> </xref:System.Windows.Window> </xref:System.Windows.Application> </xref:System.AppDomain>"
  syntax:
    content: public Window ();
    parameters: []
  overload: System.Windows.Window.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Activate
  id: Activate
  parent: System.Windows.Window
  langs:
  - csharp
  name: Activate()
  nameWithType: Window.Activate()
  fullName: System.Windows.Window.Activate()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Пытается переместить окно на передний план и активирует его."
  remarks: "Правила, определяющие, имеет ли окно активироваться совпадают с используемыми [!INCLUDE[TLA2#tla_win32](~/add/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` функции (User32.dll).       Если окно активируется в [!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)] приложение, которое не является приложением пользователя переднего плана, <xref:System.Windows.Application.Activated>событие.</xref:System.Windows.Application.Activated>      Настроек [!NOTE] настроек этот метод нельзя вызывать, когда окно размещено в браузере."
  syntax:
    content: public bool Activate ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref href=&quot;System.Windows.Window&quot;> </xref> был успешно активирован; в противном случае — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Window.Activate*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Activated
  id: Activated
  parent: System.Windows.Window
  langs:
  - csharp
  name: Activated
  nameWithType: Window.Activated
  fullName: System.Windows.Window.Activated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит, когда окно становится окно переднего плана."
  remarks: "Окно активируется (попадает на передний план) при:-сначала открывается окно.      -Пользователь переключается на окно, выбрав его с помощью мыши, нажав клавиши ALT + TAB или из диспетчера задач.      -Пользователь нажимает кнопку панели задач.       Windows, которые необходимо обнаружить, когда они становятся активации можно обрабатывать событие Activated.       После активации окна он может деактивировать и повторно много раз за время своего существования. Если поведение или состояние приложения зависит от состояния его активации, его можно проверить, <xref:System.Windows.Window.IsActive%2A>Чтобы определить, какое состояние активации его с in.</xref:System.Windows.Window.IsActive%2A>       Приложение также может быть <xref:System.Windows.Application.Activated>.</xref:System.Windows.Application.Activated>"
  syntax:
    content: public event EventHandler Activated;
    return:
      type: System.EventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.AllowsTransparency
  id: AllowsTransparency
  parent: System.Windows.Window
  langs:
  - csharp
  name: AllowsTransparency
  nameWithType: Window.AllowsTransparency
  fullName: System.Windows.Window.AllowsTransparency
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает значение, указывающее, поддерживает ли клиентская область окна прозрачность."
  remarks: "Когда <xref:System.Windows.Controls.Control.Background%2A>окна свойству прозрачного цвета, с помощью <xref:System.Windows.Media.Brushes.Transparent%2A>к примеру, окно остается непрозрачное.</xref:System.Windows.Media.Brushes.Transparent%2A> </xref:System.Windows.Controls.Control.Background%2A> Это означает, что отображается рабочий стол и любые выполняемые операции «под окном». Чтобы включить этот тип прозрачности, AllowsTransparency должно быть присвоено `true`.       Существует AllowsTransparency позволяет создавать непрямоугольные окна и, следовательно, если AllowsTransparency имеет значение `true`, окна, <xref:System.Windows.Window.WindowStyle%2A>свойство должно быть присвоено <xref:System.Windows.WindowStyle>.</xref:System.Windows.WindowStyle> </xref:System.Windows.Window.WindowStyle%2A>      <a name=&quot;dependencyPropertyInfo_WindowAllowsTransparency&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.Window.AllowsTransparencyProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.Window.AllowsTransparencyProperty>"
  syntax:
    content: public bool AllowsTransparency { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если окно поддерживает прозрачность; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Window.AllowsTransparency*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Окна, которое имеет <xref:System.Windows.Window.WindowStyle*>значение любых данных, отличных от <xref href=&quot;System.Windows.WindowStyle&quot;> </xref>.</xref:System.Windows.Window.WindowStyle*>"
  platform:
  - net462
- uid: System.Windows.Window.AllowsTransparencyProperty
  id: AllowsTransparencyProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: AllowsTransparencyProperty
  nameWithType: Window.AllowsTransparencyProperty
  fullName: System.Windows.Window.AllowsTransparencyProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.Window.AllowsTransparency*>свойство зависимостей.</xref:System.Windows.Window.AllowsTransparency*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.ArrangeOverride(System.Windows.Size)
  id: ArrangeOverride(System.Windows.Size)
  parent: System.Windows.Window
  langs:
  - csharp
  name: ArrangeOverride(Size)
  nameWithType: Window.ArrangeOverride(Size)
  fullName: System.Windows.Window.ArrangeOverride(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Переопределите этот метод для упорядочения и задания размера окна и его дочерние элементы."
  remarks: "ArrangeOverride не вызывается, когда <xref:System.Windows.UIElement.Visibility%2A>свойство имеет значение <xref:System.Windows.Visibility>.</xref:System.Windows.Visibility> </xref:System.Windows.UIElement.Visibility%2A> Если значение <xref:System.Windows.UIElement.Visibility%2A>равно либо <xref:System.Windows.Visibility>или <xref:System.Windows.Visibility>, называется ArrangeOverride.</xref:System.Windows.Visibility> </xref:System.Windows.Visibility> </xref:System.Windows.UIElement.Visibility%2A>      Настроек [!NOTE] настроек при <xref:System.Windows.Window.Show%2A>или <xref:System.Windows.Window.ShowDialog%2A>вызываются <xref:System.Windows.UIElement.Visibility%2A>свойство <xref:System.Windows.Window>имеет значение <xref:System.Windows.Visibility>.</xref:System.Windows.Visibility> </xref:System.Windows.Window> </xref:System.Windows.UIElement.Visibility%2A> </xref:System.Windows.Window.ShowDialog%2A> </xref:System.Windows.Window.Show%2A>"
  syntax:
    content: protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);
    parameters:
    - id: arrangeBounds
      type: System.Windows.Size
      description: "Объект <xref href=&quot;System.Windows.Size&quot;> </xref> , которое отражает окончательный размер, который следует использовать окну для размещения себя и свои дочерние элементы."
    return:
      type: System.Windows.Size
      description: "Объект <xref href=&quot;System.Windows.Size&quot;> </xref> , которое отражает фактический размер, который был использован."
  overload: System.Windows.Window.ArrangeOverride*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Close
  id: Close
  parent: System.Windows.Window
  langs:
  - csharp
  name: Close()
  nameWithType: Window.Close()
  fullName: System.Windows.Window.Close()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Закрывает вручную <xref href=&quot;System.Windows.Window&quot;> </xref>."
  remarks: "Объект <xref:System.Windows.Window>может быть закрыто с помощью одного из нескольких хорошо известных, системных механизмов, расположенных в его заголовке, включая:-ALT + F4.</xref:System.Windows.Window>      -Меню система | **Close**.      - **Закрыть** кнопки.       <xref:System.Windows.Window>Может быть закрыто с помощью одного из нескольких хорошо известных механизмов в клиентской области, предоставляемых разработчиками, включая:- **файл** | **Выхода** в главном окне.</xref:System.Windows.Window>      -   **File** | **Закрыть** или **закрыть** кнопки для дочернего окна.      Настроек [!NOTE]  >   **ОК** и **отменить** кнопки в диалоговом окне также указан для разработчиков, несмотря на то что скорее всего будет задан <xref:System.Windows.Window.DialogResult%2A>, который автоматически закрывает окно, которое было открыто путем вызова <xref:System.Windows.Window.ShowDialog%2A>.</xref:System.Windows.Window.ShowDialog%2A> </xref:System.Windows.Window.DialogResult%2A>       Эти механизмы необходимо явно вызвать метод Close для закрытия окна.      Настроек [!NOTE] настроек при открытии окна, вызвав <xref:System.Windows.Window.ShowDialog%2A>и с <xref:System.Windows.Controls.Button>с его <xref:System.Windows.Controls.Button.IsCancel%2A>свойству задано значение true, автоматически закроется при нажатии кнопки либо или нажатия клавиши ESC.</xref:System.Windows.Controls.Button.IsCancel%2A> </xref:System.Windows.Controls.Button> </xref:System.Windows.Window.ShowDialog%2A> Если окно было открыто с помощью <xref:System.Windows.Window.Show%2A>, однако закройте должны быть явно вызываемые, например в результате <xref:System.Windows.Controls.Primitives.ButtonBase.Click>обработчик событий для <xref:System.Windows.Controls.Button>.</xref:System.Windows.Controls.Button> </xref:System.Windows.Controls.Primitives.ButtonBase.Click> </xref:System.Windows.Window.Show%2A>       Закрытие окна вызывает <xref:System.Windows.Window.Closing>быть активизировано событие.</xref:System.Windows.Window.Closing> Если <xref:System.Windows.Window.Closing>событий не отменяется, то происходит следующее: - <xref:System.Windows.Window>удаляется из <xref:System.Windows.Application.Windows%2A?displayProperty=fullName>(если <xref:System.Windows.Application>объект существует).</xref:System.Windows.Application> </xref:System.Windows.Application.Windows%2A?displayProperty=fullName> </xref:System.Windows.Window> </xref:System.Windows.Window.Closing>      - <xref:System.Windows.Window>Удаляется из владельца <xref:System.Windows.Window>Если владелец/собственное связь была установлена до принадлежащие <xref:System.Windows.Window>было показано и после владельца <xref:System.Windows.Window>был открыт.</xref:System.Windows.Window> </xref:System.Windows.Window> </xref:System.Windows.Window> </xref:System.Windows.Window>      - <xref:System.Windows.Window.Closed>События.</xref:System.Windows.Window.Closed>      -Неуправляемые ресурсы, созданные <xref:System.Windows.Window>удаляются.</xref:System.Windows.Window>      -Если <xref:System.Windows.Window.ShowDialog%2A>был вызван для отображения <xref:System.Windows.Window>, <xref:System.Windows.Window.ShowDialog%2A>возвращает.</xref:System.Windows.Window.ShowDialog%2A> </xref:System.Windows.Window> </xref:System.Windows.Window.ShowDialog%2A>       Закрытие <xref:System.Windows.Window>предписывает принадлежащих ему будет закрыта.</xref:System.Windows.Window> Кроме того, закрытие <xref:System.Windows.Window>может привести к остановке выполнения в зависимости от того как приложение <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=fullName>свойству.</xref:System.Windows.Application.ShutdownMode%2A?displayProperty=fullName> </xref:System.Windows.Window>      Настроек [!NOTE] настроек этот метод нельзя вызывать, когда окно размещено в браузере."
  example:
  - "The following example shows a **File** &#124; **Exit** menu being handled to explicitly call Close.  \n  \n [!code-xml[WindowCloseSnippets#WindowCloseXAML](~/add/codesnippet/xaml/WindowCloseSnippets.CSharp/MainWindow.xaml#windowclosexaml)]  \n  \n [!code-cs[WindowCloseSnippets#WindowCloseCODEBEHIND](~/add/codesnippet/csharp/WindowCloseSnippets.CSharp/MainWindow.xaml.cs#windowclosecodebehind)]\n [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/add/codesnippet/visualbasic/windowclosesnippets/mainwindow.xaml.vb#windowclosecodebehind)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Windows.Window.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Closed
  id: Closed
  parent: System.Windows.Window
  langs:
  - csharp
  name: Closed
  nameWithType: Window.Closed
  fullName: System.Windows.Window.Closed
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит при закрытии окна."
  remarks: "После данного события, не может быть закрытие окна предотвратить."
  syntax:
    content: public event EventHandler Closed;
    return:
      type: System.EventHandler
      description: "Для добавления."
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<>*настроек имеет значение, или <> </> *настроек, <> </> *настроек, или <> </> *настроек вызывается во время закрытия окна."
  platform:
  - net462
- uid: System.Windows.Window.Closing
  id: Closing
  parent: System.Windows.Window
  langs:
  - csharp
  name: Closing
  nameWithType: Window.Closing
  fullName: System.Windows.Window.Closing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит непосредственно после <xref:System.Windows.Window.Close*>вызывается и может быть использован для отмены закрытия окна.</xref:System.Windows.Window.Close*>"
  remarks: "Закрытие могут обрабатываться для обнаружения при закрытии окна (например, в том случае, когда <xref:System.Windows.Window.Close%2A>вызывается).</xref:System.Windows.Window.Close%2A> Кроме того закрытия можно использовать для предотвращения закрытия окна. Для предотвращения закрытия окна, можно задать <xref:System.ComponentModel.CancelEventArgs.Cancel%2A>Свойства <xref:System.ComponentModel.CancelEventArgs>аргумент `true`.</xref:System.ComponentModel.CancelEventArgs> </xref:System.ComponentModel.CancelEventArgs.Cancel%2A>       Событие закрытия при <xref:System.Windows.Window.Close%2A>вызывается, если щелкнуть кнопку закрытия окна или при нажатии клавиш ALT + F4.</xref:System.Windows.Window.Close%2A>       Если собственное окно был открыт с помощью окна его владельца <xref:System.Windows.Window.Show%2A>и закрытии окна-владельца, не возникает событие Closing собственное окно.</xref:System.Windows.Window.Show%2A> Если владелец окна закрывается (см. <xref:System.Windows.Window.Owner%2A>), закрывающая не возникает на собственное окно.</xref:System.Windows.Window.Owner%2A>       Если <xref:System.Windows.Application.Shutdown%2A>вызывается событие Closing для каждого окна вызывается событие.</xref:System.Windows.Application.Shutdown%2A> При отмене закрытия отмены учитывается.       При завершении сеанса, так как пользователь выходит из системы или завершает работу, не возникает закрытия; обрабатывать <xref:System.Windows.Application.SessionEnding>реализовать код, который отменяет закрытия приложения.</xref:System.Windows.Application.SessionEnding>       Если вы хотите показать или скрыть окно несколько раз в течение жизненного цикла приложения и не требуется при каждом ее видимой, повторного создания экземпляра окна, можно обработать событие Closing, отменить его и вызвать <xref:System.Windows.Window.Hide%2A>метод.</xref:System.Windows.Window.Hide%2A> Затем можно вызвать <xref:System.Windows.Window.Show%2A>в том же экземпляре, чтобы снова открыть его.</xref:System.Windows.Window.Show%2A>"
  example:
  - "The following example demonstrates a <xref:System.Windows.Window> that determines whether it needs user intervention to close.  \n  \n [!code-xml[WindowClosingSnippets#WindowClosingXAML1](~/add/codesnippet/xaml/WindowClosingSnippets.CSharp/DataWindow.xaml#windowclosingxaml1)]  \n[!code-xml[WindowClosingSnippets#WindowClosingXAML2](~/add/codesnippet/xaml/WindowClosingSnippets.CSharp/DataWindow.xaml#windowclosingxaml2)]  \n  \n [!code-cs[WindowClosingSnippets#WindowClosingCODEBEHIND1](~/add/codesnippet/csharp/WindowClosingSnippets.CSharp/DataWindow.xaml.cs#windowclosingcodebehind1)]\n [!code-vb[WindowClosingSnippets#WindowClosingCODEBEHIND1](~/add/codesnippet/visualbasic/windowclosingsnippets/datawindow.xaml.vb#windowclosingcodebehind1)]  \n[!code-cs[WindowClosingSnippets#WindowClosingCODEBEHIND2](~/add/codesnippet/csharp/WindowClosingSnippets.CSharp/DataWindow.xaml.cs#windowclosingcodebehind2)]\n[!code-vb[WindowClosingSnippets#WindowClosingCODEBEHIND2](~/add/codesnippet/visualbasic/windowclosingsnippets/datawindow.xaml.vb#windowclosingcodebehind2)]"
  syntax:
    content: public event System.ComponentModel.CancelEventHandler Closing;
    return:
      type: System.ComponentModel.CancelEventHandler
      description: "Для добавления."
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<>*настроек имеет значение, или <> </> *настроек, <> </> *настроек, или <> </> *настроек вызывается во время закрытия окна."
  platform:
  - net462
- uid: System.Windows.Window.ContentRendered
  id: ContentRendered
  parent: System.Windows.Window
  langs:
  - csharp
  name: ContentRendered
  nameWithType: Window.ContentRendered
  fullName: System.Windows.Window.ContentRendered
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит после завершения отображения содержимого окна."
  remarks: "Если окно не имеет содержимого, это событие не возникает."
  syntax:
    content: public event EventHandler ContentRendered;
    return:
      type: System.EventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Deactivated
  id: Deactivated
  parent: System.Windows.Window
  langs:
  - csharp
  name: Deactivated
  nameWithType: Window.Deactivated
  fullName: System.Windows.Window.Deactivated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит при выведении окна на задний план."
  remarks: "Окно деактивируется (попадает на задний план) при:-пользователь переключается на другое окно в текущем приложении.      -Пользователь переключается на окно в другом приложении, с помощью клавиш ALT + TAB или с помощью диспетчера задач.      -Пользователь нажимает кнопку панели задач для окна в другое приложение.       Windows, которые необходимо обнаружить, когда они становятся деактивированный обработки событий деактивирован.       После деактивации окна его повторной активации и деактивации множество раз за время существования. Если поведение или состояние приложения зависит от состояния его активации, его можно проверить, <xref:System.Windows.Window.IsActive%2A>Чтобы определить, какое состояние активации его с in.</xref:System.Windows.Window.IsActive%2A>       Приложение также может быть <xref:System.Windows.Application.Deactivated>.</xref:System.Windows.Application.Deactivated>"
  syntax:
    content: public event EventHandler Deactivated;
    return:
      type: System.EventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.DialogResult
  id: DialogResult
  parent: System.Windows.Window
  langs:
  - csharp
  name: DialogResult
  nameWithType: Window.DialogResult
  fullName: System.Windows.Window.DialogResult
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает значение результат диалогового окна, которое является значением, которое возвращается из <xref:System.Windows.Window.ShowDialog*>метод.</xref:System.Windows.Window.ShowDialog*>"
  remarks: "DialogResult можно использовать из кода, в который было показано диалоговое окно для определения того, приняты ли пользователь (`true`) или отменена (`false`) диалоговое окно. Если диалоговое окно было принято, это означает для кода, который открывается диалоговое окно для получения данных, собранных с пользователем и его. Если диалоговое окно было отменено, однако это означает, что вызывающему коду следует прекратить дальнейшую обработку.       По умолчанию диалоговое окно отменяется, когда пользователь выполняет одно из следующих:-PressesALT + F4.      -Щелкает **закрыть** кнопки.      -Выбор **закрыть** в системном меню.       Во всех этих случаях DialogResult — `false` по умолчанию.       Диалоговое окно обычно предоставляет отдельную кнопку, чтобы закрыть диалоговое окно, который является кнопкой которого <xref:System.Windows.Controls.Button.IsCancel%2A>свойству `true`.</xref:System.Windows.Controls.Button.IsCancel%2A> Кнопка, настроенная таким образом автоматически закроется окно при нажатии или при нажатии клавиши ESC. В любом из этих случаев, остается DialogResult `false`.       Диалоговое окно также обычно предоставляет кнопки «принять», который является кнопкой которого <xref:System.Windows.Controls.Button.IsDefault%2A>свойству `true`.</xref:System.Windows.Controls.Button.IsDefault%2A> Кнопка, настроенная таким образом будет вызывать его <xref:System.Windows.Controls.Primitives.ButtonBase.Click>событие при нажатии ее или клавишу ВВОД.</xref:System.Windows.Controls.Primitives.ButtonBase.Click> Тем не менее, он не будет автоматически закрыто диалоговым окном, нельзя будет задать DialogResult `true`. Необходимо вручную записать этот код, обычно из <xref:System.Windows.Controls.Primitives.ButtonBase.Click>обработчик событий для кнопки по умолчанию.</xref:System.Windows.Controls.Primitives.ButtonBase.Click>       DialogResult — `null` при отображении диалогового окна но принятые ни отменена.       После закрытия диалогового окна можно получить результат диалогового окна из значения, возвращенного <xref:System.Windows.Window.ShowDialog%2A>метод, или путем проверки свойства DialogResult.</xref:System.Windows.Window.ShowDialog%2A>       DialogResult можно задать только при <xref:System.Windows.Window>открытия путем вызова его <xref:System.Windows.Window.ShowDialog%2A>метод.</xref:System.Windows.Window.ShowDialog%2A> </xref:System.Windows.Window>      Настроек [!NOTE] настроек не удается задать или получить значение этого свойства, если окно размещено в браузере."
  example:
  - "The following example shows how to configure an OK button and a Cancel button to return the appropriate DialogResult.  \n  \n [!code-xml[WindowDialogResultSnippets#WindowDialogResultXAML](~/add/codesnippet/xaml/WindowDialogResultSnippets.CSharp/DialogBox.xaml#windowdialogresultxaml)]  \n  \n [!code-cs[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/add/codesnippet/csharp/WindowDialogResultSnippets.CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]\n [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/add/codesnippet/visualbasic/windowdialogresultsnippets/dialogbox.xaml.vb#windowdialogresultcodebehind)]"
  syntax:
    content: public Nullable<bool> DialogResult { get; set; }
    return:
      type: System.Nullable{System.Boolean}
      description: "Объект &lt;xref:System.Nullable%601&gt; значение типа <xref:System.Boolean>.</xref:System.Boolean> Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Window.DialogResult*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Имеет значение DialogResult до открытия окна путем вызова <> </> *настроек.       - или - имеет значение DialogResult в окне, которое открывается вызовом <> </> *настроек."
  platform:
  - net462
- uid: System.Windows.Window.DpiChanged
  id: DpiChanged
  parent: System.Windows.Window
  langs:
  - csharp
  name: DpiChanged
  nameWithType: Window.DpiChanged
  fullName: System.Windows.Window.DpiChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит после изменения отображения разрешение экрана, на котором находится окна."
  syntax:
    content: public event System.Windows.DpiChangedEventHandler DpiChanged;
    return:
      type: System.Windows.DpiChangedEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.DpiChangedEvent
  id: DpiChangedEvent
  parent: System.Windows.Window
  langs:
  - csharp
  name: DpiChangedEvent
  nameWithType: Window.DpiChangedEvent
  fullName: System.Windows.Window.DpiChangedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Объект <xref href=&quot;System.Windows.RoutedEvent&quot;> </xref> когда DPI экрана окна находится на изменения."
  syntax:
    content: public static readonly System.Windows.RoutedEvent DpiChangedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.DragMove
  id: DragMove
  parent: System.Windows.Window
  langs:
  - csharp
  name: DragMove()
  nameWithType: Window.DragMove()
  fullName: System.Windows.Window.DragMove()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Разрешает окну перетаскивать мышью с нажатой левой кнопкой над открытой клиентской области окна."
  remarks: "Левая кнопка мыши должна быть отключена, при вызове DragMove. Является одним из способов определить при нажатии левой кнопки мыши для обработки <xref:System.Windows.UIElement.MouseLeftButtonDown>событий.</xref:System.Windows.UIElement.MouseLeftButtonDown>       При вызове DragMove необходимо нажата левая кнопка мыши над открытой клиентской области окна.      Настроек [!NOTE] настроек этот метод нельзя вызывать, когда окно размещено в браузере."
  example:
  - "The following example shows how to override <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> to call DragMove.  \n  \n [!code-cs[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/add/codesnippet/csharp/WindowDragMoveSnippets/MainWindow.xaml.cs#callwindowdragmovecodebehind)]\n [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/add/codesnippet/visualbasic/windowdragmovesnippets/mainwindow.xaml.vb#callwindowdragmovecodebehind)]"
  syntax:
    content: public void DragMove ();
    parameters: []
  overload: System.Windows.Window.DragMove*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Левая кнопка мыши не нажата."
  platform:
  - net462
- uid: System.Windows.Window.GetWindow(System.Windows.DependencyObject)
  id: GetWindow(System.Windows.DependencyObject)
  parent: System.Windows.Window
  langs:
  - csharp
  name: GetWindow(DependencyObject)
  nameWithType: Window.GetWindow(DependencyObject)
  fullName: System.Windows.Window.GetWindow(DependencyObject)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает ссылку на <xref href=&quot;System.Windows.Window&quot;> </xref> объект, содержащий дерево содержимого, в котором расположен объект зависимостей."
  syntax:
    content: public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);
    parameters:
    - id: dependencyObject
      type: System.Windows.DependencyObject
      description: "Объект зависимости."
    return:
      type: System.Windows.Window
      description: "Объект <xref href=&quot;System.Windows.Window&quot;> </xref> ссылку на главное окно."
  overload: System.Windows.Window.GetWindow*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>dependencyObject</code>имеет значение null."
  platform:
  - net462
- uid: System.Windows.Window.Hide
  id: Hide
  parent: System.Windows.Window
  langs:
  - csharp
  name: Hide()
  nameWithType: Window.Hide()
  fullName: System.Windows.Window.Hide()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Делает окно невидимым."
  remarks: "Окно не закрывается после скрыта и ни <xref:System.Windows.Window.Closing>, ни <xref:System.Windows.Window.Closed>события.</xref:System.Windows.Window.Closed> </xref:System.Windows.Window.Closing> Вместо этого окна <xref:System.Windows.UIElement.Visibility%2A>свойству <xref:System.Windows.Visibility?displayProperty=fullName>.</xref:System.Windows.Visibility?displayProperty=fullName> </xref:System.Windows.UIElement.Visibility%2A>       Если окно приложения <xref:System.Windows.Application.MainWindow%2A>и приложения <xref:System.Windows.Application.ShutdownMode%2A>— <xref:System.Windows.ShutdownMode>, приложение не завершает работу.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application.MainWindow%2A> Аналогичным образом приложения не завершена, если окно только окно и режим завершения работы приложения <xref:System.Windows.ShutdownMode>.</xref:System.Windows.ShutdownMode>       Если нужно показать или скрыть окно несколько раз в течение жизненного цикла приложения, и вы не хотите повторно создать экземпляр окна при каждом ее видимой, может обрабатывать <xref:System.Windows.Window.Closing>события, отменить его и вызвать метод скрыть.</xref:System.Windows.Window.Closing> Затем можно вызвать <xref:System.Windows.Window.Show%2A>в том же экземпляре, чтобы повторно открыть его.</xref:System.Windows.Window.Show%2A>"
  syntax:
    content: public void Hide ();
    parameters: []
  overload: System.Windows.Window.Hide*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Скрыть вызывается в окне, которое закрывает (<xref href=&quot;System.Windows.Window.Closing&quot;></xref>) или был закрыт (<xref href=&quot;System.Windows.Window.Closed&quot;></xref>)."
  platform:
  - net462
- uid: System.Windows.Window.Icon
  id: Icon
  parent: System.Windows.Window
  langs:
  - csharp
  name: Icon
  nameWithType: Window.Icon
  fullName: System.Windows.Window.Icon
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает значок окна."
  remarks: "[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]Автономные приложения имеют два вида значков:-одна сборка значок, который задается с помощью `<ApplicationIcon>` файл сборки свойство в проекте приложения. Этот значок используется на рабочем столе для сборки.          Настроек [!NOTE] настроек при отладке в Visual Studio значка может отсутствовать из-за процесса размещения. При запуске исполняемого файла, то появляется значок. Дополнительные сведения см. в разделе [размещение процесс (vshost.exe)](~/add/includes/ajax-current-ext-md.md).      — Один значок каждого окна, который задается параметром значок. Для каждого окна этот значок используется в строке заголовка кнопке панели задач и его элемент списка выбора приложения ALT TAB.       Объект [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] окно всегда отображается значок. Если значение не указано, задав значок [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] выбирает значок для отображения на основе следующих правил: 1.  Используйте значок сборки, если указан.      2.  Если значок сборки не указан, используется значение по умолчанию [!INCLUDE[TLA#tla_win](~/add/includes/ajax-current-ext-md.md)] значок.       Если значок позволяет указать значок пользовательского окна, можно восстановить значок приложения по умолчанию, установив значок `null`.       Один значок может использоваться различными способами в [!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)], включая показывается в строке заголовка окна, на панели задач для окна, список выбора файлов ALT + TAB. Каждый из них будет отображаться значок разного размера; значок 16 x 16 пикселей отображается в строке заголовка окна и на панели задач, пока значок 32 x 32 пикселя отображается в списке выбора файлов ALT + TAB. Некоторые приложения, например [!INCLUDE[TLA#tla_winexpl](~/add/includes/tlasharptla-winexpl-md.md)], предоставляют **представление** меню, в котором можно выбрать размер значка, который вы хотите просмотреть.       Чтобы ориентироваться на различные размеры, файл значка состоит из одного или нескольких реальных значков, каждый из которых представляет версии значка, который предназначен для определенной глубины размер и цвет. Например один значок может иметь только один значок 16 x 16 точек с 16 цветами, а другой — 16 x 16 точек и 32 x 32 пикселя значков с 16 цветами и 256 цветов.       Если существуют значки всех возможных размеров и цветов в файл значка <xref:System.Windows.Window>будет использовать соответствующий значок.</xref:System.Windows.Window> Если файл значка содержит только подмножество всех возможных значков <xref:System.Windows.Window>использует Далее наиболее соответствующий значок в порядке уменьшения размеров и цветов.</xref:System.Windows.Window>       Результатом является то, что значок будет всегда использоваться <xref:System.Windows.Window>, несмотря на то, что значок, используемый целевыми могут быть не требуется глубину размер и цвет.</xref:System.Windows.Window> Значок 16 x 16 точек с 16 цветами может использоваться для отображения как значок 32 x 32 точки с 256 цветами. Это может вызвать нежелательные визуальные эффекты, такие как пиксиляцию, но можно избежать, создавая значки всех целевых размеров и цветов.      Настроек [!NOTE] настроек не удается задать или получить значение этого свойства, если окно размещено в браузере.      <a name=&quot;dependencyPropertyInfo_WindowIcon&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.Window.IconProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.Window.IconProperty>"
  example:
  - "The following example shows how to set a window icon.  \n  \n [!code-xml[WindowIconSnippets#WindowIconSetXAML](~/add/codesnippet/xaml/WindowIconSnippets.WindowIconSample/MainWindow.xaml#windowiconsetxaml)]  \n  \n [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/add/codesnippet/visualbasic/windowiconsample/mainwindow.xaml.vb#setwindowiconincode)]\n [!code-cs[WindowIconSnippets#SetWindowIconInCode](~/add/codesnippet/csharp/WindowIconSnippets.WindowIconSample/MainWindow.xaml.cs#setwindowiconincode)]"
  syntax:
    content: public System.Windows.Media.ImageSource Icon { get; set; }
    return:
      type: System.Windows.Media.ImageSource
      description: "<xref href=&quot;System.Windows.Media.ImageSource&quot;> </xref> , Представляющий значок."
  overload: System.Windows.Window.Icon*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.IconProperty
  id: IconProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: IconProperty
  nameWithType: Window.IconProperty
  fullName: System.Windows.Window.IconProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.Window.Icon*>свойство зависимостей.</xref:System.Windows.Window.Icon*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IconProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.IsActive
  id: IsActive
  parent: System.Windows.Window
  langs:
  - csharp
  name: IsActive
  nameWithType: Window.IsActive
  fullName: System.Windows.Window.IsActive
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает значение, указывающее, активна ли окно."
  remarks: "Активное окно пользователя текущее окно переднего плана и имеет фокус, принятое active внешний вид заголовка окна. Активного окна также будет самый верхний всех окон верхнего уровня, в которых не задано явно <xref:System.Windows.Window.Topmost%2A>свойство.</xref:System.Windows.Window.Topmost%2A>      <a name=&quot;dependencyPropertyInfo_WindowIsActive&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.Window.IsActiveProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.Window.IsActiveProperty>"
  syntax:
    content: public bool IsActive { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если окно является активным; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Window.IsActive*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.IsActiveProperty
  id: IsActiveProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: IsActiveProperty
  nameWithType: Window.IsActiveProperty
  fullName: System.Windows.Window.IsActiveProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.Window.IsActive*>свойство зависимостей.</xref:System.Windows.Window.IsActive*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty IsActiveProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Left
  id: Left
  parent: System.Windows.Window
  langs:
  - csharp
  name: Left
  nameWithType: Window.Left
  fullName: System.Windows.Window.Left
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает позицию левого края окна относительно рабочего стола."
  remarks: "Если <xref:System.Windows.Window>развернуто или развернуто, это значение соответствует левого края восстановления точки для <xref:System.Windows.Window>.</xref:System.Windows.Window> </xref:System.Windows.Window>       Это свойство нельзя задать с помощью стиля.       Если значение не указано, то значение по умолчанию имеет значение слева. Можно также указать значение по умолчанию, задав влево, чтобы <xref:System.Double.NaN>.</xref:System.Double.NaN> Ни <xref:System.Double.NegativeInfinity>, ни <xref:System.Double.PositiveInfinity>является допустимым значением для слева.</xref:System.Double.PositiveInfinity> </xref:System.Double.NegativeInfinity>      Настроек [!NOTE] настроек не удается задать или получить значение этого свойства, если окно размещено в браузере.      <a name=&quot;dependencyPropertyInfo_WindowLeft&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.Window.LeftProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.Window.LeftProperty>"
  syntax:
    content: public double Left { get; set; }
    return:
      type: System.Double
      description: "Положение окна левого края в логических единицах (1/96 дюйма)."
  overload: System.Windows.Window.Left*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.LeftProperty
  id: LeftProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: LeftProperty
  nameWithType: Window.LeftProperty
  fullName: System.Windows.Window.LeftProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.Window.Left*>свойство зависимостей.</xref:System.Windows.Window.Left*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LeftProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.LocationChanged
  id: LocationChanged
  parent: System.Windows.Window
  langs:
  - csharp
  name: LocationChanged
  nameWithType: Window.LocationChanged
  fullName: System.Windows.Window.LocationChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит при изменении положения окна."
  remarks: "При изменении местоположения окна:-пользователь передвигает окно, перетащив заголовок окна.      -Поменять окна <xref:System.Windows.Window.DragMove%2A>называется.</xref:System.Windows.Window.DragMove%2A>      -Либо <xref:System.Windows.Window.Left%2A>или <xref:System.Windows.Window.Top%2A>задано программным путем.</xref:System.Windows.Window.Top%2A> </xref:System.Windows.Window.Left%2A>      - **Переместить** выбранного пункта меню окна системного меню.      - <xref:System.Windows.Window.WindowState%2A>Изменить свойство.</xref:System.Windows.Window.WindowState%2A>"
  syntax:
    content: public event EventHandler LocationChanged;
    return:
      type: System.EventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.LogicalChildren
  id: LogicalChildren
  parent: System.Windows.Window
  langs:
  - csharp
  name: LogicalChildren
  nameWithType: Window.LogicalChildren
  fullName: System.Windows.Window.LogicalChildren
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает перечислитель для логических дочерних окон элементов."
  syntax:
    content: protected override System.Collections.IEnumerator LogicalChildren { get; }
    return:
      type: System.Collections.IEnumerator
      description: "<xref:System.Collections.IEnumerator>Окна логических дочерних элементов.</xref:System.Collections.IEnumerator>"
  overload: System.Windows.Window.LogicalChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.MeasureOverride(System.Windows.Size)
  id: MeasureOverride(System.Windows.Size)
  parent: System.Windows.Window
  langs:
  - csharp
  name: MeasureOverride(Size)
  nameWithType: Window.MeasureOverride(Size)
  fullName: System.Windows.Window.MeasureOverride(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Переопределите этот метод для определения размера окна."
  remarks: "MeasureOverride не вызывается, когда <xref:System.Windows.UIElement.Visibility%2A>свойство имеет значение <xref:System.Windows.Visibility>.</xref:System.Windows.Visibility> </xref:System.Windows.UIElement.Visibility%2A> Если значение <xref:System.Windows.UIElement.Visibility%2A>равно либо <xref:System.Windows.Visibility>или <xref:System.Windows.Visibility>, называется MeasureOverride.</xref:System.Windows.Visibility> </xref:System.Windows.Visibility> </xref:System.Windows.UIElement.Visibility%2A>      Настроек [!NOTE] настроек при <xref:System.Windows.Window.Show%2A>или <xref:System.Windows.Window.ShowDialog%2A>вызываются <xref:System.Windows.UIElement.Visibility%2A>свойство <xref:System.Windows.Window>имеет значение <xref:System.Windows.Visibility>.</xref:System.Windows.Visibility> </xref:System.Windows.Window> </xref:System.Windows.UIElement.Visibility%2A> </xref:System.Windows.Window.ShowDialog%2A> </xref:System.Windows.Window.Show%2A>"
  syntax:
    content: protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);
    parameters:
    - id: availableSize
      type: System.Windows.Size
      description: "Объект <xref href=&quot;System.Windows.Size&quot;> </xref> , которое отражает доступный размер, который в этом окне можно предоставить дочернему элементу. Можно задать бесконечное значение для указания, что окно будет масштабироваться любым содержимым."
    return:
      type: System.Windows.Size
      description: "Объект <xref href=&quot;System.Windows.Size&quot;> </xref> , которое отражает размер, который определяет это окно требуется во время структурирования, основываясь на вычисления размеров дочерних элементов."
  overload: System.Windows.Window.MeasureOverride*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnActivated(System.EventArgs)
  id: OnActivated(System.EventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnActivated(EventArgs)
  nameWithType: Window.OnActivated(EventArgs)
  fullName: System.Windows.Window.OnActivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Window.Activated&quot;> </xref> событий."
  remarks: "Вызывает OnActivated <xref:System.Windows.Window.Activated>событий.</xref:System.Windows.Window.Activated>       Тип, производный от <xref:System.Windows.Window>могут переопределять OnActivated.</xref:System.Windows.Window> Переопределенный метод должен вызвать метод OnActivated базового класса, если <xref:System.Windows.Window.Activated>должен вызываться.</xref:System.Windows.Window.Activated>"
  syntax:
    content: protected virtual void OnActivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>, Содержащий данные события.</xref:System.EventArgs>"
  overload: System.Windows.Window.OnActivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnClosed(System.EventArgs)
  id: OnClosed(System.EventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnClosed(EventArgs)
  nameWithType: Window.OnClosed(EventArgs)
  fullName: System.Windows.Window.OnClosed(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Window.Closed&quot;> </xref> событий."
  remarks: "Вызывает OnClosed <xref:System.Windows.Window.Closed>событий.</xref:System.Windows.Window.Closed>       Тип, производный от <xref:System.Windows.Window>могут переопределять OnClosed.</xref:System.Windows.Window> Переопределенный метод необходимо вызвать OnClosed базового класса, если <xref:System.Windows.Window.Closed>должен вызываться.</xref:System.Windows.Window.Closed>"
  syntax:
    content: protected virtual void OnClosed (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>, Содержащий данные события.</xref:System.EventArgs>"
  overload: System.Windows.Window.OnClosed*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)
  id: OnClosing(System.ComponentModel.CancelEventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnClosing(CancelEventArgs)
  nameWithType: Window.OnClosing(CancelEventArgs)
  fullName: System.Windows.Window.OnClosing(CancelEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Window.Closing&quot;> </xref> событий."
  remarks: "Вызывает OnClosing <xref:System.Windows.Window.Closing>событий.</xref:System.Windows.Window.Closing>       Тип, производный от <xref:System.Windows.Window>могут переопределять OnClosing.</xref:System.Windows.Window> Переопределенный метод должен вызвать метод OnClosing базового класса, если <xref:System.Windows.Window.Closing>должен вызываться.</xref:System.Windows.Window.Closing>"
  syntax:
    content: protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);
    parameters:
    - id: e
      type: System.ComponentModel.CancelEventArgs
      description: "Объект <xref:System.ComponentModel.CancelEventArgs>, содержащий данные события.</xref:System.ComponentModel.CancelEventArgs>"
  overload: System.Windows.Window.OnClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnContentChanged(System.Object,System.Object)
  id: OnContentChanged(System.Object,System.Object)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnContentChanged(Object,Object)
  nameWithType: Window.OnContentChanged(Object,Object)
  fullName: System.Windows.Window.OnContentChanged(Object,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывается, когда <xref:System.Windows.Controls.ContentControl.Content*>изменения свойств.</xref:System.Windows.Controls.ContentControl.Content*>"
  syntax:
    content: protected override void OnContentChanged (object oldContent, object newContent);
    parameters:
    - id: oldContent
      type: System.Object
      description: "Ссылка на корневой элемент старого дерева содержимого."
    - id: newContent
      type: System.Object
      description: "Ссылка на корневой элемент нового дерева содержимого."
  overload: System.Windows.Window.OnContentChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnContentRendered(System.EventArgs)
  id: OnContentRendered(System.EventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnContentRendered(EventArgs)
  nameWithType: Window.OnContentRendered(EventArgs)
  fullName: System.Windows.Window.OnContentRendered(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Window.ContentRendered&quot;> </xref> событий."
  remarks: "Вызывает OnContentRendered <xref:System.Windows.Window.ContentRendered>событий.</xref:System.Windows.Window.ContentRendered>       Тип, производный от <xref:System.Windows.Window>могут переопределять OnContentRendered.</xref:System.Windows.Window> Переопределенный метод должен вызвать метод OnContentRendered базового класса, если <xref:System.Windows.Window.ContentRendered>должен вызываться.</xref:System.Windows.Window.ContentRendered>"
  syntax:
    content: protected virtual void OnContentRendered (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>, Содержащий данные события.</xref:System.EventArgs>"
  overload: System.Windows.Window.OnContentRendered*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnCreateAutomationPeer
  id: OnCreateAutomationPeer
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnCreateAutomationPeer()
  nameWithType: Window.OnCreateAutomationPeer()
  fullName: System.Windows.Window.OnCreateAutomationPeer()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Создает и возвращает <xref href=&quot;System.Windows.Automation.Peers.WindowAutomationPeer&quot;> </xref> для этого объекта <xref href=&quot;System.Windows.Window&quot;> </xref>."
  remarks: "Этот метод переопределяет <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.</xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>"
  syntax:
    content: protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();
    parameters: []
    return:
      type: System.Windows.Automation.Peers.AutomationPeer
      description: "A <xref href=&quot;System.Windows.Automation.Peers.WindowAutomationPeer&quot;></xref> object for this <xref href=&quot;System.Windows.Window&quot;></xref>."
  overload: System.Windows.Window.OnCreateAutomationPeer*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnDeactivated(System.EventArgs)
  id: OnDeactivated(System.EventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnDeactivated(EventArgs)
  nameWithType: Window.OnDeactivated(EventArgs)
  fullName: System.Windows.Window.OnDeactivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Window.Deactivated&quot;> </xref> событий."
  remarks: "Вызывает OnDeactivated <xref:System.Windows.Window.Deactivated>событий.</xref:System.Windows.Window.Deactivated>       Тип, производный от <xref:System.Windows.Window>могут переопределять OnDeactivated.</xref:System.Windows.Window> Переопределенный метод необходимо вызвать OnDeactivated базового класса, если <xref:System.Windows.Window.Deactivated>должен вызываться.</xref:System.Windows.Window.Deactivated>"
  syntax:
    content: protected virtual void OnDeactivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>, Содержащий данные события.</xref:System.EventArgs>"
  overload: System.Windows.Window.OnDeactivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)
  id: OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnDpiChanged(DpiScale,DpiScale)
  nameWithType: Window.OnDpiChanged(DpiScale,DpiScale)
  fullName: System.Windows.Window.OnDpiChanged(DpiScale,DpiScale)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывается, когда DPI, когда это окно отображается изменения."
  syntax:
    content: protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);
    parameters:
    - id: oldDpi
      type: System.Windows.DpiScale
      description: "Установка предыдущих точек на ДЮЙМ масштаб."
    - id: newDpi
      type: System.Windows.DpiScale
      description: "Новый параметр DPI масштаб."
  overload: System.Windows.Window.OnDpiChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnLocationChanged(System.EventArgs)
  id: OnLocationChanged(System.EventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnLocationChanged(EventArgs)
  nameWithType: Window.OnLocationChanged(EventArgs)
  fullName: System.Windows.Window.OnLocationChanged(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Window.LocationChanged&quot;> </xref> событий."
  remarks: "Вызывает OnLocationChanged <xref:System.Windows.Window.LocationChanged>событий.</xref:System.Windows.Window.LocationChanged>       Тип, производный от <xref:System.Windows.Window>могут переопределять OnLocationChanged.</xref:System.Windows.Window> Переопределенный метод должен вызвать метод OnLocationChanged базового класса, если <xref:System.Windows.Window.LocationChanged>должен вызываться.</xref:System.Windows.Window.LocationChanged>"
  syntax:
    content: protected virtual void OnLocationChanged (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>, Содержащий данные события.</xref:System.EventArgs>"
  overload: System.Windows.Window.OnLocationChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  id: OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
  nameWithType: Window.OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
  fullName: System.Windows.Window.OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывается, когда <xref href=&quot;System.Windows.UIElement.ManipulationBoundaryFeedback&quot;> </xref> событием."
  remarks: "Эта реализация не изменяет состояние обработки ( <xref:System.Windows.RoutedEventArgs.Handled%2A>свойство) из <xref:System.Windows.UIElement.ManipulationBoundaryFeedback>данные события.</xref:System.Windows.UIElement.ManipulationBoundaryFeedback> </xref:System.Windows.RoutedEventArgs.Handled%2A>"
  syntax:
    content: protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Input.ManipulationBoundaryFeedbackEventArgs
      description: "Данные для события."
  overload: System.Windows.Window.OnManipulationBoundaryFeedback*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnSourceInitialized(System.EventArgs)
  id: OnSourceInitialized(System.EventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnSourceInitialized(EventArgs)
  nameWithType: Window.OnSourceInitialized(EventArgs)
  fullName: System.Windows.Window.OnSourceInitialized(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Window.SourceInitialized&quot;> </xref> событий."
  remarks: "Вызывает OnSourceInitialized <xref:System.Windows.Window.SourceInitialized>событий.</xref:System.Windows.Window.SourceInitialized>       Тип, производный от <xref:System.Windows.Window>могут переопределять OnSourceInitialized.</xref:System.Windows.Window> Переопределенный метод должен вызвать метод OnSourceInitialized базового класса, если <xref:System.Windows.Window.SourceInitialized>должен вызываться.</xref:System.Windows.Window.SourceInitialized>"
  syntax:
    content: protected virtual void OnSourceInitialized (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>, Содержащий данные события.</xref:System.EventArgs>"
  overload: System.Windows.Window.OnSourceInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnStateChanged(System.EventArgs)
  id: OnStateChanged(System.EventArgs)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnStateChanged(EventArgs)
  nameWithType: Window.OnStateChanged(EventArgs)
  fullName: System.Windows.Window.OnStateChanged(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.Window.StateChanged&quot;> </xref> событий."
  remarks: "Вызывает OnStateChanged <xref:System.Windows.Window.StateChanged>событий.</xref:System.Windows.Window.StateChanged>       Тип, производный от <xref:System.Windows.Window>могут переопределять OnStateChanged.</xref:System.Windows.Window> Переопределенный метод должен вызвать метод OnStateChanged базового класса, если <xref:System.Windows.Window.StateChanged>должен вызываться.</xref:System.Windows.Window.StateChanged>"
  syntax:
    content: protected virtual void OnStateChanged (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>, Содержащий данные события.</xref:System.EventArgs>"
  overload: System.Windows.Window.OnStateChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)
  id: OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.Window
  langs:
  - csharp
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: Window.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.Window.OnVisualParentChanged(DependencyObject)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывается при изменении родительского окна."
  syntax:
    content: protected override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);
    parameters:
    - id: oldParent
      type: System.Windows.DependencyObject
      description: "Предыдущий родительский элемент. Значение null, если <xref href=&quot;System.Windows.DependencyObject&quot;> </xref> отсутствует предыдущий родительский."
  overload: System.Windows.Window.OnVisualParentChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.OwnedWindows
  id: OwnedWindows
  parent: System.Windows.Window
  langs:
  - csharp
  name: OwnedWindows
  nameWithType: Window.OwnedWindows
  fullName: System.Windows.Window.OwnedWindows
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает коллекцию окон, владельцем которых является в этом окне."
  remarks: "Собственное окно — это которого <xref:System.Windows.Window.Owner%2A>свойству со ссылкой на другое окно, которая называется окно-владелец.</xref:System.Windows.Window.Owner%2A> Чтобы найти все окна, которыми владеет окно-владелец, можно перечислить <xref:System.Windows.WindowCollection>, возвращаемого свойством OwnedWindows.</xref:System.Windows.WindowCollection>"
  example:
  - "The following example shows how to enumerate OwnedWindows.  \n  \n [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/add/codesnippet/visualbasic/windowownerownedwindowssnippets/mainwindow.xaml.vb#getwindowownedwindowscode)]\n [!code-cs[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/add/codesnippet/csharp/WindowOwnerOwnedWindowsSnippets.CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]"
  syntax:
    content: public System.Windows.WindowCollection OwnedWindows { get; }
    return:
      type: System.Windows.WindowCollection
      description: "Объект <xref href=&quot;System.Windows.WindowCollection&quot;> </xref> , содержащий ссылки на windows, владельцем которых является в этом окне."
  overload: System.Windows.Window.OwnedWindows*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Owner
  id: Owner
  parent: System.Windows.Window
  langs:
  - csharp
  name: Owner
  nameWithType: Window.Owner
  fullName: System.Windows.Window.Owner
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает <xref href=&quot;System.Windows.Window&quot;> </xref> , которому принадлежит это <xref href=&quot;System.Windows.Window&quot;> </xref>."
  remarks: "При открытии дочернего окна родительское окно, вызвав <xref:System.Windows.Window.ShowDialog%2A>, явную связь устанавливается между родительским и дочерним окнами.</xref:System.Windows.Window.ShowDialog%2A> Эта связь накладывает определенное поведение, в том числе по отношению к минимуму, разворачивания и восстановления.       При создании дочернего окна родительское окно, вызвав <xref:System.Windows.Window.Show%2A>, однако, дочернее окно не имеет связи с родительским окном.</xref:System.Windows.Window.Show%2A> Это означает, что:-дочернее окно не имеет ссылки на родительском окне.      -Поведение дочернего окна не зависит от поведения родительского окна. либо окна может охватывать другого или свести к минимуму, разворачиваться и восстанавливаться независимо от другого.       Чтобы можно было создать связь между дочерним и родительского окна, <xref:System.Windows.Window>поддерживает понятие владения.</xref:System.Windows.Window> Если задано свойство «владелец» окна (собственного окна), со ссылкой на другое окно (окно-владелец) установки владельца.       После установления этой связи проявляется следующее поведение:-Если окно-владелец сворачивается, все его собственные окна также сворачиваются.      -Если собственное окно сворачивается, его владелец не сводится к минимуму.      -Если развернуто окно-владелец, окна-владельца и его собственные окна восстанавливаются.      -Окно-владелец никогда не может перекрывать собственное окно.      Используемых windows, которые не были открыты с помощью <xref:System.Windows.Window.ShowDialog%2A>не модальное.</xref:System.Windows.Window.ShowDialog%2A> Пользователь по-прежнему могут взаимодействовать с окна-владельца.      -Если закрыть окно-владелец, его собственные окна также будут закрыты.      -Если собственное окно был открыт с помощью окна его владельца <xref:System.Windows.Window.Show%2A>и владелец закрытия окна, принадлежащие окна <xref:System.Windows.Window.Closing>событие не происходит.</xref:System.Windows.Window.Closing> </xref:System.Windows.Window.Show%2A>       При открытии дочернего окна, вызвав <xref:System.Windows.Window.ShowDialog%2A>, также следует задать свойство «владелец» дочернего окна.</xref:System.Windows.Window.ShowDialog%2A> Если этого не сделать, пользователи не будет доступной для восстановления дочернее окно и родительское окно, нажав кнопку панели задач. Вместо этого нажав кнопку панели задач даст список окон, включая, дочерние и родительские окна для них требуется выделить; восстанавливается только выбранный период.      Настроек [!IMPORTANT] настроек также следует задать свойство «владелец» в окне, которое открывается путем вызова <xref:System.Windows.Window.ShowDialog%2A>для обеспечения правильного поведения с.</xref:System.Windows.Window.ShowDialog%2A>      Настроек [!NOTE] настроек не удается задать или получить значение этого свойства, если окно размещено в браузере."
  example:
  - "The following example shows how to establish the owner/owned relationship.  \n  \n [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/add/codesnippet/visualbasic/windowownerownedwindowssnippets/mainwindow.xaml.vb#setwindowownercode)]\n [!code-cs[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/add/codesnippet/csharp/WindowOwnerOwnedWindowsSnippets.CSharp/MainWindow.xaml.cs#setwindowownercode)]"
  syntax:
    content: public System.Windows.Window Owner { get; set; }
    return:
      type: System.Windows.Window
      description: "Объект <xref href=&quot;System.Windows.Window&quot;> </xref> , представляющий владельца этого <xref href=&quot;System.Windows.Window&quot;> </xref>."
  overload: System.Windows.Window.Owner*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Окно пытается стать владельцем самого себя - или - два окна пытаются стать владельцами друг с другом."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Задать свойство владельца для видимого окна отображается с помощью <xref:System.Windows.Window.ShowDialog*>- или - это свойство имеет значение с помощью окна, который не был показан ранее.</xref:System.Windows.Window.ShowDialog*>"
  platform:
  - net462
- uid: System.Windows.Window.ResizeMode
  id: ResizeMode
  parent: System.Windows.Window
  langs:
  - csharp
  name: ResizeMode
  nameWithType: Window.ResizeMode
  fullName: System.Windows.Window.ResizeMode
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает режим изменения размера."
  remarks: "Ниже приведены четыре параметра:- **NoResize**. Пользователь не может изменять размеры окна. Развернуть и свернуть поля не отображаются.      - **CanMinimize**. Пользователь может только свернуть окно и восстановите ее из панели задач. Свернуть и развернуть отображаются, но включена только кнопка &quot;Свернуть&quot;.      - **CanResize**. Пользователь имеет возможность полного размера окна, с помощью свернуть и развернуть, а также перетаскиваемый контур вокруг окна. Свернуть и развернуть отображаются и включены. (По умолчанию).      - **CanResizeWithGrip**. Этот параметр может иметь ту же функциональность, что <xref:System.Windows.ResizeMode>, но добавляет «захват для изменения размера» в правом нижнем углу окна.</xref:System.Windows.ResizeMode>      Настроек [!NOTE] настроек не удается задать или получить значение этого свойства, если окно размещено в браузере.      <a name=&quot;dependencyPropertyInfo_WindowResizeMode&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.Window.ResizeModeProperty>|   | Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.Window.ResizeModeProperty>"
  syntax:
    content: public System.Windows.ResizeMode ResizeMode { get; set; }
    return:
      type: System.Windows.ResizeMode
      description: "Объект <xref href=&quot;System.Windows.ResizeMode&quot;> </xref> значение, указывающее режим изменения размера."
  overload: System.Windows.Window.ResizeMode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.ResizeModeProperty
  id: ResizeModeProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: ResizeModeProperty
  nameWithType: Window.ResizeModeProperty
  fullName: System.Windows.Window.ResizeModeProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.Window.ResizeMode*>свойство зависимостей.</xref:System.Windows.Window.ResizeMode*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ResizeModeProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.RestoreBounds
  id: RestoreBounds
  parent: System.Windows.Window
  langs:
  - csharp
  name: RestoreBounds
  nameWithType: Window.RestoreBounds
  fullName: System.Windows.Window.RestoreBounds
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает размер и расположение окна перед сворачиванием либо развернуто."
  remarks: "Прямоугольник восстановления — область, занятая окном до его сворачивания или разворачивания. Используйте RestoreBounds для сохранения последний размер и расположение окна перед закрытием приложения и получить эти значения при очередном запуске приложения, чтобы восстановить окно, так как пользователь остался.       Если вы запрашиваете RestoreBounds перед показали окна или после его закрытия <xref:System.Windows.Rect.Empty%2A>возвращается.</xref:System.Windows.Rect.Empty%2A>      Настроек [!NOTE] настроек не может получить это свойство при размещении окна в браузере."
  example:
  - "The following example uses RestoreBounds and isolated storage to ensure the size and location of a window are the same as they were the previous time the window was shown.  \n  \n [!code-xml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/add/codesnippet/xaml/WindowRestoreBoundsSnippets/MainWindow.xaml#windowrestoreboundsxaml1)]  \n[!code-xml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/add/codesnippet/xaml/WindowRestoreBoundsSnippets/MainWindow.xaml#windowrestoreboundsxaml2)]  \n  \n [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/add/codesnippet/visualbasic/windowrestoreboundssnippets/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]\n [!code-cs[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/add/codesnippet/csharp/WindowRestoreBoundsSnippets/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]  \n[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/add/codesnippet/visualbasic/windowrestoreboundssnippets/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]\n[!code-cs[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/add/codesnippet/csharp/WindowRestoreBoundsSnippets/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]"
  syntax:
    content: public System.Windows.Rect RestoreBounds { get; }
    return:
      type: System.Windows.Rect
      description: "Объект <xref href=&quot;System.Windows.Rect&quot;> </xref> , определяет размер и расположение окна перед Свертывание или развертывание."
  overload: System.Windows.Window.RestoreBounds*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Show
  id: Show
  parent: System.Windows.Window
  langs:
  - csharp
  name: Show()
  nameWithType: Window.Show()
  fullName: System.Windows.Window.Show()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Открывает окно и возвращается без ожидания закрытия нового открытого окна."
  remarks: "Когда <xref:System.Windows.Window>создается экземпляр класса, она не отображается по умолчанию.</xref:System.Windows.Window> Показать показано окно и возврат немедленно, без ожидания окна будет закрыта. Следовательно открытое окно не запрещает пользователям взаимодействовать с другими окнами в приложении. Этот тип окна называется *немодальное* окна. Распространенными примерами немодальных окон являются свойства окон, панелей инструментов и палитры. Чтобы ограничить пользователя для взаимодействия с конкретным окном, окно должно быть установлено путем вызова <xref:System.Windows.Window.ShowDialog%2A>.</xref:System.Windows.Window.ShowDialog%2A>       Окно, которое открывается вызовом Показать автоматически не имеет связь с окном, открывший его; в частности открытого окна не знает, какое окно он открыт. Эту связь можно установить с помощью <xref:System.Windows.Window.Owner%2A>свойство и управляемых с помощью <xref:System.Windows.Window.OwnedWindows%2A>свойство.</xref:System.Windows.Window.OwnedWindows%2A> </xref:System.Windows.Window.Owner%2A>       Вызов Показать обеспечивает такой же результат окончания как свойства <xref:System.Windows.UIElement.Visibility%2A> <xref:System.Windows.Window>объекта <xref:System.Windows.Visibility>.</xref:System.Windows.Visibility> </xref:System.Windows.Window> </xref:System.Windows.UIElement.Visibility%2A> Тем не менее есть различие между ними с точки зрения времени.       Вызов Показать выполняется в синхронном режиме, который возвращает только после <xref:System.Windows.FrameworkElement.Loaded>события на дочернее окно: [!code-vb [WindowShowTimingSnippets #ShowSync](~/add/codesnippet/visualbasic/windowshowtimingsnippets/window1.xaml.vb#showsync)][!code-cs[WindowShowTimingSnippets #ShowSync](~/add/codesnippet/csharp/WindowShowTimingSnippets.CSharp/Window1.xaml.cs#showsync) ] параметр <xref:System.Windows.UIElement.Visibility%2A>, то, сразу же завершает асинхронную операцию: [!code-vb [WindowShowTimingSnippets #ShowASync](~/add/codesnippet/visualbasic/windowshowtimingsnippets/window1.xaml.vb#showasync)][!code-cs[WindowShowTimingSnippets #ShowASync](~/add/codesnippet/csharp/WindowShowTimingSnippets.CSharp/Window1.xaml.cs#showasync) ] при задании <xref:System.Windows.UIElement.Visibility%2A>, все события окна регистрировать перед установкой <xref:System.Windows.UIElement.Visibility%2A>могут не возникать до и после метода, в котором заданы <xref:System.Windows.UIElement.Visibility%2A>завершила выполнение.</xref:System.Windows.UIElement.Visibility%2A> </xref:System.Windows.UIElement.Visibility%2A> </xref:System.Windows.UIElement.Visibility%2A>   </xref:System.Windows.UIElement.Visibility%2A>   </xref:System.Windows.FrameworkElement.Loaded>"
  example:
  - "The following sample demonstrates how to open a modeless window.  \n  \n [!code-vb[WindowShowSnippets#WindowShowCODE](~/add/codesnippet/visualbasic/windowshowsnippets/mainwindow.xaml.vb#windowshowcode)]\n [!code-cs[WindowShowSnippets#WindowShowCODE](~/add/codesnippet/csharp/WindowShowSnippets.CSharp/MainWindow.xaml.cs#windowshowcode)]"
  syntax:
    content: public void Show ();
    parameters: []
  overload: System.Windows.Window.Show*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Показать вызывается в окне, которое закрывает (<xref href=&quot;System.Windows.Window.Closing&quot;></xref>) или был закрыт (<xref href=&quot;System.Windows.Window.Closed&quot;></xref>)."
  platform:
  - net462
- uid: System.Windows.Window.ShowActivated
  id: ShowActivated
  parent: System.Windows.Window
  langs:
  - csharp
  name: ShowActivated
  nameWithType: Window.ShowActivated
  fullName: System.Windows.Window.ShowActivated
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает значение, указывающее, является ли окно активируется при первом отображении."
  remarks: "Если окно для его свойства ShowActivated `false` является открывается, окно не активируется и его <xref:System.Windows.Window.Activated>событие не происходит, пока пользователь вручную активирует окно, выбрав его.</xref:System.Windows.Window.Activated> После выбора окна, она активирует и деактивируется в обычном режиме.       Чтобы окно активироваться при его открытии, свойство ShowActivated должно быть присвоено `false` перед отображением этого окна (путем вызова <xref:System.Windows.Window.Show%2A>); установка ShowActivated `false` после окна на экран не делает ничего.</xref:System.Windows.Window.Show%2A>       Установка ShowActivated `false` в окне, которое открывается как модальная, вызвав <xref:System.Windows.Window.ShowDialog%2A>, имеет никаких реальных последствий.</xref:System.Windows.Window.ShowDialog%2A> Несмотря на то, что не будут активированы модальное окно, модальное окно будет запрещает пользователю активацию любые другие открытые окна приложения.      <a name=&quot;dependencyPropertyInfo_WindowShowActivated&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.Window.ShowActivatedProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.Window.ShowActivatedProperty>"
  example:
  - "The following example shows how to use markup to configure a window to be opened without being activated.  \n  \n [!code-xml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/add/codesnippet/xaml/WindowShowActivatedSnippets/AWindow.xaml#showunactivatedmarkup1)]  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]  \n  \n [!code-cs[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/add/codesnippet/csharp/WindowShowActivatedSnippets/AWindow.xaml.cs#showunactivatedcodebehind)]\n [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/add/codesnippet/visualbasic/windowshowactivatedsnippets/awindow.xaml.vb#showunactivatedcodebehind)]  \n  \n The following example shows how to use code to configure a window to be opened without it being activated.  \n  \n [!code-cs[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/add/codesnippet/csharp/WindowShowActivatedSnippets/Window1.xaml.cs#showunactivatedwindowcode)]\n [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/add/codesnippet/visualbasic/windowshowactivatedsnippets/window1.xaml.vb#showunactivatedwindowcode)]"
  syntax:
    content: public bool ShowActivated { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если окно активируется при первом отображении; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Window.ShowActivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.ShowActivatedProperty
  id: ShowActivatedProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: ShowActivatedProperty
  nameWithType: Window.ShowActivatedProperty
  fullName: System.Windows.Window.ShowActivatedProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.Window.ShowActivated*>свойство зависимостей.</xref:System.Windows.Window.ShowActivated*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ShowActivatedProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.ShowDialog
  id: ShowDialog
  parent: System.Windows.Window
  langs:
  - csharp
  name: ShowDialog()
  nameWithType: Window.ShowDialog()
  fullName: System.Windows.Window.ShowDialog()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Открывает окно и возвращает только в том случае, когда закрывается только что открытого окна."
  remarks: "Когда <xref:System.Windows.Window>создается экземпляр класса, она не отображается по умолчанию.</xref:System.Windows.Window> ShowDialog показано окно, отключает все окна в приложении и возвращает только при закрытии окна. Этот тип окна называется *модального* окно.       Модальные окна в основном используются как диалоговые окна. Диалоговое окно — это специальный тип окна, используемый приложениями для взаимодействия с пользователями при выполнении задач, таких как открытие файлов или печать документов. Диалоговые окна зачастую позволяют пользователям принять или отменить задачу, для которого они были показаны, прежде чем закрыть диалоговое окно. ShowDialog возвращает <xref:System.Nullable%601> <xref:System.Boolean>значение, указывающее, было ли действие принятия или отмены.</xref:System.Boolean></xref:System.Nullable%601> Возвращаемое значение является значением <xref:System.Windows.Window.DialogResult%2A>свойство перед закрытием окна.</xref:System.Windows.Window.DialogResult%2A> Дополнительные сведения см. в разделе <xref:System.Windows.Window.DialogResult%2A>.</xref:System.Windows.Window.DialogResult%2A>       Окно, которое открывается с помощью метода ShowDialog автоматически не имеет связи с окном, открывший его; в частности открытого окна не знает, какое окно он открыт. Эту связь можно установить с помощью <xref:System.Windows.Window.Owner%2A>свойство и управляемых с помощью <xref:System.Windows.Window.OwnedWindows%2A>свойство.</xref:System.Windows.Window.OwnedWindows%2A> </xref:System.Windows.Window.Owner%2A> Для поддержки [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] автоматизации (см. [Обзор модели автоматизации пользовательского интерфейса](~/add/includes/ajax-current-ext-md.md)), <xref:System.Windows.Window.Owner%2A>должно быть задано для окно, открытое посредством вызова ShowDialog.</xref:System.Windows.Window.Owner%2A>       Когда модальный [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] закрытия окна (окно открывается вызовом ShowDialog), ранее активированное окно активируется повторно. Если модальное окно [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] окно имеет окно-владелец (см. <xref:System.Windows.Window.Owner%2A>), окно-владелец не активируется повторно, когда модальное [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)] окно закрывается, если она была ранее активированное окно.</xref:System.Windows.Window.Owner%2A>      Настроек [!NOTE] настроек этот метод нельзя вызывать, когда окно размещено в браузере."
  example:
  - "The following sample demonstrates how to open a modal window.  \n  \n [!code-cs[WindowShowDialogSnippets#WindowShowDialogCODE](~/add/codesnippet/csharp/WindowShowDialogSnippets.CSharp/MainWindow.xaml.cs#windowshowdialogcode)]\n [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/add/codesnippet/visualbasic/windowshowdialogsnippets/mainwindow.xaml.vb#windowshowdialogcode)]"
  syntax:
    content: public Nullable<bool> ShowDialog ();
    parameters: []
    return:
      type: System.Nullable{System.Boolean}
      description: "Объект &lt;xref:System.Nullable%601&gt; значение типа <xref:System.Boolean>, указывающий, принят ли действие (<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>) или отменена (<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>).</xref:System.Boolean> Возвращаемое значение является значением <xref:System.Windows.Window.DialogResult*>свойство перед закрытием окна.</xref:System.Windows.Window.DialogResult*>"
  overload: System.Windows.Window.ShowDialog*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "ShowDialog вызывается в окне, которое закрывает (<xref href=&quot;System.Windows.Window.Closing&quot;></xref>) или был закрыт (<xref href=&quot;System.Windows.Window.Closed&quot;></xref>)."
  platform:
  - net462
- uid: System.Windows.Window.ShowInTaskbar
  id: ShowInTaskbar
  parent: System.Windows.Window
  langs:
  - csharp
  name: ShowInTaskbar
  nameWithType: Window.ShowInTaskbar
  fullName: System.Windows.Window.ShowInTaskbar
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает значение, указывающее, имеет ли окно кнопку в панели задач."
  remarks: "Если имеет значение ShowInTaskbar `true`, окне также отображаются в списке выбора приложения ALT + TAB.       Значок, используемый для кнопки панели задач и список выбора приложения ALT + TAB — это значение <xref:System.Windows.Window.Icon%2A>Свойства.</xref:System.Windows.Window.Icon%2A>      Настроек [!NOTE] настроек не удается задать или получить значение этого свойства, если окно размещено в браузере.      <a name=&quot;dependencyPropertyInfo_WindowShowInTaskbar&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.Window.ShowInTaskbarProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.Window.ShowInTaskbarProperty>"
  syntax:
    content: public bool ShowInTaskbar { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если окно имеет кнопку в панели задач; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Не применяется, если окно размещено в браузере."
  overload: System.Windows.Window.ShowInTaskbar*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.ShowInTaskbarProperty
  id: ShowInTaskbarProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: ShowInTaskbarProperty
  nameWithType: Window.ShowInTaskbarProperty
  fullName: System.Windows.Window.ShowInTaskbarProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.Window.ShowInTaskbar*>свойство зависимостей.</xref:System.Windows.Window.ShowInTaskbar*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.SizeToContent
  id: SizeToContent
  parent: System.Windows.Window
  langs:
  - csharp
  name: SizeToContent
  nameWithType: Window.SizeToContent
  fullName: System.Windows.Window.SizeToContent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает значение, указывающее, будет ли автоматически размер окна в соответствии с размером его содержимого."
  remarks: "При значении SizeToContent контейнер имеет значение <xref:System.Windows.SizeToContent>, устанавливая либо <xref:System.Windows.FrameworkElement.Height%2A>или <xref:System.Windows.FrameworkElement.Width%2A>не влияет; оба свойства могут быть заданы, но они устанавливаются с помощью значения не применяются к окна.</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.Height%2A> </xref:System.Windows.SizeToContent>       При значении SizeToContent контейнер имеет значение <xref:System.Windows.SizeToContent>, параметр <xref:System.Windows.FrameworkElement.Height%2A>не изменяет высоту окна.</xref:System.Windows.FrameworkElement.Height%2A> </xref:System.Windows.SizeToContent>       При значении SizeToContent контейнер имеет значение <xref:System.Windows.SizeToContent>, параметр <xref:System.Windows.FrameworkElement.Width%2A>не изменяет ширину окна.</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.SizeToContent>       При значении SizeToContent контейнер имеет значение, отличное от <xref:System.Windows.SizeToContent>:-значении SizeToContent контейнер автоматически устанавливается значение <xref:System.Windows.SizeToContent>при изменении размера окна с помощью захвата для изменения размера или перетащив границу.</xref:System.Windows.SizeToContent> </xref:System.Windows.SizeToContent>      -При изменении размера содержимого, в результате которого его окно будет изменяться, <xref:System.Windows.FrameworkElement.SizeChanged>возникает.</xref:System.Windows.FrameworkElement.SizeChanged>       Если окно является прозрачным (см. <xref:System.Windows.Window.AllowsTransparency%2A>), следует рассмотреть возможность установки значении SizeToContent контейнер <xref:System.Windows.SizeToContent>для обеспечения окна не больше его видимого содержимого.</xref:System.Windows.SizeToContent> </xref:System.Windows.Window.AllowsTransparency%2A>      Настроек [!NOTE] настроек не удается задать или получить значение этого свойства, если окно размещено в браузере.      <a name=&quot;dependencyPropertyInfo_WindowSizeToContent&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.Window.SizeToContentProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.Window.SizeToContentProperty>"
  example:
  - "The following example shows how to set the SizeToContent property in code to specify how a window resizes to fit its content.  \n  \n [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/add/codesnippet/visualbasic/howtowindowmanagementsnippets/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]\n [!code-cs[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/add/codesnippet/csharp/HOWTOWindowManagementSnippets/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]"
  syntax:
    content: public System.Windows.SizeToContent SizeToContent { get; set; }
    return:
      type: System.Windows.SizeToContent
      description: "A <xref href=&quot;System.Windows.SizeToContent&quot;></xref> value. Значение по умолчанию — <xref href=&quot;System.Windows.SizeToContent&quot;> </xref>."
  overload: System.Windows.Window.SizeToContent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.SizeToContentProperty
  id: SizeToContentProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: SizeToContentProperty
  nameWithType: Window.SizeToContentProperty
  fullName: System.Windows.Window.SizeToContentProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.Window.SizeToContent*>свойство зависимостей.</xref:System.Windows.Window.SizeToContent*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty SizeToContentProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.SourceInitialized
  id: SourceInitialized
  parent: System.Windows.Window
  langs:
  - csharp
  name: SourceInitialized
  nameWithType: Window.SourceInitialized
  fullName: System.Windows.Window.SourceInitialized
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Это событие вызывается для поддержки взаимодействия с [!INCLUDE[TLA#tla_win32](~/add/includes/tlasharptla-win32-md.md)]. See <xref href=&quot;System.Windows.Interop.HwndSource&quot;></xref>."
  syntax:
    content: public event EventHandler SourceInitialized;
    return:
      type: System.EventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.StateChanged
  id: StateChanged
  parent: System.Windows.Window
  langs:
  - csharp
  name: StateChanged
  nameWithType: Window.StateChanged
  fullName: System.Windows.Window.StateChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит, когда окно <xref:System.Windows.Window.WindowState*>изменения свойств.</xref:System.Windows.Window.WindowState*>"
  syntax:
    content: public event EventHandler StateChanged;
    return:
      type: System.EventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.TaskbarItemInfo
  id: TaskbarItemInfo
  parent: System.Windows.Window
  langs:
  - csharp
  name: TaskbarItemInfo
  nameWithType: Window.TaskbarItemInfo
  fullName: System.Windows.Window.TaskbarItemInfo
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает [!INCLUDE[win7](~/add/includes/win7-md.md)] эскиз задач для <xref href=&quot;System.Windows.Window&quot;> </xref>."
  remarks: "Дополнительные сведения об использовании [!INCLUDE[win7](~/add/includes/win7-md.md)] эскиз задач см. <xref:System.Windows.Shell.TaskbarItemInfo>класс.</xref:System.Windows.Shell.TaskbarItemInfo>"
  syntax:
    content: public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }
    return:
      type: System.Windows.Shell.TaskbarItemInfo
      description: "[!INCLUDE[win7](~/add/includes/win7-md.md)] Эскиз задач для <xref href=&quot;System.Windows.Window&quot;> </xref>."
  overload: System.Windows.Window.TaskbarItemInfo*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.TaskbarItemInfoProperty
  id: TaskbarItemInfoProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: TaskbarItemInfoProperty
  nameWithType: Window.TaskbarItemInfoProperty
  fullName: System.Windows.Window.TaskbarItemInfoProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.Window.TaskbarItemInfo*>свойство зависимостей.</xref:System.Windows.Window.TaskbarItemInfo*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Title
  id: Title
  parent: System.Windows.Window
  langs:
  - csharp
  name: Title
  nameWithType: Window.Title
  fullName: System.Windows.Window.Title
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает заголовок окна."
  remarks: "Заголовок <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, или [!INCLUDE[TLA#tla_iegeneric](~/add/includes/tlasharptla-iegeneric-md.md)], можно также задать с помощью <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=fullName>.</xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=fullName> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Window>      <a name=&quot;dependencyPropertyInfo_WindowTitle&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.Window.TitleProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.Window.TitleProperty>"
  syntax:
    content: public string Title { get; set; }
    return:
      type: System.String
      description: "Объект <xref:System.String>, содержащий заголовок окна.</xref:System.String>"
  overload: System.Windows.Window.Title*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.TitleProperty
  id: TitleProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: TitleProperty
  nameWithType: Window.TitleProperty
  fullName: System.Windows.Window.TitleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.Window.Title*>свойство зависимостей.</xref:System.Windows.Window.Title*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TitleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Top
  id: Top
  parent: System.Windows.Window
  langs:
  - csharp
  name: Top
  nameWithType: Window.Top
  fullName: System.Windows.Window.Top
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает позицию верхнего края окна относительно рабочего стола."
  remarks: "Если <xref:System.Windows.Window>развернуто или развернуто, это значение соответствует верхнего края восстановления точки для <xref:System.Windows.Window>.</xref:System.Windows.Window> </xref:System.Windows.Window>       Это свойство нельзя задать с помощью стиля.       Если значение не указано, то значение по умолчанию имеет значение Top. Можно также указать значение по умолчанию, задав значение <xref:System.Double.NaN>.</xref:System.Double.NaN> Top Ни <xref:System.Double.NegativeInfinity>, ни <xref:System.Double.PositiveInfinity>является допустимым значением для верхней.</xref:System.Double.PositiveInfinity> </xref:System.Double.NegativeInfinity>      Настроек [!NOTE] настроек не удается задать или получить значение этого свойства, если окно размещено в браузере.      <a name=&quot;dependencyPropertyInfo_WindowTop&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.Window.TopProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.Window.TopProperty>"
  syntax:
    content: public double Top { get; set; }
    return:
      type: System.Double
      description: "Позиция верхнего окна в логических единицах (1/96&quot;)."
  overload: System.Windows.Window.Top*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.Topmost
  id: Topmost
  parent: System.Windows.Window
  langs:
  - csharp
  name: Topmost
  nameWithType: Window.Topmost
  fullName: System.Windows.Window.Topmost
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает значение, указывающее, отображается ли окно в верхнем z порядке."
  remarks: "Окно переднего плана, свойство которого имеет значение `true` появляется над всеми переднего плана, свойства которого присваиваются windows `false`.       В группе windows, имеющих Topmost является свойство `true`, окно, которое активируется в настоящее время является самое верхнее окно. Аналогичным образом для группы windows, имеющие Topmost свойству `false`.      Настроек [!NOTE] настроек не удается задать или получить значение этого свойства, если окно размещено в браузере.      <a name=&quot;dependencyPropertyInfo_WindowTopmost&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.Window.TopmostProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.Window.TopmostProperty>"
  syntax:
    content: public bool Topmost { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если окно является самым верхним; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Window.Topmost*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.TopmostProperty
  id: TopmostProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: TopmostProperty
  nameWithType: Window.TopmostProperty
  fullName: System.Windows.Window.TopmostProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.Window.Topmost*>свойство зависимостей.</xref:System.Windows.Window.Topmost*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TopmostProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.TopProperty
  id: TopProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: TopProperty
  nameWithType: Window.TopProperty
  fullName: System.Windows.Window.TopProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.Window.Top*>свойство зависимостей.</xref:System.Windows.Window.Top*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TopProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.WindowStartupLocation
  id: WindowStartupLocation
  parent: System.Windows.Window
  langs:
  - csharp
  name: WindowStartupLocation
  nameWithType: Window.WindowStartupLocation
  fullName: System.Windows.Window.WindowStartupLocation
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает позицию окна при первом отображении."
  remarks: "Параметр <xref:System.Windows.WindowStartupLocation>для <xref:System.Windows.WindowStartupLocation>окно будет располагаться в соответствии с его <xref:System.Windows.Window.Left%2A>и <xref:System.Windows.Window.Top%2A>значений свойств.</xref:System.Windows.Window.Top%2A> </xref:System.Windows.Window.Left%2A> </xref:System.Windows.WindowStartupLocation> </xref:System.Windows.WindowStartupLocation> Если параметр <xref:System.Windows.Window.Left%2A>или <xref:System.Windows.Window.Top%2A>не были указаны свойства, их значения определяются [!INCLUDE[TLA2#tla_mswin](~/add/includes/tla2sharptla-mswin-md.md)].</xref:System.Windows.Window.Top%2A> </xref:System.Windows.Window.Left%2A>       Параметр <xref:System.Windows.WindowStartupLocation>Выводить окно должен располагаться в центре экрана, содержащего курсор мыши.</xref:System.Windows.WindowStartupLocation>       Параметр <xref:System.Windows.WindowStartupLocation>для <xref:System.Windows.WindowStartupLocation>Выводить окно должен располагаться в центре окна-владельца (см. <xref:System.Windows.Window.Owner%2A>), если он указан.</xref:System.Windows.Window.Owner%2A> </xref:System.Windows.WindowStartupLocation> </xref:System.Windows.WindowStartupLocation> Окно-владелец может быть еще одно окно WPF или окна не WPF.      Настроек [!NOTE] настроек Дополнительные сведения об окнах WPF с windows, отличных от WPF см. в разделе [WPF и взаимодействие Win32](~/add/includes/ajax-current-ext-md.md) и <xref:System.Windows.Interop.WindowInteropHelper>.</xref:System.Windows.Interop.WindowInteropHelper>       Если окно-владелец не указан, положение окна определяется таким же образом, если <xref:System.Windows.WindowStartupLocation>задано значение <xref:System.Windows.WindowStartupLocation>.</xref:System.Windows.WindowStartupLocation> </xref:System.Windows.WindowStartupLocation>      Настроек [!NOTE] настроек не удается задать или получить значение этого свойства при размещении окна в браузере."
  syntax:
    content: public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }
    return:
      type: System.Windows.WindowStartupLocation
      description: "Объект <xref href=&quot;System.Windows.WindowStartupLocation&quot;> </xref> значение, указывающее позицию верхнего левого при первом отображении окна. Значение по умолчанию — <xref href=&quot;System.Windows.WindowStartupLocation&quot;> </xref>."
  overload: System.Windows.Window.WindowStartupLocation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.WindowState
  id: WindowState
  parent: System.Windows.Window
  langs:
  - csharp
  name: WindowState
  nameWithType: Window.WindowState
  fullName: System.Windows.Window.WindowState
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает значение, указывающее, восстановлены ли, сворачивать и разворачивать."
  remarks: "Прежде чем окна сворачивать или разворачивать, его размер и расположение, хранятся в <xref:System.Windows.Window.RestoreBounds%2A>.</xref:System.Windows.Window.RestoreBounds%2A> При последующем восстановлении окна со значениями из <xref:System.Windows.Window.RestoreBounds%2A>.</xref:System.Windows.Window.RestoreBounds%2A> восстанавливаются значения его размер и расположение       При изменении свойства WindowState <xref:System.Windows.Window.StateChanged>возникает.</xref:System.Windows.Window.StateChanged>      Настроек [!NOTE] настроек не удается задать или получить значение этого свойства, если окно размещено в браузере.      <a name=&quot;dependencyPropertyInfo_WindowWindowState&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.Window.WindowStateProperty>|   | Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|</xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A> </xref:System.Windows.Window.WindowStateProperty>"
  syntax:
    content: public System.Windows.WindowState WindowState { get; set; }
    return:
      type: System.Windows.WindowState
      description: "Объект <xref href=&quot;System.Windows.WindowState&quot;> </xref> , определяющий восстановления ли, сворачивать или разворачивать. Значение по умолчанию — <xref href=&quot;System.Windows.WindowState&quot;> </xref> (восстановления)."
  overload: System.Windows.Window.WindowState*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.WindowStateProperty
  id: WindowStateProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: WindowStateProperty
  nameWithType: Window.WindowStateProperty
  fullName: System.Windows.Window.WindowStateProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.Window.WindowState*>свойство зависимостей.</xref:System.Windows.Window.WindowState*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty WindowStateProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.WindowStyle
  id: WindowStyle
  parent: System.Windows.Window
  langs:
  - csharp
  name: WindowStyle
  nameWithType: Window.WindowStyle
  fullName: System.Windows.Window.WindowStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает стиль границы окна."
  remarks: "WindowStyle может принимать одно из <xref:System.Windows.WindowStyle>значений перечисления, включая <xref:System.Windows.WindowStyle>, <xref:System.Windows.WindowStyle>, <xref:System.Windows.WindowStyle>(по умолчанию) и <xref:System.Windows.WindowStyle>.</xref:System.Windows.WindowStyle> </xref:System.Windows.WindowStyle> </xref:System.Windows.WindowStyle> </xref:System.Windows.WindowStyle> </xref:System.Windows.WindowStyle>       На следующем рисунке показана стили окна на [!INCLUDE[TLA#tla_longhorn](~/add/includes/ajax-current-ext-md.md)] (Windows Vista Aero тема с прозрачности включен): ![стили окна](~/add/media/windowoverviewfigure6.PNG &quot;стили окна&quot;)       >  [!NOTE] настроек не удается задать или получить значение этого свойства, если окно размещено в браузере.      <a name=&quot;dependencyPropertyInfo_WindowWindowStyle&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.Window.WindowStyleProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.Window.WindowStyleProperty>"
  syntax:
    content: public System.Windows.WindowStyle WindowStyle { get; set; }
    return:
      type: System.Windows.WindowStyle
      description: "Объект <xref href=&quot;System.Windows.WindowStyle&quot;> </xref> , указывающее стиль границы окна. Значение по умолчанию — <xref href=&quot;System.Windows.WindowStyle&quot;> </xref>."
  overload: System.Windows.Window.WindowStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Window.WindowStyleProperty
  id: WindowStyleProperty
  parent: System.Windows.Window
  langs:
  - csharp
  name: WindowStyleProperty
  nameWithType: Window.WindowStyleProperty
  fullName: System.Windows.Window.WindowStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.Window.WindowStyle*>свойство зависимостей.</xref:System.Windows.Window.WindowStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty WindowStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Controls.ContentControl
  isExternal: false
  name: System.Windows.Controls.ContentControl
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Windows.Window.#ctor
  parent: System.Windows.Window
  isExternal: false
  name: Window()
  nameWithType: Window.Window()
  fullName: System.Windows.Window.Window()
- uid: System.Windows.Window.Activate
  parent: System.Windows.Window
  isExternal: false
  name: Activate()
  nameWithType: Window.Activate()
  fullName: System.Windows.Window.Activate()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Window.Activated
  parent: System.Windows.Window
  isExternal: false
  name: Activated
  nameWithType: Window.Activated
  fullName: System.Windows.Window.Activated
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.Window.AllowsTransparency
  parent: System.Windows.Window
  isExternal: false
  name: AllowsTransparency
  nameWithType: Window.AllowsTransparency
  fullName: System.Windows.Window.AllowsTransparency
- uid: System.Windows.Window.AllowsTransparencyProperty
  parent: System.Windows.Window
  isExternal: false
  name: AllowsTransparencyProperty
  nameWithType: Window.AllowsTransparencyProperty
  fullName: System.Windows.Window.AllowsTransparencyProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.Window.ArrangeOverride(System.Windows.Size)
  parent: System.Windows.Window
  isExternal: false
  name: ArrangeOverride(Size)
  nameWithType: Window.ArrangeOverride(Size)
  fullName: System.Windows.Window.ArrangeOverride(Size)
- uid: System.Windows.Size
  parent: System.Windows
  isExternal: false
  name: Size
  nameWithType: Size
  fullName: System.Windows.Size
- uid: System.Windows.Window.Close
  parent: System.Windows.Window
  isExternal: false
  name: Close()
  nameWithType: Window.Close()
  fullName: System.Windows.Window.Close()
- uid: System.Windows.Window.Closed
  parent: System.Windows.Window
  isExternal: false
  name: Closed
  nameWithType: Window.Closed
  fullName: System.Windows.Window.Closed
- uid: System.Windows.Window.Closing
  parent: System.Windows.Window
  isExternal: false
  name: Closing
  nameWithType: Window.Closing
  fullName: System.Windows.Window.Closing
- uid: System.ComponentModel.CancelEventHandler
  parent: System.ComponentModel
  isExternal: false
  name: CancelEventHandler
  nameWithType: CancelEventHandler
  fullName: System.ComponentModel.CancelEventHandler
- uid: System.Windows.Window.ContentRendered
  parent: System.Windows.Window
  isExternal: false
  name: ContentRendered
  nameWithType: Window.ContentRendered
  fullName: System.Windows.Window.ContentRendered
- uid: System.Windows.Window.Deactivated
  parent: System.Windows.Window
  isExternal: false
  name: Deactivated
  nameWithType: Window.Deactivated
  fullName: System.Windows.Window.Deactivated
- uid: System.Windows.Window.DialogResult
  parent: System.Windows.Window
  isExternal: false
  name: DialogResult
  nameWithType: Window.DialogResult
  fullName: System.Windows.Window.DialogResult
- uid: System.Nullable{System.Boolean}
  parent: System
  isExternal: true
  name: Nullable<Boolean>
  nameWithType: Nullable<Boolean>
  fullName: System.Nullable<System.Boolean>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: Nullable<System.Boolean>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: Boolean
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.Window.DpiChanged
  parent: System.Windows.Window
  isExternal: false
  name: DpiChanged
  nameWithType: Window.DpiChanged
  fullName: System.Windows.Window.DpiChanged
- uid: System.Windows.DpiChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DpiChangedEventHandler
  nameWithType: DpiChangedEventHandler
  fullName: System.Windows.DpiChangedEventHandler
- uid: System.Windows.Window.DpiChangedEvent
  parent: System.Windows.Window
  isExternal: false
  name: DpiChangedEvent
  nameWithType: Window.DpiChangedEvent
  fullName: System.Windows.Window.DpiChangedEvent
- uid: System.Windows.RoutedEvent
  parent: System.Windows
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEvent
  fullName: System.Windows.RoutedEvent
- uid: System.Windows.Window.DragMove
  parent: System.Windows.Window
  isExternal: false
  name: DragMove()
  nameWithType: Window.DragMove()
  fullName: System.Windows.Window.DragMove()
- uid: System.Windows.Window.GetWindow(System.Windows.DependencyObject)
  parent: System.Windows.Window
  isExternal: false
  name: GetWindow(DependencyObject)
  nameWithType: Window.GetWindow(DependencyObject)
  fullName: System.Windows.Window.GetWindow(DependencyObject)
- uid: System.Windows.Window
  parent: System.Windows
  isExternal: false
  name: Window
  nameWithType: Window
  fullName: System.Windows.Window
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.Window.Hide
  parent: System.Windows.Window
  isExternal: false
  name: Hide()
  nameWithType: Window.Hide()
  fullName: System.Windows.Window.Hide()
- uid: System.Windows.Window.Icon
  parent: System.Windows.Window
  isExternal: false
  name: Icon
  nameWithType: Window.Icon
  fullName: System.Windows.Window.Icon
- uid: System.Windows.Media.ImageSource
  parent: System.Windows.Media
  isExternal: false
  name: ImageSource
  nameWithType: ImageSource
  fullName: System.Windows.Media.ImageSource
- uid: System.Windows.Window.IconProperty
  parent: System.Windows.Window
  isExternal: false
  name: IconProperty
  nameWithType: Window.IconProperty
  fullName: System.Windows.Window.IconProperty
- uid: System.Windows.Window.IsActive
  parent: System.Windows.Window
  isExternal: false
  name: IsActive
  nameWithType: Window.IsActive
  fullName: System.Windows.Window.IsActive
- uid: System.Windows.Window.IsActiveProperty
  parent: System.Windows.Window
  isExternal: false
  name: IsActiveProperty
  nameWithType: Window.IsActiveProperty
  fullName: System.Windows.Window.IsActiveProperty
- uid: System.Windows.Window.Left
  parent: System.Windows.Window
  isExternal: false
  name: Left
  nameWithType: Window.Left
  fullName: System.Windows.Window.Left
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.Window.LeftProperty
  parent: System.Windows.Window
  isExternal: false
  name: LeftProperty
  nameWithType: Window.LeftProperty
  fullName: System.Windows.Window.LeftProperty
- uid: System.Windows.Window.LocationChanged
  parent: System.Windows.Window
  isExternal: false
  name: LocationChanged
  nameWithType: Window.LocationChanged
  fullName: System.Windows.Window.LocationChanged
- uid: System.Windows.Window.LogicalChildren
  parent: System.Windows.Window
  isExternal: false
  name: LogicalChildren
  nameWithType: Window.LogicalChildren
  fullName: System.Windows.Window.LogicalChildren
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Windows.Window.MeasureOverride(System.Windows.Size)
  parent: System.Windows.Window
  isExternal: false
  name: MeasureOverride(Size)
  nameWithType: Window.MeasureOverride(Size)
  fullName: System.Windows.Window.MeasureOverride(Size)
- uid: System.Windows.Window.OnActivated(System.EventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnActivated(EventArgs)
  nameWithType: Window.OnActivated(EventArgs)
  fullName: System.Windows.Window.OnActivated(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.Window.OnClosed(System.EventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnClosed(EventArgs)
  nameWithType: Window.OnClosed(EventArgs)
  fullName: System.Windows.Window.OnClosed(EventArgs)
- uid: System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnClosing(CancelEventArgs)
  nameWithType: Window.OnClosing(CancelEventArgs)
  fullName: System.Windows.Window.OnClosing(CancelEventArgs)
- uid: System.ComponentModel.CancelEventArgs
  parent: System.ComponentModel
  isExternal: true
  name: CancelEventArgs
  nameWithType: CancelEventArgs
  fullName: System.ComponentModel.CancelEventArgs
- uid: System.Windows.Window.OnContentChanged(System.Object,System.Object)
  parent: System.Windows.Window
  isExternal: false
  name: OnContentChanged(Object,Object)
  nameWithType: Window.OnContentChanged(Object,Object)
  fullName: System.Windows.Window.OnContentChanged(Object,Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.Window.OnContentRendered(System.EventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnContentRendered(EventArgs)
  nameWithType: Window.OnContentRendered(EventArgs)
  fullName: System.Windows.Window.OnContentRendered(EventArgs)
- uid: System.Windows.Window.OnCreateAutomationPeer
  parent: System.Windows.Window
  isExternal: false
  name: OnCreateAutomationPeer()
  nameWithType: Window.OnCreateAutomationPeer()
  fullName: System.Windows.Window.OnCreateAutomationPeer()
- uid: System.Windows.Automation.Peers.AutomationPeer
  parent: System.Windows.Automation.Peers
  isExternal: false
  name: AutomationPeer
  nameWithType: AutomationPeer
  fullName: System.Windows.Automation.Peers.AutomationPeer
- uid: System.Windows.Window.OnDeactivated(System.EventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnDeactivated(EventArgs)
  nameWithType: Window.OnDeactivated(EventArgs)
  fullName: System.Windows.Window.OnDeactivated(EventArgs)
- uid: System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)
  parent: System.Windows.Window
  isExternal: false
  name: OnDpiChanged(DpiScale,DpiScale)
  nameWithType: Window.OnDpiChanged(DpiScale,DpiScale)
  fullName: System.Windows.Window.OnDpiChanged(DpiScale,DpiScale)
- uid: System.Windows.DpiScale
  parent: System.Windows
  isExternal: false
  name: DpiScale
  nameWithType: DpiScale
  fullName: System.Windows.DpiScale
- uid: System.Windows.Window.OnLocationChanged(System.EventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnLocationChanged(EventArgs)
  nameWithType: Window.OnLocationChanged(EventArgs)
  fullName: System.Windows.Window.OnLocationChanged(EventArgs)
- uid: System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
  nameWithType: Window.OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
  fullName: System.Windows.Window.OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs)
- uid: System.Windows.Input.ManipulationBoundaryFeedbackEventArgs
  parent: System.Windows.Input
  isExternal: false
  name: ManipulationBoundaryFeedbackEventArgs
  nameWithType: ManipulationBoundaryFeedbackEventArgs
  fullName: System.Windows.Input.ManipulationBoundaryFeedbackEventArgs
- uid: System.Windows.Window.OnSourceInitialized(System.EventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnSourceInitialized(EventArgs)
  nameWithType: Window.OnSourceInitialized(EventArgs)
  fullName: System.Windows.Window.OnSourceInitialized(EventArgs)
- uid: System.Windows.Window.OnStateChanged(System.EventArgs)
  parent: System.Windows.Window
  isExternal: false
  name: OnStateChanged(EventArgs)
  nameWithType: Window.OnStateChanged(EventArgs)
  fullName: System.Windows.Window.OnStateChanged(EventArgs)
- uid: System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.Window
  isExternal: false
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: Window.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.Window.OnVisualParentChanged(DependencyObject)
- uid: System.Windows.Window.OwnedWindows
  parent: System.Windows.Window
  isExternal: false
  name: OwnedWindows
  nameWithType: Window.OwnedWindows
  fullName: System.Windows.Window.OwnedWindows
- uid: System.Windows.WindowCollection
  parent: System.Windows
  isExternal: false
  name: WindowCollection
  nameWithType: WindowCollection
  fullName: System.Windows.WindowCollection
- uid: System.Windows.Window.Owner
  parent: System.Windows.Window
  isExternal: false
  name: Owner
  nameWithType: Window.Owner
  fullName: System.Windows.Window.Owner
- uid: System.Windows.Window.ResizeMode
  parent: System.Windows.Window
  isExternal: false
  name: ResizeMode
  nameWithType: Window.ResizeMode
  fullName: System.Windows.Window.ResizeMode
- uid: System.Windows.ResizeMode
  parent: System.Windows
  isExternal: false
  name: ResizeMode
  nameWithType: ResizeMode
  fullName: System.Windows.ResizeMode
- uid: System.Windows.Window.ResizeModeProperty
  parent: System.Windows.Window
  isExternal: false
  name: ResizeModeProperty
  nameWithType: Window.ResizeModeProperty
  fullName: System.Windows.Window.ResizeModeProperty
- uid: System.Windows.Window.RestoreBounds
  parent: System.Windows.Window
  isExternal: false
  name: RestoreBounds
  nameWithType: Window.RestoreBounds
  fullName: System.Windows.Window.RestoreBounds
- uid: System.Windows.Rect
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
- uid: System.Windows.Window.Show
  parent: System.Windows.Window
  isExternal: false
  name: Show()
  nameWithType: Window.Show()
  fullName: System.Windows.Window.Show()
- uid: System.Windows.Window.ShowActivated
  parent: System.Windows.Window
  isExternal: false
  name: ShowActivated
  nameWithType: Window.ShowActivated
  fullName: System.Windows.Window.ShowActivated
- uid: System.Windows.Window.ShowActivatedProperty
  parent: System.Windows.Window
  isExternal: false
  name: ShowActivatedProperty
  nameWithType: Window.ShowActivatedProperty
  fullName: System.Windows.Window.ShowActivatedProperty
- uid: System.Windows.Window.ShowDialog
  parent: System.Windows.Window
  isExternal: false
  name: ShowDialog()
  nameWithType: Window.ShowDialog()
  fullName: System.Windows.Window.ShowDialog()
- uid: System.Windows.Window.ShowInTaskbar
  parent: System.Windows.Window
  isExternal: false
  name: ShowInTaskbar
  nameWithType: Window.ShowInTaskbar
  fullName: System.Windows.Window.ShowInTaskbar
- uid: System.Windows.Window.ShowInTaskbarProperty
  parent: System.Windows.Window
  isExternal: false
  name: ShowInTaskbarProperty
  nameWithType: Window.ShowInTaskbarProperty
  fullName: System.Windows.Window.ShowInTaskbarProperty
- uid: System.Windows.Window.SizeToContent
  parent: System.Windows.Window
  isExternal: false
  name: SizeToContent
  nameWithType: Window.SizeToContent
  fullName: System.Windows.Window.SizeToContent
- uid: System.Windows.SizeToContent
  parent: System.Windows
  isExternal: false
  name: SizeToContent
  nameWithType: SizeToContent
  fullName: System.Windows.SizeToContent
- uid: System.Windows.Window.SizeToContentProperty
  parent: System.Windows.Window
  isExternal: false
  name: SizeToContentProperty
  nameWithType: Window.SizeToContentProperty
  fullName: System.Windows.Window.SizeToContentProperty
- uid: System.Windows.Window.SourceInitialized
  parent: System.Windows.Window
  isExternal: false
  name: SourceInitialized
  nameWithType: Window.SourceInitialized
  fullName: System.Windows.Window.SourceInitialized
- uid: System.Windows.Window.StateChanged
  parent: System.Windows.Window
  isExternal: false
  name: StateChanged
  nameWithType: Window.StateChanged
  fullName: System.Windows.Window.StateChanged
- uid: System.Windows.Window.TaskbarItemInfo
  parent: System.Windows.Window
  isExternal: false
  name: TaskbarItemInfo
  nameWithType: Window.TaskbarItemInfo
  fullName: System.Windows.Window.TaskbarItemInfo
- uid: System.Windows.Shell.TaskbarItemInfo
  parent: System.Windows.Shell
  isExternal: false
  name: TaskbarItemInfo
  nameWithType: TaskbarItemInfo
  fullName: System.Windows.Shell.TaskbarItemInfo
- uid: System.Windows.Window.TaskbarItemInfoProperty
  parent: System.Windows.Window
  isExternal: false
  name: TaskbarItemInfoProperty
  nameWithType: Window.TaskbarItemInfoProperty
  fullName: System.Windows.Window.TaskbarItemInfoProperty
- uid: System.Windows.Window.Title
  parent: System.Windows.Window
  isExternal: false
  name: Title
  nameWithType: Window.Title
  fullName: System.Windows.Window.Title
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Window.TitleProperty
  parent: System.Windows.Window
  isExternal: false
  name: TitleProperty
  nameWithType: Window.TitleProperty
  fullName: System.Windows.Window.TitleProperty
- uid: System.Windows.Window.Top
  parent: System.Windows.Window
  isExternal: false
  name: Top
  nameWithType: Window.Top
  fullName: System.Windows.Window.Top
- uid: System.Windows.Window.Topmost
  parent: System.Windows.Window
  isExternal: false
  name: Topmost
  nameWithType: Window.Topmost
  fullName: System.Windows.Window.Topmost
- uid: System.Windows.Window.TopmostProperty
  parent: System.Windows.Window
  isExternal: false
  name: TopmostProperty
  nameWithType: Window.TopmostProperty
  fullName: System.Windows.Window.TopmostProperty
- uid: System.Windows.Window.TopProperty
  parent: System.Windows.Window
  isExternal: false
  name: TopProperty
  nameWithType: Window.TopProperty
  fullName: System.Windows.Window.TopProperty
- uid: System.Windows.Window.WindowStartupLocation
  parent: System.Windows.Window
  isExternal: false
  name: WindowStartupLocation
  nameWithType: Window.WindowStartupLocation
  fullName: System.Windows.Window.WindowStartupLocation
- uid: System.Windows.WindowStartupLocation
  parent: System.Windows
  isExternal: false
  name: WindowStartupLocation
  nameWithType: WindowStartupLocation
  fullName: System.Windows.WindowStartupLocation
- uid: System.Windows.Window.WindowState
  parent: System.Windows.Window
  isExternal: false
  name: WindowState
  nameWithType: Window.WindowState
  fullName: System.Windows.Window.WindowState
- uid: System.Windows.WindowState
  parent: System.Windows
  isExternal: false
  name: WindowState
  nameWithType: WindowState
  fullName: System.Windows.WindowState
- uid: System.Windows.Window.WindowStateProperty
  parent: System.Windows.Window
  isExternal: false
  name: WindowStateProperty
  nameWithType: Window.WindowStateProperty
  fullName: System.Windows.Window.WindowStateProperty
- uid: System.Windows.Window.WindowStyle
  parent: System.Windows.Window
  isExternal: false
  name: WindowStyle
  nameWithType: Window.WindowStyle
  fullName: System.Windows.Window.WindowStyle
- uid: System.Windows.WindowStyle
  parent: System.Windows
  isExternal: false
  name: WindowStyle
  nameWithType: WindowStyle
  fullName: System.Windows.WindowStyle
- uid: System.Windows.Window.WindowStyleProperty
  parent: System.Windows.Window
  isExternal: false
  name: WindowStyleProperty
  nameWithType: Window.WindowStyleProperty
  fullName: System.Windows.Window.WindowStyleProperty
- uid: System.Windows.Window.#ctor*
  parent: System.Windows.Window
  isExternal: false
  name: Window
  nameWithType: Window.Window
- uid: System.Windows.Window.Activate*
  parent: System.Windows.Window
  isExternal: false
  name: Activate
  nameWithType: Window.Activate
- uid: System.Windows.Window.AllowsTransparency*
  parent: System.Windows.Window
  isExternal: false
  name: AllowsTransparency
  nameWithType: Window.AllowsTransparency
- uid: System.Windows.Window.ArrangeOverride*
  parent: System.Windows.Window
  isExternal: false
  name: ArrangeOverride
  nameWithType: Window.ArrangeOverride
- uid: System.Windows.Window.Close*
  parent: System.Windows.Window
  isExternal: false
  name: Close
  nameWithType: Window.Close
- uid: System.Windows.Window.DialogResult*
  parent: System.Windows.Window
  isExternal: false
  name: DialogResult
  nameWithType: Window.DialogResult
- uid: System.Windows.Window.DragMove*
  parent: System.Windows.Window
  isExternal: false
  name: DragMove
  nameWithType: Window.DragMove
- uid: System.Windows.Window.GetWindow*
  parent: System.Windows.Window
  isExternal: false
  name: GetWindow
  nameWithType: Window.GetWindow
- uid: System.Windows.Window.Hide*
  parent: System.Windows.Window
  isExternal: false
  name: Hide
  nameWithType: Window.Hide
- uid: System.Windows.Window.Icon*
  parent: System.Windows.Window
  isExternal: false
  name: Icon
  nameWithType: Window.Icon
- uid: System.Windows.Window.IsActive*
  parent: System.Windows.Window
  isExternal: false
  name: IsActive
  nameWithType: Window.IsActive
- uid: System.Windows.Window.Left*
  parent: System.Windows.Window
  isExternal: false
  name: Left
  nameWithType: Window.Left
- uid: System.Windows.Window.LogicalChildren*
  parent: System.Windows.Window
  isExternal: false
  name: LogicalChildren
  nameWithType: Window.LogicalChildren
- uid: System.Windows.Window.MeasureOverride*
  parent: System.Windows.Window
  isExternal: false
  name: MeasureOverride
  nameWithType: Window.MeasureOverride
- uid: System.Windows.Window.OnActivated*
  parent: System.Windows.Window
  isExternal: false
  name: OnActivated
  nameWithType: Window.OnActivated
- uid: System.Windows.Window.OnClosed*
  parent: System.Windows.Window
  isExternal: false
  name: OnClosed
  nameWithType: Window.OnClosed
- uid: System.Windows.Window.OnClosing*
  parent: System.Windows.Window
  isExternal: false
  name: OnClosing
  nameWithType: Window.OnClosing
- uid: System.Windows.Window.OnContentChanged*
  parent: System.Windows.Window
  isExternal: false
  name: OnContentChanged
  nameWithType: Window.OnContentChanged
- uid: System.Windows.Window.OnContentRendered*
  parent: System.Windows.Window
  isExternal: false
  name: OnContentRendered
  nameWithType: Window.OnContentRendered
- uid: System.Windows.Window.OnCreateAutomationPeer*
  parent: System.Windows.Window
  isExternal: false
  name: OnCreateAutomationPeer
  nameWithType: Window.OnCreateAutomationPeer
- uid: System.Windows.Window.OnDeactivated*
  parent: System.Windows.Window
  isExternal: false
  name: OnDeactivated
  nameWithType: Window.OnDeactivated
- uid: System.Windows.Window.OnDpiChanged*
  parent: System.Windows.Window
  isExternal: false
  name: OnDpiChanged
  nameWithType: Window.OnDpiChanged
- uid: System.Windows.Window.OnLocationChanged*
  parent: System.Windows.Window
  isExternal: false
  name: OnLocationChanged
  nameWithType: Window.OnLocationChanged
- uid: System.Windows.Window.OnManipulationBoundaryFeedback*
  parent: System.Windows.Window
  isExternal: false
  name: OnManipulationBoundaryFeedback
  nameWithType: Window.OnManipulationBoundaryFeedback
- uid: System.Windows.Window.OnSourceInitialized*
  parent: System.Windows.Window
  isExternal: false
  name: OnSourceInitialized
  nameWithType: Window.OnSourceInitialized
- uid: System.Windows.Window.OnStateChanged*
  parent: System.Windows.Window
  isExternal: false
  name: OnStateChanged
  nameWithType: Window.OnStateChanged
- uid: System.Windows.Window.OnVisualParentChanged*
  parent: System.Windows.Window
  isExternal: false
  name: OnVisualParentChanged
  nameWithType: Window.OnVisualParentChanged
- uid: System.Windows.Window.OwnedWindows*
  parent: System.Windows.Window
  isExternal: false
  name: OwnedWindows
  nameWithType: Window.OwnedWindows
- uid: System.Windows.Window.Owner*
  parent: System.Windows.Window
  isExternal: false
  name: Owner
  nameWithType: Window.Owner
- uid: System.Windows.Window.ResizeMode*
  parent: System.Windows.Window
  isExternal: false
  name: ResizeMode
  nameWithType: Window.ResizeMode
- uid: System.Windows.Window.RestoreBounds*
  parent: System.Windows.Window
  isExternal: false
  name: RestoreBounds
  nameWithType: Window.RestoreBounds
- uid: System.Windows.Window.Show*
  parent: System.Windows.Window
  isExternal: false
  name: Show
  nameWithType: Window.Show
- uid: System.Windows.Window.ShowActivated*
  parent: System.Windows.Window
  isExternal: false
  name: ShowActivated
  nameWithType: Window.ShowActivated
- uid: System.Windows.Window.ShowDialog*
  parent: System.Windows.Window
  isExternal: false
  name: ShowDialog
  nameWithType: Window.ShowDialog
- uid: System.Windows.Window.ShowInTaskbar*
  parent: System.Windows.Window
  isExternal: false
  name: ShowInTaskbar
  nameWithType: Window.ShowInTaskbar
- uid: System.Windows.Window.SizeToContent*
  parent: System.Windows.Window
  isExternal: false
  name: SizeToContent
  nameWithType: Window.SizeToContent
- uid: System.Windows.Window.TaskbarItemInfo*
  parent: System.Windows.Window
  isExternal: false
  name: TaskbarItemInfo
  nameWithType: Window.TaskbarItemInfo
- uid: System.Windows.Window.Title*
  parent: System.Windows.Window
  isExternal: false
  name: Title
  nameWithType: Window.Title
- uid: System.Windows.Window.Top*
  parent: System.Windows.Window
  isExternal: false
  name: Top
  nameWithType: Window.Top
- uid: System.Windows.Window.Topmost*
  parent: System.Windows.Window
  isExternal: false
  name: Topmost
  nameWithType: Window.Topmost
- uid: System.Windows.Window.WindowStartupLocation*
  parent: System.Windows.Window
  isExternal: false
  name: WindowStartupLocation
  nameWithType: Window.WindowStartupLocation
- uid: System.Windows.Window.WindowState*
  parent: System.Windows.Window
  isExternal: false
  name: WindowState
  nameWithType: Window.WindowState
- uid: System.Windows.Window.WindowStyle*
  parent: System.Windows.Window
  isExternal: false
  name: WindowStyle
  nameWithType: Window.WindowStyle
