### YamlMime:ManagedReference
items:
- uid: System.Windows.FrameworkContentElement
  id: FrameworkContentElement
  children:
  - System.Windows.FrameworkContentElement.#ctor
  - System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)
  - System.Windows.FrameworkContentElement.BeginInit
  - System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  - System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  - System.Windows.FrameworkContentElement.BindingGroup
  - System.Windows.FrameworkContentElement.BindingGroupProperty
  - System.Windows.FrameworkContentElement.BringIntoView
  - System.Windows.FrameworkContentElement.ContextMenu
  - System.Windows.FrameworkContentElement.ContextMenuClosing
  - System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  - System.Windows.FrameworkContentElement.ContextMenuOpening
  - System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  - System.Windows.FrameworkContentElement.ContextMenuProperty
  - System.Windows.FrameworkContentElement.Cursor
  - System.Windows.FrameworkContentElement.CursorProperty
  - System.Windows.FrameworkContentElement.DataContext
  - System.Windows.FrameworkContentElement.DataContextChanged
  - System.Windows.FrameworkContentElement.DataContextProperty
  - System.Windows.FrameworkContentElement.DefaultStyleKey
  - System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  - System.Windows.FrameworkContentElement.EndInit
  - System.Windows.FrameworkContentElement.FindName(System.String)
  - System.Windows.FrameworkContentElement.FindResource(System.Object)
  - System.Windows.FrameworkContentElement.FocusVisualStyle
  - System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  - System.Windows.FrameworkContentElement.ForceCursor
  - System.Windows.FrameworkContentElement.ForceCursorProperty
  - System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)
  - System.Windows.FrameworkContentElement.GetUIParentCore
  - System.Windows.FrameworkContentElement.Initialized
  - System.Windows.FrameworkContentElement.InputScope
  - System.Windows.FrameworkContentElement.InputScopeProperty
  - System.Windows.FrameworkContentElement.IsInitialized
  - System.Windows.FrameworkContentElement.IsLoaded
  - System.Windows.FrameworkContentElement.Language
  - System.Windows.FrameworkContentElement.LanguageProperty
  - System.Windows.FrameworkContentElement.Loaded
  - System.Windows.FrameworkContentElement.LoadedEvent
  - System.Windows.FrameworkContentElement.LogicalChildren
  - System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  - System.Windows.FrameworkContentElement.Name
  - System.Windows.FrameworkContentElement.NameProperty
  - System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  - System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)
  - System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  - System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkContentElement.OverridesDefaultStyle
  - System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  - System.Windows.FrameworkContentElement.Parent
  - System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  - System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)
  - System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)
  - System.Windows.FrameworkContentElement.Resources
  - System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)
  - System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  - System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  - System.Windows.FrameworkContentElement.ShouldSerializeResources
  - System.Windows.FrameworkContentElement.ShouldSerializeStyle
  - System.Windows.FrameworkContentElement.SourceUpdated
  - System.Windows.FrameworkContentElement.Style
  - System.Windows.FrameworkContentElement.StyleProperty
  - System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.FrameworkContentElement.Tag
  - System.Windows.FrameworkContentElement.TagProperty
  - System.Windows.FrameworkContentElement.TargetUpdated
  - System.Windows.FrameworkContentElement.TemplatedParent
  - System.Windows.FrameworkContentElement.ToolTip
  - System.Windows.FrameworkContentElement.ToolTipClosing
  - System.Windows.FrameworkContentElement.ToolTipClosingEvent
  - System.Windows.FrameworkContentElement.ToolTipOpening
  - System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  - System.Windows.FrameworkContentElement.ToolTipProperty
  - System.Windows.FrameworkContentElement.TryFindResource(System.Object)
  - System.Windows.FrameworkContentElement.Unloaded
  - System.Windows.FrameworkContentElement.UnloadedEvent
  - System.Windows.FrameworkContentElement.UnregisterName(System.String)
  - System.Windows.FrameworkContentElement.UpdateDefaultStyle
  langs:
  - csharp
  name: FrameworkContentElement
  nameWithType: FrameworkContentElement
  fullName: System.Windows.FrameworkContentElement
  type: Class
  summary: "FrameworkContentElement является реализация уровня инфраструктуры WPF и расширением <xref href=&quot;System.Windows.ContentElement&quot;> </xref> базового класса. FrameworkContentElement добавляет поддержку дополнительных входных данных [!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)] (включая подсказки и контекстные меню), раскадровки, контексты данных для привязки данных, поддержку стилей и вспомогательные логического дерева [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]."
  remarks: "FrameworkContentElement еще не определяет свое поведение отрисовки; При создании экземпляра фактического экземпляра класса FrameworkContentElement в код или разметку возможна, но не отображает ничего в [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] приложения [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]. Подготовка к просмотру логики необходимо указать классами, которые принимают FrameworkContentElement дочерние элементы как часть своей модели содержимого или в FrameworkContentElement производных классов.       Преднамеренно FrameworkContentElement параллельно многие из перечисленных [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] как <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement> Обратите внимание что некоторые [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] на <xref:System.Windows.FrameworkElement>Нет эквивалентного FrameworkContentElement.</xref:System.Windows.FrameworkElement> Некоторые <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] предназначены для функции, такие как представление geometry или макета, которые не относятся к FrameworkContentElement.</xref:System.Windows.FrameworkElement>       Большая часть существующего FrameworkContentElement производные классы, которые будут находиться в <xref:System.Windows.Documents>пространства имен.</xref:System.Windows.Documents> Многие из этих производных классов реализуют элементы для модели потокового документа. Определенные производные классы, такие как <xref:System.Windows.Documents.Hyperlink>имеют некоторые функции типа элемента управления, но являются производными от FrameworkContentElement таким образом, что элементы управления по принципу по-прежнему могут участвовать в модели потокового документа.</xref:System.Windows.Documents.Hyperlink>"
  syntax:
    content: >-
      [System.Windows.Markup.RuntimeNameProperty("Name")]

      [System.Windows.Markup.UsableDuringInitialization(true)]

      [System.Windows.Markup.XmlLangProperty("Language")]

      [System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))]

      public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.ContentElement
  implements:
  - System.ComponentModel.ISupportInitialize
  - System.Windows.IFrameworkInputElement
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  - System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.AllowDrop
  - System.Windows.ContentElement.AllowDropProperty
  - System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.ContentElement.AreAnyTouchesCaptured
  - System.Windows.ContentElement.AreAnyTouchesCapturedProperty
  - System.Windows.ContentElement.AreAnyTouchesCapturedWithin
  - System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty
  - System.Windows.ContentElement.AreAnyTouchesDirectlyOver
  - System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty
  - System.Windows.ContentElement.AreAnyTouchesOver
  - System.Windows.ContentElement.AreAnyTouchesOverProperty
  - System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.ContentElement.CaptureMouse
  - System.Windows.ContentElement.CaptureStylus
  - System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)
  - System.Windows.ContentElement.CommandBindings
  - System.Windows.ContentElement.DragEnter
  - System.Windows.ContentElement.DragEnterEvent
  - System.Windows.ContentElement.DragLeave
  - System.Windows.ContentElement.DragLeaveEvent
  - System.Windows.ContentElement.DragOver
  - System.Windows.ContentElement.DragOverEvent
  - System.Windows.ContentElement.Drop
  - System.Windows.ContentElement.DropEvent
  - System.Windows.ContentElement.Focus
  - System.Windows.ContentElement.Focusable
  - System.Windows.ContentElement.FocusableChanged
  - System.Windows.ContentElement.FocusableProperty
  - System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.ContentElement.GiveFeedback
  - System.Windows.ContentElement.GiveFeedbackEvent
  - System.Windows.ContentElement.GotFocus
  - System.Windows.ContentElement.GotFocusEvent
  - System.Windows.ContentElement.GotKeyboardFocus
  - System.Windows.ContentElement.GotKeyboardFocusEvent
  - System.Windows.ContentElement.GotMouseCapture
  - System.Windows.ContentElement.GotMouseCaptureEvent
  - System.Windows.ContentElement.GotStylusCapture
  - System.Windows.ContentElement.GotStylusCaptureEvent
  - System.Windows.ContentElement.GotTouchCapture
  - System.Windows.ContentElement.GotTouchCaptureEvent
  - System.Windows.ContentElement.HasAnimatedProperties
  - System.Windows.ContentElement.InputBindings
  - System.Windows.ContentElement.IsEnabled
  - System.Windows.ContentElement.IsEnabledChanged
  - System.Windows.ContentElement.IsEnabledCore
  - System.Windows.ContentElement.IsEnabledProperty
  - System.Windows.ContentElement.IsFocused
  - System.Windows.ContentElement.IsFocusedProperty
  - System.Windows.ContentElement.IsInputMethodEnabled
  - System.Windows.ContentElement.IsKeyboardFocused
  - System.Windows.ContentElement.IsKeyboardFocusedChanged
  - System.Windows.ContentElement.IsKeyboardFocusedProperty
  - System.Windows.ContentElement.IsKeyboardFocusWithin
  - System.Windows.ContentElement.IsKeyboardFocusWithinChanged
  - System.Windows.ContentElement.IsKeyboardFocusWithinProperty
  - System.Windows.ContentElement.IsMouseCaptured
  - System.Windows.ContentElement.IsMouseCapturedChanged
  - System.Windows.ContentElement.IsMouseCapturedProperty
  - System.Windows.ContentElement.IsMouseCaptureWithin
  - System.Windows.ContentElement.IsMouseCaptureWithinChanged
  - System.Windows.ContentElement.IsMouseCaptureWithinProperty
  - System.Windows.ContentElement.IsMouseDirectlyOver
  - System.Windows.ContentElement.IsMouseDirectlyOverChanged
  - System.Windows.ContentElement.IsMouseDirectlyOverProperty
  - System.Windows.ContentElement.IsMouseOver
  - System.Windows.ContentElement.IsMouseOverProperty
  - System.Windows.ContentElement.IsStylusCaptured
  - System.Windows.ContentElement.IsStylusCapturedChanged
  - System.Windows.ContentElement.IsStylusCapturedProperty
  - System.Windows.ContentElement.IsStylusCaptureWithin
  - System.Windows.ContentElement.IsStylusCaptureWithinChanged
  - System.Windows.ContentElement.IsStylusCaptureWithinProperty
  - System.Windows.ContentElement.IsStylusDirectlyOver
  - System.Windows.ContentElement.IsStylusDirectlyOverChanged
  - System.Windows.ContentElement.IsStylusDirectlyOverProperty
  - System.Windows.ContentElement.IsStylusOver
  - System.Windows.ContentElement.IsStylusOverProperty
  - System.Windows.ContentElement.KeyDown
  - System.Windows.ContentElement.KeyDownEvent
  - System.Windows.ContentElement.KeyUp
  - System.Windows.ContentElement.KeyUpEvent
  - System.Windows.ContentElement.LostFocus
  - System.Windows.ContentElement.LostFocusEvent
  - System.Windows.ContentElement.LostKeyboardFocus
  - System.Windows.ContentElement.LostKeyboardFocusEvent
  - System.Windows.ContentElement.LostMouseCapture
  - System.Windows.ContentElement.LostMouseCaptureEvent
  - System.Windows.ContentElement.LostStylusCapture
  - System.Windows.ContentElement.LostStylusCaptureEvent
  - System.Windows.ContentElement.LostTouchCapture
  - System.Windows.ContentElement.LostTouchCaptureEvent
  - System.Windows.ContentElement.MouseDown
  - System.Windows.ContentElement.MouseDownEvent
  - System.Windows.ContentElement.MouseEnter
  - System.Windows.ContentElement.MouseEnterEvent
  - System.Windows.ContentElement.MouseLeave
  - System.Windows.ContentElement.MouseLeaveEvent
  - System.Windows.ContentElement.MouseLeftButtonDown
  - System.Windows.ContentElement.MouseLeftButtonDownEvent
  - System.Windows.ContentElement.MouseLeftButtonUp
  - System.Windows.ContentElement.MouseLeftButtonUpEvent
  - System.Windows.ContentElement.MouseMove
  - System.Windows.ContentElement.MouseMoveEvent
  - System.Windows.ContentElement.MouseRightButtonDown
  - System.Windows.ContentElement.MouseRightButtonDownEvent
  - System.Windows.ContentElement.MouseRightButtonUp
  - System.Windows.ContentElement.MouseRightButtonUpEvent
  - System.Windows.ContentElement.MouseUp
  - System.Windows.ContentElement.MouseUpEvent
  - System.Windows.ContentElement.MouseWheel
  - System.Windows.ContentElement.MouseWheelEvent
  - System.Windows.ContentElement.OnCreateAutomationPeer
  - System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  - System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.PreviewDragEnter
  - System.Windows.ContentElement.PreviewDragEnterEvent
  - System.Windows.ContentElement.PreviewDragLeave
  - System.Windows.ContentElement.PreviewDragLeaveEvent
  - System.Windows.ContentElement.PreviewDragOver
  - System.Windows.ContentElement.PreviewDragOverEvent
  - System.Windows.ContentElement.PreviewDrop
  - System.Windows.ContentElement.PreviewDropEvent
  - System.Windows.ContentElement.PreviewGiveFeedback
  - System.Windows.ContentElement.PreviewGiveFeedbackEvent
  - System.Windows.ContentElement.PreviewGotKeyboardFocus
  - System.Windows.ContentElement.PreviewGotKeyboardFocusEvent
  - System.Windows.ContentElement.PreviewKeyDown
  - System.Windows.ContentElement.PreviewKeyDownEvent
  - System.Windows.ContentElement.PreviewKeyUp
  - System.Windows.ContentElement.PreviewKeyUpEvent
  - System.Windows.ContentElement.PreviewLostKeyboardFocus
  - System.Windows.ContentElement.PreviewLostKeyboardFocusEvent
  - System.Windows.ContentElement.PreviewMouseDown
  - System.Windows.ContentElement.PreviewMouseDownEvent
  - System.Windows.ContentElement.PreviewMouseLeftButtonDown
  - System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent
  - System.Windows.ContentElement.PreviewMouseLeftButtonUp
  - System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent
  - System.Windows.ContentElement.PreviewMouseMove
  - System.Windows.ContentElement.PreviewMouseMoveEvent
  - System.Windows.ContentElement.PreviewMouseRightButtonDown
  - System.Windows.ContentElement.PreviewMouseRightButtonDownEvent
  - System.Windows.ContentElement.PreviewMouseRightButtonUp
  - System.Windows.ContentElement.PreviewMouseRightButtonUpEvent
  - System.Windows.ContentElement.PreviewMouseUp
  - System.Windows.ContentElement.PreviewMouseUpEvent
  - System.Windows.ContentElement.PreviewMouseWheel
  - System.Windows.ContentElement.PreviewMouseWheelEvent
  - System.Windows.ContentElement.PreviewQueryContinueDrag
  - System.Windows.ContentElement.PreviewQueryContinueDragEvent
  - System.Windows.ContentElement.PreviewStylusButtonDown
  - System.Windows.ContentElement.PreviewStylusButtonDownEvent
  - System.Windows.ContentElement.PreviewStylusButtonUp
  - System.Windows.ContentElement.PreviewStylusButtonUpEvent
  - System.Windows.ContentElement.PreviewStylusDown
  - System.Windows.ContentElement.PreviewStylusDownEvent
  - System.Windows.ContentElement.PreviewStylusInAirMove
  - System.Windows.ContentElement.PreviewStylusInAirMoveEvent
  - System.Windows.ContentElement.PreviewStylusInRange
  - System.Windows.ContentElement.PreviewStylusInRangeEvent
  - System.Windows.ContentElement.PreviewStylusMove
  - System.Windows.ContentElement.PreviewStylusMoveEvent
  - System.Windows.ContentElement.PreviewStylusOutOfRange
  - System.Windows.ContentElement.PreviewStylusOutOfRangeEvent
  - System.Windows.ContentElement.PreviewStylusSystemGesture
  - System.Windows.ContentElement.PreviewStylusSystemGestureEvent
  - System.Windows.ContentElement.PreviewStylusUp
  - System.Windows.ContentElement.PreviewStylusUpEvent
  - System.Windows.ContentElement.PreviewTextInput
  - System.Windows.ContentElement.PreviewTextInputEvent
  - System.Windows.ContentElement.PreviewTouchDown
  - System.Windows.ContentElement.PreviewTouchDownEvent
  - System.Windows.ContentElement.PreviewTouchMove
  - System.Windows.ContentElement.PreviewTouchMoveEvent
  - System.Windows.ContentElement.PreviewTouchUp
  - System.Windows.ContentElement.PreviewTouchUpEvent
  - System.Windows.ContentElement.QueryContinueDrag
  - System.Windows.ContentElement.QueryContinueDragEvent
  - System.Windows.ContentElement.QueryCursor
  - System.Windows.ContentElement.QueryCursorEvent
  - System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.ReleaseAllTouchCaptures
  - System.Windows.ContentElement.ReleaseMouseCapture
  - System.Windows.ContentElement.ReleaseStylusCapture
  - System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  - System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.ContentElement.ShouldSerializeCommandBindings
  - System.Windows.ContentElement.ShouldSerializeInputBindings
  - System.Windows.ContentElement.StylusButtonDown
  - System.Windows.ContentElement.StylusButtonDownEvent
  - System.Windows.ContentElement.StylusButtonUp
  - System.Windows.ContentElement.StylusButtonUpEvent
  - System.Windows.ContentElement.StylusDown
  - System.Windows.ContentElement.StylusDownEvent
  - System.Windows.ContentElement.StylusEnter
  - System.Windows.ContentElement.StylusEnterEvent
  - System.Windows.ContentElement.StylusInAirMove
  - System.Windows.ContentElement.StylusInAirMoveEvent
  - System.Windows.ContentElement.StylusInRange
  - System.Windows.ContentElement.StylusInRangeEvent
  - System.Windows.ContentElement.StylusLeave
  - System.Windows.ContentElement.StylusLeaveEvent
  - System.Windows.ContentElement.StylusMove
  - System.Windows.ContentElement.StylusMoveEvent
  - System.Windows.ContentElement.StylusOutOfRange
  - System.Windows.ContentElement.StylusOutOfRangeEvent
  - System.Windows.ContentElement.StylusSystemGesture
  - System.Windows.ContentElement.StylusSystemGestureEvent
  - System.Windows.ContentElement.StylusUp
  - System.Windows.ContentElement.StylusUpEvent
  - System.Windows.ContentElement.TextInput
  - System.Windows.ContentElement.TextInputEvent
  - System.Windows.ContentElement.TouchDown
  - System.Windows.ContentElement.TouchDownEvent
  - System.Windows.ContentElement.TouchEnter
  - System.Windows.ContentElement.TouchEnterEvent
  - System.Windows.ContentElement.TouchesCaptured
  - System.Windows.ContentElement.TouchesCapturedWithin
  - System.Windows.ContentElement.TouchesDirectlyOver
  - System.Windows.ContentElement.TouchesOver
  - System.Windows.ContentElement.TouchLeave
  - System.Windows.ContentElement.TouchLeaveEvent
  - System.Windows.ContentElement.TouchMove
  - System.Windows.ContentElement.TouchMoveEvent
  - System.Windows.ContentElement.TouchUp
  - System.Windows.ContentElement.TouchUpEvent
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.#ctor
  id: '#ctor'
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FrameworkContentElement()
  nameWithType: FrameworkContentElement.FrameworkContentElement()
  fullName: System.Windows.FrameworkContentElement.FrameworkContentElement()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Инициализирует новый экземпляр <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> класса."
  syntax:
    content: public FrameworkContentElement ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)
  id: AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: AddLogicalChild(Object)
  nameWithType: FrameworkContentElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.AddLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Добавляет указанный элемент в качестве дочернего элемента этот элемент."
  remarks: "Этот метод может создать исключение, если вызывается в момент, когда выполняется итерация логического дерева с помощью другого процесса.       Большинство <xref:System.Windows.FrameworkContentElement>производные классы предоставляют выделенный коллекций, которые отвечают за вложения (например, <xref:System.Windows.Documents.Span.Inlines%2A> <xref:System.Windows.Documents.Span>класса; <xref:System.Windows.Documents.Section.Blocks%2A>на <xref:System.Windows.Documents.Section>класса).</xref:System.Windows.Documents.Section> </xref:System.Windows.Documents.Section.Blocks%2A> </xref:System.Windows.Documents.Span> </xref:System.Windows.Documents.Span.Inlines%2A> </xref:System.Windows.FrameworkContentElement> Обычно необходимость управления логического дерева напрямую, если наследование от этих классов, вместо этого можно избежать. Работа с логического дерева для элементов содержимого — расширенный сценарий, который может потребовать специализированное средство синтаксического анализа или специализированный <xref:System.Windows.FrameworkElement>, действует как родительский элемент отрисовки (хранилище содержимого).</xref:System.Windows.FrameworkElement>       Дополнительные сведения об использовании <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>и AddLogicalChild, в разделе [деревьев в WPF](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>"
  syntax:
    content: protected void AddLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "Добавляемый дочерний элемент."
  overload: System.Windows.FrameworkContentElement.AddLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginInit
  id: BeginInit
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginInit()
  nameWithType: FrameworkContentElement.BeginInit()
  fullName: System.Windows.FrameworkContentElement.BeginInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывается перед инициализацией элемента."
  syntax:
    content: public virtual void BeginInit ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Начинает последовательность действий, содержащихся в предоставленной раскадровке."
  remarks: "Для подписи, которые не используют `isControllable`, параметра, или при указании этого параметра `false`, связанные с анимацией часы шкалы времени удаляются сразу же после достижения периода «Заливка». Поэтому анимация не будет перезапущена после однократного запуска. Обратите внимание, что управление анимацией также требует раскадровки или доступа к ней как экземпляр в коде."
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "Чтобы начать раскадровку."
  overload: System.Windows.FrameworkContentElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Начинает последовательность действий, содержащихся в предоставленной раскадровке, с указанием, что должно произойти, если свойство уже анимировано."
  remarks: "Для подписи, которые не используют `isControllable`, параметра, или при указании этого параметра `false`, связанные с анимацией часы шкалы времени удаляются сразу же после достижения периода «Заливка». Поэтому анимация не будет перезапущена после однократного запуска. Обратите внимание, что управление анимацией также требует раскадровки или доступа к ней как экземпляр в коде.      ## Использование составлять HandoffBehavior при применении <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, или <xref:System.Windows.Media.Animation.AnimationClock>к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>, любые <xref:System.Windows.Media.Animation.Clock>ранее связанную с ним объекты по-прежнему потребление системных ресурсов; система времени не удаляет эти часы автоматически.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       Чтобы избежать проблем с производительностью при применении большое число часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior>, необходимо удалить составляющую часами анимированное свойство после их завершения.</xref:System.Windows.Media.Animation.HandoffBehavior> Существует несколько способов удаления часов: - чтобы удалить все часы из свойства, используйте <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>метод анимированного объекта.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Укажите в качестве первого параметра, анимируемого свойства и `null` вторым. При этом удаляются все часы анимации из свойства.      -Чтобы удалить <xref:System.Windows.Media.Animation.AnimationClock>из списка часов, используйте <xref:System.Windows.Media.Animation.Clock.Controller%2A>свойство <xref:System.Windows.Media.Animation.AnimationClock>для получения <xref:System.Windows.Media.Animation.ClockController>после чего вызовите <xref:System.Windows.Media.Animation.ClockController.Remove%2A>метод <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.ClockController.Remove%2A> </xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.AnimationClock> конкретных Обычно это делается <xref:System.Windows.Media.Animation.Clock.Completed>обработчика событий для часов.</xref:System.Windows.Media.Animation.Clock.Completed> Обратите внимание, что только корневые часы могут управляться <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A>свойство дочерних часов возвращает `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> Обратите внимание, что <xref:System.Windows.Media.Animation.Clock.Completed>событие не происходит, если эффективная продолжительность часов является бесконечностью.</xref:System.Windows.Media.Animation.Clock.Completed>  В этом случае пользователь должен определить, когда вызов <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       Это важно в основном для анимации объектов, с длительным временем существования.  При обнаружении объектов сбора мусора, его часы также будут отключены и собраны как мусор.       Дополнительные сведения об объектах часов см. в разделе [анимации и общие сведения о синхронизации системы](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "Чтобы начать раскадровку."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "Значение перечисления, которое описывает поведение, если свойство, описанное в раскадровке уже анимировано."
  overload: System.Windows.FrameworkContentElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Начинает последовательность действий, содержащихся в предоставленной раскадровке, с указанным состоянием управления анимацией после ее запуска."
  remarks: "Для подписи, которые не используют `isControllable`, параметра, или при указании этого параметра `false`, связанные с анимацией часы шкалы времени удаляются сразу же после достижения периода «Заливка». Поэтому анимация не будет перезапущена после однократного запуска. Обратите внимание, что управление анимацией также требует раскадровки или доступа к ней как экземпляр в коде.      ## Использование составлять HandoffBehavior при применении <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, или <xref:System.Windows.Media.Animation.AnimationClock>к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior> <xref:System.Windows.Media.Animation.HandoffBehavior>, любые <xref:System.Windows.Media.Animation.Clock>ранее связанную с ним объекты по-прежнему потребление системных ресурсов; система времени не удаляет эти часы автоматически.</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       Чтобы избежать проблем с производительностью при применении большое число часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior>, необходимо удалить составляющую часами анимированное свойство после их завершения.</xref:System.Windows.Media.Animation.HandoffBehavior> Существует несколько способов удаления часов: - чтобы удалить все часы из свойства, используйте <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>метод анимированного объекта.</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Укажите в качестве первого параметра, анимируемого свойства и `null` вторым. При этом удаляются все часы анимации из свойства.      -Чтобы удалить <xref:System.Windows.Media.Animation.AnimationClock>из списка часов, используйте <xref:System.Windows.Media.Animation.Clock.Controller%2A>свойство <xref:System.Windows.Media.Animation.AnimationClock>для получения <xref:System.Windows.Media.Animation.ClockController>после чего вызовите <xref:System.Windows.Media.Animation.ClockController.Remove%2A>метод <xref:System.Windows.Media.Animation.ClockController>.</xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.ClockController.Remove%2A> </xref:System.Windows.Media.Animation.ClockController> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.AnimationClock> конкретных Обычно это делается <xref:System.Windows.Media.Animation.Clock.Completed>обработчика событий для часов.</xref:System.Windows.Media.Animation.Clock.Completed> Обратите внимание, что только корневые часы могут управляться <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A>свойство дочерних часов возвращает `null`.</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> Обратите внимание, что <xref:System.Windows.Media.Animation.Clock.Completed>событие не происходит, если эффективная продолжительность часов является бесконечностью.</xref:System.Windows.Media.Animation.Clock.Completed>  В этом случае пользователь должен определить, когда вызов <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       Это важно в основном для анимации объектов, с длительным временем существования.  При обнаружении объектов сбора мусора, его часы также будут отключены и собраны как мусор.       Дополнительные сведения об объектах часов см. в разделе [анимации и общие сведения о синхронизации системы](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "Чтобы начать раскадровку."
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "Значение перечисления, которое описывает поведение, если свойство, описанное в раскадровке уже анимировано."
    - id: isControllable
      type: System.Boolean
      description: "Объявляет, является ли анимация управляемой (может быть приостановлена) после его запуска."
  overload: System.Windows.FrameworkContentElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BindingGroup
  id: BindingGroup
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BindingGroup
  nameWithType: FrameworkContentElement.BindingGroup
  fullName: System.Windows.FrameworkContentElement.BindingGroup
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает <xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref> , используемый для элемента."
  remarks: "Объект <xref:System.Windows.Data.BindingGroup>можно использовать для проверки значений нескольких свойств объекта.</xref:System.Windows.Data.BindingGroup> Предположим, что приложение предлагает пользователю ввести адрес и заполняет объект типа `Address`, который имеет свойства `Street`, `City`, `ZipCode`, и `Country`, со значениями, введенные пользователем. Приложение имеет панель, которая содержит четыре <xref:System.Windows.Controls.TextBox>элементов управления, привязанных к одному из свойств объекта.</xref:System.Windows.Controls.TextBox> Можно использовать <xref:System.Windows.Controls.ValidationRule>в <xref:System.Windows.Data.BindingGroup>для проверки `Address` объекта.</xref:System.Windows.Data.BindingGroup> </xref:System.Windows.Controls.ValidationRule> Например <xref:System.Windows.Controls.ValidationRule>можно обеспечить допустимость ZIP-код страны адреса.</xref:System.Windows.Controls.ValidationRule>       Дочерние элементы наследуют <xref:System.Windows.Data.BindingGroup>от своих родительских элементов, как и в случае любого другого наследуемые свойства.</xref:System.Windows.Data.BindingGroup>      <a name=&quot;dependencyPropertyInfo_BindingGroup&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|   | Значение свойства метаданных **true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.BindingGroupProperty>"
  syntax:
    content: public System.Windows.Data.BindingGroup BindingGroup { get; set; }
    return:
      type: System.Windows.Data.BindingGroup
      description: "<xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref> , Используемый для элемента."
  overload: System.Windows.FrameworkContentElement.BindingGroup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BindingGroupProperty
  id: BindingGroupProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BindingGroupProperty
  nameWithType: FrameworkContentElement.BindingGroupProperty
  fullName: System.Windows.FrameworkContentElement.BindingGroupProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.FrameworkContentElement.BindingGroup*>свойство зависимостей.</xref:System.Windows.FrameworkContentElement.BindingGroup*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty BindingGroupProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BringIntoView
  id: BringIntoView
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BringIntoView()
  nameWithType: FrameworkContentElement.BringIntoView()
  fullName: System.Windows.FrameworkContentElement.BringIntoView()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Пытается сделать видимым, прокручиваемыми областями которой он содержится внутри этого элемента."
  remarks: "Путем вызова данного метода, фактически будет вызываться <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>на все родительские прокручиваемую область, которая содержит элемент (родительский могут оказаться очень <xref:System.Windows.FrameworkElement>, а не <xref:System.Windows.FrameworkContentElement>).</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.FrameworkElement> </xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> Если этот элемент не содержится в прокручиваемую область, по-прежнему вызывается событие, но будет иметь никакого влияния."
  syntax:
    content: public void BringIntoView ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.BringIntoView*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenu
  id: ContextMenu
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenu
  nameWithType: FrameworkContentElement.ContextMenu
  fullName: System.Windows.FrameworkContentElement.ContextMenu
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает элемент контекстного меню, которое отображается при каждом запросе контекстного меню через [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] из внутри этого элемента."
  remarks: "<a name=&quot;dependencyPropertyInfo_ContextMenu&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.FrameworkContentElement.ContextMenuProperty>"
  example:
  - "The following example places a <xref:System.Windows.Controls.ContextMenu> on a <xref:System.Windows.Documents.Paragraph>.  \n  \n [!code-xml[ContentElementsSmorgasbord#ContextMenu](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page1.xaml#contextmenu)]"
  syntax:
    content: public System.Windows.Controls.ContextMenu ContextMenu { get; set; }
    return:
      type: System.Windows.Controls.ContextMenu
      description: "Контекстное меню, который использует этот элемент."
  overload: System.Windows.FrameworkContentElement.ContextMenu*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuClosing
  id: ContextMenuClosing
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuClosing
  nameWithType: FrameworkContentElement.ContextMenuClosing
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит непосредственно перед закрытием любого контекстного меню элемента."
  remarks: "Для подавления закрытия контекстных меню обработчики события следует пометить как обработанное.       Использовать это событие как <xref:System.Windows.EventTrigger>в стиле, необходимо сослаться на идентификатор события базовой службы: [!code-xml [CorePseudocode #FEContextMenuClosing](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuclosing) ] (такое использование является обязательным, поскольку реализация событий в <xref:System.Windows.FrameworkContentElement>, предоставляет базовое событие службы не сопоставляют правильно идентификатор ContextMenuClosing для использования в триггеры).</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_ContextMenuClosing&quot;></a>## Направлено сведения о событии ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|   | Стратегия маршрутизации | Передача вверх |   | Делегат | <xref:System.Windows.Controls.ContextMenuEventHandler>|</xref:System.Windows.Controls.ContextMenuEventHandler></xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>"
  example:
  - "The following example implements a handler that changes the cursor over a named region `DisplayArea` (not shown). The comment hints at a <xref:System.Windows.UIElement> usage, but in fact this sample would be identical if `DisplayArea` were a <xref:System.Windows.FrameworkContentElement>.  \n  \n [!code-cs[cursors#ChangeCursorsSample](~/add/codesnippet/csharp/cursors/Window1.xaml.cs#changecursorssample)]\n [!code-vb[cursors#ChangeCursorsSample](~/add/codesnippet/visualbasic/cursors/Window1.xaml.vb#changecursorssample)]"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  id: ContextMenuClosingEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuClosingEvent
  nameWithType: FrameworkContentElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuClosing&quot;> </xref> [направлено Общие сведения о событиях](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Объекты идентификатор события, создаваемые при их регистрации (см. <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и затем могут использоваться для добавления обработчиков класса (см. <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Идентификатор объекты содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuOpening
  id: ContextMenuOpening
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuOpening
  nameWithType: FrameworkContentElement.ContextMenuOpening
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит при открытии любого контекстного меню элемента."
  remarks: "Для открытия контекстных меню вручную обработчики событий должны помечать соответствующее событие как обработанное. В противном случае существующее значение <xref:System.Windows.FrameworkContentElement.ContextMenu%2A>будет использоваться свойство, чтобы автоматически открыть контекстное меню.</xref:System.Windows.FrameworkContentElement.ContextMenu%2A> Маркировка обрабатываемого события эффективно отменит действие по умолчанию и может быть возможность выполнить сброс значения <xref:System.Windows.FrameworkContentElement.ContextMenu%2A>Свойства и откройте новый <xref:System.Windows.Controls.ContextMenu>.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.FrameworkContentElement.ContextMenu%2A> Однако есть ошибки синхронизации, которые следует иметь в виду. Чтобы полностью заменить контекстного меню через обработчик ContextMenuOpening, меню исходного контекста не должно быть null или пустым. Кроме того может потребоваться обработать событие и затем вручную открыть новое контекстное меню. Дополнительные сведения см. в разделе [как: руководство](~/add/includes/ajax-current-ext-md.md).       Использовать это событие как <xref:System.Windows.EventTrigger>в стиле, необходимо сослаться на идентификатор события базовой службы: [!code-xml [CorePseudocode #FEContextMenuOpening](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuopening) ] (такое использование является обязательным, поскольку реализация событий в <xref:System.Windows.FrameworkContentElement>, предоставляет базовое событие службы не сопоставляют правильно идентификатор руководство для использования в триггеры).</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_ContextMenuOpening&quot;></a>## Направлено сведения о событии ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|   | Стратегия маршрутизации | Передача вверх |   | Делегат | <xref:System.Windows.Controls.ContextMenuEventHandler>|</xref:System.Windows.Controls.ContextMenuEventHandler></xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  id: ContextMenuOpeningEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkContentElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuOpening&quot;> </xref> [направлено Общие сведения о событиях](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Объекты идентификатор события, создаваемые при их регистрации (см. <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и затем могут использоваться для добавления обработчиков класса (см. <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Идентификатор объекты содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuProperty
  id: ContextMenuProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuProperty
  nameWithType: FrameworkContentElement.ContextMenuProperty
  fullName: System.Windows.FrameworkContentElement.ContextMenuProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.FrameworkContentElement.ContextMenu*>свойство зависимостей.</xref:System.Windows.FrameworkContentElement.ContextMenu*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ContextMenuProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Cursor
  id: Cursor
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Cursor
  nameWithType: FrameworkContentElement.Cursor
  fullName: System.Windows.FrameworkContentElement.Cursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает курсор, отображаемый, когда указатель мыши находится над данным элементом."
  remarks: "При задании этого свойства [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] процессора основывается на преобразование типа для <xref:System.Windows.Input.Cursor>класса для вычисления строки.</xref:System.Windows.Input.Cursor> Предоставленная строка должно выражаться <xref:System.Windows.Input.CursorType>значение.</xref:System.Windows.Input.CursorType> В разделе <xref:System.Windows.Input.Cursor>Подробные сведения.</xref:System.Windows.Input.Cursor>       Ли курсор в соответствии с параметром этого свойства будет или не будет отображаться, когда указатель мыши находится над данным элементом зависит от значения <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>свойство.</xref:System.Windows.FrameworkContentElement.ForceCursor%2A> Кроме того вопросы, связанные с событиями, как активное перетаскивание, захват мыши, режимы редактирования текста в элементы управления и т. д., также влияет на курсор с более высоким приоритетом, чем значение, указанное в данном свойстве.       Чтобы отменить поведение этого свойства к стандартному, задайте для него значение `null` еще раз.       `null` По умолчанию реально означает, что определение практического значения курсора здесь, откладывается и должны быть получены из другого источника. Если отображается без программный значений из любого источника, курсор по умолчанию над [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] приложения будет стрелкой.       Каждый движения мыши над [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] приложение создает событие <xref:System.Windows.ContentElement.QueryCursor>событий.</xref:System.Windows.ContentElement.QueryCursor> Событие может передаваться и любой элемент на маршруте имеет возможность обработать событие и задать значение для курсора через аргументов этого события. Если это происходит, тот факт, что событие обработано и имеет измененное значение в аргументах имеет приоритет над значением свойства Cursor на любом уровне, если <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>задано.</xref:System.Windows.FrameworkContentElement.ForceCursor%2A>       Если не создается специальный курсор, обычно можно установить это свойство в значение статического свойства <xref:System.Windows.Input.Cursors>класса.</xref:System.Windows.Input.Cursors>       Параметр <xref:System.Windows.Input.Cursor>пользовательское значение не включен в режиме частичного доверия.</xref:System.Windows.Input.Cursor> Дополнительные сведения о специальных курсорах см. в разделе [фокусе](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;dependencyPropertyInfo_Cursor&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.CursorProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.FrameworkContentElement.CursorProperty>"
  example:
  - "The following example sets the cursor to a custom value.  \n  \n [!code-cs[cursors#ChangeCursorsSample](~/add/codesnippet/csharp/cursors/Window1.xaml.cs#changecursorssample)]\n [!code-vb[cursors#ChangeCursorsSample](~/add/codesnippet/visualbasic/cursors/Window1.xaml.vb#changecursorssample)]"
  syntax:
    content: public System.Windows.Input.Cursor Cursor { get; set; }
    return:
      type: System.Windows.Input.Cursor
      description: "Отображаемый курсор. Значение по умолчанию определяется как <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> для данного свойства зависимостей. Тем не менее практике значение по умолчанию во время выполнения будет поступать из множества факторов."
  overload: System.Windows.FrameworkContentElement.Cursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.CursorProperty
  id: CursorProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: CursorProperty
  nameWithType: FrameworkContentElement.CursorProperty
  fullName: System.Windows.FrameworkContentElement.CursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.FrameworkContentElement.Cursor*>свойство зависимостей.</xref:System.Windows.FrameworkContentElement.Cursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty CursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DataContext
  id: DataContext
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DataContext
  nameWithType: FrameworkContentElement.DataContext
  fullName: System.Windows.FrameworkContentElement.DataContext
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает контекст данных для элемента, участвующего в привязке данных."
  remarks: "*Контекст данных* — концепция, которая позволяет элементам наследовать от своих родительских элементов об источнике привязки, который используется для привязки, а также другие характеристики привязки, например путь информацию.       Контекст данных можно задать непосредственно в [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] объекта с привязками, вычисляемыми в свойства этого объекта. Кроме того, можно задать контекст данных <xref:System.Windows.Data.DataSourceProvider>объекта.</xref:System.Windows.Data.DataSourceProvider>       Это свойство зависимостей наследуется значений свойств. Если имеются дочерние элементы и не имеет значения для DataContext, установленное с помощью локальных значений или стилей, в системе свойств установит это значение должно быть значение DataContext ближайшего родительского элемента с назначенным данным значением.       Кроме того, можно использовать один из следующих свойств <xref:System.Windows.Data.Binding>класс, чтобы явно указать источник привязки: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, или <xref:System.Windows.Data.Binding.RelativeSource%2A>.</xref:System.Windows.Data.Binding.RelativeSource%2A> </xref:System.Windows.Data.Binding.Source%2A> </xref:System.Windows.Data.Binding.ElementName%2A> </xref:System.Windows.Data.Binding> Дополнительные сведения см. в разделе [как: Укажите источник привязки](~/add/includes/ajax-current-ext-md.md).       В [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], DataContext чаще всего значение как <xref:System.Windows.Data.Binding>объявление.</xref:System.Windows.Data.Binding> Можно использовать синтаксис элемента свойства или синтаксис атрибутов. Синтаксис атрибутов показан в примере на этой странице. Можно также задать элемент DataContext в коде.      <a name=&quot;xamlPropertyElementUsage_DataContext&quot;></a>## Использование элемента свойства XAML ```   <object>     <object.DataContext>       <dataContextObject />     </object.DataContext>   </object>   ``` <a name=&quot;xamlAttributeUsage_DataContext&quot;> </a> ## использование атрибута XAML ```   <object DataContext=&quot;bindingUsage&quot;/>   - or -   <object DataContext=&quot;{resourceExtension contextResourceKey}&quot;/>   ``` <a name=&quot;xamlValues_DataContext&quot;> </a> ## значений XAML *dataContextObject* непосредственно внедренный объект, который служит в качестве контекста данных для любых привязок внутри родительского элемента.             Как правило, этот объект является <xref:System.Windows.Data.Binding>или другой <xref:System.Windows.Data.BindingBase>подкласс.</xref:System.Windows.Data.BindingBase> </xref:System.Windows.Data.Binding> Кроме того необработанные данные любого [!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)] предназначен для привязки могут быть помещены с фактические привязки определить позже, тип объекта.       *bindingUsage* использование привязки, результатом вычисления которого в соответствующий контекст данных. Дополнительные сведения см. в разделе [привязки расширения разметки](~/add/includes/ajax-current-ext-md.md).       *resourceExtension* одно из следующих: `StaticResource`, или `DynamicResource`. Данный подход используется при обращении к необработанным данным объектом, в ресурсах. В разделе [ресурсов XAML](~/add/includes/ajax-current-ext-md.md).       *contextResourceKey* идентификатор ключа для объекта, запрашиваемых в <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      <a name=&quot;dependencyPropertyInfo_DataContext&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.DataContextProperty>|   | Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.DataContextProperty>"
  example:
  - "The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as DataContext, and setting the binding path to a property within it.  \n  \n [!code-cs[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#datacontext)]\n [!code-vb[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#datacontext)]"
  syntax:
    content: public object DataContext { get; set; }
    return:
      type: System.Object
      description: "Объект для использования в качестве контекста данных."
  overload: System.Windows.FrameworkContentElement.DataContext*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DataContextChanged
  id: DataContextChanged
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DataContextChanged
  nameWithType: FrameworkContentElement.DataContextChanged
  fullName: System.Windows.FrameworkContentElement.DataContextChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит при изменении контекста данных этого элемента."
  remarks: "Объяснение контекстов данных и привязки данных см. в разделе [Общие сведения о привязке данных](~/add/includes/ajax-current-ext-md.md).      Настроек [!IMPORTANT] настроек при элемента <xref:System.Windows.FrameworkContentElement.DataContext%2A>потенциально влияет изменения, все свойства с привязкой к данным для этого элемента.</xref:System.Windows.FrameworkContentElement.DataContext%2A> Это применяется к любым элементам, являющимся элементов-потомков текущего элемента, наследующим контекст данных, а также сам элемент. Все привязки повторно интерпретировать новый <xref:System.Windows.FrameworkContentElement.DataContext%2A>в соответствии с новым значением в привязках.</xref:System.Windows.FrameworkContentElement.DataContext%2A> Нет никакой гарантии, о порядке относительно создания события DataContextChanged этих изменений.  Изменения могут происходить перед событием, после события или в любом сочетании."
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DataContextProperty
  id: DataContextProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DataContextProperty
  nameWithType: FrameworkContentElement.DataContextProperty
  fullName: System.Windows.FrameworkContentElement.DataContextProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.FrameworkContentElement.DataContext*>свойство зависимостей.</xref:System.Windows.FrameworkContentElement.DataContext*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty DataContextProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DefaultStyleKey
  id: DefaultStyleKey
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DefaultStyleKey
  nameWithType: FrameworkContentElement.DefaultStyleKey
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKey
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает ключ, используемый для поиска шаблона стиля для этого элемента управления в темах."
  remarks: "Это свойство обычно не задается через какой-либо из его прямых переключателей. Вместо этого каждый раз при создании нового подкласса переопределения метаданных определенного типа этого свойства зависимостей. Когда вы подкласс, вызовите <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>метода для <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>идентификатор в статическом конструкторе подкласса элемента управления.</xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> </xref:System.Windows.DependencyProperty.OverrideMetadata%2A>       Для экземпляра класса встроенной, например <xref:System.Windows.Documents.Bold>фактически имеет очень мало реализацию помимо переопределения метаданных DefaultStyleKey статический конструктор, и предоставление некоторые конструкторы экземпляров.</xref:System.Windows.Documents.Bold> Тот факт, что элементы окружена <xref:System.Windows.Documents.Bold>тег рост <xref:System.Windows.Documents.TextElement.FontWeight%2A>свойство <xref:System.Windows.FontWeights.Bold%2A>реализуется в стиль темы, который указывает ссылка, задав значение по умолчанию DefaultStyleKey для `typeof(Bold)`.</xref:System.Windows.FontWeights.Bold%2A> </xref:System.Windows.Documents.TextElement.FontWeight%2A> </xref:System.Windows.Documents.Bold>       Элемент или элемент управления, намеренно не используемый тематических стилей, установите <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>Свойства `true`.</xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>      <a name=&quot;dependencyPropertyInfo_DefaultStyleKey&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|   | Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>"
  syntax:
    content: protected object DefaultStyleKey { get; set; }
    return:
      type: System.Object
      description: "Ключ стиля. Для правильной работы в процессе поиска тематического стиля, это значение должно быть <xref:System.Type>элемента, к которому применяется стиль.</xref:System.Type> <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>Утвержденное значение в некоторых случаях; см. заметки."
  overload: System.Windows.FrameworkContentElement.DefaultStyleKey*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  id: DefaultStyleKeyProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkContentElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.FrameworkContentElement.DefaultStyleKey*>свойство зависимостей.</xref:System.Windows.FrameworkContentElement.DefaultStyleKey*>"
  syntax:
    content: protected static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.EndInit
  id: EndInit
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: EndInit()
  nameWithType: FrameworkContentElement.EndInit()
  fullName: System.Windows.FrameworkContentElement.EndInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывается сразу после инициализации элемента."
  remarks: "Реализация этого метода для обеспечения специальной обработки, которое должно происходить при инициализации во время процесса загрузки элемента.       Реализация должна вызывать базовую реализацию, поскольку реализация base (по умолчанию) устанавливает внутренние флаги для отслеживания инициализации.       Если <xref:System.Windows.FrameworkContentElement.BeginInit%2A>был вызван ранее, базовый вызывает реализацию <xref:System.Windows.FrameworkContentElement.Initialized>событий.</xref:System.Windows.FrameworkContentElement.Initialized> </xref:System.Windows.FrameworkContentElement.BeginInit%2A> В противном случае, если <xref:System.Windows.FrameworkContentElement.BeginInit%2A>не был вызван или не удалось определить, является ли <xref:System.Windows.FrameworkContentElement.BeginInit%2A>был вызван, событие не происходит.</xref:System.Windows.FrameworkContentElement.BeginInit%2A> </xref:System.Windows.FrameworkContentElement.BeginInit%2A>"
  syntax:
    content: public virtual void EndInit ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FindName(System.String)
  id: FindName(System.String)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FindName(String)
  nameWithType: FrameworkContentElement.FindName(String)
  fullName: System.Windows.FrameworkContentElement.FindName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Находит элемент по указанному имени идентификатора."
  remarks: "Если этот элемент содержит дочерние элементы, эти дочерние элементы являются все выполняется рекурсивный поиск запрошенного именованного элемента."
  example:
  - "The following example sets a property on an element found by name within a referenced <xref:System.Windows.Documents.FlowDocument> on a page.  \n  \n [!code-cs[ContentElementsSmorgasbord#FindName](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#findname)]\n [!code-vb[ContentElementsSmorgasbord#FindName](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#findname)]"
  syntax:
    content: public object FindName (string name);
    parameters:
    - id: name
      type: System.String
      description: "Имя элемента для поиска."
    return:
      type: System.Object
      description: "Запрошенный элемент. Возможно, <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если нет соответствующий элемент не найден."
  overload: System.Windows.FrameworkContentElement.FindName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: FrameworkContentElement.FindResource(Object)
  fullName: System.Windows.FrameworkContentElement.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ищет ресурс с указанным ключом, а также будет исключение, если запрошенный ресурс не найден."
  remarks: "> [!IMPORTANT]Настроек при вызове этого метода для ключа, который не удается найти, создается исключение. Если вы не хотите обрабатывать исключения для этого случая, вместо этого следует вызывать <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</xref:System.Windows.FrameworkContentElement.TryFindResource%2A> <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>Возвращает `null` Если ресурс не найден и не вызывает исключение.</xref:System.Windows.FrameworkContentElement.TryFindResource%2A>       Если ресурс не найден в вызывающем элементе, поиск в родительском дереве с помощью логического дерева, таким же образом, что было бы дерева поисковое ли ресурс, запрошенного по ключу во время выполнения.       Обычно вы сразу же привести возвращаемое значение к типу свойства, которое вы пытаетесь набор с возвращенным значением ресурса."
  example:
  - "The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.  \n  \n [!code-cs[ContentElementsSmorgasbord#FindResource](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#findresource)]\n [!code-vb[ContentElementsSmorgasbord#FindResource](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#findresource)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "Идентификатор ключа ресурса, который требуется найти."
    return:
      type: System.Object
      description: "Найденный ресурс или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если соответствующий ресурс не найден (но также вызовет исключение, если <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>)."
  overload: System.Windows.FrameworkContentElement.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "Запрошенный ключ ресурса не найден."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceKey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FocusVisualStyle
  id: FocusVisualStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FocusVisualStyle
  nameWithType: FrameworkContentElement.FocusVisualStyle
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает объект, позволяющий настройку внешнего вида, эффектов или других характеристик стиля, применяемых к данному элементу, когда он получает фокус клавиатуры."
  remarks: "При задании этого свойства [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], стили, почти всегда определяются как ресурс, а не встроенными как элемент, и этот ресурс обычно указывается как <xref:System.Windows.StaticResourceExtension>.</xref:System.Windows.StaticResourceExtension>       Обратите внимание, что это свойство влияет на внешний вид, но не сообщает это в метаданных. Это так, как изменение внешнего вида управляется событиями и могут применяться не все время, таким образом не следует сообщать обычно любые сведения о visual или макета в метаданных.       По существу visual поведение фокуса, примененного к элементу управления, должно быть согласовано от элемента к элементу. Наиболее понятным способом применения согласованности является изменение стиля визуального отображения фокуса только при составлении целой темы. Задание этого свойства отдельных стилей, не являющийся частью темы не предполагаемое использование этого свойства, так как это может привести к путанице при использовании фокуса клавиатуры. Если планируется поведение отдельных элементов, которое намеренно не согласовано в в теме гораздо лучшим подходом является использование триггеров в стилях для отдельных свойств состояния ввода, такие как <xref:System.Windows.UIElement.IsFocused%2A>или <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>и таким образом, в результате которого не мешает визуально любой существующий стиль визуального отображения фокуса.</xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> </xref:System.Windows.UIElement.IsFocused%2A> Дополнительные сведения о необходимым стиля визуального отображения фокуса и альтернативные фокус свойств в разделе [стиля фокуса в элементах управления и стиля визуального отображения фокуса](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_FocusVisualStyle&quot;></a>## Использование атрибута XAML ```   <object FocusVisualStyle=&quot;{resourceExtension styleResourceKey}&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_FocusVisualStyle&quot;> </a> ## использование элемента свойства XAML <a name=&quot;xamlValues_FocusVisualStyle&quot;> </a> ## значений XAML *resourceExtension* одно из следующих:, или.       В разделе [ресурсов XAML](~/add/includes/ajax-current-ext-md.md).       *styleResourceKey* ключ, который определяет запрашиваемый стиль. Ключ ссылается на существующий ресурс в <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      Настроек [!NOTE] настроек синтаксис элемента свойства технически возможно, но не рекомендуется. В разделе [встроенные стили и шаблоны](~/add/includes/ajax-current-ext-md.md).  Ссылка привязки с помощью или <xref:System.Windows.Data.Binding>также является, возможно, но встречается редко.</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_FocusVisualStyle&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>"
  syntax:
    content: public System.Windows.Style FocusVisualStyle { get; set; }
    return:
      type: System.Windows.Style
      description: "Требуемый стиль для применения при получении фокуса. Значение по умолчанию, как объявлено в свойстве зависимости является пустой статический <xref href=&quot;System.Windows.Style&quot;> </xref>. Тем не менее, является действительным значением во время выполнения часто (но не всегда) является стилем, переданным поддержкой тем для элементов управления."
  overload: System.Windows.FrameworkContentElement.FocusVisualStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  id: FocusVisualStyleProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FocusVisualStyleProperty
  nameWithType: FrameworkContentElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.FrameworkContentElement.FocusVisualStyle*>свойство зависимостей.</xref:System.Windows.FrameworkContentElement.FocusVisualStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ForceCursor
  id: ForceCursor
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ForceCursor
  nameWithType: FrameworkContentElement.ForceCursor
  fullName: System.Windows.FrameworkContentElement.ForceCursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает значение, указывающее ли это <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> должно требовать [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)] отображение курсора, объявленные в этом экземпляре <xref:System.Windows.FrameworkContentElement.Cursor*>свойство.</xref:System.Windows.FrameworkContentElement.Cursor*>"
  remarks: "Присвоение этому свойству `true` переопределяют настройки курсора, установленные дочерними элементами. Поэтому в общем приложения это [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] может сбить с толку для пользователей, особенно в том случае, если дочерние элементы пытаются задавать курсоры. Параметр <xref:System.Windows.FrameworkElement.ForceCursor%2A>больше подходит в сценариях управления подклассы или композиции.</xref:System.Windows.FrameworkElement.ForceCursor%2A>      <a name=&quot;dependencyPropertyInfo_ForceCursor&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.FrameworkContentElement.ForceCursorProperty>"
  example:
  - "The following example forces the cursor while over the element.  \n  \n [!code-xml[ForceCursor#ForceCursor](~/add/codesnippet/xaml/forcecursor/default.xaml#forcecursor)]"
  syntax:
    content: public bool ForceCursor { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>для принудительного презентации курсора над данным элементом, чтобы использовать данный экземпляр задание для курсора (включая все дочерние элементы); в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.ForceCursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ForceCursorProperty
  id: ForceCursorProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ForceCursorProperty
  nameWithType: FrameworkContentElement.ForceCursorProperty
  fullName: System.Windows.FrameworkContentElement.ForceCursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.FrameworkContentElement.ForceCursor*>свойство зависимостей.</xref:System.Windows.FrameworkContentElement.ForceCursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ForceCursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)
  id: GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkContentElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkContentElement.GetBindingExpression(DependencyProperty)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref> для указанного свойства привязки."
  remarks: ''
  example:
  - "The following example retrieves a binding by querying a property.  \n  \n [!code-cs[ContentElementsSmorgasbord#GetBindingExpression](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#getbindingexpression)]\n [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#getbindingexpression)]"
  syntax:
    content: public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Целевой объект <xref href=&quot;System.Windows.DependencyProperty&quot;> </xref> из которого нужно получить привязку."
    return:
      type: System.Windows.Data.BindingExpression
      description: "Возвращает <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref> Если целью является привязкой данных; в противном случае <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.GetBindingExpression*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.GetUIParentCore
  id: GetUIParentCore
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: GetUIParentCore()
  nameWithType: FrameworkContentElement.GetUIParentCore()
  fullName: System.Windows.FrameworkContentElement.GetUIParentCore()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает альтернативный логический родительский объект для этого элемента при отсутствии визуального родительского объекта. В этом случае <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> родителем является всегда совпадает со значением <xref:System.Windows.FrameworkContentElement.Parent*>свойство.</xref:System.Windows.FrameworkContentElement.Parent*>"
  remarks: "Реализация по умолчанию возвращает ожидаемый единый визуальный родитель. Пользовательские реализации могут возвращать альтернативные родительские связи."
  syntax:
    content: protected override System.Windows.DependencyObject GetUIParentCore ();
    parameters: []
    return:
      type: System.Windows.DependencyObject
      description: "Возвращает нечто, отличное от <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> каждый раз, когда реализация уровня инфраструктуры WPF этого метода имеет подключение без визуального родительского объекта."
  overload: System.Windows.FrameworkContentElement.GetUIParentCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Initialized
  id: Initialized
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Initialized
  nameWithType: FrameworkContentElement.Initialized
  fullName: System.Windows.FrameworkContentElement.Initialized
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит, когда это <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> инициализируется. Совпадает со случаем где значение <xref:System.Windows.FrameworkContentElement.IsInitialized*>изменяет свойство <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> (или неопределенное) для <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.IsInitialized*>"
  remarks: "Это событие будет каждый раз, когда возникает <xref:System.Windows.FrameworkContentElement.EndInit%2A>или <xref:System.Windows.FrameworkContentElement.OnInitialized%2A>методы вызываются.</xref:System.Windows.FrameworkContentElement.OnInitialized%2A> </xref:System.Windows.FrameworkContentElement.EndInit%2A> Вызовы этих методов могут выполняться из произвольного кода, либо by [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] процесса загрузки."
  syntax:
    content: public event EventHandler Initialized;
    return:
      type: System.EventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.InputScope
  id: InputScope
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: InputScope
  nameWithType: FrameworkContentElement.InputScope
  fullName: System.Windows.FrameworkContentElement.InputScope
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает контекст для входных данных, используемые этим <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref>."
  remarks: "Это свойство зависимостей наследуется значений свойств. Если имеются дочерние элементы и не имеет значения для <xref:System.Windows.FrameworkElement.InputScope%2A>установленное с помощью локальных значений или стилей, в системе свойств будет задать это значение должно быть <xref:System.Windows.FrameworkElement.InputScope%2A>значение ближайшего родительского элемента с назначенным данным значением.</xref:System.Windows.FrameworkElement.InputScope%2A> </xref:System.Windows.FrameworkElement.InputScope%2A>       Несмотря на то что [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] использование синтаксиса указано и синтаксически разрешено, задание этого свойства [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] не так часто.      <a name=&quot;dependencyPropertyInfo_InputScope&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.InputScopeProperty>|   | Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.InputScopeProperty>"
  syntax:
    content: public System.Windows.Input.InputScope InputScope { get; set; }
    return:
      type: System.Windows.Input.InputScope
      description: "Область ввода, которая изменяет интерпретацию ввода с помощью альтернативных методов. Значение по умолчанию — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> (что приводит к обработке команд по умолчанию)."
  overload: System.Windows.FrameworkContentElement.InputScope*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.InputScopeProperty
  id: InputScopeProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: InputScopeProperty
  nameWithType: FrameworkContentElement.InputScopeProperty
  fullName: System.Windows.FrameworkContentElement.InputScopeProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.FrameworkContentElement.InputScope*>свойство зависимостей.</xref:System.Windows.FrameworkContentElement.InputScope*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty InputScopeProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.IsInitialized
  id: IsInitialized
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: IsInitialized
  nameWithType: FrameworkContentElement.IsInitialized
  fullName: System.Windows.FrameworkContentElement.IsInitialized
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает значение, указывающее, этот элемент был ли инициализирован, либо путем загрузки как [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)], либо путем явного его <xref:System.Windows.FrameworkContentElement.EndInit*>вызываемый метод.</xref:System.Windows.FrameworkContentElement.EndInit*>"
  remarks: "Это свойство также может быть `true` Если этот элемент был перемещен в пределах дерева элементов таким образом, что он имеет новый родительский элемент и снова станет перегруженным."
  syntax:
    content: public bool IsInitialized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если элемент инициализирован вышеупомянутой загрузки или вызовов метода; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.IsInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.IsLoaded
  id: IsLoaded
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: IsLoaded
  nameWithType: FrameworkContentElement.IsLoaded
  fullName: System.Windows.FrameworkContentElement.IsLoaded
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает значение, указывающее, загружен ли данный элемент для презентации."
  remarks: "Вновь созданного экземпляра начинается это свойство `false`и остается `true` после ее установки `true`, даже если затем удаляется из кода."
  example:
  - "The following example code uses IsLoaded as a conditional check to assure that a function `displayData` (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler. That same logic is run as an event handler for <xref:System.Windows.FrameworkContentElement.Loaded>.  \n  \n [!code-cs[ContentElementsSmorgasbord#IsLoaded](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#isloaded)]\n [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#isloaded)]"
  syntax:
    content: public bool IsLoaded { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если текущий элемент присоединен к дереву элементов и визуализирован; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если элемент никогда не был присоединен к загруженному дереву элементов."
  overload: System.Windows.FrameworkContentElement.IsLoaded*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Language
  id: Language
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Language
  nameWithType: FrameworkContentElement.Language
  fullName: System.Windows.FrameworkContentElement.Language
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает сведения о языке локализации и глобализации, который применяется к отдельному элементу."
  remarks: "Строковые форматы соответствуют стандарту RFC 3066. К примеру США Английский — «en US». В разделе <xref:System.Windows.Markup.XmlLanguage>Дополнительные сведения о значениях и формате.</xref:System.Windows.Markup.XmlLanguage>       Это свойство зависимостей наследуется значений свойств. Если имеются дочерние элементы и не имеет значения для <xref:System.Windows.FrameworkElement.Language%2A>установленное с помощью локальных значений или стилей, в системе свойств будет задать это значение должно быть <xref:System.Windows.FrameworkElement.Language%2A>значение ближайшего родительского элемента с назначенным данным значением.</xref:System.Windows.FrameworkElement.Language%2A> </xref:System.Windows.FrameworkElement.Language%2A>      <a name=&quot;dependencyPropertyInfo_CultureInfo&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.LanguageProperty>|   | Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.LanguageProperty>"
  syntax:
    content: public System.Windows.Markup.XmlLanguage Language { get; set; }
    return:
      type: System.Windows.Markup.XmlLanguage
      description: "Сведения о культуре для данного элемента. Значение по умолчанию — <xref href=&quot;System.Windows.Markup.XmlLanguage&quot;> </xref> экземпляра с его <xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>значение в строку «en US».</xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>"
  overload: System.Windows.FrameworkContentElement.Language*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.LanguageProperty
  id: LanguageProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: LanguageProperty
  nameWithType: FrameworkContentElement.LanguageProperty
  fullName: System.Windows.FrameworkContentElement.LanguageProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.FrameworkContentElement.Language*>свойство зависимостей.</xref:System.Windows.FrameworkContentElement.Language*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LanguageProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Loaded
  id: Loaded
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Loaded
  nameWithType: FrameworkContentElement.Loaded
  fullName: System.Windows.FrameworkContentElement.Loaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит, когда элемент размещен, отрисован и готов к взаимодействию."
  remarks: "События с прямой маршрутизацией не следуют по маршруту, они обрабатываются только внутри элемента, на котором они вызываются. Прямые перенаправленные события поддерживают другое поведение перенаправленных событий: они поддерживают коллекцию доступных обработчиков и могут использоваться как <xref:System.Windows.EventTrigger>в стиле.</xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_Loaded&quot;></a>## Направлено сведения о событии ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.LoadedEvent>|   | Стратегия маршрутизации | Прямой |   | Делегат | <xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkContentElement.LoadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Loaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.LoadedEvent
  id: LoadedEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: LoadedEvent
  nameWithType: FrameworkContentElement.LoadedEvent
  fullName: System.Windows.FrameworkContentElement.LoadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref href=&quot;System.Windows.FrameworkContentElement.Loaded&quot;> </xref> [направлено Общие сведения о событиях](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Объекты идентификатор события, создаваемые при их регистрации (см. <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и затем могут использоваться для добавления обработчиков класса (см. <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Идентификатор объекты содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события."
  syntax:
    content: public static readonly System.Windows.RoutedEvent LoadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.LogicalChildren
  id: LogicalChildren
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: LogicalChildren
  nameWithType: FrameworkContentElement.LogicalChildren
  fullName: System.Windows.FrameworkContentElement.LogicalChildren
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает перечислитель для логических дочерних элементов данного элемента."
  remarks: "Дополнительные сведения об использовании LogicalChildren и <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, в разделе [деревьев в WPF](~/add/includes/ajax-current-ext-md.md).</xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>"
  syntax:
    content: protected virtual System.Collections.IEnumerator LogicalChildren { get; }
    return:
      type: System.Collections.IEnumerator
      description: "Перечислитель для логических дочерних элементов данного элемента."
  overload: System.Windows.FrameworkContentElement.LogicalChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  id: MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkContentElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkContentElement.MoveFocus(TraversalRequest)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Перемещает фокус из этого элемента к другому элементу."
  syntax:
    content: public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);
    parameters:
    - id: request
      type: System.Windows.Input.TraversalRequest
      description: "Направление, в котором фокус находится перемещаемого как значение перечисления."
    return:
      type: System.Boolean
      description: "Возвращает <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref> Если фокус перемещен успешно; <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> Если указанный целевой элемент в направлении, что не существует."
  overload: System.Windows.FrameworkContentElement.MoveFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Name
  id: Name
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Name
  nameWithType: FrameworkContentElement.Name
  fullName: System.Windows.FrameworkContentElement.Name
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает имя, идентифицирующее элемент. Имя предоставляет ссылку на экземпляр, чтобы программный код программной части, например код обработчика событий, мог ссылаться на элемент после его создания в ходе синтаксического анализа [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]."
  remarks: "Наиболее распространенное использование этого свойства является при задании [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] имя элемента в разметке.       По сути, это свойство предоставляет свойство удобства уровня платформы WPF для задания [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] [директива x: Name](~/add/includes/ajax-current-ext-md.md).       Получение имени из кода не так часто, потому что, если в коде уже присутствует соответствующая ссылка, может просто вызвать методы и свойства в элементе ссылки и выполните обычно требуется имя. Исключение — если строка имеет несколько перегруженных значение, например если полезно отображать это имя в [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]. Задание имени из кода, если исходное имя было задано из разметки также не рекомендуется и изменение значения свойства не меняется ссылка на объект. Ссылки на такие объекты создаются только в том случае, если основной области видимости имен явно создаются во время [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] загрузки.       Необходимо явно вызывать <xref:System.Windows.FrameworkContentElement.RegisterName%2A>действующие сделать по свойству Name элемента уже загружен.</xref:System.Windows.FrameworkContentElement.RegisterName%2A>       Для именования элементов, которые запускаются раскадровки является значительным случаем где имя параметра из кода. Прежде чем выполнять регистрацию имени, может потребоваться создать и назначить <xref:System.Windows.NameScope>экземпляра.</xref:System.Windows.NameScope> См. в разделе, или [Общие](~/add/includes/ajax-current-ext-md.md).       Имя параметра из кода имеет ограниченные приложения, но поиск элемента по имени чаще, особенно если задействуется модель навигации перезагрузкой страниц в приложение и код времени выполнения не обязательно является кодом программной части соответствующей страницы. Вспомогательный метод <xref:System.Windows.FrameworkContentElement.FindName%2A>, которое доступно из любого <xref:System.Windows.FrameworkContentElement>, можно найти любой элемент по имени в рекурсивно логического дерева этого элемента.</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.FrameworkContentElement.FindName%2A> Или можно использовать <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>статический метод <xref:System.Windows.LogicalTreeHelper>, принимающий строку имени в качестве аргумента.</xref:System.Windows.LogicalTreeHelper> </xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>       Часто используемые корневые элементы (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page>например) реализуют интерфейс <xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.Controls.Page> </xref:System.Windows.Window> Реализации этого интерфейса ожидается обеспечение однозначности имен в пределах их области.      <a name=&quot;dependencyPropertyInfo_Name&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.NameProperty>|   | Значение свойства метаданных `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> </xref:System.Windows.FrameworkContentElement.NameProperty>"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "Имя элемента."
  overload: System.Windows.FrameworkContentElement.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.NameProperty
  id: NameProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: NameProperty
  nameWithType: FrameworkContentElement.NameProperty
  fullName: System.Windows.FrameworkContentElement.NameProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.FrameworkContentElement.Name*>свойство зависимостей.</xref:System.Windows.FrameworkContentElement.Name*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty NameProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывается каждый раз, когда <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuClosing&quot;> </xref> перенаправленное событие встречает на своем маршруте этого класса. Реализуйте этот метод, чтобы добавить обработчик класса для данного события."
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers. Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "Предоставляет данные о событии."
  overload: System.Windows.FrameworkContentElement.OnContextMenuClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывается каждый раз, когда <xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuOpening&quot;> </xref> перенаправленное событие встречает на своем маршруте этого класса. Реализуйте этот метод, чтобы добавить обработчик класса для данного события."
  remarks: "This method has no default implementation. You should still call base() in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "Данные события для события."
  overload: System.Windows.FrameworkContentElement.OnContextMenuOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  id: OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkContentElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnGotFocus(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Обработчик класса для <xref href=&quot;System.Windows.ContentElement.GotFocus&quot;> </xref> событий."
  remarks: "Этот обработчик класса задает соответствующее поведение фокуса на этот элемент, если событие происходит из этого элемента. Если источником события был другой элемент дерева, обработчик не выполняет никаких действий.       Переопределите этот метод, чтобы изменить фокусировки на вашем элементе поведение по умолчанию."
  syntax:
    content: protected override void OnGotFocus (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "Данные события для события."
  overload: System.Windows.FrameworkContentElement.OnGotFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)
  id: OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkContentElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkContentElement.OnInitialized(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывает <xref href=&quot;System.Windows.FrameworkContentElement.Initialized&quot;> </xref> событий. Этот метод вызывается каждый раз, когда <xref:System.Windows.FrameworkContentElement.IsInitialized*>имеет значение <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.IsInitialized*>"
  remarks: "Реализация по умолчанию данного виртуального метода вызывает событие, как описано ранее в этом разделе. Переопределение должно вызывать base() для сохранения этого поведения.       Обратите внимание, что <xref:System.Windows.FrameworkContentElement.IsInitialized%2A>свойство доступно только для чтения.</xref:System.Windows.FrameworkContentElement.IsInitialized%2A> Таким образом нельзя задать для него принудительную инициализацию таким образом. Параметр инициализации должен выполняться только [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] framework."
  syntax:
    content: protected virtual void OnInitialized (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "Данные события для события."
  overload: System.Windows.FrameworkContentElement.OnInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывается каждый раз, когда действительное значение любого свойства зависимостей для данного <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> был обновлен. Измененное свойство конкретных зависимостей сообщается в параметре аргументов. Переопределяет <xref:System.Windows.DependencyObject.OnPropertyChanged*>.</xref:System.Windows.DependencyObject.OnPropertyChanged*>"
  remarks: "Этот метод не предназначен для общего выявления изменений свойств или их недействительности. Он предназначен для изменения общего шаблона недействительности, если известна определенная информация о широких классификациях свойств.       Этот метод потенциально вызывается несколько раз за время существования объекта. Таким образом, можно улучшить производительность, если переопределения метаданных свойств, а затем подключите <xref:System.Windows.CoerceValueCallback>или <xref:System.Windows.PropertyChangedCallback>функции для отдельных свойств.</xref:System.Windows.PropertyChangedCallback> </xref:System.Windows.CoerceValueCallback> Тем не менее, будет использовать этот метод, если <xref:System.Windows.FrameworkContentElement>включает значительное количество свойств зависимостей с взаимосвязанными значениями, или если он содержит логику, например поведение отрисовки, необходимо повторно для нескольких связанных случаев недействительности свойств.</xref:System.Windows.FrameworkContentElement>       Обратите внимание, что таким же именем `OnPropertyChanged` метод с другой сигнатурой (тип параметра является <xref:System.ComponentModel.PropertyChangedEventArgs>), которые могут возникнуть на несколько классов.</xref:System.ComponentModel.PropertyChangedEventArgs> Что `OnPropertyChanged` используется для уведомления объекта данных и является частью контракта <xref:System.ComponentModel.INotifyPropertyChanged>.</xref:System.ComponentModel.INotifyPropertyChanged>"
  syntax:
    content: protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "Данные события, описывающие измененное свойство, включая старое и новое значения."
  overload: System.Windows.FrameworkContentElement.OnPropertyChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  id: OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkContentElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkContentElement.OnStyleChanged(Style,Style)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывается при использовании стиля, для данного элемента."
  remarks: "Этот метод имеет реализацию по умолчанию, которая задает внутренний флаг, уведомляя об измененном состоянии стиля."
  syntax:
    content: protected virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);
    parameters:
    - id: oldStyle
      type: System.Windows.Style
      description: "Старый стиль."
    - id: newStyle
      type: System.Windows.Style
      description: "Новый стиль."
  overload: System.Windows.FrameworkContentElement.OnStyleChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывается каждый раз, когда <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipClosing&quot;> </xref> перенаправленное событие встречает на своем маршруте этого класса. Реализуйте этот метод, чтобы добавить обработчик класса для данного события."
  remarks: "This method has no default implementation. You should still call base() in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "Предоставляет данные о событии."
  overload: System.Windows.FrameworkContentElement.OnToolTipClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Вызывается каждый раз, когда <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipOpening&quot;> </xref> перенаправленное событие встречает на своем маршруте этого класса. Реализуйте этот метод, чтобы добавить обработчик класса для данного события."
  remarks: "This method has no default implementation. You should still call base() in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "Предоставляет данные о событии."
  overload: System.Windows.FrameworkContentElement.OnToolTipOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyle
  id: OverridesDefaultStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OverridesDefaultStyle
  nameWithType: FrameworkContentElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает значение, указывающее, содержит ли данный элемент свойства стиля из тематических стилей."
  remarks: "Наиболее распространенное использование этого свойства является непрямое использование в переключателе стиля, который передает тематический стиль.      <a name=&quot;dependencyPropertyInfo_OverridesDefaultStyle&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|   | Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>"
  syntax:
    content: public bool OverridesDefaultStyle { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если этот элемент не использует свойства тематических стилей; все свойства стиля исходящие поступают из локальных стилей приложения, а свойства тематических стилей не применяются. <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>Если применяются стили приложения, а затем примените стили тем для свойств, которые не были заданы специально в стилях приложения."
  overload: System.Windows.FrameworkContentElement.OverridesDefaultStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  id: OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkContentElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle*>свойство зависимостей.</xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Parent
  id: Parent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Parent
  nameWithType: FrameworkContentElement.Parent
  fullName: System.Windows.FrameworkContentElement.Parent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает родителя в логическом дереве для этого элемента."
  remarks: "Обратите внимание, что логический родительский элемент может измениться в зависимости от функциональности приложения, и сохранение значения этого свойства не отражает такое изменение. Обычно следует получать значение, непосредственно перед он нужен.       В разделе [деревьев в WPF](~/add/includes/ajax-current-ext-md.md) Дополнительные сведения о просмотре логические деревья и сценарии, когда этот подход к обнаружения элемента не соответствует.       В системе свойств потенциально пересчитает все значения свойств элемента при изменении его родителя, так как некоторые свойства наследуют значения через логическое дерево. <xref:System.Windows.FrameworkContentElement.DataContext%2A>, Применяемый для привязки также можно изменить при изменении элементов родителя.</xref:System.Windows.FrameworkContentElement.DataContext%2A>       Изменение родителя элемента обычно выполняется только через управление коллекциями, с использованием выделенных методов добавления и удаления, или путем задания свойств содержимого элементов.       Наиболее типичный сценарий свойство Parent является получить ссылку, а затем получить различные <xref:System.Windows.FrameworkContentElement>значения свойств из родительского элемента.</xref:System.Windows.FrameworkContentElement> Для шаблонов, родительского шаблона в конечном итоге будет `null`. Чтобы получить на этом этапе и расширить в логическом дереве, где фактически применяется шаблон, используйте <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>"
  example:
  - "The following example checks to see whether the Parent of a <xref:System.Windows.Documents.TextPointer> is of a particular type.  \n  \n [!code-cs[TextPointer_snippets#FCEParent](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#fceparent)]\n [!code-vb[TextPointer_snippets#FCEParent](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#fceparent)]"
  syntax:
    content: public System.Windows.DependencyObject Parent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "Логический родительский объект для этого элемента."
  overload: System.Windows.FrameworkContentElement.Parent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  id: PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkContentElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkContentElement.PredictFocus(FocusNavigationDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Определяет следующий элемент, который получит фокус, относительно данного элемента для указанного направления движения фокуса, но фактически не перемещает фокус. Этот метод является запечатанным и не может быть переопределен."
  remarks: "<xref:System.Windows.FrameworkContentElement.MoveFocus%2A>имеет связанный метод, который фактически перемещения фокуса.</xref:System.Windows.FrameworkContentElement.MoveFocus%2A>"
  syntax:
    content: public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Input.FocusNavigationDirection
      description: "Направление, для которого необходимо определить изменение потенциального фокуса."
    return:
      type: System.Windows.DependencyObject
      description: "Следующий элемент, на который перемещает Если фактического обхода фокуса. Может возвращать <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если фокус нельзя переместить относительно данного элемента в указанном направлении."
  overload: System.Windows.FrameworkContentElement.PredictFocus*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: 'Specified one of the following directions in the <xref href=&quot;System.Windows.Input.TraversalRequest&quot;></xref>: <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>. Эти инструкции не допустимы для PredictFocus (но они допустимы для <xref:System.Windows.FrameworkContentElement.MoveFocus*>).</xref:System.Windows.FrameworkContentElement.MoveFocus*>'
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)
  id: RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: RegisterName(String,Object)
  nameWithType: FrameworkContentElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkContentElement.RegisterName(String,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Предоставляет метод доступа, который упрощает доступ к <xref:System.Windows.NameScope>метод регистрации.</xref:System.Windows.NameScope>"
  remarks: "Этот метод является самым удобным для вызова <xref:System.Windows.NameScope.RegisterName%2A>.</xref:System.Windows.NameScope.RegisterName%2A> Реализация будет проверять последовательных родительских элементов, пока не найдет соответствующий <xref:System.Windows.NameScope>реализацию, расположенное по поиск элемента, который реализует <xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.NameScope> Дополнительные сведения об области видимости имен см. в разделе [области имен XAML WPF](~/add/includes/ajax-current-ext-md.md).       Вызов Имярегистра необходим, чтобы правильно подключать анимации раскадровки для приложений, созданных в коде. Это вызвано одно из ключевых раскадровки свойства, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, выполняет поиск имени во время выполнения не предоставляется возможность указать ссылку на целевой элемент.</xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> Это верно, даже если этому элементу осуществляется по ссылке из кода. Дополнительные сведения о том, почему необходимо зарегистрировать имена целей раскадровки см. в разделе [Общие](~/add/includes/ajax-current-ext-md.md). Анимация элементов содержимого реже, чем анимация элементов, [Общие](../Topic/Storyboards%20Overview.md) управления."
  syntax:
    content: public void RegisterName (string name, object scopedElement);
    parameters:
    - id: name
      type: System.String
      description: "Имя, используемое для сопоставления указанного имени объекта."
    - id: scopedElement
      type: System.Object
      description: "Объект для сопоставления."
  overload: System.Windows.FrameworkContentElement.RegisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)
  id: RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkContentElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.RemoveLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Удаляет указанный элемент из логического дерева данного элемента."
  remarks: "Это [!INCLUDE[TLA#tla_api](~/add/includes/tlasharptla-api-md.md)] основном относится к классу, производные сценариев, при добавлении поддержки дочерних коллекций.       Большинство <xref:System.Windows.FrameworkContentElement>производные классы предоставляют выделенный коллекций, которые отвечают за вложения (например, <xref:System.Windows.Documents.Span.Inlines%2A> <xref:System.Windows.Documents.Span>класса; <xref:System.Windows.Documents.Section.Blocks%2A>на <xref:System.Windows.Documents.Section>класса).</xref:System.Windows.Documents.Section> </xref:System.Windows.Documents.Section.Blocks%2A> </xref:System.Windows.Documents.Span> </xref:System.Windows.Documents.Span.Inlines%2A> </xref:System.Windows.FrameworkContentElement> Наследование из таких классов обычно можно избежать необходимости напрямую управлять логического дерева."
  syntax:
    content: protected void RemoveLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "Подлежащий удалению элемент."
  overload: System.Windows.FrameworkContentElement.RemoveLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Resources
  id: Resources
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Resources
  nameWithType: FrameworkContentElement.Resources
  fullName: System.Windows.FrameworkContentElement.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает текущий локально определенный словарь ресурсов."
  remarks: "Словари ресурсов, которые могут быть определены полностью или частично в [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] обычно создаются как элемент свойства и обычно представляют собой в корневом элементе любой отдельной страницы или приложения. Размещение словаря ресурсов на этом уровне облегчает поиск из отдельных дочерних элементов на странице (или на любой странице, в случае приложения). В большинстве сценариев приложений, рекомендуется определить эти стили как элементы-объекты в словаре ресурсов или как внешние ресурсы, чтобы весь ресурс стиля мог быть автономным (этот подход помогает отделить ответственность дизайнера от ответственности разработчика путем разделения физических файлов, которые нужно редактировать).       Обратите внимание, что это свойство возвращает только словарь ресурсов, объявленный непосредственно внутри этого элемента. Это отличается от фактического процесса поиска ресурсов, где дочерний элемент можно использовать все ресурсы, определенные в каждом родительском элементе, выполняя рекурсивный восходящий поиск.       Ресурсы также могут ссылаться с помощью кода из коллекции, но имейте в виду, что ресурсы, созданные в [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] определенно будут недоступны до после <xref:System.Windows.FrameworkContentElement.Loaded>возникает для элемента, который объявляет словаря.</xref:System.Windows.FrameworkContentElement.Loaded> На самом деле ресурсы анализируется асинхронно и даже <xref:System.Windows.FrameworkContentElement.Loaded>событий является гарантией того, можно ссылаться [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] определенных ресурсов.</xref:System.Windows.FrameworkContentElement.Loaded> По этой причине следует обычно только обращаться к [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] определены ресурсы в рамках кода во время выполнения, или с помощью других [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] методы, такие как ссылки на расширение ресурса для значений атрибутов или стилей. При доступе к ресурсам через код, он фактически эквивалентна ссылку из [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)].       Базовый <xref:System.Windows.ResourceDictionary>поддерживает методы, необходимые для добавления, удаления или запроса ресурсов из коллекции с помощью кода.</xref:System.Windows.ResourceDictionary> Свойства ресурсов можно настроить для поддержки полной замены коллекции ресурсов элемента, используется новый сценарий или другой <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>       Обратите внимание, что [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] синтаксис, показанный отсутствует элемент для <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> Это пример неявного синтаксиса коллекции; можно опустить тег представляет элемент коллекции. Вместо этого указаны элементы, которые будут добавлены как элементы в коллекцию. Дополнительные сведения о неявных коллекциях и [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)], в разделе [XAML Syntax In Detail](~/add/includes/ajax-current-ext-md.md). Один вариант, если не <xref:System.Windows.ResourceDictionary>указан, по-прежнему явно как элемент есть ли вы ввели объединенный словарь, в этом случае обычно нет дочерних элементов для <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> </xref:System.Windows.ResourceDictionary> Дополнительные сведения см. в разделе [слияние словари ресурсов](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlPropertyElementUsage_Resources&quot;></a>## Использование элемента свойства XAML ```   <object>     <object.Resources>       oneOrMoreResourceElements     </object.Resources>   </object>   ``` <a name=&quot;xamlValues_Resources&quot;> </a> ## значений XAML *oneOrMoreResourceElements* один или несколько элементов-объектов, каждый из которых определяет ресурс.       В каждом элементе свойства ресурсов в каждом <xref:System.Windows.ResourceDictionary>должен иметь уникальное значение для [директива x: Key](~/add/includes/ajax-current-ext-md.md), который используется в качестве уникального ключа при извлечении значений из <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary> </xref:System.Windows.ResourceDictionary>"
  example:
  - "The following example establishes a Resources collection on a <xref:System.Windows.Documents.FlowDocument> root element. <xref:System.Windows.Documents.FlowDocument> is a typical choice because it is one of the few <xref:System.Windows.FrameworkContentElement> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.  \n  \n [!code-xml[ContentElementsSmorgasbord#FCEResources](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page2.xaml#fceresources)]"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "Текущий локально определенные ресурсы. Это словарь ресурсов, где доступ к ресурсам по ключу."
  overload: System.Windows.FrameworkContentElement.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)
  id: SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Прикрепляет привязку к данному элементу на основе указанного источника свойство имени виде классификационного пути к источнику данных."
  remarks: "Этот метод является самым удобным для вызова <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>, который передает текущего экземпляра в качестве <xref:System.Windows.DependencyObject>и создает новый <xref:System.Windows.Data.Binding>на основе предоставленной `path` параметр.</xref:System.Windows.Data.Binding> </xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName> Эта подпись является более удобным в том случае, если устанавливается простой привязки по умолчанию. Если вам нужно указать любые свойства привязки для нестандартных условий, или использовать <xref:System.Windows.Data.MultiBinding>или <xref:System.Windows.Data.PriorityBinding>, следует использовать <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>подпись.</xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> </xref:System.Windows.Data.PriorityBinding> </xref:System.Windows.Data.MultiBinding>"
  example:
  - "The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.  \n  \n [!code-cs[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#datacontext)]\n [!code-vb[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#datacontext)]"
  syntax:
    content: public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Идентифицирует привязанное свойство."
    - id: path
      type: System.String
      description: "Имя исходного свойства или путь к свойству, используемый для привязки."
    return:
      type: System.Windows.Data.BindingExpression
      description: "Фиксирует состояния привязки. Это возвращаемое значение может быть полезно для проверки ошибок."
  overload: System.Windows.FrameworkContentElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  id: SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Прикрепляет привязку к данному элементу на основе предоставленной привязки объекта."
  remarks: "Этот метод является самым удобным для вызова <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>, который передает текущий экземпляр как <xref:System.Windows.DependencyObject>.</xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>"
  example:
  - "The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new <xref:System.Windows.Data.Binding> and setting the source to a newly built `DateTime` object.  \n  \n [!code-cs[ContentElementsSmorgasbord#SetBinding](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#setbinding)]\n [!code-vb[ContentElementsSmorgasbord#SetBinding](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#setbinding)]"
  syntax:
    content: public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Идентифицирует привязанное свойство."
    - id: binding
      type: System.Windows.Data.BindingBase
      description: "Представляет привязку данных."
    return:
      type: System.Windows.Data.BindingExpressionBase
      description: "Фиксирует состояния привязки. Это возвращаемое значение может быть полезно для проверки ошибок."
  overload: System.Windows.FrameworkContentElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  id: SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ищет ресурс с указанным именем и устанавливает ссылку на этот ресурс для указанного свойства."
  remarks: "Ссылка на ресурс похож на использование [DynamicResource Markup Extension](~/add/includes/ajax-current-ext-md.md) в разметке. Ссылка на ресурс создает внутреннее выражение, содержащий значение заданного свойства на основе отложенного выполнения. Выражение будет повторно вычисляться каждый раз, когда словарем ресурсов измененного значения через внутренние события или при изменении родителя текущего элемента (родителя изменяется путь для поиска словаря)."
  syntax:
    content: public void SetResourceReference (System.Windows.DependencyProperty dp, object name);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "Свойство, с которым связан ресурс."
    - id: name
      type: System.Object
      description: "Имя ресурса."
  overload: System.Windows.FrameworkContentElement.SetResourceReference*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ShouldSerializeResources
  id: ShouldSerializeResources
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ShouldSerializeResources()
  nameWithType: FrameworkContentElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeResources()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает, должны ли процессы сериализации сериализовать содержимое <xref:System.Windows.FrameworkContentElement.Resources*>Свойства для экземпляров этого класса.</xref:System.Windows.FrameworkContentElement.Resources*>"
  remarks: "Будет возвращен `true` при условии, что имеется по крайней мере один ресурс с ключом в локальной <xref:System.Windows.FrameworkContentElement.Resources%2A>.</xref:System.Windows.FrameworkContentElement.Resources%2A>"
  syntax:
    content: public bool ShouldSerializeResources ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref:System.Windows.FrameworkContentElement.Resources*>значение свойства должно быть сериализованы; в противном случае — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.Resources*>"
  overload: System.Windows.FrameworkContentElement.ShouldSerializeResources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ShouldSerializeStyle
  id: ShouldSerializeStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ShouldSerializeStyle()
  nameWithType: FrameworkContentElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает, должны ли процессы сериализации сериализовать содержимое <xref:System.Windows.FrameworkContentElement.Style*>Свойства для экземпляров этого класса.</xref:System.Windows.FrameworkContentElement.Style*>"
  remarks: "Будет возвращен `true` Если <xref:System.Windows.Style>установлено локально.</xref:System.Windows.Style>"
  syntax:
    content: public bool ShouldSerializeStyle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref:System.Windows.FrameworkContentElement.Style*>значение свойства должно быть сериализованы; в противном случае — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>.</xref:System.Windows.FrameworkContentElement.Style*>"
  overload: System.Windows.FrameworkContentElement.ShouldSerializeStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SourceUpdated
  id: SourceUpdated
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SourceUpdated
  nameWithType: FrameworkContentElement.SourceUpdated
  fullName: System.Windows.FrameworkContentElement.SourceUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит, когда любого связанного источника данных, участвующего в привязке для данного элемента."
  remarks: "Это событие поверхности <xref:System.Windows.Data.Binding.SourceUpdated>событие, возникающее по любому <xref:System.Windows.Data.Binding>связанные с данным элементом.</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.SourceUpdated>      <a name=&quot;xamlAttributeUsage_SourceUpdated&quot;></a>## Использование атрибута XAML```   <object SourceUpdated=&quot;EventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> SourceUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Style
  id: Style
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Style
  nameWithType: FrameworkContentElement.Style
  fullName: System.Windows.FrameworkContentElement.Style
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает стиль, используемый этим элементом."
  remarks: "Текущий стиль часто обеспечивается стилем по умолчанию из темы или из стилей, обычно применяется к объектам этого типа по ресурсам на уровне страницы или приложения (неявный стиль). Данное свойство не устанавливает и не возвращает по умолчанию стили (тема), но возвращает неявный или явный стиль. В случае неявных или явных стилей не проверяются ли стиль доступен как ресурс или определен локально.       Задание стилей имеет некоторые ограничения. Можно сбросить все свойства Style новый <xref:System.Windows.Style>в любое время, который выполняет принудительное рекомпозиции макета.</xref:System.Windows.Style> Тем не менее, как можно раньше этим стилем помещается используется загруженным элементом <xref:System.Windows.Style>следует учитывать sealed.</xref:System.Windows.Style> Попытка внести изменение любое отдельное свойство для используемого стиля (такие как что-либо из коллекции <xref:System.Windows.Style.Setters%2A>) приводит к созданию исключения.</xref:System.Windows.Style.Setters%2A> Стиль, определенный в разметке считается используется сразу после ее загрузки из словаря ресурсов (для ресурсов) или загрузки страницы, в которой он содержится в (для встроенные стили).       Стиль — свойство зависимостей с специальные приоритетом. Локально заданное стиль обычно действует с более высоким приоритетом в системе свойств. Если на этом этапе стиль имеет значение null, во время загрузки свойство система проверяет неявные стили как определенных ресурсов этого типа. Если после выполнения этого шага стиль равен null, затем стиль поступает из стиля по умолчанию (тема), но стиль по умолчанию не возвращается в значении свойства стиля. В разделе [приоритет значения свойства зависимости](~/add/includes/ajax-current-ext-md.md).      <a name=&quot;xamlAttributeUsage_Style&quot;></a>## Использование атрибута XAML ```   <object Style=&quot;{resourceExtension StyleResourceKey}&quot;/>   ``` <a name=&quot;xamlValues_Style&quot;> </a> ## значений XAML *resourceExtension* одно из следующих:, или.       В разделе [ресурсов XAML](~/add/includes/ajax-current-ext-md.md).       *styleResourceKey* ключ, который определяет запрашиваемый стиль. Ключ ссылается на существующий ресурс в <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>      Настроек [!NOTE] настроек синтаксис элемента свойства технически возможно, но не рекомендуется. В разделе [встроенные стили и шаблоны](~/add/includes/ajax-current-ext-md.md).  Ссылка привязки с помощью или <xref:System.Windows.Data.Binding>также является, возможно, но встречается редко.</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_Style&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.StyleProperty>|   | Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkContentElement.StyleProperty>"
  example:
  - "The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element and then references it as a resource as a specific style for a <xref:System.Windows.Documents.Paragraph>.  \n  \n [!code-xml[ContentElementsSmorgasbord#FCEResources](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page2.xaml#fceresources)]"
  syntax:
    content: public System.Windows.Style Style { get; set; }
    return:
      type: System.Windows.Style
      description: "Примененный стиль не по умолчанию для элемента, если он имеется. В противном случае <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>. Значение по умолчанию для созданного по умолчанию <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref> — <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.Style*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.StyleProperty
  id: StyleProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: StyleProperty
  nameWithType: FrameworkContentElement.StyleProperty
  fullName: System.Windows.FrameworkContentElement.StyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.FrameworkContentElement.Style*>свойство зависимостей.</xref:System.Windows.FrameworkContentElement.Style*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty StyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Описание этого члена см. в разделе <xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>метод.</xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>"
  remarks: "Этот член представляет явную реализацию члена интерфейса. Он может использоваться только если <xref:System.Windows.FrameworkContentElement>экземпляр приводится к <xref:System.Windows.Markup.IQueryAmbient>интерфейс.</xref:System.Windows.Markup.IQueryAmbient> </xref:System.Windows.FrameworkContentElement>"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "Имя запрошенного свойства окружения."
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <code> propertyName </code> доступен; в противном случае — <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Tag
  id: Tag
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Tag
  nameWithType: FrameworkContentElement.Tag
  fullName: System.Windows.FrameworkContentElement.Tag
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает произвольное значение объекта, можно использовать для хранения особых сведений об этом элементе."
  remarks: "Это свойство является аналогом тег свойства в других [!INCLUDE[TLA#tla_ms](~/add/includes/tlasharptla-ms-md.md)] моделях программирования, таких как [!INCLUDE[TLA#tla_vba](~/add/includes/ajax-current-ext-md.md)] или [!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)]. Он предназначен для предоставления уже существующее место для хранения базовой пользовательской информации о любом элементе без перезагрузки разработчикам приложений подкласс.      <a name=&quot;xamlValues_Tag&quot;></a>## Значения XAML поскольку это свойство принимает объект, необходимо использовать использование элемента свойства, чтобы задать свойство тег в [!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)] только на объект с известным и встроенным преобразователя, такие как строка. Объекты, используемые таким образом, обычно не входят в стандартные [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] пространства имен и поэтому может потребоваться сопоставление пространства имен с внешним пространством имен для новых [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] элементов.      <a name=&quot;dependencyPropertyInfo_Tag&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.TagProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.FrameworkContentElement.TagProperty>"
  syntax:
    content: public object Tag { get; set; }
    return:
      type: System.Object
      description: "Целевое значение. Это свойство имеет значение по умолчанию отсутствует."
  overload: System.Windows.FrameworkContentElement.Tag*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TagProperty
  id: TagProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TagProperty
  nameWithType: FrameworkContentElement.TagProperty
  fullName: System.Windows.FrameworkContentElement.TagProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.FrameworkContentElement.Tag*>свойство зависимостей.</xref:System.Windows.FrameworkContentElement.Tag*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TagProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TargetUpdated
  id: TargetUpdated
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TargetUpdated
  nameWithType: FrameworkContentElement.TargetUpdated
  fullName: System.Windows.FrameworkContentElement.TargetUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит, когда любого связанного целевого свойства, участвующего в привязке для данного элемента."
  remarks: "Это событие поверхности <xref:System.Windows.Data.Binding.TargetUpdated>событие, возникающее по любому <xref:System.Windows.Data.Binding>связанные с данным элементом.</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.TargetUpdated> Обычно это означает, что рассматриваемая двустороннюю привязку, и что свойства привязанного зависимостей подтверждает недействительность предыдущее значение свойства в любой схеме проверки или кэширования, поддерживает свойство.       Аргументы события данного события будет информировать того, какие свойства, привязанного к была изменена.      <a name=&quot;xamlAttributeUsage_TargetUpdated&quot;></a>## Использование атрибута XAML```   <object TargetUpdated=&quot;EventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> TargetUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TemplatedParent
  id: TemplatedParent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TemplatedParent
  nameWithType: FrameworkContentElement.TemplatedParent
  fullName: System.Windows.FrameworkContentElement.TemplatedParent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Получает ссылку на родительский объект шаблона данного элемента. Это свойство не применимо, если элемент не был создан с помощью шаблона."
  remarks: "Шаблоны являются фактически общие объекты, в котором содержимое шаблона создаются только один раз. Таким образом Если получить ссылку на элемент, поступивший из шаблона, может оказаться очевидной логического дерева не достигает корня страницы. Чтобы подключить такая ссылка шаблона в дереве логической страницы, следует получить значение TemplatedParent и продолжить для перемещения этого элемента дерева в случае необходимости.       Часто оказываются TemplatedParent `null` для общих объектов, поскольку если приобретается ссылку на объект из линейных страницы в приложении через стандартные средства этот элемент, скорее всего, не был создан из шаблона. Случаях TemplatedParent не может быть `null` включает операции, например события нажатия, обработки для определенных низкоуровневых событий ввода или работа с перечислителями, которые могут возвращать элементы, полученные из шаблонов."
  syntax:
    content: public System.Windows.DependencyObject TemplatedParent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "Элемент которого <xref href=&quot;System.Windows.FrameworkTemplate&quot;> </xref> <xref:System.Windows.FrameworkTemplate.VisualTree*>вызвал этот элемент должен быть создан.</xref:System.Windows.FrameworkTemplate.VisualTree*> Это значение часто равно <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; см. заметки."
  overload: System.Windows.FrameworkContentElement.TemplatedParent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTip
  id: ToolTip
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTip
  nameWithType: FrameworkContentElement.ToolTip
  fullName: System.Windows.FrameworkContentElement.ToolTip
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Возвращает или задает объект подсказки, отображаемый для этого элемента в [!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]."
  remarks: "Если значение этого свойства имеет тип <xref:System.Windows.Controls.ToolTip>, то, является всплывающей подсказки, будет использоваться в [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)].</xref:System.Windows.Controls.ToolTip>  Если значение любого другого типа, то это значение будет использоваться в качестве *содержимого* для <xref:System.Windows.Controls.ToolTip>указано (создан) системой.</xref:System.Windows.Controls.ToolTip> Дополнительные сведения см. <xref:System.Windows.Controls.ToolTipService>.</xref:System.Windows.Controls.ToolTipService> Служебный класс предоставляет вложенные свойства, которые могут использоваться для дальнейшей настройки подсказки.      <a name=&quot;xamlAttributeUsage_ToolTip&quot;></a>## Использование атрибута XAML ```   <object ToolTip=&quot;toolTipContent&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_ToolTip&quot;> </a> ## использование элемента свойства XAML ```   <object>     <object.ToolTip>       <ToolTip .../>     </object.ToolTip>   </object>   - or -   <object>     <object.ToolTip>       toolTipObjectContent     </object.ToolTip>   </object>   ``` <a name=&quot;xamlValues_ToolTip&quot;> </a> ## значений XAML *toolTipContent* строка, которая становится отображаемый текст всплывающей подсказки.                   *toolTipObjectContent* некоторые объектом, указанным в форме элемента объекта, который должен использоваться в качестве содержимого для <xref:System.Windows.FrameworkContentElement>.</xref:System.Windows.FrameworkContentElement> Обычно это было бы <xref:System.Windows.FrameworkElement>или другой элемент, создающий композиции макета для всплывающей подсказки, содержащий текст в конце концов содержимого в композиции.</xref:System.Windows.FrameworkElement> При таком использовании <xref:System.Windows.Controls.ToolTip>создается элемент неявно из проанализированный [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]и *toolTipObjectContent* содержимое задано как его <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName>свойство.</xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName> </xref:System.Windows.Controls.ToolTip>       `ToolTip`.../>    See <xref:System.Windows.Controls.ToolTip>.</xref:System.Windows.Controls.ToolTip>      <a name=&quot;dependencyPropertyInfo_ToolTip&quot;></a>## Сведения о свойстве зависимостей ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.ToolTipProperty>|   | Значение свойства метаданных `true`| None |</xref:System.Windows.FrameworkContentElement.ToolTipProperty>"
  example:
  - "The following example sets the value of the <xref:System.Windows.FrameworkElement.ToolTip%2A> property directly to a string.  \n  \n [!code-cs[TableSnippets2#_Table_RowGroups_ManipRows](~/add/codesnippet/csharp/TableSnippets2/Window1.xaml.cs#_table_rowgroups_maniprows)]\n [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/add/codesnippet/visualbasic/tablesnippets2/window1.xaml.vb#_table_rowgroups_maniprows)]"
  syntax:
    content: public object ToolTip { get; set; }
    return:
      type: System.Object
      description: "Объект подсказки. Дополнительные сведения о том, почему этот параметр не является строго типизированным см. примечания ниже."
  overload: System.Windows.FrameworkContentElement.ToolTip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipClosing
  id: ToolTipClosing
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipClosing
  nameWithType: FrameworkContentElement.ToolTipClosing
  fullName: System.Windows.FrameworkContentElement.ToolTipClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит непосредственно перед закрытием любой всплывающей подсказки к элементу."
  remarks: "Чтобы подавить закрытие подсказки, обработчики события должны его нужно пометить как обработанное.       Это событие не может быть <xref:System.Windows.EventTrigger>в стиле.</xref:System.Windows.EventTrigger> Это потому, что поле идентификатора данного события повторно использует реализацию из службы, которая не открывает методы добавления и удаления события.      <a name=&quot;routedEventInfo_ToolTipClosing&quot;></a>## Направлено сведения о событии ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|   | Стратегия маршрутизации | Прямой |   | Делегат | <xref:System.Windows.Controls.ToolTipEventHandler>|</xref:System.Windows.Controls.ToolTipEventHandler></xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipClosingEvent
  id: ToolTipClosingEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipClosingEvent
  nameWithType: FrameworkContentElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipClosing&quot;> </xref> [направлено Общие сведения о событиях](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Объекты идентификатор события, создаваемые при их регистрации (см. <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и затем могут использоваться для добавления обработчиков класса (см. <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Идентификатор объекты содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipOpening
  id: ToolTipOpening
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipOpening
  nameWithType: FrameworkContentElement.ToolTipOpening
  fullName: System.Windows.FrameworkContentElement.ToolTipOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит при открытии любой всплывающей подсказки к элементу."
  remarks: "Для открытия подсказок вручную обработчики событий должны помечать соответствующее событие как обработанное. В противном случае — значение <xref:System.Windows.FrameworkContentElement.ToolTip%2A>будет использоваться свойство, чтобы автоматически открыть контекстное меню.</xref:System.Windows.FrameworkContentElement.ToolTip%2A> Маркировка обрабатываемого события эффективно отменит действие по умолчанию и может быть возможность выполнить сброс значения <xref:System.Windows.FrameworkContentElement.ToolTip%2A>Свойства и откройте новый <xref:System.Windows.Controls.ContextMenu>.</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.FrameworkContentElement.ToolTip%2A> Обратите внимание, что это событие не будет вызываться, если <xref:System.Windows.FrameworkContentElement.ToolTip%2A>является пустой ссылкой или в противном случае значение не задано.</xref:System.Windows.FrameworkContentElement.ToolTip%2A>       Это событие не может быть <xref:System.Windows.EventTrigger>в стиле.</xref:System.Windows.EventTrigger> Это потому, что поле идентификатора данного события повторно использует реализацию из службы, которая не открывает методы добавления и удаления события.      <a name=&quot;routedEventInfo_ToolTipOpening&quot;></a>## Направлено сведения о событии ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|   | Стратегия маршрутизации | Прямой |   | Делегат | <xref:System.Windows.Controls.ToolTipEventHandler>|</xref:System.Windows.Controls.ToolTipEventHandler></xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  id: ToolTipOpeningEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipOpeningEvent
  nameWithType: FrameworkContentElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref href=&quot;System.Windows.FrameworkContentElement.ToolTipOpening&quot;> </xref> [направлено Общие сведения о событиях](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Объекты идентификатор события, создаваемые при их регистрации (см. <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и затем могут использоваться для добавления обработчиков класса (см. <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Идентификатор объекты содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события."
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipProperty
  id: ToolTipProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipProperty
  nameWithType: FrameworkContentElement.ToolTipProperty
  fullName: System.Windows.FrameworkContentElement.ToolTipProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref:System.Windows.FrameworkContentElement.ToolTip*>свойство зависимостей.</xref:System.Windows.FrameworkContentElement.ToolTip*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ToolTipProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: FrameworkContentElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkContentElement.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Ищет ресурс с указанным ключом и возвращает его, если найден."
  remarks: "Если ресурс не найден в вызывающем элементе, родительского дерева осуществляется с помощью логического дерева таким же образом, который бы выполнялся поиск, если ссылка на динамический ресурс был запрошен по ключу во время выполнения.       Обычно вы сразу же привести возвращаемое значение к типу свойства, которое вы пытаетесь набор с возвращенным значением ресурса.       <xref:System.Windows.FrameworkContentElement.FindResource%2A>Метод имеет аналогичное поведение, за исключением того, что он будет вызывать исключение в случае не найден ресурс с указанным ключом.</xref:System.Windows.FrameworkContentElement.FindResource%2A>"
  example:
  - "The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.  \n  \n [!code-cs[ContentElementsSmorgasbord#TryFindResource](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#tryfindresource)]\n [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#tryfindresource)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "Идентификатор ключа ресурса, который требуется найти."
    return:
      type: System.Object
      description: "Найденный ресурс. Если ресурс не найден, <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> возвращается."
  overload: System.Windows.FrameworkContentElement.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Unloaded
  id: Unloaded
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Unloaded
  nameWithType: FrameworkContentElement.Unloaded
  fullName: System.Windows.FrameworkContentElement.Unloaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Происходит при удалении элемента из дерева загруженных элементов."
  remarks: "События с прямой маршрутизацией не следуют по маршруту, они обрабатываются только внутри элемента, на котором они вызываются. Прямые перенаправленные события поддерживают другое поведение перенаправленных событий: они поддерживают коллекцию доступных обработчиков и могут использоваться как <xref:System.Windows.EventTrigger>в стиле.</xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_Unloaded&quot;></a>## Направлено сведения о событии ^ ^ ^   |-|-|   | Поле идентификатора | <xref:System.Windows.FrameworkContentElement.UnloadedEvent>|   | Стратегия маршрутизации | Прямой |   | Делегат | <xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkContentElement.UnloadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Unloaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.UnloadedEvent
  id: UnloadedEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: UnloadedEvent
  nameWithType: FrameworkContentElement.UnloadedEvent
  fullName: System.Windows.FrameworkContentElement.UnloadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Идентифицирует <xref href=&quot;System.Windows.FrameworkContentElement.Unloaded&quot;> </xref> [направлено Общие сведения о событиях](~/add/includes/ajax-current-ext-md.md)."
  remarks: "Объекты идентификатор события, создаваемые при их регистрации (см. <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) и затем могут использоваться для добавления обработчиков класса (см. <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> Идентификатор объекты содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события."
  syntax:
    content: public static readonly System.Windows.RoutedEvent UnloadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.UnregisterName(System.String)
  id: UnregisterName(System.String)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: UnregisterName(String)
  nameWithType: FrameworkContentElement.UnregisterName(String)
  fullName: System.Windows.FrameworkContentElement.UnregisterName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Упрощает доступ к <xref:System.Windows.NameScope>отмены регистрации метод.</xref:System.Windows.NameScope>"
  remarks: "Только необходимо отменить регистрацию имен Если предполагается повторно зарегистрировать другой элемент с таким же именем."
  syntax:
    content: public void UnregisterName (string name);
    parameters:
    - id: name
      type: System.String
      description: "Имя пары имя объект для удаления из текущей области."
  overload: System.Windows.FrameworkContentElement.UnregisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.UpdateDefaultStyle
  id: UpdateDefaultStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: UpdateDefaultStyle()
  nameWithType: FrameworkContentElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkContentElement.UpdateDefaultStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "Повторно применяет стиль по умолчанию для текущего <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref>."
  syntax:
    content: public void UpdateDefaultStyle ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.UpdateDefaultStyle*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.ContentElement
  isExternal: false
  name: System.Windows.ContentElement
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Windows.FrameworkContentElement.#ctor
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FrameworkContentElement()
  nameWithType: FrameworkContentElement.FrameworkContentElement()
  fullName: System.Windows.FrameworkContentElement.FrameworkContentElement()
- uid: System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: AddLogicalChild(Object)
  nameWithType: FrameworkContentElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.AddLogicalChild(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.FrameworkContentElement.BeginInit
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginInit()
  nameWithType: FrameworkContentElement.BeginInit()
  fullName: System.Windows.FrameworkContentElement.BeginInit()
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard)
- uid: System.Windows.Media.Animation.Storyboard
  parent: System.Windows.Media.Animation
  isExternal: false
  name: Storyboard
  nameWithType: Storyboard
  fullName: System.Windows.Media.Animation.Storyboard
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
- uid: System.Windows.Media.Animation.HandoffBehavior
  parent: System.Windows.Media.Animation
  isExternal: false
  name: HandoffBehavior
  nameWithType: HandoffBehavior
  fullName: System.Windows.Media.Animation.HandoffBehavior
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.FrameworkContentElement.BindingGroup
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkContentElement.BindingGroup
  fullName: System.Windows.FrameworkContentElement.BindingGroup
- uid: System.Windows.Data.BindingGroup
  parent: System.Windows.Data
  isExternal: false
  name: BindingGroup
  nameWithType: BindingGroup
  fullName: System.Windows.Data.BindingGroup
- uid: System.Windows.FrameworkContentElement.BindingGroupProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BindingGroupProperty
  nameWithType: FrameworkContentElement.BindingGroupProperty
  fullName: System.Windows.FrameworkContentElement.BindingGroupProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.FrameworkContentElement.BringIntoView
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BringIntoView()
  nameWithType: FrameworkContentElement.BringIntoView()
  fullName: System.Windows.FrameworkContentElement.BringIntoView()
- uid: System.Windows.FrameworkContentElement.ContextMenu
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkContentElement.ContextMenu
  fullName: System.Windows.FrameworkContentElement.ContextMenu
- uid: System.Windows.Controls.ContextMenu
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenu
  nameWithType: ContextMenu
  fullName: System.Windows.Controls.ContextMenu
- uid: System.Windows.FrameworkContentElement.ContextMenuClosing
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuClosing
  nameWithType: FrameworkContentElement.ContextMenuClosing
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosing
- uid: System.Windows.Controls.ContextMenuEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventHandler
  nameWithType: ContextMenuEventHandler
  fullName: System.Windows.Controls.ContextMenuEventHandler
- uid: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuClosingEvent
  nameWithType: FrameworkContentElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
- uid: System.Windows.RoutedEvent
  parent: System.Windows
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEvent
  fullName: System.Windows.RoutedEvent
- uid: System.Windows.FrameworkContentElement.ContextMenuOpening
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuOpening
  nameWithType: FrameworkContentElement.ContextMenuOpening
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpening
- uid: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkContentElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
- uid: System.Windows.FrameworkContentElement.ContextMenuProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuProperty
  nameWithType: FrameworkContentElement.ContextMenuProperty
  fullName: System.Windows.FrameworkContentElement.ContextMenuProperty
- uid: System.Windows.FrameworkContentElement.Cursor
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkContentElement.Cursor
  fullName: System.Windows.FrameworkContentElement.Cursor
- uid: System.Windows.Input.Cursor
  parent: System.Windows.Input
  isExternal: false
  name: Cursor
  nameWithType: Cursor
  fullName: System.Windows.Input.Cursor
- uid: System.Windows.FrameworkContentElement.CursorProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: CursorProperty
  nameWithType: FrameworkContentElement.CursorProperty
  fullName: System.Windows.FrameworkContentElement.CursorProperty
- uid: System.Windows.FrameworkContentElement.DataContext
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkContentElement.DataContext
  fullName: System.Windows.FrameworkContentElement.DataContext
- uid: System.Windows.FrameworkContentElement.DataContextChanged
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContextChanged
  nameWithType: FrameworkContentElement.DataContextChanged
  fullName: System.Windows.FrameworkContentElement.DataContextChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.FrameworkContentElement.DataContextProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContextProperty
  nameWithType: FrameworkContentElement.DataContextProperty
  fullName: System.Windows.FrameworkContentElement.DataContextProperty
- uid: System.Windows.FrameworkContentElement.DefaultStyleKey
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkContentElement.DefaultStyleKey
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKey
- uid: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkContentElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
- uid: System.Windows.FrameworkContentElement.EndInit
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: EndInit()
  nameWithType: FrameworkContentElement.EndInit()
  fullName: System.Windows.FrameworkContentElement.EndInit()
- uid: System.Windows.FrameworkContentElement.FindName(System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindName(String)
  nameWithType: FrameworkContentElement.FindName(String)
  fullName: System.Windows.FrameworkContentElement.FindName(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.FrameworkContentElement.FindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindResource(Object)
  nameWithType: FrameworkContentElement.FindResource(Object)
  fullName: System.Windows.FrameworkContentElement.FindResource(Object)
- uid: System.Windows.FrameworkContentElement.FocusVisualStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkContentElement.FocusVisualStyle
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyle
- uid: System.Windows.Style
  parent: System.Windows
  isExternal: false
  name: Style
  nameWithType: Style
  fullName: System.Windows.Style
- uid: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FocusVisualStyleProperty
  nameWithType: FrameworkContentElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
- uid: System.Windows.FrameworkContentElement.ForceCursor
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkContentElement.ForceCursor
  fullName: System.Windows.FrameworkContentElement.ForceCursor
- uid: System.Windows.FrameworkContentElement.ForceCursorProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ForceCursorProperty
  nameWithType: FrameworkContentElement.ForceCursorProperty
  fullName: System.Windows.FrameworkContentElement.ForceCursorProperty
- uid: System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkContentElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkContentElement.GetBindingExpression(DependencyProperty)
- uid: System.Windows.Data.BindingExpression
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpression
  nameWithType: BindingExpression
  fullName: System.Windows.Data.BindingExpression
- uid: System.Windows.FrameworkContentElement.GetUIParentCore
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetUIParentCore()
  nameWithType: FrameworkContentElement.GetUIParentCore()
  fullName: System.Windows.FrameworkContentElement.GetUIParentCore()
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.FrameworkContentElement.Initialized
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Initialized
  nameWithType: FrameworkContentElement.Initialized
  fullName: System.Windows.FrameworkContentElement.Initialized
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.FrameworkContentElement.InputScope
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkContentElement.InputScope
  fullName: System.Windows.FrameworkContentElement.InputScope
- uid: System.Windows.Input.InputScope
  parent: System.Windows.Input
  isExternal: false
  name: InputScope
  nameWithType: InputScope
  fullName: System.Windows.Input.InputScope
- uid: System.Windows.FrameworkContentElement.InputScopeProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: InputScopeProperty
  nameWithType: FrameworkContentElement.InputScopeProperty
  fullName: System.Windows.FrameworkContentElement.InputScopeProperty
- uid: System.Windows.FrameworkContentElement.IsInitialized
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkContentElement.IsInitialized
  fullName: System.Windows.FrameworkContentElement.IsInitialized
- uid: System.Windows.FrameworkContentElement.IsLoaded
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkContentElement.IsLoaded
  fullName: System.Windows.FrameworkContentElement.IsLoaded
- uid: System.Windows.FrameworkContentElement.Language
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Language
  nameWithType: FrameworkContentElement.Language
  fullName: System.Windows.FrameworkContentElement.Language
- uid: System.Windows.Markup.XmlLanguage
  parent: System.Windows.Markup
  isExternal: false
  name: XmlLanguage
  nameWithType: XmlLanguage
  fullName: System.Windows.Markup.XmlLanguage
- uid: System.Windows.FrameworkContentElement.LanguageProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LanguageProperty
  nameWithType: FrameworkContentElement.LanguageProperty
  fullName: System.Windows.FrameworkContentElement.LanguageProperty
- uid: System.Windows.FrameworkContentElement.Loaded
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Loaded
  nameWithType: FrameworkContentElement.Loaded
  fullName: System.Windows.FrameworkContentElement.Loaded
- uid: System.Windows.RoutedEventHandler
  parent: System.Windows
  isExternal: false
  name: RoutedEventHandler
  nameWithType: RoutedEventHandler
  fullName: System.Windows.RoutedEventHandler
- uid: System.Windows.FrameworkContentElement.LoadedEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LoadedEvent
  nameWithType: FrameworkContentElement.LoadedEvent
  fullName: System.Windows.FrameworkContentElement.LoadedEvent
- uid: System.Windows.FrameworkContentElement.LogicalChildren
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkContentElement.LogicalChildren
  fullName: System.Windows.FrameworkContentElement.LogicalChildren
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkContentElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkContentElement.MoveFocus(TraversalRequest)
- uid: System.Windows.Input.TraversalRequest
  parent: System.Windows.Input
  isExternal: false
  name: TraversalRequest
  nameWithType: TraversalRequest
  fullName: System.Windows.Input.TraversalRequest
- uid: System.Windows.FrameworkContentElement.Name
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Name
  nameWithType: FrameworkContentElement.Name
  fullName: System.Windows.FrameworkContentElement.Name
- uid: System.Windows.FrameworkContentElement.NameProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: NameProperty
  nameWithType: FrameworkContentElement.NameProperty
  fullName: System.Windows.FrameworkContentElement.NameProperty
- uid: System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
- uid: System.Windows.Controls.ContextMenuEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventArgs
  nameWithType: ContextMenuEventArgs
  fullName: System.Windows.Controls.ContextMenuEventArgs
- uid: System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
- uid: System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkContentElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnGotFocus(RoutedEventArgs)
- uid: System.Windows.RoutedEventArgs
  parent: System.Windows
  isExternal: false
  name: RoutedEventArgs
  nameWithType: RoutedEventArgs
  fullName: System.Windows.RoutedEventArgs
- uid: System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkContentElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkContentElement.OnInitialized(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.DependencyPropertyChangedEventArgs
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventArgs
  nameWithType: DependencyPropertyChangedEventArgs
  fullName: System.Windows.DependencyPropertyChangedEventArgs
- uid: System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkContentElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkContentElement.OnStyleChanged(Style,Style)
- uid: System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
- uid: System.Windows.Controls.ToolTipEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventArgs
  nameWithType: ToolTipEventArgs
  fullName: System.Windows.Controls.ToolTipEventArgs
- uid: System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkContentElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkContentElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
- uid: System.Windows.FrameworkContentElement.Parent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkContentElement.Parent
  fullName: System.Windows.FrameworkContentElement.Parent
- uid: System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkContentElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkContentElement.PredictFocus(FocusNavigationDirection)
- uid: System.Windows.Input.FocusNavigationDirection
  parent: System.Windows.Input
  isExternal: false
  name: FocusNavigationDirection
  nameWithType: FocusNavigationDirection
  fullName: System.Windows.Input.FocusNavigationDirection
- uid: System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RegisterName(String,Object)
  nameWithType: FrameworkContentElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkContentElement.RegisterName(String,Object)
- uid: System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkContentElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.RemoveLogicalChild(Object)
- uid: System.Windows.FrameworkContentElement.Resources
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkContentElement.Resources
  fullName: System.Windows.FrameworkContentElement.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,String)
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
- uid: System.Windows.Data.BindingExpressionBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpressionBase
  nameWithType: BindingExpressionBase
  fullName: System.Windows.Data.BindingExpressionBase
- uid: System.Windows.Data.BindingBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingBase
  nameWithType: BindingBase
  fullName: System.Windows.Data.BindingBase
- uid: System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
- uid: System.Windows.FrameworkContentElement.ShouldSerializeResources
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeResources()
  nameWithType: FrameworkContentElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeResources()
- uid: System.Windows.FrameworkContentElement.ShouldSerializeStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeStyle()
  nameWithType: FrameworkContentElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeStyle()
- uid: System.Windows.FrameworkContentElement.SourceUpdated
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SourceUpdated
  nameWithType: FrameworkContentElement.SourceUpdated
  fullName: System.Windows.FrameworkContentElement.SourceUpdated
- uid: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<DataTransferEventArgs>
  nameWithType: EventHandler<DataTransferEventArgs>
  fullName: System.EventHandler<System.Windows.Data.DataTransferEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Data.DataTransferEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Data.DataTransferEventArgs
    name: DataTransferEventArgs
    nameWithType: DataTransferEventArgs
    fullName: DataTransferEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.FrameworkContentElement.Style
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Style
  nameWithType: FrameworkContentElement.Style
  fullName: System.Windows.FrameworkContentElement.Style
- uid: System.Windows.FrameworkContentElement.StyleProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: StyleProperty
  nameWithType: FrameworkContentElement.StyleProperty
  fullName: System.Windows.FrameworkContentElement.StyleProperty
- uid: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Windows.FrameworkContentElement.Tag
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkContentElement.Tag
  fullName: System.Windows.FrameworkContentElement.Tag
- uid: System.Windows.FrameworkContentElement.TagProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TagProperty
  nameWithType: FrameworkContentElement.TagProperty
  fullName: System.Windows.FrameworkContentElement.TagProperty
- uid: System.Windows.FrameworkContentElement.TargetUpdated
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TargetUpdated
  nameWithType: FrameworkContentElement.TargetUpdated
  fullName: System.Windows.FrameworkContentElement.TargetUpdated
- uid: System.Windows.FrameworkContentElement.TemplatedParent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkContentElement.TemplatedParent
  fullName: System.Windows.FrameworkContentElement.TemplatedParent
- uid: System.Windows.FrameworkContentElement.ToolTip
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkContentElement.ToolTip
  fullName: System.Windows.FrameworkContentElement.ToolTip
- uid: System.Windows.FrameworkContentElement.ToolTipClosing
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipClosing
  nameWithType: FrameworkContentElement.ToolTipClosing
  fullName: System.Windows.FrameworkContentElement.ToolTipClosing
- uid: System.Windows.Controls.ToolTipEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventHandler
  nameWithType: ToolTipEventHandler
  fullName: System.Windows.Controls.ToolTipEventHandler
- uid: System.Windows.FrameworkContentElement.ToolTipClosingEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipClosingEvent
  nameWithType: FrameworkContentElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipClosingEvent
- uid: System.Windows.FrameworkContentElement.ToolTipOpening
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipOpening
  nameWithType: FrameworkContentElement.ToolTipOpening
  fullName: System.Windows.FrameworkContentElement.ToolTipOpening
- uid: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipOpeningEvent
  nameWithType: FrameworkContentElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
- uid: System.Windows.FrameworkContentElement.ToolTipProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipProperty
  nameWithType: FrameworkContentElement.ToolTipProperty
  fullName: System.Windows.FrameworkContentElement.ToolTipProperty
- uid: System.Windows.FrameworkContentElement.TryFindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: FrameworkContentElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkContentElement.TryFindResource(Object)
- uid: System.Windows.FrameworkContentElement.Unloaded
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Unloaded
  nameWithType: FrameworkContentElement.Unloaded
  fullName: System.Windows.FrameworkContentElement.Unloaded
- uid: System.Windows.FrameworkContentElement.UnloadedEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UnloadedEvent
  nameWithType: FrameworkContentElement.UnloadedEvent
  fullName: System.Windows.FrameworkContentElement.UnloadedEvent
- uid: System.Windows.FrameworkContentElement.UnregisterName(System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UnregisterName(String)
  nameWithType: FrameworkContentElement.UnregisterName(String)
  fullName: System.Windows.FrameworkContentElement.UnregisterName(String)
- uid: System.Windows.FrameworkContentElement.UpdateDefaultStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UpdateDefaultStyle()
  nameWithType: FrameworkContentElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkContentElement.UpdateDefaultStyle()
- uid: System.Windows.FrameworkContentElement.#ctor*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FrameworkContentElement
  nameWithType: FrameworkContentElement.FrameworkContentElement
- uid: System.Windows.FrameworkContentElement.AddLogicalChild*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: AddLogicalChild
  nameWithType: FrameworkContentElement.AddLogicalChild
- uid: System.Windows.FrameworkContentElement.BeginInit*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginInit
  nameWithType: FrameworkContentElement.BeginInit
- uid: System.Windows.FrameworkContentElement.BeginStoryboard*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard
  nameWithType: FrameworkContentElement.BeginStoryboard
- uid: System.Windows.FrameworkContentElement.BindingGroup*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkContentElement.BindingGroup
- uid: System.Windows.FrameworkContentElement.BringIntoView*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BringIntoView
  nameWithType: FrameworkContentElement.BringIntoView
- uid: System.Windows.FrameworkContentElement.ContextMenu*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkContentElement.ContextMenu
- uid: System.Windows.FrameworkContentElement.Cursor*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkContentElement.Cursor
- uid: System.Windows.FrameworkContentElement.DataContext*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkContentElement.DataContext
- uid: System.Windows.FrameworkContentElement.DefaultStyleKey*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkContentElement.DefaultStyleKey
- uid: System.Windows.FrameworkContentElement.EndInit*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: EndInit
  nameWithType: FrameworkContentElement.EndInit
- uid: System.Windows.FrameworkContentElement.FindName*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindName
  nameWithType: FrameworkContentElement.FindName
- uid: System.Windows.FrameworkContentElement.FindResource*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindResource
  nameWithType: FrameworkContentElement.FindResource
- uid: System.Windows.FrameworkContentElement.FocusVisualStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkContentElement.FocusVisualStyle
- uid: System.Windows.FrameworkContentElement.ForceCursor*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkContentElement.ForceCursor
- uid: System.Windows.FrameworkContentElement.GetBindingExpression*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetBindingExpression
  nameWithType: FrameworkContentElement.GetBindingExpression
- uid: System.Windows.FrameworkContentElement.GetUIParentCore*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetUIParentCore
  nameWithType: FrameworkContentElement.GetUIParentCore
- uid: System.Windows.FrameworkContentElement.InputScope*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkContentElement.InputScope
- uid: System.Windows.FrameworkContentElement.IsInitialized*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkContentElement.IsInitialized
- uid: System.Windows.FrameworkContentElement.IsLoaded*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkContentElement.IsLoaded
- uid: System.Windows.FrameworkContentElement.Language*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Language
  nameWithType: FrameworkContentElement.Language
- uid: System.Windows.FrameworkContentElement.LogicalChildren*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkContentElement.LogicalChildren
- uid: System.Windows.FrameworkContentElement.MoveFocus*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: MoveFocus
  nameWithType: FrameworkContentElement.MoveFocus
- uid: System.Windows.FrameworkContentElement.Name*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Name
  nameWithType: FrameworkContentElement.Name
- uid: System.Windows.FrameworkContentElement.OnContextMenuClosing*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuClosing
  nameWithType: FrameworkContentElement.OnContextMenuClosing
- uid: System.Windows.FrameworkContentElement.OnContextMenuOpening*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuOpening
  nameWithType: FrameworkContentElement.OnContextMenuOpening
- uid: System.Windows.FrameworkContentElement.OnGotFocus*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnGotFocus
  nameWithType: FrameworkContentElement.OnGotFocus
- uid: System.Windows.FrameworkContentElement.OnInitialized*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnInitialized
  nameWithType: FrameworkContentElement.OnInitialized
- uid: System.Windows.FrameworkContentElement.OnPropertyChanged*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnPropertyChanged
  nameWithType: FrameworkContentElement.OnPropertyChanged
- uid: System.Windows.FrameworkContentElement.OnStyleChanged*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnStyleChanged
  nameWithType: FrameworkContentElement.OnStyleChanged
- uid: System.Windows.FrameworkContentElement.OnToolTipClosing*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipClosing
  nameWithType: FrameworkContentElement.OnToolTipClosing
- uid: System.Windows.FrameworkContentElement.OnToolTipOpening*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipOpening
  nameWithType: FrameworkContentElement.OnToolTipOpening
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkContentElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkContentElement.Parent*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkContentElement.Parent
- uid: System.Windows.FrameworkContentElement.PredictFocus*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: PredictFocus
  nameWithType: FrameworkContentElement.PredictFocus
- uid: System.Windows.FrameworkContentElement.RegisterName*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RegisterName
  nameWithType: FrameworkContentElement.RegisterName
- uid: System.Windows.FrameworkContentElement.RemoveLogicalChild*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RemoveLogicalChild
  nameWithType: FrameworkContentElement.RemoveLogicalChild
- uid: System.Windows.FrameworkContentElement.Resources*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkContentElement.Resources
- uid: System.Windows.FrameworkContentElement.SetBinding*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetBinding
  nameWithType: FrameworkContentElement.SetBinding
- uid: System.Windows.FrameworkContentElement.SetResourceReference*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetResourceReference
  nameWithType: FrameworkContentElement.SetResourceReference
- uid: System.Windows.FrameworkContentElement.ShouldSerializeResources*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeResources
  nameWithType: FrameworkContentElement.ShouldSerializeResources
- uid: System.Windows.FrameworkContentElement.ShouldSerializeStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeStyle
  nameWithType: FrameworkContentElement.ShouldSerializeStyle
- uid: System.Windows.FrameworkContentElement.Style*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Style
  nameWithType: FrameworkContentElement.Style
- uid: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.FrameworkContentElement.Tag*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkContentElement.Tag
- uid: System.Windows.FrameworkContentElement.TemplatedParent*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkContentElement.TemplatedParent
- uid: System.Windows.FrameworkContentElement.ToolTip*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkContentElement.ToolTip
- uid: System.Windows.FrameworkContentElement.TryFindResource*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TryFindResource
  nameWithType: FrameworkContentElement.TryFindResource
- uid: System.Windows.FrameworkContentElement.UnregisterName*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UnregisterName
  nameWithType: FrameworkContentElement.UnregisterName
- uid: System.Windows.FrameworkContentElement.UpdateDefaultStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UpdateDefaultStyle
  nameWithType: FrameworkContentElement.UpdateDefaultStyle
