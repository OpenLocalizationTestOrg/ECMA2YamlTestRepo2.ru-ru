### YamlMime:ManagedReference
items:
- uid: System.Windows.Threading.Dispatcher
  id: Dispatcher
  children:
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.CheckAccess
  - System.Windows.Threading.Dispatcher.CurrentDispatcher
  - System.Windows.Threading.Dispatcher.DisableProcessing
  - System.Windows.Threading.Dispatcher.ExitAllFrames
  - System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  - System.Windows.Threading.Dispatcher.HasShutdownFinished
  - System.Windows.Threading.Dispatcher.HasShutdownStarted
  - System.Windows.Threading.Dispatcher.Hooks
  - System.Windows.Threading.Dispatcher.Invoke(System.Action)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.InvokeShutdown
  - System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  - System.Windows.Threading.Dispatcher.Run
  - System.Windows.Threading.Dispatcher.ShutdownFinished
  - System.Windows.Threading.Dispatcher.ShutdownStarted
  - System.Windows.Threading.Dispatcher.Thread
  - System.Windows.Threading.Dispatcher.UnhandledException
  - System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  - System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  - System.Windows.Threading.Dispatcher.VerifyAccess
  - System.Windows.Threading.Dispatcher.Yield
  - System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  langs:
  - csharp
  name: Dispatcher
  nameWithType: Dispatcher
  fullName: System.Windows.Threading.Dispatcher
  type: Class
  summary: "Предоставляет службы для управления очередью рабочих элементов для потока."
  remarks: "Диспетчер хранит очередь приоритетов рабочих элементов для конкретного потока.       Диспетчер создается в потоке, становится только диспетчер, который может быть связан с потоком, даже если диспетчер выключен.       При попытке получить <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>для текущего потока и диспетчер не связан с потоком, будет создан диспетчер.</xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> Диспетчер также создается при создании <xref:System.Windows.Threading.DispatcherObject>.</xref:System.Windows.Threading.DispatcherObject> При создании объекта Dispatcher в фоновом потоке, не забудьте выключить диспетчер перед выходом из потока.       Если диспетчер завершает работу, его нельзя перезапустить.       В [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], <xref:System.Windows.Threading.DispatcherObject>может осуществляться только диспетчером, связанного с ним.</xref:System.Windows.Threading.DispatcherObject>  Например, фоновый поток не может обновить содержимое <xref:System.Windows.Controls.Button>, связанный с диспетчером на [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] потока.</xref:System.Windows.Controls.Button>  Чтобы фоновый поток для доступа к <xref:System.Windows.Controls.ContentControl.Content%2A>свойство <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в диспетчер, связанный с [!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)] потока.</xref:System.Windows.Controls.Button> </xref:System.Windows.Controls.ContentControl.Content%2A>  Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  Операция добавляется в очередь диспетчера на указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority>       Если <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>вызывается на диспетчер, который завершил работу, возвращаемый <xref:System.Windows.Threading.DispatcherOperation> <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> имеет значение</xref:System.Windows.Threading.DispatcherOperation> свойства status</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Все методы на диспетчер, за исключением <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, являются свободнопоточный.</xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>       Объекты, которые являются производными от <xref:System.Windows.Threading.DispatcherObject>поддерживают сходство потоков.</xref:System.Windows.Threading.DispatcherObject>       Объекты, которые являются производными от <xref:System.Windows.Freezable>являются свободнопоточный зафиксированный они.</xref:System.Windows.Freezable>  Дополнительные сведения см. в разделе [Freezable Общие сведения об объектах](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example shows how to place an operation onto a Dispatcher.  For the full source code of this example, see [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  \n  \n First, a delegate is created that accepts no arguments.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/visualbasic/t-system.windows.threadi_2_1.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/csharp/t-system.windows.threadi_2_1.cs)]  \n  \n Next, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> is called.  This call to <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> takes two parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>, and the callback, which is passed in through an instance of the delegate `NextPrimeDelegate`.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/visualbasic/t-system.windows.threadi_2_2.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/csharp/t-system.windows.threadi_2_2.cs)]"
  syntax:
    content: public sealed class Dispatcher
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  id: BeginInvoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(Delegate,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанный делегат асинхронно с указанными аргументами в потоке, <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> был создан."
  remarks: "<xref:System.Windows.Threading.DispatcherOperation>Объект, возвращаемый <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>может использоваться несколькими способами для взаимодействия с заданного делегата, например: - изменение <xref:System.Windows.Threading.DispatcherPriority>делегата, как он находится в состоянии ожидания выполнения в очередь событий.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Удаление делегата из очереди событий.      -Ожидание возврата из делегата.      -Получение значения, возвращаемого делегатом после его выполнения.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронным; поэтому управление немедленно возвращается вызывающему объекту после его вызова.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       В [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], поток, создавший <xref:System.Windows.Threading.DispatcherObject>может получить доступ к этому объекту.</xref:System.Windows.Threading.DispatcherObject> Например, фоновый поток, который выполнения от основного потока пользовательского интерфейса не может обновить содержимое <xref:System.Windows.Controls.Button>, созданного в потоке пользовательского интерфейса.</xref:System.Windows.Controls.Button> Чтобы фоновый поток для доступа к свойства Content <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в <xref:System.Windows.Threading.Dispatcher>связанного с потоком пользовательского интерфейса.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> Операция добавляется в очередь событий <xref:System.Windows.Threading.Dispatcher>в указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       Если <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>вызывается в <xref:System.Windows.Threading.Dispatcher>, ее работа была прекращена <xref:System.Windows.Threading.DispatcherOperation>равно <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> возвращаемое свойство status</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Делегат для метода, принимающего параметры, заданные в `args`, который помещается в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очередь событий."
    - id: args
      type: System.Object[]
      description: "Массив объектов для передачи в качестве аргументов указанному методу. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Объект, который возвращается сразу после <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>вызове, который может использоваться для взаимодействия с делегатом, как ожидает выполнения события очереди.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанный делегат асинхронно в определенной последовательности в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> сопоставлен."
  remarks: "Если несколько BeginInvoke вызовов, выполняемых на том же <xref:System.Windows.Threading.DispatcherPriority>, они будут выполнены в порядке вызовов.</xref:System.Windows.Threading.DispatcherPriority>       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Возвращает <xref:System.Windows.Threading.DispatcherOperation>объект, который может использоваться для взаимодействия с делегатом после делегата события очереди.</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       <xref:System.Windows.Threading.DispatcherOperation>Объект, возвращаемый <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>может использоваться несколькими способами для взаимодействия с заданного делегата, например: - изменение <xref:System.Windows.Threading.DispatcherPriority>делегата, как он находится в состоянии ожидания выполнения в очередь событий.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Удаление делегата из очереди событий.      -Ожидание возврата из делегата.      -Получение значения, возвращаемого делегатом после его выполнения.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронным; поэтому управление немедленно возвращается вызывающему объекту после его вызова.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       В [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], поток, создавший <xref:System.Windows.Threading.DispatcherObject>может получить доступ к этому объекту.</xref:System.Windows.Threading.DispatcherObject>  Например, фоновый поток, который выполнения от основного потока пользовательского интерфейса не может обновить содержимое <xref:System.Windows.Controls.Button>, созданного в потоке пользовательского интерфейса.</xref:System.Windows.Controls.Button>  Чтобы фоновый поток для доступа к свойства Content <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в <xref:System.Windows.Threading.Dispatcher>связанного с потоком пользовательского интерфейса.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  Операция добавляется в очередь событий <xref:System.Windows.Threading.Dispatcher>в указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       Если <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>вызывается в <xref:System.Windows.Threading.Dispatcher>, ее работа была прекращена <xref:System.Windows.Threading.DispatcherOperation>равно <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> возвращаемое свойство status</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  example:
  - "The following example shows how to place an operation onto a <xref:System.Windows.Threading.Dispatcher>.  For the full source code of this example, see [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  \n  \n First, a delegate is created that accepts no arguments.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/visualbasic/8c08cb62-5b5f-4560-a7bd-_1.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/csharp/8c08cb62-5b5f-4560-a7bd-_1.cs)]  \n  \n Next, BeginInvoke is called.  Because every <xref:System.Windows.Threading.DispatcherObject> has a property that returns the <xref:System.Windows.Threading.Dispatcher> it is associated with, the desired <xref:System.Windows.Threading.Dispatcher> is obtained by querying the <xref:System.Windows.Threading.DispatcherObject>, in this case a <xref:System.Windows.Controls.Button> named `startStopButton`.   The call to BeginInvoke takes two parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>, and the callback, which is passed in through an instance of the delegate `NextPrimeDelegate`.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/visualbasic/8c08cb62-5b5f-4560-a7bd-_2.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/csharp/8c08cb62-5b5f-4560-a7bd-_2.cs)]"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет относительно других ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> вызывается очереди событий, указанного метода."
    - id: method
      type: System.Delegate
      description: "Делегат метода, который не принимает аргументы, который помещается в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очередь событий."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Объект, который возвращается сразу после <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>вызове, который может использоваться для взаимодействия с делегатом, как ожидает выполнения события очереди.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>не является допустимым <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанный делегат асинхронно с указанными аргументами, с указанным приоритетом в потоке, <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> был создан."
  remarks: "<xref:System.Windows.Threading.DispatcherOperation>Объект, возвращаемый <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>может использоваться несколькими способами для взаимодействия с заданного делегата, например: - изменение <xref:System.Windows.Threading.DispatcherPriority>делегата, как он находится в состоянии ожидания выполнения в очередь событий.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Удаление делегата из очереди событий.      -Ожидание возврата из делегата.      -Получение значения, возвращаемого делегатом после его выполнения.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронным; поэтому управление немедленно возвращается вызывающему объекту после его вызова.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       В [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], поток, создавший <xref:System.Windows.Threading.DispatcherObject>может получить доступ к этому объекту.</xref:System.Windows.Threading.DispatcherObject> Например, фоновый поток, который выполнения от основного потока пользовательского интерфейса не может обновить содержимое <xref:System.Windows.Controls.Button>, созданного в потоке пользовательского интерфейса.</xref:System.Windows.Controls.Button> Чтобы фоновый поток для доступа к свойства Content <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в <xref:System.Windows.Threading.Dispatcher>связанного с потоком пользовательского интерфейса.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> Операция добавляется в очередь событий <xref:System.Windows.Threading.Dispatcher>в указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       Если <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>вызывается в <xref:System.Windows.Threading.Dispatcher>, ее работа была прекращена <xref:System.Windows.Threading.DispatcherOperation>равно <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> возвращаемое свойство status</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Делегат для метода, принимающего параметры, заданные в `args`, который помещается в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очередь событий."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет относительно других ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> вызывается очереди событий, указанного метода."
    - id: args
      type: System.Object[]
      description: "Массив объектов для передачи в качестве аргументов указанному методу. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Объект, который возвращается сразу после <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>вызове, который может использоваться для взаимодействия с делегатом, как ожидает выполнения события очереди.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанный делегат асинхронно в определенной последовательности и с заданным аргументом в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> сопоставлен."
  remarks: "`Arg`может быть `null` Если аргументы не требуются.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Возвращает <xref:System.Windows.Threading.DispatcherOperation>объект, который может использоваться для взаимодействия с делегатом после делегата события очереди.</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       <xref:System.Windows.Threading.DispatcherOperation>Объект, возвращаемый <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>может использоваться несколькими способами для взаимодействия с заданного делегата, например: - изменение <xref:System.Windows.Threading.DispatcherPriority>делегата, как он находится в состоянии ожидания выполнения в очередь событий.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Удаление делегата из очереди событий.      -Ожидание возврата из делегата.      -Получение значения, возвращаемого делегатом после его выполнения.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронным; поэтому управление немедленно возвращается вызывающему объекту после его вызова.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       В [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], поток, создавший <xref:System.Windows.Threading.DispatcherObject>может получить доступ к этому объекту.</xref:System.Windows.Threading.DispatcherObject>  Например, фоновый поток, который выполнения от основного потока пользовательского интерфейса не может обновить содержимое <xref:System.Windows.Controls.Button>, созданного в потоке пользовательского интерфейса.</xref:System.Windows.Controls.Button>  Чтобы фоновый поток для доступа к свойства content <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в <xref:System.Windows.Threading.Dispatcher>связанного с потоком пользовательского интерфейса.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  Операция добавляется в очередь событий <xref:System.Windows.Threading.Dispatcher>в указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       При наличии нескольких <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>вызовов, выполняемых на том же <xref:System.Windows.Threading.DispatcherPriority>, они будут выполнены в порядке вызовов.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Если <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>вызывается в <xref:System.Windows.Threading.Dispatcher>, ее работа была прекращена <xref:System.Windows.Threading.DispatcherOperation>равно <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> возвращаемое свойство status</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  example:
  - "The following example shows how to place an operation onto a <xref:System.Windows.Threading.Dispatcher>.  \n  \n First, a delegate is created that accepts one argument, in this case a string.  \n  \n [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/add/codesnippet/visualbasic/threadingweatherforecastsample/window1.xaml.vb#threadingweatherdelegates)]\n [!code-cs[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/add/codesnippet/csharp/ThreadingWeatherForecastSample/Window1.xaml.cs#threadingweatherdelegates)]  \n  \n Next, BeginInvoke is called.  Because every <xref:System.Windows.Threading.DispatcherObject> has a property that returns the <xref:System.Windows.Threading.Dispatcher> it is associated with, the desired <xref:System.Windows.Threading.Dispatcher> is obtained by querying the <xref:System.Windows.Threading.DispatcherObject>, in this case a <xref:System.Windows.Controls.Grid> named `tomorrowsWeather`. The call to BeginInvoke takes three parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>; the callback, which is passed in through an instance of the delegate `OneArgDelegate`; and a string named `weather`, which is the argument for the callback.  \n  \n [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/add/codesnippet/visualbasic/threadingweatherforecastsample/window1.xaml.vb#threadingweatherdispatcheronearge)]\n [!code-cs[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/add/codesnippet/csharp/ThreadingWeatherForecastSample/Window1.xaml.cs#threadingweatherdispatcheronearge)]"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет относительно других ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> вызывается очереди событий, указанного метода."
    - id: method
      type: System.Delegate
      description: "Делегат для метода, принимающего один аргумент, который помещается в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очередь событий."
    - id: arg
      type: System.Object
      description: "Объект, передаваемый в качестве аргумента указанному методу."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Объект, который возвращается сразу после <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>вызове, который может использоваться для взаимодействия с делегатом, как ожидает выполнения события очереди.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>не является допустимым <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанный делегат асинхронно в указанный приоритет, используя заданный массив аргументов в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> сопоставлен."
  remarks: "`arg` Параметр может иметь `null` Если аргументы не требуются.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Возвращает <xref:System.Windows.Threading.DispatcherOperation>объект, который может использоваться для взаимодействия с делегатом после делегата события очереди.</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       <xref:System.Windows.Threading.DispatcherOperation>Объект, возвращаемый <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>может использоваться несколькими способами для взаимодействия с заданного делегата, например: - изменение <xref:System.Windows.Threading.DispatcherPriority>делегата, как он находится в состоянии ожидания выполнения в очередь событий.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -Удаление делегата из очереди событий.      -Ожидание возврата из делегата.      -Получение значения, возвращаемого делегатом после его выполнения.       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронным; поэтому управление немедленно возвращается вызывающему объекту после его вызова.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       В [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], поток, создавший <xref:System.Windows.Threading.DispatcherObject>может получить доступ к этому объекту.</xref:System.Windows.Threading.DispatcherObject>  Например, фоновый поток, который выполнения от основного потока пользовательского интерфейса не может обновить содержимое <xref:System.Windows.Controls.Button>, созданного в потоке пользовательского интерфейса.</xref:System.Windows.Controls.Button>  Чтобы фоновый поток для доступа к свойства Content <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в <xref:System.Windows.Threading.Dispatcher>связанного с потоком пользовательского интерфейса.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  Операция добавляется в очередь событий <xref:System.Windows.Threading.Dispatcher>в указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       При наличии нескольких <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>вызовов, выполняемых на том же <xref:System.Windows.Threading.DispatcherPriority>, они будут выполнены в порядке вызовов.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       Если <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>вызывается в <xref:System.Windows.Threading.Dispatcher>, ее работа была прекращена <xref:System.Windows.Threading.DispatcherOperation>равно <xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus> </xref:System.Windows.Threading.DispatcherOperation> возвращаемое свойство status</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет относительно других ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> вызывается очереди событий, указанного метода."
    - id: method
      type: System.Delegate
      description: "Делегат метода, который принимает несколько аргументов которого возложена на <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очередь событий."
    - id: arg
      type: System.Object
      description: "Объект, передаваемый в качестве аргумента указанному методу."
    - id: args
      type: System.Object[]
      description: "Массив объектов для передачи в качестве аргументов указанному методу."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Объект, который возвращается сразу после <xref:System.Windows.Threading.Dispatcher.BeginInvoke*>вызове, который может использоваться для взаимодействия с делегатом, как ожидает выполнения в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очереди.</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;></xref>не является допустимым приоритет."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  id: BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvokeShutdown(DispatcherPriority)
  nameWithType: Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Инициирует завершение работы <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> асинхронно."
  remarks: "BeginInvokeShutdown требует неограниченными разрешениями пользовательского интерфейса.       Когда <xref:System.Windows.Threading.Dispatcher>начнет завершение работы, <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>события и <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>равно `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>Не полностью выключить пока очередь событий освобождает.</xref:System.Windows.Threading.Dispatcher>       По завершении диспетчер завершает работу, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>события и <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>свойству `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       После начала процесса завершения работы всех ожидающих рабочих элементов в очереди прерываются."
  syntax:
    content: public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет, с которого начинается остановка диспетчера."
  overload: System.Windows.Threading.Dispatcher.BeginInvokeShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.CheckAccess
  id: CheckAccess
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: CheckAccess()
  nameWithType: Dispatcher.CheckAccess()
  fullName: System.Windows.Threading.Dispatcher.CheckAccess()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Определяет, является ли вызывающий поток в поток, связанный с этим <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "Только <xref:System.Windows.Threading.Dispatcher>, <xref:System.Windows.Threading.DispatcherObject>создается на может получить доступ к объекту.</xref:System.Windows.Threading.DispatcherObject> </xref:System.Windows.Threading.Dispatcher>  Используйте <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>доступ к объекту из другого потока.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       CheckAccess может вызываться из любого потока.       Разница между CheckAccess и <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>CheckAccess возвращает логическое значение, указывающее, имеет ли вызывающий поток доступ к <xref:System.Windows.Threading.Dispatcher>и <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>приводит к возникновению исключения.</xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>"
  example:
  - "The following example uses CheckAccess to determine whether a thread has access to a <xref:System.Windows.Controls.Button>.  The CheckAccess method on the <xref:System.Windows.Threading.Dispatcher> associated with the <xref:System.Windows.Controls.Button> is called to verify access to the thread.  If the calling thread has access to the <xref:System.Windows.Threading.Dispatcher>, the <xref:System.Windows.Controls.Button> is updated by accessing the members of the <xref:System.Windows.Controls.Button>; otherwise, a delegate, which accepts a <xref:System.Windows.Controls.Button> as an argument, is placed onto the <xref:System.Windows.Threading.Dispatcher>.  The <xref:System.Windows.Threading.Dispatcher> will delegate the work of updating the <xref:System.Windows.Controls.Button>.  \n  \n [!code-cs[DispatcherAccessSample#DispatcherAccessCheckAccess](~/add/codesnippet/csharp/DispatcherAccessSample/Window1.xaml.cs#dispatcheraccesscheckaccess)]\n [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/add/codesnippet/visualbasic/dispatcheraccesssample/window1.xaml.vb#dispatcheraccesscheckaccess)]"
  syntax:
    content: public bool CheckAccess ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если вызывающий поток является поток, связанный с этим <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.CheckAccess*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher
  id: CurrentDispatcher
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
  fullName: System.Windows.Threading.Dispatcher.CurrentDispatcher
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Возвращает <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> потока в данный момент и создает новый <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> , если он еще не связанные с потоком."
  remarks: "Если <xref:System.Windows.Threading.Dispatcher>не связан с текущим потоком новый <xref:System.Windows.Threading.Dispatcher>будет создан.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>  Это не относится к <xref:System.Windows.Threading.Dispatcher.FromThread%2A>метод.</xref:System.Windows.Threading.Dispatcher.FromThread%2A>  <xref:System.Windows.Threading.Dispatcher.FromThread%2A>Возвращает `null` здесь не dispatcher, связанный с указанным потоком.</xref:System.Windows.Threading.Dispatcher.FromThread%2A>"
  syntax:
    content: public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }
    return:
      type: System.Windows.Threading.Dispatcher
      description: "Диспетчер, связанный с текущим потоком."
  overload: System.Windows.Threading.Dispatcher.CurrentDispatcher*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.DisableProcessing
  id: DisableProcessing
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: DisableProcessing()
  nameWithType: Dispatcher.DisableProcessing()
  fullName: System.Windows.Threading.Dispatcher.DisableProcessing()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Отключает обработку <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очереди."
  remarks: "Отключение диспетчера является операцией, предназначено для устранения возможности ненужного повторного входа.       Результаты отключения диспетчера таковы:- [!INCLUDE[TLA2#tla_clr#initcap](~/add/includes/tla2sharptla-clrsharpinitcap-md.md)] блокировки не будет выдавать сообщения внутренним образом.      - <xref:System.Windows.Threading.DispatcherFrame>объекты не могут отправляться.</xref:System.Windows.Threading.DispatcherFrame>      -Обработка сообщений запрещено.       <xref:System.Windows.Threading.DispatcherProcessingDisabled>Структуру, которая возвращает DisableProcessing при вызове может использоваться для повторного включения.</xref:System.Windows.Threading.DispatcherProcessingDisabled>  Вызов <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A>на <xref:System.Windows.Threading.DispatcherProcessingDisabled>структуры заново включает обработку.</xref:System.Windows.Threading.DispatcherProcessingDisabled> </xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A>       DisableProcessing может вызываться только в потоке <xref:System.Windows.Threading.Dispatcher>связан с.</xref:System.Windows.Threading.Dispatcher>"
  example:
  - "The following example shows how to disable dispatcher processing and re-enable dispatcher processing.  DisableProcessing is called in a **using** statement.  DisableProcessing returns a <xref:System.Windows.Threading.DispatcherProcessingDisabled> structure that is used as the object to be disposed when the **using** block finishes.  When <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> is called on the <xref:System.Windows.Threading.DispatcherProcessingDisabled> structure, dispatcher processing is re-enabled.  \n  \n [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/add/codesnippet/visualbasic/dispatchersnippets/window1.xaml.vb#dispatcherdisableprocessing)]\n [!code-cs[DispatcherSnippets#DispatcherDisableProcessing](~/add/codesnippet/csharp/DispatcherSnippets/Window1.xaml.cs#dispatcherdisableprocessing)]"
  syntax:
    content: public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();
    parameters: []
    return:
      type: System.Windows.Threading.DispatcherProcessingDisabled
      description: "Структура, используемая для повторного включения."
  overload: System.Windows.Threading.Dispatcher.DisableProcessing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames
  id: ExitAllFrames
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ExitAllFrames()
  nameWithType: Dispatcher.ExitAllFrames()
  fullName: System.Windows.Threading.Dispatcher.ExitAllFrames()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Закрыть все кадры, включая вложенные запросы."
  syntax:
    content: public static void ExitAllFrames ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.ExitAllFrames*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  id: FromThread(System.Threading.Thread)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: FromThread(Thread)
  nameWithType: Dispatcher.FromThread(Thread)
  fullName: System.Windows.Threading.Dispatcher.FromThread(Thread)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Возвращает <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> для заданного потока."
  remarks: "Если диспетчер недоступен для заданного потока, `null` будут возвращены.       FromThread не создается <xref:System.Windows.Threading.Dispatcher>в потоке, не имеющим <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>   Новый <xref:System.Windows.Threading.Dispatcher>создается в потоке, который еще не содержит <xref:System.Windows.Threading.Dispatcher>при попытке получить <xref:System.Windows.Threading.Dispatcher>с помощью <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>свойство.</xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>"
  syntax:
    content: public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);
    parameters:
    - id: thread
      type: System.Threading.Thread
      description: "Поток, который необходимо получить <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> из."
    return:
      type: System.Windows.Threading.Dispatcher
      description: "Диспетчер для <code> thread </code>."
  overload: System.Windows.Threading.Dispatcher.FromThread*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished
  id: HasShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.HasShutdownFinished
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Определяет, является ли <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> завершил процесс остановки."
  remarks: "Когда <xref:System.Windows.Threading.Dispatcher>начнет завершение работы, <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>события и <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>равно `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>Не выполняет завершение полностью пока очередь событий освобождает.</xref:System.Windows.Threading.Dispatcher>       По завершении диспетчер завершает работу, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>событие и HasShutdownFinished является свойство `true`.</xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       После начала процесса завершения работы всех ожидающих рабочих элементов в очереди прерываются."
  syntax:
    content: public bool HasShutdownFinished { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если диспетчер завершил процесс остановки; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.HasShutdownFinished*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted
  id: HasShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.HasShutdownStarted
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Определяет, является ли <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> завершает работу."
  remarks: "Когда <xref:System.Windows.Threading.Dispatcher>начнет завершение работы, <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>событие и HasShutdownStarted равно `true`.</xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>Не полностью выключить пока очередь событий освобождает.</xref:System.Windows.Threading.Dispatcher>       По завершении диспетчер завершает работу, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>события и <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>свойству `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       После начала процесса завершения работы всех ожидающих рабочих элементов в очереди прерываются."
  syntax:
    content: public bool HasShutdownStarted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> начал завершает работу; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.HasShutdownStarted*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Hooks
  id: Hooks
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Hooks
  nameWithType: Dispatcher.Hooks
  fullName: System.Windows.Threading.Dispatcher.Hooks
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Возвращает коллекцию обработчиков, которые содержат дополнительные сведения о <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "<xref:System.Windows.Threading.DispatcherHooks>Класс предоставляет дополнительную информацию о <xref:System.Windows.Threading.Dispatcher>, например когда <xref:System.Windows.Threading.Dispatcher>неактивна или если операция завершена.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.DispatcherHooks>"
  syntax:
    content: public System.Windows.Threading.DispatcherHooks Hooks { get; }
    return:
      type: System.Windows.Threading.DispatcherHooks
      description: "Обработчики, связанный с этим <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.Hooks*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action)
  id: Invoke(System.Action)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action)
  nameWithType: Dispatcher.Invoke(Action)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанную <xref:System.Action>синхронно в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> связан с.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback);
    parameters:
    - id: callback
      type: System.Action
      description: "Делегат, вызываемый через диспетчер."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанную <xref:System.Action>синхронно с указанным приоритетом в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> связан с.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Action
      description: "Делегат, вызываемый через диспетчер."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет, который определяет, в каком порядке указанной обратный вызов выполняется относительно другие ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  id: Invoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Синхронно выполняет указанный делегат с указанными аргументами в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> сопоставлен."
  remarks: "В [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], поток, создавший <xref:System.Windows.Threading.DispatcherObject>может получить доступ к этому объекту.</xref:System.Windows.Threading.DispatcherObject> Например, фоновый поток, который выполнения от основного потока пользовательского интерфейса не может обновить содержимое <xref:System.Windows.Controls.Button>, созданного в потоке пользовательского интерфейса.</xref:System.Windows.Controls.Button> Чтобы фоновый поток для доступа к свойства Content <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в <xref:System.Windows.Threading.Dispatcher>связанного с потоком пользовательского интерфейса.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> Операция добавляется в очередь событий <xref:System.Windows.Threading.Dispatcher>в указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>представляет собой синхронную операцию; Таким образом элемент управления не возвращает вызывающему объекту до после функция обратного вызова.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Делегат для метода, принимающего параметры, заданные в `args`, который помещается в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очередь событий."
    - id: args
      type: System.Object[]
      description: "Массив объектов для передачи в качестве аргументов указанному методу. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "Значение, возвращаемое вызываемым делегатом или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если делегат не имеет возвращаемого значения."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанный делегат синхронно с указанным приоритетом в потоке, в котором <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> сопоставлен."
  remarks: "В [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], поток, создавший <xref:System.Windows.Threading.DispatcherObject>может получить доступ к этому объекту.</xref:System.Windows.Threading.DispatcherObject>  Например, фоновый поток, который выполнения от основного потока пользовательского интерфейса не может обновить содержимое <xref:System.Windows.Controls.Button>, созданного в потоке пользовательского интерфейса.</xref:System.Windows.Controls.Button>  Чтобы фоновый поток для доступа к свойства Content <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в <xref:System.Windows.Threading.Dispatcher>связанного с потоком пользовательского интерфейса.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  Операция добавляется в очередь событий <xref:System.Windows.Threading.Dispatcher>в указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>представляет собой синхронную операцию; Таким образом элемент управления не возвращает вызывающему объекту до после функция обратного вызова.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  example:
  - "The following example places a delegate onto a <xref:System.Windows.Threading.Dispatcher> at <xref:System.Windows.Threading.DispatcherPriority> using Invoke.  \n  \n [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/add/codesnippet/visualbasic/invalidaterequerywithsystemtimer/window1.xaml.vb#systemtimerdispatcherinvoke)]\n [!code-cs[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/add/codesnippet/csharp/InvalidateRequeryWithSystemTimer/Window1.xaml.cs#systemtimerdispatcherinvoke)]"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет относительно других ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> вызывается очереди событий, указанного метода."
    - id: method
      type: System.Delegate
      description: "Делегат метода, который не принимает аргументы, который помещается в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очередь событий."
    return:
      type: System.Object
      description: "Значение, возвращаемое вызываемым делегатом или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если делегат не имеет возвращаемого значения."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>равен <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>не является допустимым приоритет."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанную <xref:System.Action>синхронно с указанным приоритетом в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> связан с.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Action
      description: "Делегат, вызываемый через диспетчер."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет, который определяет, в каком порядке указанной обратный вызов выполняется относительно другие ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Объект, который указывает, следует ли отменить действие."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  id: Invoke(System.Delegate,System.TimeSpan,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,TimeSpan,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Синхронно выполняет указанный делегат в течение заданного промежутка времени с указанным приоритетом с указанными аргументами в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> сопоставлен."
  remarks: "В [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], поток, создавший <xref:System.Windows.Threading.DispatcherObject>может получить доступ к этому объекту.</xref:System.Windows.Threading.DispatcherObject> Например, фоновый поток, который выполнения от основного потока пользовательского интерфейса не может обновить содержимое <xref:System.Windows.Controls.Button>, созданного в потоке пользовательского интерфейса.</xref:System.Windows.Controls.Button> Чтобы фоновый поток для доступа к свойства Content <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в <xref:System.Windows.Threading.Dispatcher>связанного с потоком пользовательского интерфейса.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> Операция добавляется в очередь событий <xref:System.Windows.Threading.Dispatcher>в указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>представляет собой синхронную операцию; Таким образом элемент управления не возвращает вызывающему объекту до после функция обратного вызова.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, TimeSpan timeout, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Делегат для метода, принимающего параметры, заданные в `args`, который помещается в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очередь событий."
    - id: timeout
      type: System.TimeSpan
      description: "Максимальное время ожидания завершения операции."
    - id: args
      type: System.Object[]
      description: "Массив объектов для передачи в качестве аргументов указанному методу. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "Значение, возвращаемое вызываемым делегатом или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если делегат не имеет возвращаемого значения."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Синхронно выполняет указанный делегат в определенной последовательности с указанными аргументами в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> сопоставлен."
  remarks: "В [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], поток, создавший <xref:System.Windows.Threading.DispatcherObject>может получить доступ к этому объекту.</xref:System.Windows.Threading.DispatcherObject> Например, фоновый поток, который выполнения от основного потока пользовательского интерфейса не может обновить содержимое <xref:System.Windows.Controls.Button>, созданного в потоке пользовательского интерфейса.</xref:System.Windows.Controls.Button> Чтобы фоновый поток для доступа к свойства Content <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в <xref:System.Windows.Threading.Dispatcher>связанного с потоком пользовательского интерфейса.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> Операция добавляется в очередь событий <xref:System.Windows.Threading.Dispatcher>в указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>представляет собой синхронную операцию; Таким образом элемент управления не возвращает вызывающему объекту до после функция обратного вызова.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Делегат для метода, принимающего параметры, заданные в `args`, который помещается в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очередь событий."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет относительно других ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> вызывается очереди событий, указанного метода."
    - id: args
      type: System.Object[]
      description: "Массив объектов для передачи в качестве аргументов указанному методу. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "Значение, возвращаемое вызываемым делегатом или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если делегат не имеет возвращаемого значения."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанный делегат в определенной последовательности с заданным аргументом синхронно в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> сопоставлен."
  remarks: "`Arg`может быть `null` Если аргумент не является обязательным в [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], потока, который создал <xref:System.Windows.Threading.DispatcherObject>может получить доступ к этому объекту.</xref:System.Windows.Threading.DispatcherObject>  Например, фоновый поток, который выполнения от основного потока пользовательского интерфейса не может обновить содержимое <xref:System.Windows.Controls.Button>, созданного в потоке пользовательского интерфейса.</xref:System.Windows.Controls.Button>  Чтобы фоновый поток для доступа к свойства Content <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в <xref:System.Windows.Threading.Dispatcher>связанного с потоком пользовательского интерфейса.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  Операция добавляется в очередь событий <xref:System.Windows.Threading.Dispatcher>в указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>представляет собой синхронную операцию; Таким образом элемент управления не возвращает вызывающему объекту до после функция обратного вызова.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет относительно других ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> вызывается очереди событий, указанного метода."
    - id: method
      type: System.Delegate
      description: "Делегат для метода, принимающего один аргумент, который помещается в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очередь событий."
    - id: arg
      type: System.Object
      description: "Объект, передаваемый в качестве аргумента указанному методу."
    return:
      type: System.Object
      description: "Значение, возвращаемое вызываемым делегатом или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если делегат не имеет возвращаемого значения."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>равен <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>не является допустимым приоритет."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанный делегат синхронно в указанный приоритет, используя указанное время ожидания в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> был создан."
  remarks: "В [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], поток, создавший <xref:System.Windows.Threading.DispatcherObject>может получить доступ к этому объекту.</xref:System.Windows.Threading.DispatcherObject>  Например, фоновый поток, который выполнения от основного потока пользовательского интерфейса не может обновить содержимое <xref:System.Windows.Controls.Button>, созданного в потоке пользовательского интерфейса.</xref:System.Windows.Controls.Button>  Чтобы фоновый поток для доступа к свойства Content <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в <xref:System.Windows.Threading.Dispatcher>связанного с потоком пользовательского интерфейса.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  Операция добавляется в очередь событий <xref:System.Windows.Threading.Dispatcher>в указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>представляет собой синхронную операцию; Таким образом элемент управления не возвращает вызывающему объекту до после функция обратного вызова.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет относительно других ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> вызывается очереди событий, указанного метода."
    - id: timeout
      type: System.TimeSpan
      description: "Максимальное время ожидания завершения операции."
    - id: method
      type: System.Delegate
      description: "Делегат метода, который не принимает аргументы, который помещается в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очередь событий."
    return:
      type: System.Object
      description: "Значение, возвращаемое вызываемым делегатом или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если делегат не имеет возвращаемого значения."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанную <xref:System.Action>синхронно с указанным приоритетом в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> связан с.</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);
    parameters:
    - id: callback
      type: System.Action
      description: "Делегат, вызываемый через диспетчер."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет, который определяет, в каком порядке указанной обратный вызов выполняется относительно другие ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Объект, который указывает, следует ли отменить действие."
    - id: timeout
      type: System.TimeSpan
      description: "Минимальное количество времени ожидания для начала операции."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Синхронно выполняет указанный делегат в течение заданного промежутка времени с указанным приоритетом с указанными аргументами в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> сопоставлен."
  remarks: "В [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], поток, создавший <xref:System.Windows.Threading.DispatcherObject>может получить доступ к этому объекту.</xref:System.Windows.Threading.DispatcherObject> Например, фоновый поток, который выполнения от основного потока пользовательского интерфейса не может обновить содержимое <xref:System.Windows.Controls.Button>, созданного в потоке пользовательского интерфейса.</xref:System.Windows.Controls.Button> Чтобы фоновый поток для доступа к свойства Content <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в <xref:System.Windows.Threading.Dispatcher>связанного с потоком пользовательского интерфейса.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> Операция добавляется в очередь событий <xref:System.Windows.Threading.Dispatcher>в указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>представляет собой синхронную операцию; Таким образом элемент управления не возвращает вызывающему объекту до после функция обратного вызова.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "Делегат для метода, принимающего параметры, заданные в `args`, который помещается в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очередь событий."
    - id: timeout
      type: System.TimeSpan
      description: "Максимальное время ожидания завершения операции."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет относительно других ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> вызывается очереди событий, указанного метода."
    - id: args
      type: System.Object[]
      description: "Массив объектов для передачи в качестве аргументов указанному методу. Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "Значение, возвращаемое вызываемым делегатом или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если делегат не имеет возвращаемого значения."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Синхронно выполняет указанный делегат в определенной последовательности с указанными аргументами в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> сопоставлен."
  remarks: "`Arg`может быть `null` Если аргумент не является обязательным в [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], потока, который создал <xref:System.Windows.Threading.DispatcherObject>может получить доступ к этому объекту.</xref:System.Windows.Threading.DispatcherObject>  Например, фоновый поток, который выполнения от основного потока пользовательского интерфейса не может обновить содержимое <xref:System.Windows.Controls.Button>, созданного в потоке пользовательского интерфейса.</xref:System.Windows.Controls.Button>  Чтобы фоновый поток для доступа к свойства Content <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в <xref:System.Windows.Threading.Dispatcher>связанного с потоком пользовательского интерфейса.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  Операция добавляется в очередь событий <xref:System.Windows.Threading.Dispatcher>в указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>представляет собой синхронную операцию; Таким образом элемент управления не возвращает вызывающему объекту до после функция обратного вызова.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет относительно других ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> вызывается очереди событий, указанного метода."
    - id: method
      type: System.Delegate
      description: "Делегат метода, который принимает несколько аргументов которого возложена на <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очередь событий."
    - id: arg
      type: System.Object
      description: "Объект, передаваемый в качестве аргумента указанному методу."
    - id: args
      type: System.Object[]
      description: "Массив объектов для передачи в качестве аргументов указанному методу."
    return:
      type: System.Object
      description: "Значение, возвращаемое вызываемым делегатом или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если делегат не имеет возвращаемого значения."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>равен <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>не является допустимым приоритет."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанный делегат в определенной последовательности с заданным аргументом синхронно в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> сопоставлен."
  remarks: "`Arg`может быть `null` Если аргумент не является обязательным в [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], потока, который создал <xref:System.Windows.Threading.DispatcherObject>может получить доступ к этому объекту.</xref:System.Windows.Threading.DispatcherObject>  Например, фоновый поток, который выполнения от основного потока пользовательского интерфейса не может обновить содержимое <xref:System.Windows.Controls.Button>, созданного в потоке пользовательского интерфейса.</xref:System.Windows.Controls.Button>  Чтобы фоновый поток для доступа к свойства Content <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в <xref:System.Windows.Threading.Dispatcher>связанного с потоком пользовательского интерфейса.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  Операция добавляется в очередь событий <xref:System.Windows.Threading.Dispatcher>в указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>представляет собой синхронную операцию; Таким образом элемент управления не возвращает вызывающему объекту до после функция обратного вызова.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет относительно других ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> вызывается очереди событий, указанного метода."
    - id: timeout
      type: System.TimeSpan
      description: "Максимальное время ожидания завершения операции."
    - id: method
      type: System.Delegate
      description: "Делегат метода, который принимает несколько аргументов которого возложена на <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очередь событий."
    - id: arg
      type: System.Object
      description: "Объект, передаваемый в качестве аргумента указанному методу. Это может быть <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если аргументы не требуются."
    return:
      type: System.Object
      description: "Значение, возвращаемое вызываемым делегатом или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если делегат не имеет возвращаемого значения."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>равен <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>не является допустимым приоритет."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Синхронно выполняет указанный делегат в определенной последовательности с указанными аргументами в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> сопоставлен."
  remarks: "`Arg`может быть `null` Если аргумент не требуется.       В [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)], поток, создавший <xref:System.Windows.Threading.DispatcherObject>может получить доступ к этому объекту.</xref:System.Windows.Threading.DispatcherObject>  Например, фоновый поток, который выполнения от основного потока пользовательского интерфейса не может обновить содержимое <xref:System.Windows.Controls.Button>, созданного в потоке пользовательского интерфейса.</xref:System.Windows.Controls.Button>  Чтобы фоновый поток для доступа к свойства Content <xref:System.Windows.Controls.Button>, фоновый поток должны делегировать работу в <xref:System.Windows.Threading.Dispatcher>связанного с потоком пользовательского интерфейса.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  Это достигается с помощью либо <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>является синхронным и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронной.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  Операция добавляется в очередь событий <xref:System.Windows.Threading.Dispatcher>в указанный <xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>представляет собой синхронную операцию; Таким образом элемент управления не возвращает вызывающему объекту до после функция обратного вызова.</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет относительно других ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> вызывается очереди событий, указанного метода."
    - id: timeout
      type: System.TimeSpan
      description: "Максимальное время ожидания завершения операции."
    - id: method
      type: System.Delegate
      description: "Делегат метода, который принимает несколько аргументов которого возложена на <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> очередь событий."
    - id: arg
      type: System.Object
      description: "Объект, передаваемый в качестве аргумента указанному методу."
    - id: args
      type: System.Object[]
      description: "Массив объектов для передачи в качестве аргументов указанному методу."
    return:
      type: System.Object
      description: "Значение, возвращаемое вызываемым делегатом или <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> Если делегат не имеет возвращаемого значения."
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>равен <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>не является допустимым <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  id: Invoke``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>)
  nameWithType: Dispatcher.Invoke(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "Для добавления."
    return:
      type: TResult
      description: "Для добавления."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "Для добавления."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Для добавления."
    return:
      type: TResult
      description: "Для добавления."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "Для добавления."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Для добавления."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Для добавления."
    return:
      type: TResult
      description: "Для добавления."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "Для добавления."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Для добавления."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Для добавления."
    - id: timeout
      type: System.TimeSpan
      description: "Для добавления."
    return:
      type: TResult
      description: "Для добавления."
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  id: InvokeAsync(System.Action)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action)
  nameWithType: Dispatcher.InvokeAsync(Action)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанную <xref:System.Action>асинхронно в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> связан с.</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);
    parameters:
    - id: callback
      type: System.Action
      description: "Делегат, вызываемый через диспетчер."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Объект, который возвращается сразу после вызова InvokeAsync, который может использоваться для взаимодействия с делегатом, как ожидает выполнения события очереди."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  id: InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанную <xref:System.Action>асинхронно в определенной последовательности в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> связан с.</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Action
      description: "Делегат, вызываемый через диспетчер."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет, который определяет, в каком порядке указанной обратный вызов выполняется относительно другие ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Объект, который возвращается сразу после вызова InvokeAsync, который может использоваться для взаимодействия с делегатом, как ожидает выполнения события очереди."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Выполняет указанную <xref:System.Action>асинхронно в определенной последовательности в потоке <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> связан с.</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Action
      description: "Делегат, вызываемый через диспетчер."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет, который определяет, в каком порядке указанной обратный вызов выполняется относительно другие ожидающие операции в <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Объект, который указывает, следует ли отменить действие."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "Объект, который возвращается сразу после вызова InvokeAsync, который может использоваться для взаимодействия с делегатом, как ожидает выполнения события очереди."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  id: InvokeAsync``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "Для добавления."
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "Для добавления."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  id: InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "Для добавления."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Для добавления."
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "Для добавления."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "Для добавления."
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Для добавления."
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "Для добавления."
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "Для добавления."
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown
  id: InvokeShutdown
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeShutdown()
  nameWithType: Dispatcher.InvokeShutdown()
  fullName: System.Windows.Threading.Dispatcher.InvokeShutdown()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Инициирует процесс завершения работы <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> синхронно."
  remarks: "InvokeShutdown требует неограниченными разрешениями пользовательского интерфейса.       Когда <xref:System.Windows.Threading.Dispatcher>начнет завершение работы, <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>события и <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>равно `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>Не полностью выключить пока очередь событий освобождает.</xref:System.Windows.Threading.Dispatcher>       По завершении диспетчер завершает работу, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>события и <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>свойству `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       После начала процесса завершения работы всех ожидающих рабочих элементов в очереди прерываются."
  syntax:
    content: public void InvokeShutdown ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.InvokeShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  id: PushFrame(System.Windows.Threading.DispatcherFrame)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: PushFrame(DispatcherFrame)
  nameWithType: Dispatcher.PushFrame(DispatcherFrame)
  fullName: System.Windows.Threading.Dispatcher.PushFrame(DispatcherFrame)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Входит в цикл выполнения."
  remarks: "Объект <xref:System.Windows.Threading.DispatcherFrame>представляет цикл, который обрабатывает ожидающих работ.</xref:System.Windows.Threading.DispatcherFrame>       Диспетчер обрабатывает очередь рабочих элементов в цикле.  Цикл называется кадром.  Начальный цикла обычно инициируется приложением путем вызова метода <xref:System.Windows.Threading.Dispatcher.Run%2A>.</xref:System.Windows.Threading.Dispatcher.Run%2A>       PushFrame входит в цикл, представленный параметром `frame`.  В каждой итерации цикла <xref:System.Windows.Threading.Dispatcher>проверит <xref:System.Windows.Threading.DispatcherFrame.Continue%2A>свойство <xref:System.Windows.Threading.DispatcherFrame>класс, чтобы определить, следует ли продолжать цикла или если его следует остановить.</xref:System.Windows.Threading.DispatcherFrame> </xref:System.Windows.Threading.DispatcherFrame.Continue%2A> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.DispatcherFrame>позволяет <xref:System.Windows.Threading.DispatcherFrame.Continue%2A>явно установить это свойство и его соблюдает <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>свойство <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.DispatcherFrame.Continue%2A></xref:System.Windows.Threading.DispatcherFrame>  Это означает, что когда <xref:System.Windows.Threading.Dispatcher>начинает завершение работы, кадры, которые использует по умолчанию <xref:System.Windows.Threading.DispatcherFrame>реализацию завершит работу, которая разрешает всех вложенных кадров для выхода из.</xref:System.Windows.Threading.DispatcherFrame> </xref:System.Windows.Threading.Dispatcher>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Threading.DispatcherFrame> to achieve similar results as the [!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)] <xref:System.Windows.Forms.Application.DoEvents%2A> method.  \n  \n [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/add/codesnippet/visualbasic/dispatchersnippets/window1.xaml.vb#dispatcherdispatcherframedoevents)]\n [!code-cs[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/add/codesnippet/csharp/DispatcherSnippets/Window1.xaml.cs#dispatcherdispatcherframedoevents)]"
  syntax:
    content: public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);
    parameters:
    - id: frame
      type: System.Windows.Threading.DispatcherFrame
      description: "Фрейм для обработки диспетчером."
  overload: System.Windows.Threading.Dispatcher.PushFrame*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>frame</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished*>is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>       -or-       <code>frame</code> is running on a different <xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished*>       - или - диспетчер обработки была отключена."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Run
  id: Run
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Run()
  nameWithType: Dispatcher.Run()
  fullName: System.Windows.Threading.Dispatcher.Run()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Помещает в очередь событий фрейма главного выполнения <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "<xref:System.Windows.Threading.Dispatcher>Обрабатывает очередь событий в цикле.</xref:System.Windows.Threading.Dispatcher>  Цикл называется кадром.  Начальный цикла обычно инициируется приложением путем вызова метода выполнения.       Кадр основное выполнение продолжится до <xref:System.Windows.Threading.Dispatcher>выключен.</xref:System.Windows.Threading.Dispatcher>"
  syntax:
    content: public static void Run ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.Run*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ShutdownFinished
  id: ShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ShutdownFinished
  nameWithType: Dispatcher.ShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.ShutdownFinished
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Происходит, когда <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> завершения завершает работу."
  remarks: "Когда процесс завершения работы <xref:System.Windows.Threading.Dispatcher>запускается, <xref:System.Windows.Threading.Dispatcher.ShutdownStarted>события и <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>равно `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>Не выполняет завершение полностью пока очередь событий освобождает.</xref:System.Windows.Threading.Dispatcher>       По завершении завершение работы диспетчера события ShutdownFinished и <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>свойству `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>       После начала процесса завершения работы всех ожидающих рабочих элементов в очереди прерываются."
  syntax:
    content: public event EventHandler ShutdownFinished;
    return:
      type: System.EventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ShutdownStarted
  id: ShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ShutdownStarted
  nameWithType: Dispatcher.ShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.ShutdownStarted
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Происходит, когда <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> начнет завершение работы."
  remarks: "Когда процесс завершения работы <xref:System.Windows.Threading.Dispatcher>является запущена, ShutdownStarted события и <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>имеет значение `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>Не выполняет завершение полностью пока очередь событий освобождает.</xref:System.Windows.Threading.Dispatcher>       По завершении диспетчер завершает работу, <xref:System.Windows.Threading.Dispatcher.ShutdownFinished>события и <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>свойству `true`.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       После начала процесса завершения работы всех ожидающих рабочих элементов в очереди прерываются."
  syntax:
    content: public event EventHandler ShutdownStarted;
    return:
      type: System.EventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Thread
  id: Thread
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Thread
  nameWithType: Dispatcher.Thread
  fullName: System.Windows.Threading.Dispatcher.Thread
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Получает поток, это <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref> сопоставлен."
  syntax:
    content: public System.Threading.Thread Thread { get; }
    return:
      type: System.Threading.Thread
      description: "Поток."
  overload: System.Windows.Threading.Dispatcher.Thread*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.UnhandledException
  id: UnhandledException
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: UnhandledException
  nameWithType: Dispatcher.UnhandledException
  fullName: System.Windows.Threading.Dispatcher.UnhandledException
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Происходит, когда создаваемое и во время выполнения делегата посредством неперехваченное исключение потока <> </> *настроек или <> </> *настроек."
  remarks: "Это событие возникает в том случае, если исключение, инициированное во время выполнения делегата посредством <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>— неперехваченных.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       Обработчик может пометить исключение как обработанное, что позволит блокировать внутреннего обработчика исключений вызывается.       Обработчики событий для этого события должны записываться осторожно во избежание создания вторичных исключений и перехватывать те, что происходят. Рекомендуется избегать выделения памяти или выполнения операций с большим объемом в обработчике.       <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>Событий позволяет не вызывают событие UnhandledException.</xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>  <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>События во-первых и если <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>на <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs>имеет значение `false`, не возникает событие UnhandledException.</xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> </xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  id: UnhandledExceptionFilter
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: UnhandledExceptionFilter
  nameWithType: Dispatcher.UnhandledExceptionFilter
  fullName: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Происходит, когда создаваемое и во время выполнения делегата посредством неперехваченное исключение потока <> </> *настроек или <> </> *настроек в рабочей области фильтра."
  remarks: "Это событие возникает во время этапа фильтра для исключение, возникшее во время выполнения делегата посредством <xref:System.Windows.Threading.Dispatcher.Invoke%2A>или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>и неперехваченных.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       Стек вызовов не развернут на этом этапе (первичное исключение).       Обработчики событий для этого события должны записываться осторожно во избежание создания вторичных исключений и перехватывать те, что происходят.  Рекомендуется избегать выделения памяти или выполнения операций с большим объемом в обработчике.       Событие UnhandledExceptionFilter предоставляет средства для вызывает <xref:System.Windows.Threading.Dispatcher.UnhandledException>событий.</xref:System.Windows.Threading.Dispatcher.UnhandledException>  Во-первых, вызывается событие UnhandledExceptionFilter и, если <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>на <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs>равно `false`, <xref:System.Windows.Threading.Dispatcher.UnhandledException>события не вызываются.</xref:System.Windows.Threading.Dispatcher.UnhandledException> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  id: ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ValidatePriority(DispatcherPriority,String)
  nameWithType: Dispatcher.ValidatePriority(DispatcherPriority,String)
  fullName: System.Windows.Threading.Dispatcher.ValidatePriority(DispatcherPriority,String)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Определяет, является ли указанный <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref> является допустимым приоритетом."
  syntax:
    content: public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет для проверки."
    - id: parameterName
      type: System.String
      description: "Строка, которая возвращается исключение, которое возникает, если Недопустимый приоритет."
  overload: System.Windows.Threading.Dispatcher.ValidatePriority*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>не является допустимым <xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.VerifyAccess
  id: VerifyAccess
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: VerifyAccess()
  nameWithType: Dispatcher.VerifyAccess()
  fullName: System.Windows.Threading.Dispatcher.VerifyAccess()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Определяет, имеет ли вызывающий поток доступ к этой <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  remarks: "Только поток <xref:System.Windows.Threading.Dispatcher>создается на может получать доступ к <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>       Этот метод является общим; Таким образом любой поток можно проверить наличие доступа к <xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher>       Разница между <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>и метод VerifyAccess <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>возвращает логическое значение, если вызывающий поток не имеет доступа к <xref:System.Windows.Threading.Dispatcher>и метод VerifyAccess создает исключение.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> </xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>"
  example:
  - "The following example uses VerifyAccess to determine whether a thread has access to the thread that a <xref:System.Windows.Controls.Button> was created on.  The method takes an object as an argument, which is cast to a <xref:System.Windows.Controls.Button>.  The VerifyAccess method on the <xref:System.Windows.Threading.Dispatcher> of the <xref:System.Windows.Controls.Button> is called to verify access to the thread.  \n  \n If the calling thread has access to the <xref:System.Windows.Threading.Dispatcher>, the <xref:System.Windows.Controls.Button> is updated by just accessing the members of the <xref:System.Windows.Controls.Button>.  \n  \n If the calling thread does not have access, an <xref:System.InvalidOperationException> is thrown.  This example catches the exception and pushes a delegate, which accepts a <xref:System.Windows.Controls.Button> as an argument, onto the <xref:System.Windows.Threading.Dispatcher> of the <xref:System.Windows.Controls.Button>.  This <xref:System.Windows.Threading.Dispatcher> will do the work of updating the <xref:System.Windows.Controls.Button>.  \n  \n [!code-cs[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/add/codesnippet/csharp/DispatcherAccessSample/Window1.xaml.cs#dispatcheraccessverifyaccess)]\n [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/add/codesnippet/visualbasic/dispatcheraccesssample/window1.xaml.vb#dispatcheraccessverifyaccess)]"
  syntax:
    content: public void VerifyAccess ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.VerifyAccess*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Вызывающий поток не имеет доступа к этому <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Yield
  id: Yield
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Yield()
  nameWithType: Dispatcher.Yield()
  fullName: System.Windows.Threading.Dispatcher.Yield()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Создает объект типа awaitable, который асинхронно передает управление обратно в текущего dispatcher и дает возможность диспетчер для обработки других событий."
  remarks: "Этот метод позволяет временно разблокировки выполнения для текущего dispatcher, он может выполнять другие работы, такие как обработка других событий. Используйте `await`, или `Await` в Visual Basic, оператор для возвращаемого значения, чтобы вернуть управление текущего dispatcher. Используйте этот метод, если требуется предоставить возможность обработки событий, пока приложение выполняет большой объем работы в потоке пользовательского интерфейса приложения. Например можно использовать этот метод в цикле длительное время, который обновляет элемент управления.       Этот метод эквивалентен методу вызова <xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29>метода и передачи <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>.</xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName> </xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29>"
  syntax:
    content: public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();
    parameters: []
    return:
      type: System.Windows.Threading.DispatcherPriorityAwaitable
      description: "Типа awaitable объекта, асинхронно передает управление обратно в текущего dispatcher и дает возможность диспетчер для обработки других событий."
  overload: System.Windows.Threading.Dispatcher.Yield*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  id: Yield(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Yield(DispatcherPriority)
  nameWithType: Dispatcher.Yield(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Yield(DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "Создает объект типа awaitable, который асинхронно передает управление обратно в текущего dispatcher и дает возможность диспетчер для обработки других событий.  Работа, возникает, когда управление возвращается коду, ожидающие результат выполнения этого метода запланирован с заданным приоритетом."
  remarks: "Этот метод позволяет временно разблокировки выполнения для текущего dispatcher, он может выполнять другие работы, такие как обработка других событий. Используйте `await`, или `Await` в Visual Basic, оператор для возвращаемого значения, чтобы вернуть управление текущего dispatcher. Используйте этот метод, если требуется предоставить возможность обработки событий, пока приложение выполняет большой объем работы в потоке пользовательского интерфейса приложения. Например можно использовать этот метод в цикле длительное время, который обновляет элемент управления."
  syntax:
    content: public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "Приоритет, с которой необходимо планировать продолжения."
    return:
      type: System.Windows.Threading.DispatcherPriorityAwaitable
      description: "Типа awaitable объекта, асинхронно передает управление обратно в текущего dispatcher и дает возможность диспетчер для обработки других событий."
  overload: System.Windows.Threading.Dispatcher.Yield*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(Delegate,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,Object[])
- uid: System.Windows.Threading.DispatcherOperation
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherOperation
  nameWithType: DispatcherOperation
  fullName: System.Windows.Threading.DispatcherOperation
- uid: System.Delegate
  parent: System
  isExternal: true
  name: Delegate
  nameWithType: Delegate
  fullName: System.Delegate
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
- uid: System.Windows.Threading.DispatcherPriority
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherPriority
  nameWithType: DispatcherPriority
  fullName: System.Windows.Threading.DispatcherPriority
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvokeShutdown(DispatcherPriority)
  nameWithType: Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.CheckAccess
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CheckAccess()
  nameWithType: Dispatcher.CheckAccess()
  fullName: System.Windows.Threading.Dispatcher.CheckAccess()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
  fullName: System.Windows.Threading.Dispatcher.CurrentDispatcher
- uid: System.Windows.Threading.Dispatcher
  parent: System.Windows.Threading
  isExternal: false
  name: Dispatcher
  nameWithType: Dispatcher
  fullName: System.Windows.Threading.Dispatcher
- uid: System.Windows.Threading.Dispatcher.DisableProcessing
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: DisableProcessing()
  nameWithType: Dispatcher.DisableProcessing()
  fullName: System.Windows.Threading.Dispatcher.DisableProcessing()
- uid: System.Windows.Threading.DispatcherProcessingDisabled
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherProcessingDisabled
  nameWithType: DispatcherProcessingDisabled
  fullName: System.Windows.Threading.DispatcherProcessingDisabled
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ExitAllFrames()
  nameWithType: Dispatcher.ExitAllFrames()
  fullName: System.Windows.Threading.Dispatcher.ExitAllFrames()
- uid: System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: FromThread(Thread)
  nameWithType: Dispatcher.FromThread(Thread)
  fullName: System.Windows.Threading.Dispatcher.FromThread(Thread)
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.HasShutdownFinished
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.HasShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Hooks
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Hooks
  nameWithType: Dispatcher.Hooks
  fullName: System.Windows.Threading.Dispatcher.Hooks
- uid: System.Windows.Threading.DispatcherHooks
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherHooks
  nameWithType: DispatcherHooks
  fullName: System.Windows.Threading.DispatcherHooks
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action)
  nameWithType: Dispatcher.Invoke(Action)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action)
- uid: System.Action
  parent: System
  isExternal: true
  name: Action
  nameWithType: Action
  fullName: System.Action
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,TimeSpan,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,Object[])
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>)
  nameWithType: Dispatcher.Invoke(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>)
- uid: TResult
  isExternal: true
  name: TResult
  nameWithType: TResult
  fullName: TResult
- uid: System.Func{TResult}
  parent: System
  isExternal: true
  name: Func<TResult>
  nameWithType: Func<TResult>
  fullName: System.Func<TResult>
  spec.csharp:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: Func<TResult>
  - name: <
    nameWithType: <
    fullName: <
  - uid: TResult
    name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action)
  nameWithType: Dispatcher.InvokeAsync(Action)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>)
- uid: System.Windows.Threading.DispatcherOperation`1
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherOperation<TResult>
  nameWithType: DispatcherOperation<TResult>
  fullName: System.Windows.Threading.DispatcherOperation<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeShutdown()
  nameWithType: Dispatcher.InvokeShutdown()
  fullName: System.Windows.Threading.Dispatcher.InvokeShutdown()
- uid: System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: PushFrame(DispatcherFrame)
  nameWithType: Dispatcher.PushFrame(DispatcherFrame)
  fullName: System.Windows.Threading.Dispatcher.PushFrame(DispatcherFrame)
- uid: System.Windows.Threading.DispatcherFrame
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherFrame
  nameWithType: DispatcherFrame
  fullName: System.Windows.Threading.DispatcherFrame
- uid: System.Windows.Threading.Dispatcher.Run
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Run()
  nameWithType: Dispatcher.Run()
  fullName: System.Windows.Threading.Dispatcher.Run()
- uid: System.Windows.Threading.Dispatcher.ShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ShutdownFinished
  nameWithType: Dispatcher.ShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.ShutdownFinished
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.Threading.Dispatcher.ShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ShutdownStarted
  nameWithType: Dispatcher.ShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.ShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Thread
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Thread
  nameWithType: Dispatcher.Thread
  fullName: System.Windows.Threading.Dispatcher.Thread
- uid: System.Windows.Threading.Dispatcher.UnhandledException
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: UnhandledException
  nameWithType: Dispatcher.UnhandledException
  fullName: System.Windows.Threading.Dispatcher.UnhandledException
- uid: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionEventHandler
  nameWithType: DispatcherUnhandledExceptionEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
- uid: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: UnhandledExceptionFilter
  nameWithType: Dispatcher.UnhandledExceptionFilter
  fullName: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
- uid: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionFilterEventHandler
  nameWithType: DispatcherUnhandledExceptionFilterEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
- uid: System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ValidatePriority(DispatcherPriority,String)
  nameWithType: Dispatcher.ValidatePriority(DispatcherPriority,String)
  fullName: System.Windows.Threading.Dispatcher.ValidatePriority(DispatcherPriority,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Threading.Dispatcher.VerifyAccess
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: VerifyAccess()
  nameWithType: Dispatcher.VerifyAccess()
  fullName: System.Windows.Threading.Dispatcher.VerifyAccess()
- uid: System.Windows.Threading.Dispatcher.Yield
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield()
  nameWithType: Dispatcher.Yield()
  fullName: System.Windows.Threading.Dispatcher.Yield()
- uid: System.Windows.Threading.DispatcherPriorityAwaitable
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherPriorityAwaitable
  nameWithType: DispatcherPriorityAwaitable
  fullName: System.Windows.Threading.DispatcherPriorityAwaitable
- uid: System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield(DispatcherPriority)
  nameWithType: Dispatcher.Yield(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Yield(DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.BeginInvoke*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke
  nameWithType: Dispatcher.BeginInvoke
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvokeShutdown
  nameWithType: Dispatcher.BeginInvokeShutdown
- uid: System.Windows.Threading.Dispatcher.CheckAccess*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CheckAccess
  nameWithType: Dispatcher.CheckAccess
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
- uid: System.Windows.Threading.Dispatcher.DisableProcessing*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: DisableProcessing
  nameWithType: Dispatcher.DisableProcessing
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ExitAllFrames
  nameWithType: Dispatcher.ExitAllFrames
- uid: System.Windows.Threading.Dispatcher.FromThread*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: FromThread
  nameWithType: Dispatcher.FromThread
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Hooks*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Hooks
  nameWithType: Dispatcher.Hooks
- uid: System.Windows.Threading.Dispatcher.Invoke*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke
  nameWithType: Dispatcher.Invoke
- uid: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke<TResult>
  nameWithType: Dispatcher.Invoke<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeAsync*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync
  nameWithType: Dispatcher.InvokeAsync
- uid: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync<TResult>
  nameWithType: Dispatcher.InvokeAsync<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeShutdown
  nameWithType: Dispatcher.InvokeShutdown
- uid: System.Windows.Threading.Dispatcher.PushFrame*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: PushFrame
  nameWithType: Dispatcher.PushFrame
- uid: System.Windows.Threading.Dispatcher.Run*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Run
  nameWithType: Dispatcher.Run
- uid: System.Windows.Threading.Dispatcher.Thread*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Thread
  nameWithType: Dispatcher.Thread
- uid: System.Windows.Threading.Dispatcher.ValidatePriority*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ValidatePriority
  nameWithType: Dispatcher.ValidatePriority
- uid: System.Windows.Threading.Dispatcher.VerifyAccess*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: VerifyAccess
  nameWithType: Dispatcher.VerifyAccess
- uid: System.Windows.Threading.Dispatcher.Yield*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield
  nameWithType: Dispatcher.Yield
