### YamlMime:ManagedReference
items:
- uid: System.IO.Log.IRecordSequence
  id: IRecordSequence
  children:
  - System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.BaseSequenceNumber
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.CreateReservationCollection
  - System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.Flush
  - System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.LastSequenceNumber
  - System.IO.Log.IRecordSequence.MaximumRecordLength
  - System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.IRecordSequence.ReadRestartAreas
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReservedBytes
  - System.IO.Log.IRecordSequence.RestartSequenceNumber
  - System.IO.Log.IRecordSequence.RetryAppend
  - System.IO.Log.IRecordSequence.TailPinned
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: IRecordSequence
  nameWithType: IRecordSequence
  fullName: System.IO.Log.IRecordSequence
  type: Interface
  summary: "Предоставляет универсальный интерфейс последовательности записей."
  remarks: "Интерфейс IRecordSequence предоставляет абстрактный интерфейс потоку, ориентированному на записи. Экземпляр IRecordSequence может использоваться для чтения и записи в журнале.       Интерфейс IRecordSequence предоставляет следующие возможности, - Добавление журнала записываются с помощью <xref:System.IO.Log.IRecordSequence.Append%2A>методы.</xref:System.IO.Log.IRecordSequence.Append%2A>      -Считывание добавленных записей с помощью <xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>метод.</xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>      — Написание специальные записи перезапуска с помощью <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>метод.</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>      -Чтения перезапустите записей из последней записанной записи перезапуска с помощью <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>метод.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>      -Очистка записей для устойчивого хранения с помощью <xref:System.IO.Log.IRecordSequence.Flush%2A>метод.</xref:System.IO.Log.IRecordSequence.Flush%2A>      -Резервирование пространства для добавления записей.      -Свободного места для журналов с помощью перемещения базы журнала.      -Receive <xref:System.IO.Log.IRecordSequence.TailPinned>уведомления о событиях для перемещения базы журнала на свободное пространство.</xref:System.IO.Log.IRecordSequence.TailPinned>       Записи журнала добавляются к экземпляру IRecordSequence, и каждая запись журнала присваивается уникальный порядковый номер. Порядковые номера увеличиваются строго монотонно в рамках определенной последовательности записей. Запись журнала состоит из непрозрачных данных, предоставляемых экземпляру IRecordSequence в <xref:System.Collections.IList>фрагментов массива байтов.</xref:System.Collections.IList>       Интерфейс IRecordSequence также предоставляет несколько базовых свойств, предоставляющих сведения о границах журнала.      - <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>Свойство содержит порядковый номер первой допустимой записи в последовательности записей.</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      - <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>Свойство содержит порядковый номер, который гарантированно быть больше, чем порядковый номер последней добавленной записи.</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>      - <xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>Свойство содержит порядковый номер последней записанной области перезапуска.</xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>      - <xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>Свойство содержит размер наибольшей записи, которую можно добавить или прочитать из последовательности.</xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>      - <xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>Свойство содержит общий размер резервирований, созданных в последовательности записей.</xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>      -Если <xref:System.IO.Log.IRecordSequence.RetryAppend%2A>свойству `true`и <xref:System.IO.Log.IRecordSequence.Append%2A>операция завершается неудачей, поскольку нет места в последовательности, последовательность записей пытается освободить место и повторите операцию добавления.</xref:System.IO.Log.IRecordSequence.Append%2A> </xref:System.IO.Log.IRecordSequence.RetryAppend%2A>"
  syntax:
    content: 'public interface IRecordSequence : IDisposable'
  implements:
  - System.IDisposable
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Выполняет переход базового порядкового номера журнала."
  remarks: "При использовании <xref:System.IO.Log.LogRecordSequence>экземпляр и попытке переместить порядковый номер для освобождения места в журнале, новый базовый порядковый номер должен находиться в другой области журнала для Предыдущая область была помечена как пустая.</xref:System.IO.Log.LogRecordSequence> Частичное освобождение областей не поддерживается."
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Новый базовый порядковый номер в последовательности записей."
  overload: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>является недопустимым."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSequenceNumber</code>не включен в журнал."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При изменении последовательности произошла ошибка ввода-вывода."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательность записей заполнена."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе записывает запись журнала <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Данные, содержащиеся в `data` параметров будут объединены в единый массив байтов для добавления в качестве записи. Однако не делается допущение обратном разделении данных на фрагменты массива при чтении записи.       Обычно этот метод завершает работу перед записи. Чтобы убедиться, что запись была записана, либо укажите <xref:System.IO.Log.RecordAppendOptions>флаг с помощью `recordAppendOptions` параметра, либо вызовите <xref:System.IO.Log.IRecordSequence.Flush%2A>метод.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в порядке, заданном пользователем."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в обратном порядке."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Является допустимым значением для <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , указывающее, как должны записываться данные."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер добавленной в журнал записи."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При добавлении записи произошла ошибка ввода-вывода."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного места для новой записи."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе добавляет запись журнала для <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Данные, содержащиеся в `data` параметров будут объединены в единый массив байтов для добавления в качестве записи. Однако не делается допущение обратном разделении данных на фрагменты массива при чтении записи.       Обычно этот метод завершает работу перед записи. Чтобы убедиться, что запись была записана, либо укажите <xref:System.IO.Log.RecordAppendOptions>флаг с помощью `recordAppendOptions` параметра, либо вызовите <xref:System.IO.Log.IRecordSequence.Flush%2A>метод.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в порядке, заданном пользователем."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в обратном порядке."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Является допустимым значением для <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , указывающее, как должны записываться данные."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер добавленной в журнал записи."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При добавлении записи произошла ошибка ввода-вывода."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного места для новой записи."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе добавляет запись журнала для <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, используя пространство, которое было ранее зарезервировано в последовательности."
  remarks: "Данные, содержащиеся в `data` параметров будут объединены в единый массив байтов для добавления в качестве записи. Однако не делается допущение обратном разделении данных на фрагменты массива при чтении записи.       Добавленная запись будет занимать место, ранее зарезервированное с помощью резервирования, заданного параметром `reservations` параметр. Если выполнить добавление удается, оно займет минимальную область резервирования, которая может содержать данные, а эта область резервирования будет удалена из коллекции.       Обычно этот метод завершает работу перед записи. Чтобы убедиться, что запись была записана, либо укажите <xref:System.IO.Log.RecordAppendOptions>флаг с помощью `recordAppendOptions` параметра, либо вызовите <xref:System.IO.Log.IRecordSequence.Flush%2A>метод.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в порядке, заданном пользователем."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в обратном порядке."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Является допустимым значением для <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , указывающее, как должны записываться данные."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Объект <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , содержащая резервирование, которое следует использовать для данной записи."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер добавленной в журнал записи."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При добавлении записи произошла ошибка ввода-вывода."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного места для новой записи."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе добавляет запись журнала для <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>, используя пространство, которое было ранее зарезервировано в последовательности."
  remarks: "Данные, содержащиеся в `data` параметров будут объединены в единый массив байтов для добавления в качестве записи. Однако не делается допущение обратном разделении данных на фрагменты массива при чтении записи.       Добавленная запись будет занимать место, ранее зарезервированное с помощью резервирования, заданного параметром `reservations` параметр. Если выполнить добавление удается, оно займет минимальную область резервирования, которая может содержать данные, а эта область резервирования будет удалена из коллекции.       Обычно этот метод завершает работу перед записи. Чтобы убедиться, что запись была записана, либо укажите <xref:System.IO.Log.RecordAppendOptions>флаг с помощью `recordAppendOptions` параметра, либо вызовите <xref:System.IO.Log.IRecordSequence.Flush%2A>метод.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в порядке, заданном пользователем."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в обратном порядке."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Является допустимым значением для <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , указывающее, как должны записываться данные."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Объект <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , содержащая резервирование, которое следует использовать для данной записи."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер добавленной в журнал записи."
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При добавлении записи произошла ошибка ввода-вывода."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного места для новой записи."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе возвращает порядковый номер первой допустимой записи в текущем <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Допустимые порядковые номера больше или равен порядковому номер BaseSequenceNumber и меньше, чем <xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>       Значение этого свойства можно изменить с помощью вызова <xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>или <xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>метод.</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> </xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Наименьший порядковый номер, соответствующий допустимой записи в <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Обращение к свойству был после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе начинает асинхронную операцию добавления."
  remarks: "Необходимо передать <xref:System.IAsyncResult>возвращаемый этим методом, чтобы <xref:System.IO.Log.IRecordSequence.EndAppend%2A>метод, чтобы убедиться, что завершения операции добавления и соответствующим образом освободить ресурсы.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Если произошла ошибка при выполнении асинхронного добавления, исключение не создается до <xref:System.IO.Log.IRecordSequence.EndAppend%2A>метод вызывается с <xref:System.IAsyncResult>возвращаемый этим методом.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Данные, содержащиеся в `data` параметров будут объединены в единый массив байтов для добавления в качестве записи. Однако не делается допущение обратном разделении данных на фрагменты массива при чтении записи.       Обычно этот метод завершает работу перед записи. Чтобы убедиться, что запись была записана, либо укажите <xref:System.IO.Log.RecordAppendOptions>флаг с помощью `recordAppendOptions` параметра, либо вызовите <xref:System.IO.Log.IRecordSequence.Flush%2A>метод.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в порядке, заданном пользователем."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в обратном порядке."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Является допустимым значением для <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , указывающее, как должны записываться данные."
    - id: callback
      type: System.AsyncCallback
      description: "Необязательный асинхронный обратный вызов, вызываемый по завершении добавления."
    - id: state
      type: System.Object
      description: "Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного асинхронного запрос на добавление от других запросов."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>, Представляющий асинхронное Добавление, все еще быть отложена.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При добавлении записи произошла ошибка ввода-вывода."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного места для новой записи."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе начинает асинхронную операцию добавления, используя пространство, которое было ранее зарезервировано в последовательности."
  remarks: "Необходимо передать <xref:System.IAsyncResult>возвращаемый этим методом, чтобы <xref:System.IO.Log.IRecordSequence.EndAppend%2A>метод, чтобы убедиться, что завершения операции добавления и соответствующим образом освободить ресурсы.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Если произошла ошибка при выполнении асинхронного добавления, исключение не создается до <xref:System.IO.Log.IRecordSequence.EndAppend%2A>метод вызывается с <xref:System.IAsyncResult>возвращаемый этим методом.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Данные, содержащиеся в `data` параметров будут объединены в единый массив байтов для добавления в качестве записи. Однако не делается допущение обратном разделении данных на фрагменты массива при чтении записи.       Обычно этот метод завершает работу перед записи. Чтобы убедиться, что запись была записана, либо укажите <xref:System.IO.Log.RecordAppendOptions>флаг с помощью `recordAppendOptions` параметра, либо вызовите <xref:System.IO.Log.IRecordSequence.Flush%2A>метод.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в порядке, заданном пользователем."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в обратном порядке."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Является допустимым значением для <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , указывающее, как должны записываться данные."
    - id: callback
      type: System.AsyncCallback
      description: "Необязательный асинхронный обратный вызов, вызываемый по завершении добавления."
    - id: state
      type: System.Object
      description: "Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного асинхронного запрос на добавление от других запросов."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>, Представляющий асинхронное Добавление, все еще быть отложена.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При добавлении записи произошла ошибка ввода-вывода."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного места для новой записи."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе начинает асинхронную операцию добавления, используя пространство, ранее зарезервировано в последовательности."
  remarks: "Необходимо передать <xref:System.IAsyncResult>возвращаемый этим методом, чтобы <xref:System.IO.Log.IRecordSequence.EndAppend%2A>метод, чтобы убедиться, что завершения операции добавления и соответствующим образом освободить ресурсы.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Если произошла ошибка при выполнении асинхронного добавления, исключение не создается до <xref:System.IO.Log.IRecordSequence.EndAppend%2A>метод вызывается с <xref:System.IAsyncResult>возвращаемый этим методом.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Данные, содержащиеся в `data` параметров будут объединены в единый массив байтов для добавления в качестве записи. Однако не делается допущение обратном разделении данных на фрагменты массива при чтении записи.       Добавленная запись будет занимать место, ранее зарезервированное с помощью резервирования, заданного параметром `reservations` параметр. Если выполнить добавление удается, оно займет минимальную область резервирования, которая может содержать данные, а эта область резервирования будет удалена из коллекции.       Обычно этот метод завершает работу перед записи. Чтобы убедиться, что запись была записана, либо укажите <xref:System.IO.Log.RecordAppendOptions>флаг с помощью `recordAppendOptions` параметра, либо вызовите <xref:System.IO.Log.IRecordSequence.Flush%2A>метод.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в порядке, заданном пользователем."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в обратном порядке."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Является допустимым значением для <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , указывающее, как должны записываться данные."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Объект <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , содержащая резервирование, которое следует использовать для данной записи."
    - id: callback
      type: System.AsyncCallback
      description: "Необязательный асинхронный обратный вызов, вызываемый по завершении добавления."
    - id: state
      type: System.Object
      description: "Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного асинхронного запрос на добавление от других запросов."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>, Представляющий асинхронное Добавление, все еще быть отложена.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При добавлении записи произошла ошибка ввода-вывода."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного места для новой записи."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе начинает асинхронную операцию добавления, используя пространство, которое было ранее зарезервировано в последовательности."
  remarks: "Необходимо передать <xref:System.IAsyncResult>возвращаемый этим методом, чтобы <xref:System.IO.Log.IRecordSequence.EndAppend%2A>метод, чтобы убедиться, что завершения операции добавления и соответствующим образом освободить ресурсы.</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> Если произошла ошибка при выполнении асинхронного добавления, исключение не создается до <xref:System.IO.Log.IRecordSequence.EndAppend%2A>метод вызывается с <xref:System.IAsyncResult>возвращаемый этим методом.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       Данные, содержащиеся в `data` параметров будут объединены в единый массив байтов для добавления в качестве записи. Однако не делается допущение обратном разделении данных на фрагменты массива при чтении записи.       Добавленная запись будет занимать место, ранее зарезервированное с помощью резервирования, заданного параметром `reservations` параметр. Если выполнить добавление удается, оно займет минимальную область резервирования, которая может содержать данные, а эта область резервирования будет удалена из коллекции.       Обычно этот метод завершает работу перед записи. Чтобы убедиться, что запись была записана, либо укажите <xref:System.IO.Log.RecordAppendOptions>флаг с помощью `recordAppendOptions` параметра, либо вызовите <xref:System.IO.Log.IRecordSequence.Flush%2A>метод.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в порядке, заданном пользователем."
    - id: previousUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в обратном порядке."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Является допустимым значением для <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , указывающее, как должны записываться данные."
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "Объект <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , содержащая резервирование, которое следует использовать для данной записи."
    - id: callback
      type: System.AsyncCallback
      description: "Необязательный асинхронный обратный вызов, вызываемый по завершении добавления."
    - id: state
      type: System.Object
      description: "Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного асинхронного запрос на добавление от других запросов."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>, Представляющий асинхронное Добавление, все еще быть отложена.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При добавлении записи произошла ошибка ввода-вывода."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного места для новой записи."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе начинает асинхронную операцию очистки, используя пространство, которое было ранее зарезервировано в последовательности."
  remarks: "Необходимо передать <xref:System.IAsyncResult>возвращаемый текущим методом <xref:System.IO.Log.IRecordSequence.EndFlush%2A>метод, чтобы обеспечить завершение очистки и правильное освобождение ресурсов.</xref:System.IO.Log.IRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> При возникновении ошибки во время асинхронной очистки, исключение не создается до <xref:System.IO.Log.IRecordSequence.EndFlush%2A>метод вызывается с <xref:System.IAsyncResult>возвращаемый этим методом.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndFlush%2A>       Вызов этого метода гарантирует выполнение устойчивых записей, добавленных в <xref:System.IO.Log.IRecordSequence>внесены.</xref:System.IO.Log.IRecordSequence>       Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно в пределах данной операции. Ошибки, произошла во время запроса асинхронной очистки, например ошибка диска в процессе запроса ввода-вывода, приводят к созданию исключений при <xref:System.IO.Log.IRecordSequence.EndFlush%2A>вызывается метод.</xref:System.IO.Log.IRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер последней записи, которую требуется записать. Если этот <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> не является допустимым, необходимо записать все записи."
    - id: callback
      type: System.AsyncCallback
      description: "Необязательный асинхронный обратный вызов, вызываемый после завершения сохранения на диск."
    - id: state
      type: System.Object
      description: "Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного асинхронного запроса записи от других запросов."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>, Представляет асинхронную операцию очистки, которая может все еще быть отложена.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При очистке данных произошла ошибка ввода-вывода."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе начинает асинхронную резерва и операцию добавления."
  remarks: "Необходимо передать <xref:System.IAsyncResult>возвращаемый этим методом, чтобы <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>метод, чтобы убедиться, что завершения операции добавления и соответствующим образом освободить ресурсы.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Если произошла ошибка при выполнении асинхронного добавления, исключение не создается до <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>метод вызывается с <xref:System.IAsyncResult>возвращаемый этим методом.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       Данные, содержащиеся в `data` параметров будут объединены в единый массив байтов для добавления в качестве записи. Однако не делается допущение обратном разделении данных на фрагменты массива при чтении записи.       Заданные резервирования добавляются предоставленный резервирования операцию добавления коллекции в атомарной операции записи. В случае добавления место не резервируется.       Как правило этот метод может завершить перед записи. Чтобы убедиться, что запись была записана, либо укажите <xref:System.IO.Log.RecordAppendOptions>флаг с помощью `recordAppendOptions` параметра, либо вызовите <xref:System.IO.Log.IRecordSequence.Flush%2A>метод.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приведет к возникновению исключений, генерируемых при <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>вызывается метод.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в порядке, заданном пользователем."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в обратном порядке."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Является допустимым значением для <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , указывающее, как должны записываться данные."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Коллекция резервирования, который требуется сделать резервирования."
    - id: reservations
      type: System.Int64[]
      description: "Размер необходимого резервирования, в байтах."
    - id: callback
      type: System.AsyncCallback
      description: "Необязательный асинхронный обратный вызов, вызываемый по завершении добавления."
    - id: state
      type: System.Object
      description: "Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного асинхронного запрос на добавление от других запросов."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>, Представляющий данную асинхронную операцию, которая может все еще быть отложена.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При добавлении записи произошла ошибка ввода-вывода."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного места для новой записи или выполнить резервирование."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе начинает асинхронную резерва и операцию добавления."
  remarks: "Необходимо передать <xref:System.IAsyncResult>возвращаемый этим методом, чтобы <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>метод, чтобы убедиться, что завершения операции добавления и соответствующим образом освободить ресурсы.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> Если произошла ошибка при выполнении асинхронного добавления, исключение не создается до <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>метод вызывается с <xref:System.IAsyncResult>возвращаемый этим методом.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       Данные, содержащиеся в `data` параметров будут объединены в единый массив байтов для добавления в качестве записи. Однако не делается допущение обратном разделении данных на фрагменты массива при чтении записи.       Заданные резервирования добавляются предоставленный резервирования операцию добавления коллекции в атомарной операции записи. В случае добавления место не резервируется.       Как правило этот метод может завершить перед записи. Чтобы убедиться, что запись была записана, либо укажите <xref:System.IO.Log.RecordAppendOptions>флаг с помощью `recordAppendOptions` параметра, либо вызовите <xref:System.IO.Log.IRecordSequence.Flush%2A>метод.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приведет к возникновению исключений, генерируемых при <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>вызывается метод.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в порядке, заданном пользователем."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в обратном порядке."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Является допустимым значением для <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , указывающее, как должны записываться данные."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Коллекция резервирования, который требуется сделать резервирования."
    - id: reservations
      type: System.Int64[]
      description: "Размер необходимого резервирования, в байтах."
    - id: callback
      type: System.AsyncCallback
      description: "Необязательный асинхронный обратный вызов, вызываемый по завершении добавления."
    - id: state
      type: System.Object
      description: "Предоставляемый пользователем объект, являющийся отличительным признаком данного конкретного асинхронного запрос на добавление от других запросов."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>, Представляющий данную асинхронную операцию, которая может все еще быть отложена.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При добавлении записи произошла ошибка ввода-вывода."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного места для новой записи или выполнить резервирование."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе начинает асинхронную операцию записи области перезапуска, используя пространство, которое было ранее зарезервировано в последовательности."
  remarks: "Необходимо передать <xref:System.IAsyncResult>возвращаемый этим методом, чтобы <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>Завершение метода, чтобы убедиться, что операцию записи области перезапуска и соответствующим образом освободить ресурсы.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Если произошла ошибка при выполнении операции записи области перезапуска, исключение не создается до <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>метод вызывается с <xref:System.IAsyncResult>возвращаемый этим методом.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       Данные, содержащиеся в `data` параметров будут объединены в единый массив байтов для добавления в качестве записи. Однако не делается допущение обратном разделении данных на фрагменты массива при чтении записи.       При успешном выполнении операции базовый порядковый номер был обновлен. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.       Если <xref:System.IO.Log.ReservationCollection>указан, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью содержащегося в коллекции резервирования.</xref:System.IO.Log.ReservationCollection> Если метод выполнен успешно, будет занята Минимальная область резервирования, которая может содержать данные, и эта область резервирования будет удалена из коллекции.       Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приведет к возникновению исключений, генерируемых при <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>вызывается метод.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Новый базовый порядковый номер. Указанный порядковый номер должен быть больше или равен текущему базовому порядковому номеру."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "Объект <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , содержащая резервирование, которое следует использовать для данной области перезапуска."
    - id: callback
      type: System.AsyncCallback
      description: "Необязательный асинхронный обратный вызов, вызываемый при записи в области перезапуска."
    - id: state
      type: System.Object
      description: "Предоставляемый пользователем объект, являющийся отличительным признаком данного запроса на определенной перезапуска области запись от других запросов."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Представляет асинхронную перезапуска операции записи в область, которая может все еще быть отложена.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе начинает асинхронную операцию записи области перезапуска, используя пространство, которое было ранее зарезервировано в последовательности."
  remarks: "Необходимо передать <xref:System.IAsyncResult>возвращаемый этим методом, чтобы <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>метод, чтобы гарантировать, что операцию записи области перезапуска завершена, и соответствующим образом освободить ресурсы.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> Если произошла ошибка при выполнении операции записи области перезапуска, исключение не создается до <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>метод вызывается с <xref:System.IAsyncResult>возвращаемый этим методом.</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       Данные, содержащиеся в `data` параметров будут объединены в единый массив байтов для добавления в качестве записи. Однако не делается допущение обратном разделении данных на фрагменты массива при чтении записи.       При успешном выполнении операции базовый порядковый номер был обновлен. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.       Если <xref:System.IO.Log.ReservationCollection>указан, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью содержащегося в коллекции резервирования.</xref:System.IO.Log.ReservationCollection> Если метод выполнен успешно, будет занята Минимальная область резервирования, которая может содержать данные, и эта область резервирования будет удалена из коллекции.       Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приведет к возникновению исключений, генерируемых при <xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>вызывается метод.</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Новый базовый порядковый номер. Указанный порядковый номер должен быть больше или равен текущему базовому порядковому номеру."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "Объект <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , содержащая резервирование, которое следует использовать для данной области перезапуска."
    - id: callback
      type: System.AsyncCallback
      description: "Необязательный асинхронный обратный вызов, вызываемый при записи в области перезапуска."
    - id: state
      type: System.Object
      description: "Предоставляемый пользователем объект, являющийся отличительным признаком данного запроса на определенной перезапуска области запись от других запросов."
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>Представляет асинхронную перезапуска операции записи в область, которая может все еще быть отложена.</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода при записи области перезапуска."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного места для новой записи."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе создает новый <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "Вновь созданный <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе завершает асинхронную операцию добавления."
  remarks: "Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие при выполнении запроса асинхронной записи, например ошибка диска в процессе запроса ввода-вывода, становятся видимыми, когда вызывается EndAppend.       Этот метод должен вызываться ровно по одному разу для каждого <xref:System.IAsyncResult>возвращенных <xref:System.IO.Log.IRecordSequence.BeginAppend%2A>метод.</xref:System.IO.Log.IRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Ссылка на невыполненный асинхронный запрос ввода-вывода."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер добавленной в журнал записи."
  overload: System.IO.Log.IRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе завершает асинхронную операцию очистки."
  remarks: "Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие во время запроса асинхронной очистки, например ошибка диска в процессе запроса ввода-вывода, становятся видимыми, когда вызывается EndFlush.       Этот метод должен вызываться ровно по одному разу для каждого <xref:System.IAsyncResult>возвращенных <xref:System.IO.Log.IRecordSequence.BeginFlush%2A>метод.</xref:System.IO.Log.IRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Ссылка на невыполненный асинхронный запрос ввода-вывода."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер последней записи, запись."
  overload: System.IO.Log.IRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе завершает асинхронную операцию резервирования и добавления."
  remarks: "Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие при выполнении запроса асинхронной записи, например ошибка диска в процессе запроса ввода-вывода, становятся видимыми, когда вызывается EndReserveAndAppend.       Этот метод должен вызываться ровно по одному разу для каждого <xref:System.IAsyncResult>возвращенных <xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>метод.</xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Ссылка на невыполненный асинхронный запрос ввода-вывода."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер добавленной в журнал записи."
  overload: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе завершает операцию записи области перезапуска."
  remarks: "Этот метод блокируется до завершения операции ввода-вывода. Ошибки, возникающие при выполнении запроса асинхронной записи, например ошибка диска в процессе запроса ввода-вывода, становятся видимыми, когда вызывается EndWriteRestartArea.       Этот метод должен вызываться ровно по одному разу для каждого <xref:System.IAsyncResult>возвращенных <xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>метод.</xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "Ссылка на невыполненный асинхронный запрос ввода-вывода."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер записанной в журнал записи."
  overload: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе обеспечивает запись всех добавленных записей."
  remarks: "Вызов этого метода гарантирует выполнение устойчивых записей, добавленных в <xref:System.IO.Log.IRecordSequence>устойчивую запись.</xref:System.IO.Log.IRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер последней записи, запись."
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При очистке данных произошла ошибка ввода-вывода."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе, гарантирует, что устойчивую запись всех добавленных записей до указанного порядкового номера включительно."
  remarks: "Вызов этого метода обеспечивает всех записей до и включая заданный порядковый номер устойчивую запись."
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер последней записи, которую требуется записать. Если этот <xref href=&quot;System.IO.Log.SequenceNumber&quot;> </xref> не является допустимым, необходимо записать все записи."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер последней записи, запись."
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При очистке данных произошла ошибка ввода-вывода."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе возвращает порядковый номер, превышающий последнюю добавленную запись."
  remarks: "Это свойство содержит порядковый номер, который гарантированно быть больше, чем порядковый номер последней добавленной записи. Допустимые порядковые номера больше или равно <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>и меньше, чем LastSequenceNumber.</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      Настроек [!NOTE] настроек при использовании <xref:System.IO.Log.LogRecordSequence>экземпляра, <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>может стать устаревшим пока записи помещены в журнал.</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> </xref:System.IO.Log.LogRecordSequence> В разделе <xref:System.IO.Log.IRecordSequence.Flush%2A>и <xref:System.IO.Log.RecordAppendOptions>Дополнительные сведения об очистке записей...</xref:System.IO.Log.RecordAppendOptions> </xref:System.IO.Log.IRecordSequence.Flush%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер, превышающий последнюю добавленную запись."
  overload: System.IO.Log.IRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Обращение к свойству был после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе получает размер наибольшей записи, которую можно добавить или прочитать из последовательности, в байтах."
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "Размер наибольшей записи, которую можно добавить или прочитать из последовательности, в байтах."
  overload: System.IO.Log.IRecordSequence.MaximumRecordLength*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Обращение к свойству был после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе Возвращает перечисляемую коллекцию записей в последовательности."
  remarks: "При переопределении в производном классе Возвращает перечисляемую коллекцию записей в последовательности. Порядок перечисленных записей зависит от значения `logRecordEnum` параметра."
  example:
  - "This sample demonstrates the use of the ReadLogRecords method.  \n  \n```c#  \nusing System;  \n using System.IO;  \n using System.IO.Log;  \n  \n class ReadRecordsSample  \n {  \n     static SequenceNumber AppendRecord(IRecordSequence sequence,  \n                                        string message,  \n                                        SequenceNumber user,  \n                                        SequenceNumber previous)  \n     {  \n         MemoryStream data = new MemoryStream();  \n         BinaryWriter writer = new BinaryWriter(data);  \n         writer.Write(message);  \n  \n         ArraySegment<byte>[] segments;  \n         segments = new ArraySegment<byte>[1];  \n         segments[0] = new ArraySegment(data.GetBuffer(),  \n                                        0,  \n                                        Data.Length);  \n  \n         return sequence.Append(segments,  \n                                user,  \n                                previous,  \n                                WriteFlags.None);  \n     }  \n  \n     public static void Main(string[] args)  \n     {  \n         IRecordSequence sequence;  \n         sequence = new FileIRecordSequence(args[0]);  \n  \n         SequenceNumber a, b, c, d;  \n  \n         a = AppendRecord(sequence,  \n                          \"This is record A\",  \n                          SequenceNumber.Invalid,  \n                          SequenceNumber.Invalid);  \n         Console.WriteLine(\"Record A has sequence number System.IO.Log\", a);  \n  \n         b = AppendRecord(sequence,  \n                          \"This is record B\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record B has sequence number System.IO.Log\", b);  \n  \n         c = AppendRecord(sequence,  \n                          \"This is record C\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record C has sequence number System.IO.Log\", c);  \n  \n         d = AppendRecord(sequence,  \n                          \"This is record D\",  \n                          b,  \n                          c);  \n         Console.WriteLine(\"Record D has sequence number System.IO.Log\", d);  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(a, ReadDirection.Forward))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.User))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.Previous))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n     }  \n       }  \n```"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер первой записи, в которой начинается чтение."
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "Является допустимым <xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;> </xref> значение, указывающее способ (то есть вперед или назад), в котором записи должны считываться из <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>."
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Перечисляемая коллекция записей в последовательности."
  overload: System.IO.Log.IRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода при чтении записи."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе Возвращает перечисляемую коллекцию областей перезапуска в последовательности."
  remarks: "Области перезапуска перечислены в обратном порядке их номеров, то есть с наибольшим порядковым номером для наименьшего порядкового номера. Выполняется перечисление базовый порядковый номер, и только областей с порядковыми номерами между порядковый номер последнего перезапуска.      Настроек [!NOTE] настроек Если области журнала, содержащей <xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>становится повреждены, этот метод может выдавать <xref:System.IO.IOException>сообщение об ошибке «не удалось выполнить запрос из-за непредвиденного исключения ввода-вывода.</xref:System.IO.IOException> </xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> Возвращен код ошибки: &quot;80070026&quot;»."
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "Перечисляемая коллекция областей перезапуска в последовательности."
  overload: System.IO.Log.IRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода при чтении записи."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе автоматически делает одно резервирование и добавляет запись в последовательность."
  remarks: "Данные, содержащиеся в `data` параметров будут объединены в единый массив байтов для добавления в качестве записи. Однако не делается допущение обратном разделении данных на фрагменты массива при чтении записи.       Заданные резервирования добавляются предоставленный резервирования операцию добавления коллекции в атомарной операции записи. В случае добавления место не резервируется.       Как правило этот метод может завершить перед записи. Чтобы убедиться, что запись была записана, либо укажите <xref:System.IO.Log.RecordAppendOptions>флаг с помощью `recordAppendOptions` параметра, либо вызовите <xref:System.IO.Log.IRecordSequence.Flush%2A>метод.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в порядке, заданном пользователем."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в обратном порядке."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Является допустимым значением для <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , указывающее, как должны записываться данные."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Объект <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , содержащий коллекцию требуется сделать резервирования."
    - id: reservations
      type: System.Int64[]
      description: "Размер необходимого резервирования, в байтах."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер добавленной в журнал записи."
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При добавлении записи произошла ошибка ввода-вывода."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного места для новой записи или выполнить резервирование."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе автоматически делает одно резервирование и добавляет запись в последовательность."
  remarks: "Данные, содержащиеся в `data` параметров будут объединены в единый массив байтов для добавления в качестве записи. Однако не делается допущение обратном разделении данных на фрагменты массива при чтении записи.       Заданные резервирования добавляются предоставленный резервирования операцию добавления коллекции в атомарной операции записи. В случае добавления место не резервируется.       Как правило этот метод может завершить перед записи. Чтобы убедиться, что запись была записана, либо укажите <xref:System.IO.Log.RecordAppendOptions>флаг с помощью `recordAppendOptions` параметра, либо вызовите <xref:System.IO.Log.IRecordSequence.Flush%2A>метод.</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в порядке, заданном пользователем."
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер следующей записи в обратном порядке."
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "Является допустимым значением для <xref href=&quot;System.IO.Log.RecordAppendOptions&quot;> </xref> , указывающее, как должны записываться данные."
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "Коллекция резервирования, который требуется сделать резервирования."
    - id: reservations
      type: System.Int64[]
      description: "Размер необходимого резервирования, в байтах."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер добавленной в журнал записи."
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "При добавлении записи произошла ошибка ввода-вывода."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного места для новой записи или выполнить резервирование."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе возвращает общее число байтов, которые были зарезервированы."
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "Общий размер резервирований, созданных в последовательности записей."
  overload: System.IO.Log.IRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Обращение к свойству был после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе возвращает порядковый номер последней записанной области перезапуска."
  remarks: "Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если во время восстановления требуется, вы можете проанализировать область перезапуска, чтобы получить все данные из последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу &quot;грязных страниц&quot; и таблицу открытых файлов, чтобы их можно использовать в процессе восстановления."
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер последней записанной области перезапуска."
  overload: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Обращение к свойству был после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Возвращает или задает значение, указывающее, является ли добавляет являются повторная автоматическая попытка добавления при заполнении журнала."
  remarks: "Если значение этого свойства равно `true`и <xref:System.IO.Log.IRecordSequence.Append%2A>вызов завершается ошибкой, поскольку не хватает места в последовательности, последовательность записей пытается освободить место и повторите попытку добавления.</xref:System.IO.Log.IRecordSequence.Append%2A>"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>Если добавляет производятся автоматически в том случае, если журнал заполнен; в противном случае <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>. Значение по умолчанию — <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>."
  overload: System.IO.Log.IRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Обращение к свойству был после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "Происходит, когда последовательность записей определяет, что заключительный фрагмент необходимо переместить вперед."
  remarks: "Это событие, когда в последовательности записей закончилось свободное пространство, можно создать. При возникновении этого события завершающая часть последовательности (то есть базовый порядковый номер) перемещается вперед для освобождения места."
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "Для добавления."
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе записывает область перезапуска <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Общие системы файла журнала (CLFS) поддерживает две области, чтобы гарантировать, что по крайней мере одна действительная область всегда доступен перезапуска. При необходимости во время восстановления файловая система CLFS читает область перезапуска и все данные из последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу &quot;грязных страниц&quot; и таблицу открытых файлов, чтобы их можно использовать в процессе восстановления.       Чтение области перезапуска с помощью <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>метод.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Данные в этих фрагментах массива байтов будут сцеплены в единый массив байтов для добавления в качестве записи. Не делается допущение обратном разделении данных на фрагменты массива при чтении области перезапуска."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер записанной области перезапуска."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода при записи области перезапуска."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе записывает область перезапуска <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>."
  remarks: "Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если во время восстановления требуется, вы можете проанализировать область перезапуска, чтобы получить все данные из последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу &quot;грязных страниц&quot; и таблицу открытых файлов, чтобы их можно использовать в процессе восстановления. Чтение области перезапуска с помощью <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>метод.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       Данные в этих фрагментах массива байтов будут сцеплены в единый массив байтов для добавления в качестве записи. Не делается допущение обратном разделении данных на фрагменты массива при чтении области перезапуска."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер записанной области перезапуска."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода при записи области перезапуска."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе записывает область перезапуска <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> и обновляет базовый порядковый номер"
  remarks: "Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если во время восстановления требуется, вы можете проанализировать область перезапуска, чтобы получить все данные из последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу &quot;грязных страниц&quot; и таблицу открытых файлов, чтобы их можно использовать в процессе восстановления. Чтение области перезапуска с помощью <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>метод.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается допущение обратном разделении данных на фрагменты массива при чтении области перезапуска.       При успешном выполнении этого метода базовый порядковый номер был обновлен. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Новый базовый порядковый номер. Указанный порядковый номер должен быть больше или равен текущему базовому порядковому номеру."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер записанной области перезапуска."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода при записи области перезапуска."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе записывает область перезапуска <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> и обновляет базовый порядковый номер."
  remarks: "Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если во время восстановления требуется, вы можете проанализировать область перезапуска, чтобы получить все данные из последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу &quot;грязных страниц&quot; и таблицу открытых файлов, чтобы их можно использовать в процессе восстановления. Чтение области перезапуска с помощью <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>метод.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается допущение обратном разделении данных на фрагменты массива при чтении области перезапуска.       При успешном выполнении этого метода базовый порядковый номер был обновлен. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны."
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Новый базовый порядковый номер. Указанный порядковый номер должен быть больше или равен текущему базовому порядковому номеру."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер записанной области перезапуска."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода при записи области перезапуска."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе записывает область перезапуска <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> используя резервирование и обновляет базовый порядковый номер"
  remarks: "Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если во время восстановления требуется, вы можете проанализировать область перезапуска, чтобы получить все данные из последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу &quot;грязных страниц&quot; и таблицу открытых файлов, чтобы их можно использовать в процессе восстановления. Чтение области перезапуска с помощью <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>метод.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается допущение обратном разделении данных на фрагменты массива при чтении области перезапуска.       Если задано резервирование, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью резервирования, содержащихся в коллекции. Если метод выполнен успешно, будет занята Минимальная область резервирования, который может содержать данные, и эта область резервирования будет удалена из коллекции.       При успешном выполнении этого метода базовый порядковый номер был обновлен. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.       Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приведет к возникновению исключений, генерируемых при <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>вызывается метод.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Новый базовый порядковый номер. Указанный порядковый номер должен быть больше или равен текущему базовому порядковому номеру."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "Объект <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , содержащая резервирование, которое следует использовать для данной области перезапуска."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер записанной области перезапуска."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода при записи области перезапуска."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "При переопределении в производном классе записывает область перезапуска <xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref> используя резервирование и обновляет базовый порядковый номер."
  remarks: "Область перезапуска служит для временного хранения сведений, содержащих последнюю операцию контрольной точки клиента. Если во время восстановления требуется, вы можете проанализировать область перезапуска, чтобы получить все данные из последней операции контрольной точки. Эти данные инициализирует таблицу транзакций, таблицу &quot;грязных страниц&quot; и таблицу открытых файлов, чтобы их можно использовать в процессе восстановления. Чтение области перезапуска с помощью <xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>метод.</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       При записи области перезапуска данные в этих фрагментах массива байтов сцепляются в единый массив байтов для добавления в качестве записи. Не делается допущение обратном разделении данных на фрагменты массива при чтении области перезапуска.       Если задано резервирование, записанная область перезапуска будет занимать место, ранее зарезервированное с помощью резервирования, содержащихся в коллекции. Если метод выполнен успешно, будет занята Минимальная область резервирования, который может содержать данные, и эта область резервирования будет удалена из коллекции.       При успешном выполнении этого метода базовый порядковый номер был обновлен. Все записи журнала с порядковыми номерами меньшими, чем новый базовый порядковый номер, недоступны.       Если последовательность записей была удалена, или если передается неверный аргумент, исключения создаются немедленно в пределах данной операции. Ошибки, возникшие при выполнении запроса асинхронного добавления, например ошибка диска в процессе запроса ввода-вывода, приведет к возникновению исключений, генерируемых при <xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>вызывается метод.</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "Список фрагментов массива байтов, которые будут сцеплены и добавлены в качестве записи."
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "Новый базовый порядковый номер. Указанный порядковый номер должен быть больше или равен текущему базовому порядковому номеру."
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "Объект <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> , содержащая резервирование, которое следует использовать для данной области перезапуска."
    return:
      type: System.IO.Log.SequenceNumber
      description: "Порядковый номер записанной области перезапуска."
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Один или несколько аргументов являются недопустимыми."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "Произошла ошибка ввода-вывода при записи области перезапуска."
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "Последовательности записей не удалось выделить достаточно свободного пространства для новой области перезапуска."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "Метод был вызван после удаления последовательности."
  platform:
  - net462
references:
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.Flush
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.IRecordSequence.TailPinned
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.Append*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append
  nameWithType: IRecordSequence.Append
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: IRecordSequence.BeginAppend
- uid: System.IO.Log.IRecordSequence.BeginFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: IRecordSequence.BeginFlush
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: IRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: IRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: IRecordSequence.CreateReservationCollection
- uid: System.IO.Log.IRecordSequence.EndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: IRecordSequence.EndAppend
- uid: System.IO.Log.IRecordSequence.EndFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: IRecordSequence.EndFlush
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: IRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: IRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.IRecordSequence.Flush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush
  nameWithType: IRecordSequence.Flush
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
- uid: System.IO.Log.IRecordSequence.ReadLogRecords*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: IRecordSequence.ReadLogRecords
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: IRecordSequence.ReadRestartAreas
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: IRecordSequence.ReserveAndAppend
- uid: System.IO.Log.IRecordSequence.ReservedBytes*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
- uid: System.IO.Log.IRecordSequence.WriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: IRecordSequence.WriteRestartArea
